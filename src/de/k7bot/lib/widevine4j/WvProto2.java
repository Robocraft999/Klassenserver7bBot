// Generated by the protocol buffer compiler. DO NOT EDIT!
// source: wv_proto2.proto

package de.k7bot.lib.widevine4j;

import com.google.protobuf.AbstractMessage;
import com.google.protobuf.AbstractMessageLite;
import com.google.protobuf.AbstractParser;
import com.google.protobuf.ByteString;
import com.google.protobuf.CodedInputStream;
import com.google.protobuf.CodedOutputStream;
import com.google.protobuf.Descriptors;
import com.google.protobuf.ExtensionRegistry;
import com.google.protobuf.ExtensionRegistryLite;
import com.google.protobuf.GeneratedMessageV3;
import com.google.protobuf.Internal;
import com.google.protobuf.InvalidProtocolBufferException;
import com.google.protobuf.Message;
import com.google.protobuf.MessageOrBuilder;
import com.google.protobuf.Parser;
import com.google.protobuf.ProtocolMessageEnum;
import com.google.protobuf.RepeatedFieldBuilderV3;
import com.google.protobuf.SingleFieldBuilderV3;
import com.google.protobuf.UninitializedMessageException;
import com.google.protobuf.UnknownFieldSet;

public final class WvProto2 {
	private WvProto2() {
	}

	public static void registerAllExtensions(@SuppressWarnings("unused") ExtensionRegistryLite registry) {
		//
	}

	public static void registerAllExtensions(ExtensionRegistry registry) {
		registerAllExtensions((ExtensionRegistryLite) registry);
	}

	/**
	 * Protobuf enum {@code LicenseType}
	 */
	public enum LicenseType implements ProtocolMessageEnum {
		/**
		 * <code>STREAMING = 1;</code>
		 */
		STREAMING(1),
		/**
		 * <code>OFFLINE = 2;</code>
		 */
		OFFLINE(2),
		/**
		 * <pre>
		 * License type decision is left to provider.
		 * </pre>
		 *
		 * <code>AUTOMATIC = 3;</code>
		 */
		AUTOMATIC(3),;

		/**
		 * <code>STREAMING = 1;</code>
		 */
		public static final int STREAMING_VALUE = 1;
		/**
		 * <code>OFFLINE = 2;</code>
		 */
		public static final int OFFLINE_VALUE = 2;
		/**
		 * <pre>
		 * License type decision is left to provider.
		 * </pre>
		 *
		 * <code>AUTOMATIC = 3;</code>
		 */
		public static final int AUTOMATIC_VALUE = 3;

		@Override
		public final int getNumber() {
			return value;
		}

		/**
		 * @param value The numeric wire value of the corresponding enum entry.
		 * @return The enum associated with the given numeric wire value.
		 * @deprecated Use {@link #forNumber(int)} instead.
		 */
		@java.lang.Deprecated
		public static LicenseType valueOf(int value) {
			return forNumber(value);
		}

		/**
		 * @param value The numeric wire value of the corresponding enum entry.
		 * @return The enum associated with the given numeric wire value.
		 */
		public static LicenseType forNumber(int value) {
			switch (value) {
			case 1:
				return STREAMING;
			case 2:
				return OFFLINE;
			case 3:
				return AUTOMATIC;
			default:
				return null;
			}
		}

		public static Internal.EnumLiteMap<LicenseType> internalGetValueMap() {
			return internalValueMap;
		}

		private static final Internal.EnumLiteMap<LicenseType> internalValueMap = new Internal.EnumLiteMap<>() {
			@Override
			public LicenseType findValueByNumber(int number) {
				return LicenseType.forNumber(number);
			}
		};

		@Override
		public final Descriptors.EnumValueDescriptor getValueDescriptor() {
			return getDescriptor().getValues().get(ordinal());
		}

		@Override
		public final Descriptors.EnumDescriptor getDescriptorForType() {
			return getDescriptor();
		}

		public static final Descriptors.EnumDescriptor getDescriptor() {
			return WvProto2.getDescriptor().getEnumTypes().get(0);
		}

		private static final LicenseType[] VALUES = values();

		public static LicenseType valueOf(Descriptors.EnumValueDescriptor desc) {
			if (desc.getType() != getDescriptor()) {
				throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
			}
			return VALUES[desc.getIndex()];
		}

		private final int value;

		private LicenseType(int value) {
			this.value = value;
		}

		// @@protoc_insertion_point(enum_scope:LicenseType)
	}

	/**
	 * Protobuf enum {@code PlatformVerificationStatus}
	 */
	public enum PlatformVerificationStatus implements ProtocolMessageEnum {
		/**
		 * <pre>
		 * The platform is not verified.
		 * </pre>
		 *
		 * <code>PLATFORM_UNVERIFIED = 0;</code>
		 */
		PLATFORM_UNVERIFIED(0),
		/**
		 * <pre>
		 * Tampering detected on the platform.
		 * </pre>
		 *
		 * <code>PLATFORM_TAMPERED = 1;</code>
		 */
		PLATFORM_TAMPERED(1),
		/**
		 * <pre>
		 * The platform has been verified by means of software.
		 * </pre>
		 *
		 * <code>PLATFORM_SOFTWARE_VERIFIED = 2;</code>
		 */
		PLATFORM_SOFTWARE_VERIFIED(2),
		/**
		 * <pre>
		 * The platform has been verified by means of hardware (e.g. secure boot).
		 * </pre>
		 *
		 * <code>PLATFORM_HARDWARE_VERIFIED = 3;</code>
		 */
		PLATFORM_HARDWARE_VERIFIED(3),
		/**
		 * <pre>
		 * Platform verification was not performed.
		 * </pre>
		 *
		 * <code>PLATFORM_NO_VERIFICATION = 4;</code>
		 */
		PLATFORM_NO_VERIFICATION(4),
		/**
		 * <pre>
		 * Platform and secure storage capability have been verified by means of
		 * software.
		 * </pre>
		 *
		 * <code>PLATFORM_SECURE_STORAGE_SOFTWARE_VERIFIED = 5;</code>
		 */
		PLATFORM_SECURE_STORAGE_SOFTWARE_VERIFIED(5),;

		/**
		 * <pre>
		 * The platform is not verified.
		 * </pre>
		 *
		 * <code>PLATFORM_UNVERIFIED = 0;</code>
		 */
		public static final int PLATFORM_UNVERIFIED_VALUE = 0;
		/**
		 * <pre>
		 * Tampering detected on the platform.
		 * </pre>
		 *
		 * <code>PLATFORM_TAMPERED = 1;</code>
		 */
		public static final int PLATFORM_TAMPERED_VALUE = 1;
		/**
		 * <pre>
		 * The platform has been verified by means of software.
		 * </pre>
		 *
		 * <code>PLATFORM_SOFTWARE_VERIFIED = 2;</code>
		 */
		public static final int PLATFORM_SOFTWARE_VERIFIED_VALUE = 2;
		/**
		 * <pre>
		 * The platform has been verified by means of hardware (e.g. secure boot).
		 * </pre>
		 *
		 * <code>PLATFORM_HARDWARE_VERIFIED = 3;</code>
		 */
		public static final int PLATFORM_HARDWARE_VERIFIED_VALUE = 3;
		/**
		 * <pre>
		 * Platform verification was not performed.
		 * </pre>
		 *
		 * <code>PLATFORM_NO_VERIFICATION = 4;</code>
		 */
		public static final int PLATFORM_NO_VERIFICATION_VALUE = 4;
		/**
		 * <pre>
		 * Platform and secure storage capability have been verified by means of
		 * software.
		 * </pre>
		 *
		 * <code>PLATFORM_SECURE_STORAGE_SOFTWARE_VERIFIED = 5;</code>
		 */
		public static final int PLATFORM_SECURE_STORAGE_SOFTWARE_VERIFIED_VALUE = 5;

		@Override
		public final int getNumber() {
			return value;
		}

		/**
		 * @param value The numeric wire value of the corresponding enum entry.
		 * @return The enum associated with the given numeric wire value.
		 * @deprecated Use {@link #forNumber(int)} instead.
		 */
		@java.lang.Deprecated
		public static PlatformVerificationStatus valueOf(int value) {
			return forNumber(value);
		}

		/**
		 * @param value The numeric wire value of the corresponding enum entry.
		 * @return The enum associated with the given numeric wire value.
		 */
		public static PlatformVerificationStatus forNumber(int value) {
			switch (value) {
			case 0:
				return PLATFORM_UNVERIFIED;
			case 1:
				return PLATFORM_TAMPERED;
			case 2:
				return PLATFORM_SOFTWARE_VERIFIED;
			case 3:
				return PLATFORM_HARDWARE_VERIFIED;
			case 4:
				return PLATFORM_NO_VERIFICATION;
			case 5:
				return PLATFORM_SECURE_STORAGE_SOFTWARE_VERIFIED;
			default:
				return null;
			}
		}

		public static Internal.EnumLiteMap<PlatformVerificationStatus> internalGetValueMap() {
			return internalValueMap;
		}

		private static final Internal.EnumLiteMap<PlatformVerificationStatus> internalValueMap = new Internal.EnumLiteMap<>() {
			@Override
			public PlatformVerificationStatus findValueByNumber(int number) {
				return PlatformVerificationStatus.forNumber(number);
			}
		};

		@Override
		public final Descriptors.EnumValueDescriptor getValueDescriptor() {
			return getDescriptor().getValues().get(ordinal());
		}

		@Override
		public final Descriptors.EnumDescriptor getDescriptorForType() {
			return getDescriptor();
		}

		public static final Descriptors.EnumDescriptor getDescriptor() {
			return WvProto2.getDescriptor().getEnumTypes().get(1);
		}

		private static final PlatformVerificationStatus[] VALUES = values();

		public static PlatformVerificationStatus valueOf(Descriptors.EnumValueDescriptor desc) {
			if (desc.getType() != getDescriptor()) {
				throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
			}
			return VALUES[desc.getIndex()];
		}

		private final int value;

		private PlatformVerificationStatus(int value) {
			this.value = value;
		}

		// @@protoc_insertion_point(enum_scope:PlatformVerificationStatus)
	}

	/**
	 * Protobuf enum {@code ProtocolVersion}
	 */
	public enum ProtocolVersion implements ProtocolMessageEnum {
		/**
		 * <code>VERSION_2_0 = 20;</code>
		 */
		VERSION_2_0(20),
		/**
		 * <code>VERSION_2_1 = 21;</code>
		 */
		VERSION_2_1(21),
		/**
		 * <code>VERSION_2_2 = 22;</code>
		 */
		VERSION_2_2(22),;

		/**
		 * <code>VERSION_2_0 = 20;</code>
		 */
		public static final int VERSION_2_0_VALUE = 20;
		/**
		 * <code>VERSION_2_1 = 21;</code>
		 */
		public static final int VERSION_2_1_VALUE = 21;
		/**
		 * <code>VERSION_2_2 = 22;</code>
		 */
		public static final int VERSION_2_2_VALUE = 22;

		@Override
		public final int getNumber() {
			return value;
		}

		/**
		 * @param value The numeric wire value of the corresponding enum entry.
		 * @return The enum associated with the given numeric wire value.
		 * @deprecated Use {@link #forNumber(int)} instead.
		 */
		@java.lang.Deprecated
		public static ProtocolVersion valueOf(int value) {
			return forNumber(value);
		}

		/**
		 * @param value The numeric wire value of the corresponding enum entry.
		 * @return The enum associated with the given numeric wire value.
		 */
		public static ProtocolVersion forNumber(int value) {
			switch (value) {
			case 20:
				return VERSION_2_0;
			case 21:
				return VERSION_2_1;
			case 22:
				return VERSION_2_2;
			default:
				return null;
			}
		}

		public static Internal.EnumLiteMap<ProtocolVersion> internalGetValueMap() {
			return internalValueMap;
		}

		private static final Internal.EnumLiteMap<ProtocolVersion> internalValueMap = new Internal.EnumLiteMap<>() {
			@Override
			public ProtocolVersion findValueByNumber(int number) {
				return ProtocolVersion.forNumber(number);
			}
		};

		@Override
		public final Descriptors.EnumValueDescriptor getValueDescriptor() {
			return getDescriptor().getValues().get(ordinal());
		}

		@Override
		public final Descriptors.EnumDescriptor getDescriptorForType() {
			return getDescriptor();
		}

		public static final Descriptors.EnumDescriptor getDescriptor() {
			return WvProto2.getDescriptor().getEnumTypes().get(2);
		}

		private static final ProtocolVersion[] VALUES = values();

		public static ProtocolVersion valueOf(Descriptors.EnumValueDescriptor desc) {
			if (desc.getType() != getDescriptor()) {
				throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
			}
			return VALUES[desc.getIndex()];
		}

		private final int value;

		private ProtocolVersion(int value) {
			this.value = value;
		}

		// @@protoc_insertion_point(enum_scope:ProtocolVersion)
	}

	/**
	 * Protobuf enum {@code HashAlgorithmProto}
	 */
	public enum HashAlgorithmProto implements ProtocolMessageEnum {
		/**
		 * <pre>
		 * Unspecified hash algorithm: SHA_256 shall be used for ECC based algorithms
		 * and SHA_1 shall be used otherwise.
		 * </pre>
		 *
		 * <code>HASH_ALGORITHM_UNSPECIFIED = 0;</code>
		 */
		HASH_ALGORITHM_UNSPECIFIED(0),
		/**
		 * <code>HASH_ALGORITHM_SHA_1 = 1;</code>
		 */
		HASH_ALGORITHM_SHA_1(1),
		/**
		 * <code>HASH_ALGORITHM_SHA_256 = 2;</code>
		 */
		HASH_ALGORITHM_SHA_256(2),
		/**
		 * <code>HASH_ALGORITHM_SHA_384 = 3;</code>
		 */
		HASH_ALGORITHM_SHA_384(3),;

		/**
		 * <pre>
		 * Unspecified hash algorithm: SHA_256 shall be used for ECC based algorithms
		 * and SHA_1 shall be used otherwise.
		 * </pre>
		 *
		 * <code>HASH_ALGORITHM_UNSPECIFIED = 0;</code>
		 */
		public static final int HASH_ALGORITHM_UNSPECIFIED_VALUE = 0;
		/**
		 * <code>HASH_ALGORITHM_SHA_1 = 1;</code>
		 */
		public static final int HASH_ALGORITHM_SHA_1_VALUE = 1;
		/**
		 * <code>HASH_ALGORITHM_SHA_256 = 2;</code>
		 */
		public static final int HASH_ALGORITHM_SHA_256_VALUE = 2;
		/**
		 * <code>HASH_ALGORITHM_SHA_384 = 3;</code>
		 */
		public static final int HASH_ALGORITHM_SHA_384_VALUE = 3;

		@Override
		public final int getNumber() {
			return value;
		}

		/**
		 * @param value The numeric wire value of the corresponding enum entry.
		 * @return The enum associated with the given numeric wire value.
		 * @deprecated Use {@link #forNumber(int)} instead.
		 */
		@java.lang.Deprecated
		public static HashAlgorithmProto valueOf(int value) {
			return forNumber(value);
		}

		/**
		 * @param value The numeric wire value of the corresponding enum entry.
		 * @return The enum associated with the given numeric wire value.
		 */
		public static HashAlgorithmProto forNumber(int value) {
			switch (value) {
			case 0:
				return HASH_ALGORITHM_UNSPECIFIED;
			case 1:
				return HASH_ALGORITHM_SHA_1;
			case 2:
				return HASH_ALGORITHM_SHA_256;
			case 3:
				return HASH_ALGORITHM_SHA_384;
			default:
				return null;
			}
		}

		public static Internal.EnumLiteMap<HashAlgorithmProto> internalGetValueMap() {
			return internalValueMap;
		}

		private static final Internal.EnumLiteMap<HashAlgorithmProto> internalValueMap = new Internal.EnumLiteMap<>() {
			@Override
			public HashAlgorithmProto findValueByNumber(int number) {
				return HashAlgorithmProto.forNumber(number);
			}
		};

		@Override
		public final Descriptors.EnumValueDescriptor getValueDescriptor() {
			return getDescriptor().getValues().get(ordinal());
		}

		@Override
		public final Descriptors.EnumDescriptor getDescriptorForType() {
			return getDescriptor();
		}

		public static final Descriptors.EnumDescriptor getDescriptor() {
			return WvProto2.getDescriptor().getEnumTypes().get(3);
		}

		private static final HashAlgorithmProto[] VALUES = values();

		public static HashAlgorithmProto valueOf(Descriptors.EnumValueDescriptor desc) {
			if (desc.getType() != getDescriptor()) {
				throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
			}
			return VALUES[desc.getIndex()];
		}

		private final int value;

		private HashAlgorithmProto(int value) {
			this.value = value;
		}

		// @@protoc_insertion_point(enum_scope:HashAlgorithmProto)
	}

	public interface LicenseIdentificationOrBuilder extends
			// @@protoc_insertion_point(interface_extends:LicenseIdentification)
			MessageOrBuilder {

		/**
		 * <code>optional bytes request_id = 1;</code>
		 * 
		 * @return Whether the requestId field is set.
		 */
		boolean hasRequestId();

		/**
		 * <code>optional bytes request_id = 1;</code>
		 * 
		 * @return The requestId.
		 */
		ByteString getRequestId();

		/**
		 * <code>optional bytes session_id = 2;</code>
		 * 
		 * @return Whether the sessionId field is set.
		 */
		boolean hasSessionId();

		/**
		 * <code>optional bytes session_id = 2;</code>
		 * 
		 * @return The sessionId.
		 */
		ByteString getSessionId();

		/**
		 * <code>optional bytes purchase_id = 3;</code>
		 * 
		 * @return Whether the purchaseId field is set.
		 */
		boolean hasPurchaseId();

		/**
		 * <code>optional bytes purchase_id = 3;</code>
		 * 
		 * @return The purchaseId.
		 */
		ByteString getPurchaseId();

		/**
		 * <code>optional .LicenseType type = 4;</code>
		 * 
		 * @return Whether the type field is set.
		 */
		boolean hasType();

		/**
		 * <code>optional .LicenseType type = 4;</code>
		 * 
		 * @return The type.
		 */
		WvProto2.LicenseType getType();

		/**
		 * <code>optional int32 version = 5;</code>
		 * 
		 * @return Whether the version field is set.
		 */
		boolean hasVersion();

		/**
		 * <code>optional int32 version = 5;</code>
		 * 
		 * @return The version.
		 */
		int getVersion();

		/**
		 * <code>optional bytes provider_session_token = 6;</code>
		 * 
		 * @return Whether the providerSessionToken field is set.
		 */
		boolean hasProviderSessionToken();

		/**
		 * <code>optional bytes provider_session_token = 6;</code>
		 * 
		 * @return The providerSessionToken.
		 */
		ByteString getProviderSessionToken();
	}

	/**
	 * <pre>
	 * LicenseIdentification is propagated from LicenseRequest to License,
	 * incrementing version with each iteration.
	 * </pre>
	 *
	 * Protobuf type {@code LicenseIdentification}
	 */
	public static final class LicenseIdentification extends GeneratedMessageV3 implements
			// @@protoc_insertion_point(message_implements:LicenseIdentification)
			LicenseIdentificationOrBuilder {
		private static final long serialVersionUID = 0L;

		// Use LicenseIdentification.newBuilder() to construct.
		private LicenseIdentification(GeneratedMessageV3.Builder<?> builder) {
			super(builder);
		}

		private LicenseIdentification() {
			requestId_ = ByteString.EMPTY;
			sessionId_ = ByteString.EMPTY;
			purchaseId_ = ByteString.EMPTY;
			type_ = 1;
			providerSessionToken_ = ByteString.EMPTY;
		}

		@java.lang.Override
		protected java.lang.Object newInstance(UnusedPrivateParameter unused) {
			return new LicenseIdentification();
		}

		public static final Descriptors.Descriptor getDescriptor() {
			return WvProto2.internal_static_LicenseIdentification_descriptor;
		}

		@java.lang.Override
		protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
			return WvProto2.internal_static_LicenseIdentification_fieldAccessorTable
					.ensureFieldAccessorsInitialized(WvProto2.LicenseIdentification.class,
							WvProto2.LicenseIdentification.Builder.class);
		}

		private int bitField0_;
		public static final int REQUEST_ID_FIELD_NUMBER = 1;
		private ByteString requestId_ = ByteString.EMPTY;

		/**
		 * <code>optional bytes request_id = 1;</code>
		 * 
		 * @return Whether the requestId field is set.
		 */
		@java.lang.Override
		public boolean hasRequestId() {
			return ((bitField0_ & 0x00000001) != 0);
		}

		/**
		 * <code>optional bytes request_id = 1;</code>
		 * 
		 * @return The requestId.
		 */
		@java.lang.Override
		public ByteString getRequestId() {
			return requestId_;
		}

		public static final int SESSION_ID_FIELD_NUMBER = 2;
		private ByteString sessionId_ = ByteString.EMPTY;

		/**
		 * <code>optional bytes session_id = 2;</code>
		 * 
		 * @return Whether the sessionId field is set.
		 */
		@java.lang.Override
		public boolean hasSessionId() {
			return ((bitField0_ & 0x00000002) != 0);
		}

		/**
		 * <code>optional bytes session_id = 2;</code>
		 * 
		 * @return The sessionId.
		 */
		@java.lang.Override
		public ByteString getSessionId() {
			return sessionId_;
		}

		public static final int PURCHASE_ID_FIELD_NUMBER = 3;
		private ByteString purchaseId_ = ByteString.EMPTY;

		/**
		 * <code>optional bytes purchase_id = 3;</code>
		 * 
		 * @return Whether the purchaseId field is set.
		 */
		@java.lang.Override
		public boolean hasPurchaseId() {
			return ((bitField0_ & 0x00000004) != 0);
		}

		/**
		 * <code>optional bytes purchase_id = 3;</code>
		 * 
		 * @return The purchaseId.
		 */
		@java.lang.Override
		public ByteString getPurchaseId() {
			return purchaseId_;
		}

		public static final int TYPE_FIELD_NUMBER = 4;
		private int type_ = 1;

		/**
		 * <code>optional .LicenseType type = 4;</code>
		 * 
		 * @return Whether the type field is set.
		 */
		@java.lang.Override
		public boolean hasType() {
			return ((bitField0_ & 0x00000008) != 0);
		}

		/**
		 * <code>optional .LicenseType type = 4;</code>
		 * 
		 * @return The type.
		 */
		@java.lang.Override
		public WvProto2.LicenseType getType() {
			WvProto2.LicenseType result = WvProto2.LicenseType
					.forNumber(type_);
			return result == null ? WvProto2.LicenseType.STREAMING : result;
		}

		public static final int VERSION_FIELD_NUMBER = 5;
		private int version_ = 0;

		/**
		 * <code>optional int32 version = 5;</code>
		 * 
		 * @return Whether the version field is set.
		 */
		@java.lang.Override
		public boolean hasVersion() {
			return ((bitField0_ & 0x00000010) != 0);
		}

		/**
		 * <code>optional int32 version = 5;</code>
		 * 
		 * @return The version.
		 */
		@java.lang.Override
		public int getVersion() {
			return version_;
		}

		public static final int PROVIDER_SESSION_TOKEN_FIELD_NUMBER = 6;
		private ByteString providerSessionToken_ = ByteString.EMPTY;

		/**
		 * <code>optional bytes provider_session_token = 6;</code>
		 * 
		 * @return Whether the providerSessionToken field is set.
		 */
		@java.lang.Override
		public boolean hasProviderSessionToken() {
			return ((bitField0_ & 0x00000020) != 0);
		}

		/**
		 * <code>optional bytes provider_session_token = 6;</code>
		 * 
		 * @return The providerSessionToken.
		 */
		@java.lang.Override
		public ByteString getProviderSessionToken() {
			return providerSessionToken_;
		}

		private byte memoizedIsInitialized = -1;

		@java.lang.Override
		public final boolean isInitialized() {
			byte isInitialized = memoizedIsInitialized;
			if (isInitialized == 1)
				return true;
			if (isInitialized == 0)
				return false;

			memoizedIsInitialized = 1;
			return true;
		}

		@java.lang.Override
		public void writeTo(CodedOutputStream output) throws java.io.IOException {
			if (((bitField0_ & 0x00000001) != 0)) {
				output.writeBytes(1, requestId_);
			}
			if (((bitField0_ & 0x00000002) != 0)) {
				output.writeBytes(2, sessionId_);
			}
			if (((bitField0_ & 0x00000004) != 0)) {
				output.writeBytes(3, purchaseId_);
			}
			if (((bitField0_ & 0x00000008) != 0)) {
				output.writeEnum(4, type_);
			}
			if (((bitField0_ & 0x00000010) != 0)) {
				output.writeInt32(5, version_);
			}
			if (((bitField0_ & 0x00000020) != 0)) {
				output.writeBytes(6, providerSessionToken_);
			}
			getUnknownFields().writeTo(output);
		}

		@java.lang.Override
		public int getSerializedSize() {
			int size = memoizedSize;
			if (size != -1)
				return size;

			size = 0;
			if (((bitField0_ & 0x00000001) != 0)) {
				size += CodedOutputStream.computeBytesSize(1, requestId_);
			}
			if (((bitField0_ & 0x00000002) != 0)) {
				size += CodedOutputStream.computeBytesSize(2, sessionId_);
			}
			if (((bitField0_ & 0x00000004) != 0)) {
				size += CodedOutputStream.computeBytesSize(3, purchaseId_);
			}
			if (((bitField0_ & 0x00000008) != 0)) {
				size += CodedOutputStream.computeEnumSize(4, type_);
			}
			if (((bitField0_ & 0x00000010) != 0)) {
				size += CodedOutputStream.computeInt32Size(5, version_);
			}
			if (((bitField0_ & 0x00000020) != 0)) {
				size += CodedOutputStream.computeBytesSize(6, providerSessionToken_);
			}
			size += getUnknownFields().getSerializedSize();
			memoizedSize = size;
			return size;
		}

		@java.lang.Override
		public boolean equals(final java.lang.Object obj) {
			if (obj == this) {
				return true;
			}
			if (!(obj instanceof WvProto2.LicenseIdentification)) {
				return super.equals(obj);
			}
			WvProto2.LicenseIdentification other = (WvProto2.LicenseIdentification) obj;

			if (hasRequestId() != other.hasRequestId())
				return false;
			if (hasRequestId()) {
				if (!getRequestId().equals(other.getRequestId()))
					return false;
			}
			if (hasSessionId() != other.hasSessionId())
				return false;
			if (hasSessionId()) {
				if (!getSessionId().equals(other.getSessionId()))
					return false;
			}
			if (hasPurchaseId() != other.hasPurchaseId())
				return false;
			if (hasPurchaseId()) {
				if (!getPurchaseId().equals(other.getPurchaseId()))
					return false;
			}
			if (hasType() != other.hasType())
				return false;
			if (hasType()) {
				if (type_ != other.type_)
					return false;
			}
			if (hasVersion() != other.hasVersion())
				return false;
			if (hasVersion()) {
				if (getVersion() != other.getVersion())
					return false;
			}
			if (hasProviderSessionToken() != other.hasProviderSessionToken())
				return false;
			if (hasProviderSessionToken()) {
				if (!getProviderSessionToken().equals(other.getProviderSessionToken()))
					return false;
			}
			if (!getUnknownFields().equals(other.getUnknownFields()))
				return false;
			return true;
		}

		@SuppressWarnings("unchecked")
		@java.lang.Override
		public int hashCode() {
			if (memoizedHashCode != 0) {
				return memoizedHashCode;
			}
			int hash = 41;
			hash = (19 * hash) + getDescriptor().hashCode();
			if (hasRequestId()) {
				hash = (37 * hash) + REQUEST_ID_FIELD_NUMBER;
				hash = (53 * hash) + getRequestId().hashCode();
			}
			if (hasSessionId()) {
				hash = (37 * hash) + SESSION_ID_FIELD_NUMBER;
				hash = (53 * hash) + getSessionId().hashCode();
			}
			if (hasPurchaseId()) {
				hash = (37 * hash) + PURCHASE_ID_FIELD_NUMBER;
				hash = (53 * hash) + getPurchaseId().hashCode();
			}
			if (hasType()) {
				hash = (37 * hash) + TYPE_FIELD_NUMBER;
				hash = (53 * hash) + type_;
			}
			if (hasVersion()) {
				hash = (37 * hash) + VERSION_FIELD_NUMBER;
				hash = (53 * hash) + getVersion();
			}
			if (hasProviderSessionToken()) {
				hash = (37 * hash) + PROVIDER_SESSION_TOKEN_FIELD_NUMBER;
				hash = (53 * hash) + getProviderSessionToken().hashCode();
			}
			hash = (29 * hash) + getUnknownFields().hashCode();
			memoizedHashCode = hash;
			return hash;
		}

		public static WvProto2.LicenseIdentification parseFrom(java.nio.ByteBuffer data)
				throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data);
		}

		public static WvProto2.LicenseIdentification parseFrom(java.nio.ByteBuffer data,
				ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data, extensionRegistry);
		}

		public static WvProto2.LicenseIdentification parseFrom(ByteString data)
				throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data);
		}

		public static WvProto2.LicenseIdentification parseFrom(ByteString data,
				ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data, extensionRegistry);
		}

		public static WvProto2.LicenseIdentification parseFrom(byte[] data)
				throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data);
		}

		public static WvProto2.LicenseIdentification parseFrom(byte[] data,
				ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data, extensionRegistry);
		}

		public static WvProto2.LicenseIdentification parseFrom(java.io.InputStream input)
				throws java.io.IOException {
			return GeneratedMessageV3.parseWithIOException(PARSER, input);
		}

		public static WvProto2.LicenseIdentification parseFrom(java.io.InputStream input,
				ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
			return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
		}

		public static WvProto2.LicenseIdentification parseDelimitedFrom(
				java.io.InputStream input) throws java.io.IOException {
			return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
		}

		public static WvProto2.LicenseIdentification parseDelimitedFrom(
				java.io.InputStream input, ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
			return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input, extensionRegistry);
		}

		public static WvProto2.LicenseIdentification parseFrom(CodedInputStream input)
				throws java.io.IOException {
			return GeneratedMessageV3.parseWithIOException(PARSER, input);
		}

		public static WvProto2.LicenseIdentification parseFrom(CodedInputStream input,
				ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
			return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
		}

		@java.lang.Override
		public Builder newBuilderForType() {
			return newBuilder();
		}

		public static Builder newBuilder() {
			return DEFAULT_INSTANCE.toBuilder();
		}

		public static Builder newBuilder(WvProto2.LicenseIdentification prototype) {
			return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
		}

		@java.lang.Override
		public Builder toBuilder() {
			return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
		}

		@java.lang.Override
		protected Builder newBuilderForType(GeneratedMessageV3.BuilderParent parent) {
			Builder builder = new Builder(parent);
			return builder;
		}

		/**
		 * <pre>
		 * LicenseIdentification is propagated from LicenseRequest to License,
		 * incrementing version with each iteration.
		 * </pre>
		 *
		 * Protobuf type {@code LicenseIdentification}
		 */
		public static final class Builder extends GeneratedMessageV3.Builder<Builder> implements
				// @@protoc_insertion_point(builder_implements:LicenseIdentification)
				WvProto2.LicenseIdentificationOrBuilder {
			public static final Descriptors.Descriptor getDescriptor() {
				return WvProto2.internal_static_LicenseIdentification_descriptor;
			}

			@java.lang.Override
			protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
				return WvProto2.internal_static_LicenseIdentification_fieldAccessorTable
						.ensureFieldAccessorsInitialized(WvProto2.LicenseIdentification.class,
								WvProto2.LicenseIdentification.Builder.class);
			}

			// Construct using
			// WvProto2.LicenseIdentification.newBuilder()
			private Builder() {

			}

			private Builder(GeneratedMessageV3.BuilderParent parent) {
				super(parent);

			}

			@java.lang.Override
			public Builder clear() {
				super.clear();
				bitField0_ = 0;
				requestId_ = ByteString.EMPTY;
				sessionId_ = ByteString.EMPTY;
				purchaseId_ = ByteString.EMPTY;
				type_ = 1;
				version_ = 0;
				providerSessionToken_ = ByteString.EMPTY;
				return this;
			}

			@java.lang.Override
			public Descriptors.Descriptor getDescriptorForType() {
				return WvProto2.internal_static_LicenseIdentification_descriptor;
			}

			@java.lang.Override
			public WvProto2.LicenseIdentification getDefaultInstanceForType() {
				return WvProto2.LicenseIdentification.getDefaultInstance();
			}

			@java.lang.Override
			public WvProto2.LicenseIdentification build() {
				WvProto2.LicenseIdentification result = buildPartial();
				if (!result.isInitialized()) {
					throw newUninitializedMessageException(result);
				}
				return result;
			}

			@java.lang.Override
			public WvProto2.LicenseIdentification buildPartial() {
				WvProto2.LicenseIdentification result = new WvProto2.LicenseIdentification(
						this);
				if (bitField0_ != 0) {
					buildPartial0(result);
				}
				onBuilt();
				return result;
			}

			private void buildPartial0(WvProto2.LicenseIdentification result) {
				int from_bitField0_ = bitField0_;
				int to_bitField0_ = 0;
				if (((from_bitField0_ & 0x00000001) != 0)) {
					result.requestId_ = requestId_;
					to_bitField0_ |= 0x00000001;
				}
				if (((from_bitField0_ & 0x00000002) != 0)) {
					result.sessionId_ = sessionId_;
					to_bitField0_ |= 0x00000002;
				}
				if (((from_bitField0_ & 0x00000004) != 0)) {
					result.purchaseId_ = purchaseId_;
					to_bitField0_ |= 0x00000004;
				}
				if (((from_bitField0_ & 0x00000008) != 0)) {
					result.type_ = type_;
					to_bitField0_ |= 0x00000008;
				}
				if (((from_bitField0_ & 0x00000010) != 0)) {
					result.version_ = version_;
					to_bitField0_ |= 0x00000010;
				}
				if (((from_bitField0_ & 0x00000020) != 0)) {
					result.providerSessionToken_ = providerSessionToken_;
					to_bitField0_ |= 0x00000020;
				}
				result.bitField0_ |= to_bitField0_;
			}

			@java.lang.Override
			public Builder mergeFrom(Message other) {
				if (other instanceof WvProto2.LicenseIdentification) {
					return mergeFrom((WvProto2.LicenseIdentification) other);
				}
				super.mergeFrom(other);
				return this;
			}

			public Builder mergeFrom(WvProto2.LicenseIdentification other) {
				if (other == WvProto2.LicenseIdentification.getDefaultInstance())
					return this;
				if (other.hasRequestId()) {
					setRequestId(other.getRequestId());
				}
				if (other.hasSessionId()) {
					setSessionId(other.getSessionId());
				}
				if (other.hasPurchaseId()) {
					setPurchaseId(other.getPurchaseId());
				}
				if (other.hasType()) {
					setType(other.getType());
				}
				if (other.hasVersion()) {
					setVersion(other.getVersion());
				}
				if (other.hasProviderSessionToken()) {
					setProviderSessionToken(other.getProviderSessionToken());
				}
				this.mergeUnknownFields(other.getUnknownFields());
				onChanged();
				return this;
			}

			@java.lang.Override
			public final boolean isInitialized() {
				return true;
			}

			@java.lang.Override
			public Builder mergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
					throws java.io.IOException {
				if (extensionRegistry == null) {
					throw new java.lang.NullPointerException();
				}
				try {
					boolean done = false;
					while (!done) {
						int tag = input.readTag();
						switch (tag) {
						case 0:
							done = true;
							break;
						case 10: {
							requestId_ = input.readBytes();
							bitField0_ |= 0x00000001;
							break;
						} // case 10
						case 18: {
							sessionId_ = input.readBytes();
							bitField0_ |= 0x00000002;
							break;
						} // case 18
						case 26: {
							purchaseId_ = input.readBytes();
							bitField0_ |= 0x00000004;
							break;
						} // case 26
						case 32: {
							int tmpRaw = input.readEnum();
							WvProto2.LicenseType tmpValue = WvProto2.LicenseType
									.forNumber(tmpRaw);
							if (tmpValue == null) {
								mergeUnknownVarintField(4, tmpRaw);
							} else {
								type_ = tmpRaw;
								bitField0_ |= 0x00000008;
							}
							break;
						} // case 32
						case 40: {
							version_ = input.readInt32();
							bitField0_ |= 0x00000010;
							break;
						} // case 40
						case 50: {
							providerSessionToken_ = input.readBytes();
							bitField0_ |= 0x00000020;
							break;
						} // case 50
						default: {
							if (!super.parseUnknownField(input, extensionRegistry, tag)) {
								done = true; // was an endgroup tag
							}
							break;
						} // default:
						} // switch (tag)
					} // while (!done)
				} catch (InvalidProtocolBufferException e) {
					throw e.unwrapIOException();
				}
				finally {
					onChanged();
				} // finally
				return this;
			}

			private int bitField0_;

			private ByteString requestId_ = ByteString.EMPTY;

			/**
			 * <code>optional bytes request_id = 1;</code>
			 * 
			 * @return Whether the requestId field is set.
			 */
			@java.lang.Override
			public boolean hasRequestId() {
				return ((bitField0_ & 0x00000001) != 0);
			}

			/**
			 * <code>optional bytes request_id = 1;</code>
			 * 
			 * @return The requestId.
			 */
			@java.lang.Override
			public ByteString getRequestId() {
				return requestId_;
			}

			/**
			 * <code>optional bytes request_id = 1;</code>
			 * 
			 * @param value The requestId to set.
			 * @return This builder for chaining.
			 */
			public Builder setRequestId(ByteString value) {
				if (value == null) {
					throw new NullPointerException();
				}
				requestId_ = value;
				bitField0_ |= 0x00000001;
				onChanged();
				return this;
			}

			/**
			 * <code>optional bytes request_id = 1;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearRequestId() {
				bitField0_ = (bitField0_ & ~0x00000001);
				requestId_ = getDefaultInstance().getRequestId();
				onChanged();
				return this;
			}

			private ByteString sessionId_ = ByteString.EMPTY;

			/**
			 * <code>optional bytes session_id = 2;</code>
			 * 
			 * @return Whether the sessionId field is set.
			 */
			@java.lang.Override
			public boolean hasSessionId() {
				return ((bitField0_ & 0x00000002) != 0);
			}

			/**
			 * <code>optional bytes session_id = 2;</code>
			 * 
			 * @return The sessionId.
			 */
			@java.lang.Override
			public ByteString getSessionId() {
				return sessionId_;
			}

			/**
			 * <code>optional bytes session_id = 2;</code>
			 * 
			 * @param value The sessionId to set.
			 * @return This builder for chaining.
			 */
			public Builder setSessionId(ByteString value) {
				if (value == null) {
					throw new NullPointerException();
				}
				sessionId_ = value;
				bitField0_ |= 0x00000002;
				onChanged();
				return this;
			}

			/**
			 * <code>optional bytes session_id = 2;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearSessionId() {
				bitField0_ = (bitField0_ & ~0x00000002);
				sessionId_ = getDefaultInstance().getSessionId();
				onChanged();
				return this;
			}

			private ByteString purchaseId_ = ByteString.EMPTY;

			/**
			 * <code>optional bytes purchase_id = 3;</code>
			 * 
			 * @return Whether the purchaseId field is set.
			 */
			@java.lang.Override
			public boolean hasPurchaseId() {
				return ((bitField0_ & 0x00000004) != 0);
			}

			/**
			 * <code>optional bytes purchase_id = 3;</code>
			 * 
			 * @return The purchaseId.
			 */
			@java.lang.Override
			public ByteString getPurchaseId() {
				return purchaseId_;
			}

			/**
			 * <code>optional bytes purchase_id = 3;</code>
			 * 
			 * @param value The purchaseId to set.
			 * @return This builder for chaining.
			 */
			public Builder setPurchaseId(ByteString value) {
				if (value == null) {
					throw new NullPointerException();
				}
				purchaseId_ = value;
				bitField0_ |= 0x00000004;
				onChanged();
				return this;
			}

			/**
			 * <code>optional bytes purchase_id = 3;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearPurchaseId() {
				bitField0_ = (bitField0_ & ~0x00000004);
				purchaseId_ = getDefaultInstance().getPurchaseId();
				onChanged();
				return this;
			}

			private int type_ = 1;

			/**
			 * <code>optional .LicenseType type = 4;</code>
			 * 
			 * @return Whether the type field is set.
			 */
			@java.lang.Override
			public boolean hasType() {
				return ((bitField0_ & 0x00000008) != 0);
			}

			/**
			 * <code>optional .LicenseType type = 4;</code>
			 * 
			 * @return The type.
			 */
			@java.lang.Override
			public WvProto2.LicenseType getType() {
				WvProto2.LicenseType result = WvProto2.LicenseType
						.forNumber(type_);
				return result == null ? WvProto2.LicenseType.STREAMING : result;
			}

			/**
			 * <code>optional .LicenseType type = 4;</code>
			 * 
			 * @param value The type to set.
			 * @return This builder for chaining.
			 */
			public Builder setType(WvProto2.LicenseType value) {
				if (value == null) {
					throw new NullPointerException();
				}
				bitField0_ |= 0x00000008;
				type_ = value.getNumber();
				onChanged();
				return this;
			}

			/**
			 * <code>optional .LicenseType type = 4;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearType() {
				bitField0_ = (bitField0_ & ~0x00000008);
				type_ = 1;
				onChanged();
				return this;
			}

			private int version_;

			/**
			 * <code>optional int32 version = 5;</code>
			 * 
			 * @return Whether the version field is set.
			 */
			@java.lang.Override
			public boolean hasVersion() {
				return ((bitField0_ & 0x00000010) != 0);
			}

			/**
			 * <code>optional int32 version = 5;</code>
			 * 
			 * @return The version.
			 */
			@java.lang.Override
			public int getVersion() {
				return version_;
			}

			/**
			 * <code>optional int32 version = 5;</code>
			 * 
			 * @param value The version to set.
			 * @return This builder for chaining.
			 */
			public Builder setVersion(int value) {

				version_ = value;
				bitField0_ |= 0x00000010;
				onChanged();
				return this;
			}

			/**
			 * <code>optional int32 version = 5;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearVersion() {
				bitField0_ = (bitField0_ & ~0x00000010);
				version_ = 0;
				onChanged();
				return this;
			}

			private ByteString providerSessionToken_ = ByteString.EMPTY;

			/**
			 * <code>optional bytes provider_session_token = 6;</code>
			 * 
			 * @return Whether the providerSessionToken field is set.
			 */
			@java.lang.Override
			public boolean hasProviderSessionToken() {
				return ((bitField0_ & 0x00000020) != 0);
			}

			/**
			 * <code>optional bytes provider_session_token = 6;</code>
			 * 
			 * @return The providerSessionToken.
			 */
			@java.lang.Override
			public ByteString getProviderSessionToken() {
				return providerSessionToken_;
			}

			/**
			 * <code>optional bytes provider_session_token = 6;</code>
			 * 
			 * @param value The providerSessionToken to set.
			 * @return This builder for chaining.
			 */
			public Builder setProviderSessionToken(ByteString value) {
				if (value == null) {
					throw new NullPointerException();
				}
				providerSessionToken_ = value;
				bitField0_ |= 0x00000020;
				onChanged();
				return this;
			}

			/**
			 * <code>optional bytes provider_session_token = 6;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearProviderSessionToken() {
				bitField0_ = (bitField0_ & ~0x00000020);
				providerSessionToken_ = getDefaultInstance().getProviderSessionToken();
				onChanged();
				return this;
			}

			@java.lang.Override
			public final Builder setUnknownFields(final UnknownFieldSet unknownFields) {
				return super.setUnknownFields(unknownFields);
			}

			@java.lang.Override
			public final Builder mergeUnknownFields(final UnknownFieldSet unknownFields) {
				return super.mergeUnknownFields(unknownFields);
			}

			// @@protoc_insertion_point(builder_scope:LicenseIdentification)
		}

		// @@protoc_insertion_point(class_scope:LicenseIdentification)
		private static final WvProto2.LicenseIdentification DEFAULT_INSTANCE;
		static {
			DEFAULT_INSTANCE = new WvProto2.LicenseIdentification();
		}

		public static WvProto2.LicenseIdentification getDefaultInstance() {
			return DEFAULT_INSTANCE;
		}

		@java.lang.Deprecated public static final Parser<LicenseIdentification> PARSER = new AbstractParser<>() {
			@java.lang.Override
			public LicenseIdentification parsePartialFrom(CodedInputStream input,
					ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
				Builder builder = newBuilder();
				try {
					builder.mergeFrom(input, extensionRegistry);
				} catch (InvalidProtocolBufferException e) {
					throw e.setUnfinishedMessage(builder.buildPartial());
				} catch (UninitializedMessageException e) {
					throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
				} catch (java.io.IOException e) {
					throw new InvalidProtocolBufferException(e).setUnfinishedMessage(builder.buildPartial());
				}
				return builder.buildPartial();
			}
		};

		public static Parser<LicenseIdentification> parser() {
			return PARSER;
		}

		@java.lang.Override
		public Parser<LicenseIdentification> getParserForType() {
			return PARSER;
		}

		@java.lang.Override
		public WvProto2.LicenseIdentification getDefaultInstanceForType() {
			return DEFAULT_INSTANCE;
		}

	}

	public interface LicenseOrBuilder extends
			// @@protoc_insertion_point(interface_extends:License)
			MessageOrBuilder {

		/**
		 * <code>optional .LicenseIdentification id = 1;</code>
		 * 
		 * @return Whether the id field is set.
		 */
		boolean hasId();

		/**
		 * <code>optional .LicenseIdentification id = 1;</code>
		 * 
		 * @return The id.
		 */
		WvProto2.LicenseIdentification getId();

		/**
		 * <code>optional .LicenseIdentification id = 1;</code>
		 */
		WvProto2.LicenseIdentificationOrBuilder getIdOrBuilder();

		/**
		 * <code>optional .License.Policy policy = 2;</code>
		 * 
		 * @return Whether the policy field is set.
		 */
		boolean hasPolicy();

		/**
		 * <code>optional .License.Policy policy = 2;</code>
		 * 
		 * @return The policy.
		 */
		WvProto2.License.Policy getPolicy();

		/**
		 * <code>optional .License.Policy policy = 2;</code>
		 */
		WvProto2.License.PolicyOrBuilder getPolicyOrBuilder();

		/**
		 * <code>repeated .License.KeyContainer key = 3;</code>
		 */
		java.util.List<WvProto2.License.KeyContainer> getKeyList();

		/**
		 * <code>repeated .License.KeyContainer key = 3;</code>
		 */
		WvProto2.License.KeyContainer getKey(int index);

		/**
		 * <code>repeated .License.KeyContainer key = 3;</code>
		 */
		int getKeyCount();

		/**
		 * <code>repeated .License.KeyContainer key = 3;</code>
		 */
		java.util.List<? extends WvProto2.License.KeyContainerOrBuilder> getKeyOrBuilderList();

		/**
		 * <code>repeated .License.KeyContainer key = 3;</code>
		 */
		WvProto2.License.KeyContainerOrBuilder getKeyOrBuilder(int index);

		/**
		 * <pre>
		 * Time of the request in seconds (UTC) as set in
		 * LicenseRequest.request_time.  If this time is not set in the request,
		 * the local time at the license service is used in this field.
		 * </pre>
		 *
		 * <code>optional int64 license_start_time = 4;</code>
		 * 
		 * @return Whether the licenseStartTime field is set.
		 */
		boolean hasLicenseStartTime();

		/**
		 * <pre>
		 * Time of the request in seconds (UTC) as set in
		 * LicenseRequest.request_time.  If this time is not set in the request,
		 * the local time at the license service is used in this field.
		 * </pre>
		 *
		 * <code>optional int64 license_start_time = 4;</code>
		 * 
		 * @return The licenseStartTime.
		 */
		long getLicenseStartTime();

		/**
		 * <code>optional bool remote_attestation_verified = 5 [default = false];</code>
		 * 
		 * @return Whether the remoteAttestationVerified field is set.
		 */
		boolean hasRemoteAttestationVerified();

		/**
		 * <code>optional bool remote_attestation_verified = 5 [default = false];</code>
		 * 
		 * @return The remoteAttestationVerified.
		 */
		boolean getRemoteAttestationVerified();

		/**
		 * <pre>
		 * Client token generated by the content provider. Optional.
		 * </pre>
		 *
		 * <code>optional bytes provider_client_token = 6;</code>
		 * 
		 * @return Whether the providerClientToken field is set.
		 */
		boolean hasProviderClientToken();

		/**
		 * <pre>
		 * Client token generated by the content provider. Optional.
		 * </pre>
		 *
		 * <code>optional bytes provider_client_token = 6;</code>
		 * 
		 * @return The providerClientToken.
		 */
		ByteString getProviderClientToken();

		/**
		 * <pre>
		 * 4cc code specifying the CENC protection scheme as defined in the CENC 3.0
		 * specification. Propagated from Widevine PSSH box. Optional.
		 * </pre>
		 *
		 * <code>optional uint32 protection_scheme = 7;</code>
		 * 
		 * @return Whether the protectionScheme field is set.
		 */
		boolean hasProtectionScheme();

		/**
		 * <pre>
		 * 4cc code specifying the CENC protection scheme as defined in the CENC 3.0
		 * specification. Propagated from Widevine PSSH box. Optional.
		 * </pre>
		 *
		 * <code>optional uint32 protection_scheme = 7;</code>
		 * 
		 * @return The protectionScheme.
		 */
		int getProtectionScheme();

		/**
		 * <pre>
		 * 8 byte verification field "HDCPDATA" followed by unsigned 32 bit minimum
		 * HDCP SRM version (whether the version is for HDCP1 SRM or HDCP2 SRM
		 * depends on client max_hdcp_version).
		 * Additional details can be found in Widevine Modular DRM Security
		 * Integration Guide for CENC.
		 * </pre>
		 *
		 * <code>optional bytes srm_requirement = 8;</code>
		 * 
		 * @return Whether the srmRequirement field is set.
		 */
		boolean hasSrmRequirement();

		/**
		 * <pre>
		 * 8 byte verification field "HDCPDATA" followed by unsigned 32 bit minimum
		 * HDCP SRM version (whether the version is for HDCP1 SRM or HDCP2 SRM
		 * depends on client max_hdcp_version).
		 * Additional details can be found in Widevine Modular DRM Security
		 * Integration Guide for CENC.
		 * </pre>
		 *
		 * <code>optional bytes srm_requirement = 8;</code>
		 * 
		 * @return The srmRequirement.
		 */
		ByteString getSrmRequirement();

		/**
		 * <pre>
		 * If present this contains a signed SRM file (either HDCP1 SRM or HDCP2 SRM
		 * depending on client max_hdcp_version) that should be installed on the
		 * client device.
		 * </pre>
		 *
		 * <code>optional bytes srm_update = 9;</code>
		 * 
		 * @return Whether the srmUpdate field is set.
		 */
		boolean hasSrmUpdate();

		/**
		 * <pre>
		 * If present this contains a signed SRM file (either HDCP1 SRM or HDCP2 SRM
		 * depending on client max_hdcp_version) that should be installed on the
		 * client device.
		 * </pre>
		 *
		 * <code>optional bytes srm_update = 9;</code>
		 * 
		 * @return The srmUpdate.
		 */
		ByteString getSrmUpdate();

		/**
		 * <pre>
		 * Indicates the status of any type of platform verification performed by the
		 * server.
		 * </pre>
		 *
		 * <code>optional .PlatformVerificationStatus platform_verification_status = 10 [default = PLATFORM_NO_VERIFICATION];</code>
		 * 
		 * @return Whether the platformVerificationStatus field is set.
		 */
		boolean hasPlatformVerificationStatus();

		/**
		 * <pre>
		 * Indicates the status of any type of platform verification performed by the
		 * server.
		 * </pre>
		 *
		 * <code>optional .PlatformVerificationStatus platform_verification_status = 10 [default = PLATFORM_NO_VERIFICATION];</code>
		 * 
		 * @return The platformVerificationStatus.
		 */
		WvProto2.PlatformVerificationStatus getPlatformVerificationStatus();

		/**
		 * <pre>
		 * IDs of the groups for which keys are delivered in this license, if any.
		 * </pre>
		 *
		 * <code>repeated bytes group_ids = 11;</code>
		 * 
		 * @return A list containing the groupIds.
		 */
		java.util.List<ByteString> getGroupIdsList();

		/**
		 * <pre>
		 * IDs of the groups for which keys are delivered in this license, if any.
		 * </pre>
		 *
		 * <code>repeated bytes group_ids = 11;</code>
		 * 
		 * @return The count of groupIds.
		 */
		int getGroupIdsCount();

		/**
		 * <pre>
		 * IDs of the groups for which keys are delivered in this license, if any.
		 * </pre>
		 *
		 * <code>repeated bytes group_ids = 11;</code>
		 * 
		 * @param index The index of the element to return.
		 * @return The groupIds at the given index.
		 */
		ByteString getGroupIds(int index);
	}

	/**
	 * Protobuf type {@code License}
	 */
	public static final class License extends GeneratedMessageV3 implements
			// @@protoc_insertion_point(message_implements:License)
			LicenseOrBuilder {
		private static final long serialVersionUID = 0L;

		// Use License.newBuilder() to construct.
		private License(GeneratedMessageV3.Builder<?> builder) {
			super(builder);
		}

		private License() {
			key_ = java.util.Collections.emptyList();
			providerClientToken_ = ByteString.EMPTY;
			srmRequirement_ = ByteString.EMPTY;
			srmUpdate_ = ByteString.EMPTY;
			platformVerificationStatus_ = 4;
			groupIds_ = java.util.Collections.emptyList();
		}

		@java.lang.Override
		@SuppressWarnings({})
		protected java.lang.Object newInstance(UnusedPrivateParameter unused) {
			return new License();
		}

		public static final Descriptors.Descriptor getDescriptor() {
			return WvProto2.internal_static_License_descriptor;
		}

		@java.lang.Override
		protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
			return WvProto2.internal_static_License_fieldAccessorTable
					.ensureFieldAccessorsInitialized(WvProto2.License.class,
							WvProto2.License.Builder.class);
		}

		public interface PolicyOrBuilder extends
				// @@protoc_insertion_point(interface_extends:License.Policy)
				MessageOrBuilder {

			/**
			 * <pre>
			 * Indicates that playback of the content is allowed.
			 * </pre>
			 *
			 * <code>optional bool can_play = 1 [default = false];</code>
			 * 
			 * @return Whether the canPlay field is set.
			 */
			boolean hasCanPlay();

			/**
			 * <pre>
			 * Indicates that playback of the content is allowed.
			 * </pre>
			 *
			 * <code>optional bool can_play = 1 [default = false];</code>
			 * 
			 * @return The canPlay.
			 */
			boolean getCanPlay();

			/**
			 * <pre>
			 * Indicates that the license may be persisted to non-volatile
			 * storage for offline use.
			 * </pre>
			 *
			 * <code>optional bool can_persist = 2 [default = false];</code>
			 * 
			 * @return Whether the canPersist field is set.
			 */
			boolean hasCanPersist();

			/**
			 * <pre>
			 * Indicates that the license may be persisted to non-volatile
			 * storage for offline use.
			 * </pre>
			 *
			 * <code>optional bool can_persist = 2 [default = false];</code>
			 * 
			 * @return The canPersist.
			 */
			boolean getCanPersist();

			/**
			 * <pre>
			 * Indicates that renewal of this license is allowed.
			 * </pre>
			 *
			 * <code>optional bool can_renew = 3 [default = false];</code>
			 * 
			 * @return Whether the canRenew field is set.
			 */
			boolean hasCanRenew();

			/**
			 * <pre>
			 * Indicates that renewal of this license is allowed.
			 * </pre>
			 *
			 * <code>optional bool can_renew = 3 [default = false];</code>
			 * 
			 * @return The canRenew.
			 */
			boolean getCanRenew();

			/**
			 * <pre>
			 * Indicates the rental window.
			 * </pre>
			 *
			 * <code>optional int64 rental_duration_seconds = 4 [default = 0];</code>
			 * 
			 * @return Whether the rentalDurationSeconds field is set.
			 */
			boolean hasRentalDurationSeconds();

			/**
			 * <pre>
			 * Indicates the rental window.
			 * </pre>
			 *
			 * <code>optional int64 rental_duration_seconds = 4 [default = 0];</code>
			 * 
			 * @return The rentalDurationSeconds.
			 */
			long getRentalDurationSeconds();

			/**
			 * <pre>
			 * Indicates the viewing window, once playback has begun.
			 * </pre>
			 *
			 * <code>optional int64 playback_duration_seconds = 5 [default = 0];</code>
			 * 
			 * @return Whether the playbackDurationSeconds field is set.
			 */
			boolean hasPlaybackDurationSeconds();

			/**
			 * <pre>
			 * Indicates the viewing window, once playback has begun.
			 * </pre>
			 *
			 * <code>optional int64 playback_duration_seconds = 5 [default = 0];</code>
			 * 
			 * @return The playbackDurationSeconds.
			 */
			long getPlaybackDurationSeconds();

			/**
			 * <pre>
			 * Indicates the time window for this specific license.
			 * </pre>
			 *
			 * <code>optional int64 license_duration_seconds = 6 [default = 0];</code>
			 * 
			 * @return Whether the licenseDurationSeconds field is set.
			 */
			boolean hasLicenseDurationSeconds();

			/**
			 * <pre>
			 * Indicates the time window for this specific license.
			 * </pre>
			 *
			 * <code>optional int64 license_duration_seconds = 6 [default = 0];</code>
			 * 
			 * @return The licenseDurationSeconds.
			 */
			long getLicenseDurationSeconds();

			/**
			 * <pre>
			 * The window of time, in which playback is allowed to continue while
			 * renewal is attempted, yet unsuccessful due to backend problems with
			 * the license server.
			 * </pre>
			 *
			 * <code>optional int64 renewal_recovery_duration_seconds = 7 [default = 0];</code>
			 * 
			 * @return Whether the renewalRecoveryDurationSeconds field is set.
			 */
			boolean hasRenewalRecoveryDurationSeconds();

			/**
			 * <pre>
			 * The window of time, in which playback is allowed to continue while
			 * renewal is attempted, yet unsuccessful due to backend problems with
			 * the license server.
			 * </pre>
			 *
			 * <code>optional int64 renewal_recovery_duration_seconds = 7 [default = 0];</code>
			 * 
			 * @return The renewalRecoveryDurationSeconds.
			 */
			long getRenewalRecoveryDurationSeconds();

			/**
			 * <pre>
			 * All renewal requests for this license shall be directed to the
			 * specified URL.
			 * </pre>
			 *
			 * <code>optional string renewal_server_url = 8;</code>
			 * 
			 * @return Whether the renewalServerUrl field is set.
			 */
			boolean hasRenewalServerUrl();

			/**
			 * <pre>
			 * All renewal requests for this license shall be directed to the
			 * specified URL.
			 * </pre>
			 *
			 * <code>optional string renewal_server_url = 8;</code>
			 * 
			 * @return The renewalServerUrl.
			 */
			java.lang.String getRenewalServerUrl();

			/**
			 * <pre>
			 * All renewal requests for this license shall be directed to the
			 * specified URL.
			 * </pre>
			 *
			 * <code>optional string renewal_server_url = 8;</code>
			 * 
			 * @return The bytes for renewalServerUrl.
			 */
			ByteString getRenewalServerUrlBytes();

			/**
			 * <pre>
			 * How many seconds after license_start_time, before renewal is first
			 * attempted.
			 * </pre>
			 *
			 * <code>optional int64 renewal_delay_seconds = 9 [default = 0];</code>
			 * 
			 * @return Whether the renewalDelaySeconds field is set.
			 */
			boolean hasRenewalDelaySeconds();

			/**
			 * <pre>
			 * How many seconds after license_start_time, before renewal is first
			 * attempted.
			 * </pre>
			 *
			 * <code>optional int64 renewal_delay_seconds = 9 [default = 0];</code>
			 * 
			 * @return The renewalDelaySeconds.
			 */
			long getRenewalDelaySeconds();

			/**
			 * <pre>
			 * Specifies the delay in seconds between subsequent license
			 * renewal requests, in case of failure.
			 * </pre>
			 *
			 * <code>optional int64 renewal_retry_interval_seconds = 10 [default = 0];</code>
			 * 
			 * @return Whether the renewalRetryIntervalSeconds field is set.
			 */
			boolean hasRenewalRetryIntervalSeconds();

			/**
			 * <pre>
			 * Specifies the delay in seconds between subsequent license
			 * renewal requests, in case of failure.
			 * </pre>
			 *
			 * <code>optional int64 renewal_retry_interval_seconds = 10 [default = 0];</code>
			 * 
			 * @return The renewalRetryIntervalSeconds.
			 */
			long getRenewalRetryIntervalSeconds();

			/**
			 * <pre>
			 * Indicates that the license shall be sent for renewal when usage is
			 * started.
			 * </pre>
			 *
			 * <code>optional bool renew_with_usage = 11 [default = false];</code>
			 * 
			 * @return Whether the renewWithUsage field is set.
			 */
			boolean hasRenewWithUsage();

			/**
			 * <pre>
			 * Indicates that the license shall be sent for renewal when usage is
			 * started.
			 * </pre>
			 *
			 * <code>optional bool renew_with_usage = 11 [default = false];</code>
			 * 
			 * @return The renewWithUsage.
			 */
			boolean getRenewWithUsage();

			/**
			 * <pre>
			 * Indicates to client that license renewal and release requests ought to
			 * include ClientIdentification (client_id).
			 * </pre>
			 *
			 * <code>optional bool always_include_client_id = 12 [default = false];</code>
			 * 
			 * @return Whether the alwaysIncludeClientId field is set.
			 */
			boolean hasAlwaysIncludeClientId();

			/**
			 * <pre>
			 * Indicates to client that license renewal and release requests ought to
			 * include ClientIdentification (client_id).
			 * </pre>
			 *
			 * <code>optional bool always_include_client_id = 12 [default = false];</code>
			 * 
			 * @return The alwaysIncludeClientId.
			 */
			boolean getAlwaysIncludeClientId();

			/**
			 * <pre>
			 * Duration of grace period before playback_duration_seconds (short window)
			 * goes into effect. Optional.
			 * </pre>
			 *
			 * <code>optional int64 play_start_grace_period_seconds = 13 [default = 0];</code>
			 * 
			 * @return Whether the playStartGracePeriodSeconds field is set.
			 */
			boolean hasPlayStartGracePeriodSeconds();

			/**
			 * <pre>
			 * Duration of grace period before playback_duration_seconds (short window)
			 * goes into effect. Optional.
			 * </pre>
			 *
			 * <code>optional int64 play_start_grace_period_seconds = 13 [default = 0];</code>
			 * 
			 * @return The playStartGracePeriodSeconds.
			 */
			long getPlayStartGracePeriodSeconds();

			/**
			 * <pre>
			 * Enables "soft enforcement" of playback_duration_seconds, letting the user
			 * finish playback even if short window expires. Optional.
			 * </pre>
			 *
			 * <code>optional bool soft_enforce_playback_duration = 14 [default = false];</code>
			 * 
			 * @return Whether the softEnforcePlaybackDuration field is set.
			 */
			boolean hasSoftEnforcePlaybackDuration();

			/**
			 * <pre>
			 * Enables "soft enforcement" of playback_duration_seconds, letting the user
			 * finish playback even if short window expires. Optional.
			 * </pre>
			 *
			 * <code>optional bool soft_enforce_playback_duration = 14 [default = false];</code>
			 * 
			 * @return The softEnforcePlaybackDuration.
			 */
			boolean getSoftEnforcePlaybackDuration();

			/**
			 * <pre>
			 * Enables "soft enforcement" of rental_duration_seconds. Initial playback
			 * must always start before rental duration expires.  In order to allow
			 * subsequent playbacks to start after the rental duration expires,
			 * soft_enforce_playback_duration must be true. Otherwise, subsequent
			 * playbacks will not be allowed once rental duration expires. Optional.
			 * </pre>
			 *
			 * <code>optional bool soft_enforce_rental_duration = 15 [default = true];</code>
			 * 
			 * @return Whether the softEnforceRentalDuration field is set.
			 */
			boolean hasSoftEnforceRentalDuration();

			/**
			 * <pre>
			 * Enables "soft enforcement" of rental_duration_seconds. Initial playback
			 * must always start before rental duration expires.  In order to allow
			 * subsequent playbacks to start after the rental duration expires,
			 * soft_enforce_playback_duration must be true. Otherwise, subsequent
			 * playbacks will not be allowed once rental duration expires. Optional.
			 * </pre>
			 *
			 * <code>optional bool soft_enforce_rental_duration = 15 [default = true];</code>
			 * 
			 * @return The softEnforceRentalDuration.
			 */
			boolean getSoftEnforceRentalDuration();
		}

		/**
		 * Protobuf type {@code License.Policy}
		 */
		public static final class Policy extends GeneratedMessageV3 implements
				// @@protoc_insertion_point(message_implements:License.Policy)
				PolicyOrBuilder {
			private static final long serialVersionUID = 0L;

			// Use Policy.newBuilder() to construct.
			private Policy(GeneratedMessageV3.Builder<?> builder) {
				super(builder);
			}

			private Policy() {
				renewalServerUrl_ = "";
				softEnforceRentalDuration_ = true;
			}

			@java.lang.Override
			@SuppressWarnings({})
			protected java.lang.Object newInstance(UnusedPrivateParameter unused) {
				return new Policy();
			}

			public static final Descriptors.Descriptor getDescriptor() {
				return WvProto2.internal_static_License_Policy_descriptor;
			}

			@java.lang.Override
			protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
				return WvProto2.internal_static_License_Policy_fieldAccessorTable
						.ensureFieldAccessorsInitialized(WvProto2.License.Policy.class,
								WvProto2.License.Policy.Builder.class);
			}

			private int bitField0_;
			public static final int CAN_PLAY_FIELD_NUMBER = 1;
			private boolean canPlay_ = false;

			/**
			 * <pre>
			 * Indicates that playback of the content is allowed.
			 * </pre>
			 *
			 * <code>optional bool can_play = 1 [default = false];</code>
			 * 
			 * @return Whether the canPlay field is set.
			 */
			@java.lang.Override
			public boolean hasCanPlay() {
				return ((bitField0_ & 0x00000001) != 0);
			}

			/**
			 * <pre>
			 * Indicates that playback of the content is allowed.
			 * </pre>
			 *
			 * <code>optional bool can_play = 1 [default = false];</code>
			 * 
			 * @return The canPlay.
			 */
			@java.lang.Override
			public boolean getCanPlay() {
				return canPlay_;
			}

			public static final int CAN_PERSIST_FIELD_NUMBER = 2;
			private boolean canPersist_ = false;

			/**
			 * <pre>
			 * Indicates that the license may be persisted to non-volatile
			 * storage for offline use.
			 * </pre>
			 *
			 * <code>optional bool can_persist = 2 [default = false];</code>
			 * 
			 * @return Whether the canPersist field is set.
			 */
			@java.lang.Override
			public boolean hasCanPersist() {
				return ((bitField0_ & 0x00000002) != 0);
			}

			/**
			 * <pre>
			 * Indicates that the license may be persisted to non-volatile
			 * storage for offline use.
			 * </pre>
			 *
			 * <code>optional bool can_persist = 2 [default = false];</code>
			 * 
			 * @return The canPersist.
			 */
			@java.lang.Override
			public boolean getCanPersist() {
				return canPersist_;
			}

			public static final int CAN_RENEW_FIELD_NUMBER = 3;
			private boolean canRenew_ = false;

			/**
			 * <pre>
			 * Indicates that renewal of this license is allowed.
			 * </pre>
			 *
			 * <code>optional bool can_renew = 3 [default = false];</code>
			 * 
			 * @return Whether the canRenew field is set.
			 */
			@java.lang.Override
			public boolean hasCanRenew() {
				return ((bitField0_ & 0x00000004) != 0);
			}

			/**
			 * <pre>
			 * Indicates that renewal of this license is allowed.
			 * </pre>
			 *
			 * <code>optional bool can_renew = 3 [default = false];</code>
			 * 
			 * @return The canRenew.
			 */
			@java.lang.Override
			public boolean getCanRenew() {
				return canRenew_;
			}

			public static final int RENTAL_DURATION_SECONDS_FIELD_NUMBER = 4;
			private long rentalDurationSeconds_ = 0L;

			/**
			 * <pre>
			 * Indicates the rental window.
			 * </pre>
			 *
			 * <code>optional int64 rental_duration_seconds = 4 [default = 0];</code>
			 * 
			 * @return Whether the rentalDurationSeconds field is set.
			 */
			@java.lang.Override
			public boolean hasRentalDurationSeconds() {
				return ((bitField0_ & 0x00000008) != 0);
			}

			/**
			 * <pre>
			 * Indicates the rental window.
			 * </pre>
			 *
			 * <code>optional int64 rental_duration_seconds = 4 [default = 0];</code>
			 * 
			 * @return The rentalDurationSeconds.
			 */
			@java.lang.Override
			public long getRentalDurationSeconds() {
				return rentalDurationSeconds_;
			}

			public static final int PLAYBACK_DURATION_SECONDS_FIELD_NUMBER = 5;
			private long playbackDurationSeconds_ = 0L;

			/**
			 * <pre>
			 * Indicates the viewing window, once playback has begun.
			 * </pre>
			 *
			 * <code>optional int64 playback_duration_seconds = 5 [default = 0];</code>
			 * 
			 * @return Whether the playbackDurationSeconds field is set.
			 */
			@java.lang.Override
			public boolean hasPlaybackDurationSeconds() {
				return ((bitField0_ & 0x00000010) != 0);
			}

			/**
			 * <pre>
			 * Indicates the viewing window, once playback has begun.
			 * </pre>
			 *
			 * <code>optional int64 playback_duration_seconds = 5 [default = 0];</code>
			 * 
			 * @return The playbackDurationSeconds.
			 */
			@java.lang.Override
			public long getPlaybackDurationSeconds() {
				return playbackDurationSeconds_;
			}

			public static final int LICENSE_DURATION_SECONDS_FIELD_NUMBER = 6;
			private long licenseDurationSeconds_ = 0L;

			/**
			 * <pre>
			 * Indicates the time window for this specific license.
			 * </pre>
			 *
			 * <code>optional int64 license_duration_seconds = 6 [default = 0];</code>
			 * 
			 * @return Whether the licenseDurationSeconds field is set.
			 */
			@java.lang.Override
			public boolean hasLicenseDurationSeconds() {
				return ((bitField0_ & 0x00000020) != 0);
			}

			/**
			 * <pre>
			 * Indicates the time window for this specific license.
			 * </pre>
			 *
			 * <code>optional int64 license_duration_seconds = 6 [default = 0];</code>
			 * 
			 * @return The licenseDurationSeconds.
			 */
			@java.lang.Override
			public long getLicenseDurationSeconds() {
				return licenseDurationSeconds_;
			}

			public static final int RENEWAL_RECOVERY_DURATION_SECONDS_FIELD_NUMBER = 7;
			private long renewalRecoveryDurationSeconds_ = 0L;

			/**
			 * <pre>
			 * The window of time, in which playback is allowed to continue while
			 * renewal is attempted, yet unsuccessful due to backend problems with
			 * the license server.
			 * </pre>
			 *
			 * <code>optional int64 renewal_recovery_duration_seconds = 7 [default = 0];</code>
			 * 
			 * @return Whether the renewalRecoveryDurationSeconds field is set.
			 */
			@java.lang.Override
			public boolean hasRenewalRecoveryDurationSeconds() {
				return ((bitField0_ & 0x00000040) != 0);
			}

			/**
			 * <pre>
			 * The window of time, in which playback is allowed to continue while
			 * renewal is attempted, yet unsuccessful due to backend problems with
			 * the license server.
			 * </pre>
			 *
			 * <code>optional int64 renewal_recovery_duration_seconds = 7 [default = 0];</code>
			 * 
			 * @return The renewalRecoveryDurationSeconds.
			 */
			@java.lang.Override
			public long getRenewalRecoveryDurationSeconds() {
				return renewalRecoveryDurationSeconds_;
			}

			public static final int RENEWAL_SERVER_URL_FIELD_NUMBER = 8;
			private volatile java.lang.Object renewalServerUrl_ = "";

			/**
			 * <pre>
			 * All renewal requests for this license shall be directed to the
			 * specified URL.
			 * </pre>
			 *
			 * <code>optional string renewal_server_url = 8;</code>
			 * 
			 * @return Whether the renewalServerUrl field is set.
			 */
			@java.lang.Override
			public boolean hasRenewalServerUrl() {
				return ((bitField0_ & 0x00000080) != 0);
			}

			/**
			 * <pre>
			 * All renewal requests for this license shall be directed to the
			 * specified URL.
			 * </pre>
			 *
			 * <code>optional string renewal_server_url = 8;</code>
			 * 
			 * @return The renewalServerUrl.
			 */
			@java.lang.Override
			public java.lang.String getRenewalServerUrl() {
				java.lang.Object ref = renewalServerUrl_;
				if (ref instanceof java.lang.String) {
					return (java.lang.String) ref;
				}
				ByteString bs = (ByteString) ref;
				java.lang.String s = bs.toStringUtf8();
				if (bs.isValidUtf8()) {
					renewalServerUrl_ = s;
				}
				return s;
			}

			/**
			 * <pre>
			 * All renewal requests for this license shall be directed to the
			 * specified URL.
			 * </pre>
			 *
			 * <code>optional string renewal_server_url = 8;</code>
			 * 
			 * @return The bytes for renewalServerUrl.
			 */
			@java.lang.Override
			public ByteString getRenewalServerUrlBytes() {
				java.lang.Object ref = renewalServerUrl_;
				if (ref instanceof java.lang.String) {
					ByteString b = ByteString.copyFromUtf8((java.lang.String) ref);
					renewalServerUrl_ = b;
					return b;
				}
				return (ByteString) ref;
			}

			public static final int RENEWAL_DELAY_SECONDS_FIELD_NUMBER = 9;
			private long renewalDelaySeconds_ = 0L;

			/**
			 * <pre>
			 * How many seconds after license_start_time, before renewal is first
			 * attempted.
			 * </pre>
			 *
			 * <code>optional int64 renewal_delay_seconds = 9 [default = 0];</code>
			 * 
			 * @return Whether the renewalDelaySeconds field is set.
			 */
			@java.lang.Override
			public boolean hasRenewalDelaySeconds() {
				return ((bitField0_ & 0x00000100) != 0);
			}

			/**
			 * <pre>
			 * How many seconds after license_start_time, before renewal is first
			 * attempted.
			 * </pre>
			 *
			 * <code>optional int64 renewal_delay_seconds = 9 [default = 0];</code>
			 * 
			 * @return The renewalDelaySeconds.
			 */
			@java.lang.Override
			public long getRenewalDelaySeconds() {
				return renewalDelaySeconds_;
			}

			public static final int RENEWAL_RETRY_INTERVAL_SECONDS_FIELD_NUMBER = 10;
			private long renewalRetryIntervalSeconds_ = 0L;

			/**
			 * <pre>
			 * Specifies the delay in seconds between subsequent license
			 * renewal requests, in case of failure.
			 * </pre>
			 *
			 * <code>optional int64 renewal_retry_interval_seconds = 10 [default = 0];</code>
			 * 
			 * @return Whether the renewalRetryIntervalSeconds field is set.
			 */
			@java.lang.Override
			public boolean hasRenewalRetryIntervalSeconds() {
				return ((bitField0_ & 0x00000200) != 0);
			}

			/**
			 * <pre>
			 * Specifies the delay in seconds between subsequent license
			 * renewal requests, in case of failure.
			 * </pre>
			 *
			 * <code>optional int64 renewal_retry_interval_seconds = 10 [default = 0];</code>
			 * 
			 * @return The renewalRetryIntervalSeconds.
			 */
			@java.lang.Override
			public long getRenewalRetryIntervalSeconds() {
				return renewalRetryIntervalSeconds_;
			}

			public static final int RENEW_WITH_USAGE_FIELD_NUMBER = 11;
			private boolean renewWithUsage_ = false;

			/**
			 * <pre>
			 * Indicates that the license shall be sent for renewal when usage is
			 * started.
			 * </pre>
			 *
			 * <code>optional bool renew_with_usage = 11 [default = false];</code>
			 * 
			 * @return Whether the renewWithUsage field is set.
			 */
			@java.lang.Override
			public boolean hasRenewWithUsage() {
				return ((bitField0_ & 0x00000400) != 0);
			}

			/**
			 * <pre>
			 * Indicates that the license shall be sent for renewal when usage is
			 * started.
			 * </pre>
			 *
			 * <code>optional bool renew_with_usage = 11 [default = false];</code>
			 * 
			 * @return The renewWithUsage.
			 */
			@java.lang.Override
			public boolean getRenewWithUsage() {
				return renewWithUsage_;
			}

			public static final int ALWAYS_INCLUDE_CLIENT_ID_FIELD_NUMBER = 12;
			private boolean alwaysIncludeClientId_ = false;

			/**
			 * <pre>
			 * Indicates to client that license renewal and release requests ought to
			 * include ClientIdentification (client_id).
			 * </pre>
			 *
			 * <code>optional bool always_include_client_id = 12 [default = false];</code>
			 * 
			 * @return Whether the alwaysIncludeClientId field is set.
			 */
			@java.lang.Override
			public boolean hasAlwaysIncludeClientId() {
				return ((bitField0_ & 0x00000800) != 0);
			}

			/**
			 * <pre>
			 * Indicates to client that license renewal and release requests ought to
			 * include ClientIdentification (client_id).
			 * </pre>
			 *
			 * <code>optional bool always_include_client_id = 12 [default = false];</code>
			 * 
			 * @return The alwaysIncludeClientId.
			 */
			@java.lang.Override
			public boolean getAlwaysIncludeClientId() {
				return alwaysIncludeClientId_;
			}

			public static final int PLAY_START_GRACE_PERIOD_SECONDS_FIELD_NUMBER = 13;
			private long playStartGracePeriodSeconds_ = 0L;

			/**
			 * <pre>
			 * Duration of grace period before playback_duration_seconds (short window)
			 * goes into effect. Optional.
			 * </pre>
			 *
			 * <code>optional int64 play_start_grace_period_seconds = 13 [default = 0];</code>
			 * 
			 * @return Whether the playStartGracePeriodSeconds field is set.
			 */
			@java.lang.Override
			public boolean hasPlayStartGracePeriodSeconds() {
				return ((bitField0_ & 0x00001000) != 0);
			}

			/**
			 * <pre>
			 * Duration of grace period before playback_duration_seconds (short window)
			 * goes into effect. Optional.
			 * </pre>
			 *
			 * <code>optional int64 play_start_grace_period_seconds = 13 [default = 0];</code>
			 * 
			 * @return The playStartGracePeriodSeconds.
			 */
			@java.lang.Override
			public long getPlayStartGracePeriodSeconds() {
				return playStartGracePeriodSeconds_;
			}

			public static final int SOFT_ENFORCE_PLAYBACK_DURATION_FIELD_NUMBER = 14;
			private boolean softEnforcePlaybackDuration_ = false;

			/**
			 * <pre>
			 * Enables "soft enforcement" of playback_duration_seconds, letting the user
			 * finish playback even if short window expires. Optional.
			 * </pre>
			 *
			 * <code>optional bool soft_enforce_playback_duration = 14 [default = false];</code>
			 * 
			 * @return Whether the softEnforcePlaybackDuration field is set.
			 */
			@java.lang.Override
			public boolean hasSoftEnforcePlaybackDuration() {
				return ((bitField0_ & 0x00002000) != 0);
			}

			/**
			 * <pre>
			 * Enables "soft enforcement" of playback_duration_seconds, letting the user
			 * finish playback even if short window expires. Optional.
			 * </pre>
			 *
			 * <code>optional bool soft_enforce_playback_duration = 14 [default = false];</code>
			 * 
			 * @return The softEnforcePlaybackDuration.
			 */
			@java.lang.Override
			public boolean getSoftEnforcePlaybackDuration() {
				return softEnforcePlaybackDuration_;
			}

			public static final int SOFT_ENFORCE_RENTAL_DURATION_FIELD_NUMBER = 15;
			private boolean softEnforceRentalDuration_ = true;

			/**
			 * <pre>
			 * Enables "soft enforcement" of rental_duration_seconds. Initial playback
			 * must always start before rental duration expires.  In order to allow
			 * subsequent playbacks to start after the rental duration expires,
			 * soft_enforce_playback_duration must be true. Otherwise, subsequent
			 * playbacks will not be allowed once rental duration expires. Optional.
			 * </pre>
			 *
			 * <code>optional bool soft_enforce_rental_duration = 15 [default = true];</code>
			 * 
			 * @return Whether the softEnforceRentalDuration field is set.
			 */
			@java.lang.Override
			public boolean hasSoftEnforceRentalDuration() {
				return ((bitField0_ & 0x00004000) != 0);
			}

			/**
			 * <pre>
			 * Enables "soft enforcement" of rental_duration_seconds. Initial playback
			 * must always start before rental duration expires.  In order to allow
			 * subsequent playbacks to start after the rental duration expires,
			 * soft_enforce_playback_duration must be true. Otherwise, subsequent
			 * playbacks will not be allowed once rental duration expires. Optional.
			 * </pre>
			 *
			 * <code>optional bool soft_enforce_rental_duration = 15 [default = true];</code>
			 * 
			 * @return The softEnforceRentalDuration.
			 */
			@java.lang.Override
			public boolean getSoftEnforceRentalDuration() {
				return softEnforceRentalDuration_;
			}

			private byte memoizedIsInitialized = -1;

			@java.lang.Override
			public final boolean isInitialized() {
				byte isInitialized = memoizedIsInitialized;
				if (isInitialized == 1)
					return true;
				if (isInitialized == 0)
					return false;

				memoizedIsInitialized = 1;
				return true;
			}

			@java.lang.Override
			public void writeTo(CodedOutputStream output) throws java.io.IOException {
				if (((bitField0_ & 0x00000001) != 0)) {
					output.writeBool(1, canPlay_);
				}
				if (((bitField0_ & 0x00000002) != 0)) {
					output.writeBool(2, canPersist_);
				}
				if (((bitField0_ & 0x00000004) != 0)) {
					output.writeBool(3, canRenew_);
				}
				if (((bitField0_ & 0x00000008) != 0)) {
					output.writeInt64(4, rentalDurationSeconds_);
				}
				if (((bitField0_ & 0x00000010) != 0)) {
					output.writeInt64(5, playbackDurationSeconds_);
				}
				if (((bitField0_ & 0x00000020) != 0)) {
					output.writeInt64(6, licenseDurationSeconds_);
				}
				if (((bitField0_ & 0x00000040) != 0)) {
					output.writeInt64(7, renewalRecoveryDurationSeconds_);
				}
				if (((bitField0_ & 0x00000080) != 0)) {
					GeneratedMessageV3.writeString(output, 8, renewalServerUrl_);
				}
				if (((bitField0_ & 0x00000100) != 0)) {
					output.writeInt64(9, renewalDelaySeconds_);
				}
				if (((bitField0_ & 0x00000200) != 0)) {
					output.writeInt64(10, renewalRetryIntervalSeconds_);
				}
				if (((bitField0_ & 0x00000400) != 0)) {
					output.writeBool(11, renewWithUsage_);
				}
				if (((bitField0_ & 0x00000800) != 0)) {
					output.writeBool(12, alwaysIncludeClientId_);
				}
				if (((bitField0_ & 0x00001000) != 0)) {
					output.writeInt64(13, playStartGracePeriodSeconds_);
				}
				if (((bitField0_ & 0x00002000) != 0)) {
					output.writeBool(14, softEnforcePlaybackDuration_);
				}
				if (((bitField0_ & 0x00004000) != 0)) {
					output.writeBool(15, softEnforceRentalDuration_);
				}
				getUnknownFields().writeTo(output);
			}

			@java.lang.Override
			public int getSerializedSize() {
				int size = memoizedSize;
				if (size != -1)
					return size;

				size = 0;
				if (((bitField0_ & 0x00000001) != 0)) {
					size += CodedOutputStream.computeBoolSize(1, canPlay_);
				}
				if (((bitField0_ & 0x00000002) != 0)) {
					size += CodedOutputStream.computeBoolSize(2, canPersist_);
				}
				if (((bitField0_ & 0x00000004) != 0)) {
					size += CodedOutputStream.computeBoolSize(3, canRenew_);
				}
				if (((bitField0_ & 0x00000008) != 0)) {
					size += CodedOutputStream.computeInt64Size(4, rentalDurationSeconds_);
				}
				if (((bitField0_ & 0x00000010) != 0)) {
					size += CodedOutputStream.computeInt64Size(5, playbackDurationSeconds_);
				}
				if (((bitField0_ & 0x00000020) != 0)) {
					size += CodedOutputStream.computeInt64Size(6, licenseDurationSeconds_);
				}
				if (((bitField0_ & 0x00000040) != 0)) {
					size += CodedOutputStream.computeInt64Size(7, renewalRecoveryDurationSeconds_);
				}
				if (((bitField0_ & 0x00000080) != 0)) {
					size += GeneratedMessageV3.computeStringSize(8, renewalServerUrl_);
				}
				if (((bitField0_ & 0x00000100) != 0)) {
					size += CodedOutputStream.computeInt64Size(9, renewalDelaySeconds_);
				}
				if (((bitField0_ & 0x00000200) != 0)) {
					size += CodedOutputStream.computeInt64Size(10, renewalRetryIntervalSeconds_);
				}
				if (((bitField0_ & 0x00000400) != 0)) {
					size += CodedOutputStream.computeBoolSize(11, renewWithUsage_);
				}
				if (((bitField0_ & 0x00000800) != 0)) {
					size += CodedOutputStream.computeBoolSize(12, alwaysIncludeClientId_);
				}
				if (((bitField0_ & 0x00001000) != 0)) {
					size += CodedOutputStream.computeInt64Size(13, playStartGracePeriodSeconds_);
				}
				if (((bitField0_ & 0x00002000) != 0)) {
					size += CodedOutputStream.computeBoolSize(14, softEnforcePlaybackDuration_);
				}
				if (((bitField0_ & 0x00004000) != 0)) {
					size += CodedOutputStream.computeBoolSize(15, softEnforceRentalDuration_);
				}
				size += getUnknownFields().getSerializedSize();
				memoizedSize = size;
				return size;
			}

			@java.lang.Override
			public boolean equals(final java.lang.Object obj) {
				if (obj == this) {
					return true;
				}
				if (!(obj instanceof WvProto2.License.Policy)) {
					return super.equals(obj);
				}
				WvProto2.License.Policy other = (WvProto2.License.Policy) obj;

				if (hasCanPlay() != other.hasCanPlay())
					return false;
				if (hasCanPlay()) {
					if (getCanPlay() != other.getCanPlay())
						return false;
				}
				if (hasCanPersist() != other.hasCanPersist())
					return false;
				if (hasCanPersist()) {
					if (getCanPersist() != other.getCanPersist())
						return false;
				}
				if (hasCanRenew() != other.hasCanRenew())
					return false;
				if (hasCanRenew()) {
					if (getCanRenew() != other.getCanRenew())
						return false;
				}
				if (hasRentalDurationSeconds() != other.hasRentalDurationSeconds())
					return false;
				if (hasRentalDurationSeconds()) {
					if (getRentalDurationSeconds() != other.getRentalDurationSeconds())
						return false;
				}
				if (hasPlaybackDurationSeconds() != other.hasPlaybackDurationSeconds())
					return false;
				if (hasPlaybackDurationSeconds()) {
					if (getPlaybackDurationSeconds() != other.getPlaybackDurationSeconds())
						return false;
				}
				if (hasLicenseDurationSeconds() != other.hasLicenseDurationSeconds())
					return false;
				if (hasLicenseDurationSeconds()) {
					if (getLicenseDurationSeconds() != other.getLicenseDurationSeconds())
						return false;
				}
				if (hasRenewalRecoveryDurationSeconds() != other.hasRenewalRecoveryDurationSeconds())
					return false;
				if (hasRenewalRecoveryDurationSeconds()) {
					if (getRenewalRecoveryDurationSeconds() != other.getRenewalRecoveryDurationSeconds())
						return false;
				}
				if (hasRenewalServerUrl() != other.hasRenewalServerUrl())
					return false;
				if (hasRenewalServerUrl()) {
					if (!getRenewalServerUrl().equals(other.getRenewalServerUrl()))
						return false;
				}
				if (hasRenewalDelaySeconds() != other.hasRenewalDelaySeconds())
					return false;
				if (hasRenewalDelaySeconds()) {
					if (getRenewalDelaySeconds() != other.getRenewalDelaySeconds())
						return false;
				}
				if (hasRenewalRetryIntervalSeconds() != other.hasRenewalRetryIntervalSeconds())
					return false;
				if (hasRenewalRetryIntervalSeconds()) {
					if (getRenewalRetryIntervalSeconds() != other.getRenewalRetryIntervalSeconds())
						return false;
				}
				if (hasRenewWithUsage() != other.hasRenewWithUsage())
					return false;
				if (hasRenewWithUsage()) {
					if (getRenewWithUsage() != other.getRenewWithUsage())
						return false;
				}
				if (hasAlwaysIncludeClientId() != other.hasAlwaysIncludeClientId())
					return false;
				if (hasAlwaysIncludeClientId()) {
					if (getAlwaysIncludeClientId() != other.getAlwaysIncludeClientId())
						return false;
				}
				if (hasPlayStartGracePeriodSeconds() != other.hasPlayStartGracePeriodSeconds())
					return false;
				if (hasPlayStartGracePeriodSeconds()) {
					if (getPlayStartGracePeriodSeconds() != other.getPlayStartGracePeriodSeconds())
						return false;
				}
				if (hasSoftEnforcePlaybackDuration() != other.hasSoftEnforcePlaybackDuration())
					return false;
				if (hasSoftEnforcePlaybackDuration()) {
					if (getSoftEnforcePlaybackDuration() != other.getSoftEnforcePlaybackDuration())
						return false;
				}
				if (hasSoftEnforceRentalDuration() != other.hasSoftEnforceRentalDuration())
					return false;
				if (hasSoftEnforceRentalDuration()) {
					if (getSoftEnforceRentalDuration() != other.getSoftEnforceRentalDuration())
						return false;
				}
				if (!getUnknownFields().equals(other.getUnknownFields()))
					return false;
				return true;
			}

			@SuppressWarnings("unchecked")
			@java.lang.Override
			public int hashCode() {
				if (memoizedHashCode != 0) {
					return memoizedHashCode;
				}
				int hash = 41;
				hash = (19 * hash) + getDescriptor().hashCode();
				if (hasCanPlay()) {
					hash = (37 * hash) + CAN_PLAY_FIELD_NUMBER;
					hash = (53 * hash) + Internal.hashBoolean(getCanPlay());
				}
				if (hasCanPersist()) {
					hash = (37 * hash) + CAN_PERSIST_FIELD_NUMBER;
					hash = (53 * hash) + Internal.hashBoolean(getCanPersist());
				}
				if (hasCanRenew()) {
					hash = (37 * hash) + CAN_RENEW_FIELD_NUMBER;
					hash = (53 * hash) + Internal.hashBoolean(getCanRenew());
				}
				if (hasRentalDurationSeconds()) {
					hash = (37 * hash) + RENTAL_DURATION_SECONDS_FIELD_NUMBER;
					hash = (53 * hash) + Internal.hashLong(getRentalDurationSeconds());
				}
				if (hasPlaybackDurationSeconds()) {
					hash = (37 * hash) + PLAYBACK_DURATION_SECONDS_FIELD_NUMBER;
					hash = (53 * hash) + Internal.hashLong(getPlaybackDurationSeconds());
				}
				if (hasLicenseDurationSeconds()) {
					hash = (37 * hash) + LICENSE_DURATION_SECONDS_FIELD_NUMBER;
					hash = (53 * hash) + Internal.hashLong(getLicenseDurationSeconds());
				}
				if (hasRenewalRecoveryDurationSeconds()) {
					hash = (37 * hash) + RENEWAL_RECOVERY_DURATION_SECONDS_FIELD_NUMBER;
					hash = (53 * hash) + Internal.hashLong(getRenewalRecoveryDurationSeconds());
				}
				if (hasRenewalServerUrl()) {
					hash = (37 * hash) + RENEWAL_SERVER_URL_FIELD_NUMBER;
					hash = (53 * hash) + getRenewalServerUrl().hashCode();
				}
				if (hasRenewalDelaySeconds()) {
					hash = (37 * hash) + RENEWAL_DELAY_SECONDS_FIELD_NUMBER;
					hash = (53 * hash) + Internal.hashLong(getRenewalDelaySeconds());
				}
				if (hasRenewalRetryIntervalSeconds()) {
					hash = (37 * hash) + RENEWAL_RETRY_INTERVAL_SECONDS_FIELD_NUMBER;
					hash = (53 * hash) + Internal.hashLong(getRenewalRetryIntervalSeconds());
				}
				if (hasRenewWithUsage()) {
					hash = (37 * hash) + RENEW_WITH_USAGE_FIELD_NUMBER;
					hash = (53 * hash) + Internal.hashBoolean(getRenewWithUsage());
				}
				if (hasAlwaysIncludeClientId()) {
					hash = (37 * hash) + ALWAYS_INCLUDE_CLIENT_ID_FIELD_NUMBER;
					hash = (53 * hash) + Internal.hashBoolean(getAlwaysIncludeClientId());
				}
				if (hasPlayStartGracePeriodSeconds()) {
					hash = (37 * hash) + PLAY_START_GRACE_PERIOD_SECONDS_FIELD_NUMBER;
					hash = (53 * hash) + Internal.hashLong(getPlayStartGracePeriodSeconds());
				}
				if (hasSoftEnforcePlaybackDuration()) {
					hash = (37 * hash) + SOFT_ENFORCE_PLAYBACK_DURATION_FIELD_NUMBER;
					hash = (53 * hash) + Internal.hashBoolean(getSoftEnforcePlaybackDuration());
				}
				if (hasSoftEnforceRentalDuration()) {
					hash = (37 * hash) + SOFT_ENFORCE_RENTAL_DURATION_FIELD_NUMBER;
					hash = (53 * hash) + Internal.hashBoolean(getSoftEnforceRentalDuration());
				}
				hash = (29 * hash) + getUnknownFields().hashCode();
				memoizedHashCode = hash;
				return hash;
			}

			public static WvProto2.License.Policy parseFrom(java.nio.ByteBuffer data)
					throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data);
			}

			public static WvProto2.License.Policy parseFrom(java.nio.ByteBuffer data,
					ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data, extensionRegistry);
			}

			public static WvProto2.License.Policy parseFrom(ByteString data)
					throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data);
			}

			public static WvProto2.License.Policy parseFrom(ByteString data,
					ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data, extensionRegistry);
			}

			public static WvProto2.License.Policy parseFrom(byte[] data)
					throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data);
			}

			public static WvProto2.License.Policy parseFrom(byte[] data,
					ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data, extensionRegistry);
			}

			public static WvProto2.License.Policy parseFrom(java.io.InputStream input)
					throws java.io.IOException {
				return GeneratedMessageV3.parseWithIOException(PARSER, input);
			}

			public static WvProto2.License.Policy parseFrom(java.io.InputStream input,
					ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
				return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
			}

			public static WvProto2.License.Policy parseDelimitedFrom(java.io.InputStream input)
					throws java.io.IOException {
				return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
			}

			public static WvProto2.License.Policy parseDelimitedFrom(java.io.InputStream input,
					ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
				return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input, extensionRegistry);
			}

			public static WvProto2.License.Policy parseFrom(CodedInputStream input)
					throws java.io.IOException {
				return GeneratedMessageV3.parseWithIOException(PARSER, input);
			}

			public static WvProto2.License.Policy parseFrom(CodedInputStream input,
					ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
				return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
			}

			@java.lang.Override
			public Builder newBuilderForType() {
				return newBuilder();
			}

			public static Builder newBuilder() {
				return DEFAULT_INSTANCE.toBuilder();
			}

			public static Builder newBuilder(WvProto2.License.Policy prototype) {
				return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
			}

			@java.lang.Override
			public Builder toBuilder() {
				return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
			}

			@java.lang.Override
			protected Builder newBuilderForType(GeneratedMessageV3.BuilderParent parent) {
				Builder builder = new Builder(parent);
				return builder;
			}

			/**
			 * Protobuf type {@code License.Policy}
			 */
			public static final class Builder extends GeneratedMessageV3.Builder<Builder> implements
					// @@protoc_insertion_point(builder_implements:License.Policy)
					WvProto2.License.PolicyOrBuilder {
				public static final Descriptors.Descriptor getDescriptor() {
					return WvProto2.internal_static_License_Policy_descriptor;
				}

				@java.lang.Override
				protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
					return WvProto2.internal_static_License_Policy_fieldAccessorTable
							.ensureFieldAccessorsInitialized(WvProto2.License.Policy.class,
									WvProto2.License.Policy.Builder.class);
				}

				// Construct using WvProto2.License.Policy.newBuilder()
				private Builder() {

				}

				private Builder(GeneratedMessageV3.BuilderParent parent) {
					super(parent);

				}

				@java.lang.Override
				public Builder clear() {
					super.clear();
					bitField0_ = 0;
					canPlay_ = false;
					canPersist_ = false;
					canRenew_ = false;
					rentalDurationSeconds_ = 0L;
					playbackDurationSeconds_ = 0L;
					licenseDurationSeconds_ = 0L;
					renewalRecoveryDurationSeconds_ = 0L;
					renewalServerUrl_ = "";
					renewalDelaySeconds_ = 0L;
					renewalRetryIntervalSeconds_ = 0L;
					renewWithUsage_ = false;
					alwaysIncludeClientId_ = false;
					playStartGracePeriodSeconds_ = 0L;
					softEnforcePlaybackDuration_ = false;
					softEnforceRentalDuration_ = true;
					return this;
				}

				@java.lang.Override
				public Descriptors.Descriptor getDescriptorForType() {
					return WvProto2.internal_static_License_Policy_descriptor;
				}

				@java.lang.Override
				public WvProto2.License.Policy getDefaultInstanceForType() {
					return WvProto2.License.Policy.getDefaultInstance();
				}

				@java.lang.Override
				public WvProto2.License.Policy build() {
					WvProto2.License.Policy result = buildPartial();
					if (!result.isInitialized()) {
						throw newUninitializedMessageException(result);
					}
					return result;
				}

				@java.lang.Override
				public WvProto2.License.Policy buildPartial() {
					WvProto2.License.Policy result = new WvProto2.License.Policy(
							this);
					if (bitField0_ != 0) {
						buildPartial0(result);
					}
					onBuilt();
					return result;
				}

				private void buildPartial0(WvProto2.License.Policy result) {
					int from_bitField0_ = bitField0_;
					int to_bitField0_ = 0;
					if (((from_bitField0_ & 0x00000001) != 0)) {
						result.canPlay_ = canPlay_;
						to_bitField0_ |= 0x00000001;
					}
					if (((from_bitField0_ & 0x00000002) != 0)) {
						result.canPersist_ = canPersist_;
						to_bitField0_ |= 0x00000002;
					}
					if (((from_bitField0_ & 0x00000004) != 0)) {
						result.canRenew_ = canRenew_;
						to_bitField0_ |= 0x00000004;
					}
					if (((from_bitField0_ & 0x00000008) != 0)) {
						result.rentalDurationSeconds_ = rentalDurationSeconds_;
						to_bitField0_ |= 0x00000008;
					}
					if (((from_bitField0_ & 0x00000010) != 0)) {
						result.playbackDurationSeconds_ = playbackDurationSeconds_;
						to_bitField0_ |= 0x00000010;
					}
					if (((from_bitField0_ & 0x00000020) != 0)) {
						result.licenseDurationSeconds_ = licenseDurationSeconds_;
						to_bitField0_ |= 0x00000020;
					}
					if (((from_bitField0_ & 0x00000040) != 0)) {
						result.renewalRecoveryDurationSeconds_ = renewalRecoveryDurationSeconds_;
						to_bitField0_ |= 0x00000040;
					}
					if (((from_bitField0_ & 0x00000080) != 0)) {
						result.renewalServerUrl_ = renewalServerUrl_;
						to_bitField0_ |= 0x00000080;
					}
					if (((from_bitField0_ & 0x00000100) != 0)) {
						result.renewalDelaySeconds_ = renewalDelaySeconds_;
						to_bitField0_ |= 0x00000100;
					}
					if (((from_bitField0_ & 0x00000200) != 0)) {
						result.renewalRetryIntervalSeconds_ = renewalRetryIntervalSeconds_;
						to_bitField0_ |= 0x00000200;
					}
					if (((from_bitField0_ & 0x00000400) != 0)) {
						result.renewWithUsage_ = renewWithUsage_;
						to_bitField0_ |= 0x00000400;
					}
					if (((from_bitField0_ & 0x00000800) != 0)) {
						result.alwaysIncludeClientId_ = alwaysIncludeClientId_;
						to_bitField0_ |= 0x00000800;
					}
					if (((from_bitField0_ & 0x00001000) != 0)) {
						result.playStartGracePeriodSeconds_ = playStartGracePeriodSeconds_;
						to_bitField0_ |= 0x00001000;
					}
					if (((from_bitField0_ & 0x00002000) != 0)) {
						result.softEnforcePlaybackDuration_ = softEnforcePlaybackDuration_;
						to_bitField0_ |= 0x00002000;
					}
					if (((from_bitField0_ & 0x00004000) != 0)) {
						result.softEnforceRentalDuration_ = softEnforceRentalDuration_;
						to_bitField0_ |= 0x00004000;
					}
					result.bitField0_ |= to_bitField0_;
				}

				@java.lang.Override
				public Builder mergeFrom(Message other) {
					if (other instanceof WvProto2.License.Policy) {
						return mergeFrom((WvProto2.License.Policy) other);
					}
					super.mergeFrom(other);
					return this;
				}

				public Builder mergeFrom(WvProto2.License.Policy other) {
					if (other == WvProto2.License.Policy.getDefaultInstance())
						return this;
					if (other.hasCanPlay()) {
						setCanPlay(other.getCanPlay());
					}
					if (other.hasCanPersist()) {
						setCanPersist(other.getCanPersist());
					}
					if (other.hasCanRenew()) {
						setCanRenew(other.getCanRenew());
					}
					if (other.hasRentalDurationSeconds()) {
						setRentalDurationSeconds(other.getRentalDurationSeconds());
					}
					if (other.hasPlaybackDurationSeconds()) {
						setPlaybackDurationSeconds(other.getPlaybackDurationSeconds());
					}
					if (other.hasLicenseDurationSeconds()) {
						setLicenseDurationSeconds(other.getLicenseDurationSeconds());
					}
					if (other.hasRenewalRecoveryDurationSeconds()) {
						setRenewalRecoveryDurationSeconds(other.getRenewalRecoveryDurationSeconds());
					}
					if (other.hasRenewalServerUrl()) {
						renewalServerUrl_ = other.renewalServerUrl_;
						bitField0_ |= 0x00000080;
						onChanged();
					}
					if (other.hasRenewalDelaySeconds()) {
						setRenewalDelaySeconds(other.getRenewalDelaySeconds());
					}
					if (other.hasRenewalRetryIntervalSeconds()) {
						setRenewalRetryIntervalSeconds(other.getRenewalRetryIntervalSeconds());
					}
					if (other.hasRenewWithUsage()) {
						setRenewWithUsage(other.getRenewWithUsage());
					}
					if (other.hasAlwaysIncludeClientId()) {
						setAlwaysIncludeClientId(other.getAlwaysIncludeClientId());
					}
					if (other.hasPlayStartGracePeriodSeconds()) {
						setPlayStartGracePeriodSeconds(other.getPlayStartGracePeriodSeconds());
					}
					if (other.hasSoftEnforcePlaybackDuration()) {
						setSoftEnforcePlaybackDuration(other.getSoftEnforcePlaybackDuration());
					}
					if (other.hasSoftEnforceRentalDuration()) {
						setSoftEnforceRentalDuration(other.getSoftEnforceRentalDuration());
					}
					this.mergeUnknownFields(other.getUnknownFields());
					onChanged();
					return this;
				}

				@java.lang.Override
				public final boolean isInitialized() {
					return true;
				}

				@java.lang.Override
				public Builder mergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
						throws java.io.IOException {
					if (extensionRegistry == null) {
						throw new java.lang.NullPointerException();
					}
					try {
						boolean done = false;
						while (!done) {
							int tag = input.readTag();
							switch (tag) {
							case 0:
								done = true;
								break;
							case 8: {
								canPlay_ = input.readBool();
								bitField0_ |= 0x00000001;
								break;
							} // case 8
							case 16: {
								canPersist_ = input.readBool();
								bitField0_ |= 0x00000002;
								break;
							} // case 16
							case 24: {
								canRenew_ = input.readBool();
								bitField0_ |= 0x00000004;
								break;
							} // case 24
							case 32: {
								rentalDurationSeconds_ = input.readInt64();
								bitField0_ |= 0x00000008;
								break;
							} // case 32
							case 40: {
								playbackDurationSeconds_ = input.readInt64();
								bitField0_ |= 0x00000010;
								break;
							} // case 40
							case 48: {
								licenseDurationSeconds_ = input.readInt64();
								bitField0_ |= 0x00000020;
								break;
							} // case 48
							case 56: {
								renewalRecoveryDurationSeconds_ = input.readInt64();
								bitField0_ |= 0x00000040;
								break;
							} // case 56
							case 66: {
								renewalServerUrl_ = input.readBytes();
								bitField0_ |= 0x00000080;
								break;
							} // case 66
							case 72: {
								renewalDelaySeconds_ = input.readInt64();
								bitField0_ |= 0x00000100;
								break;
							} // case 72
							case 80: {
								renewalRetryIntervalSeconds_ = input.readInt64();
								bitField0_ |= 0x00000200;
								break;
							} // case 80
							case 88: {
								renewWithUsage_ = input.readBool();
								bitField0_ |= 0x00000400;
								break;
							} // case 88
							case 96: {
								alwaysIncludeClientId_ = input.readBool();
								bitField0_ |= 0x00000800;
								break;
							} // case 96
							case 104: {
								playStartGracePeriodSeconds_ = input.readInt64();
								bitField0_ |= 0x00001000;
								break;
							} // case 104
							case 112: {
								softEnforcePlaybackDuration_ = input.readBool();
								bitField0_ |= 0x00002000;
								break;
							} // case 112
							case 120: {
								softEnforceRentalDuration_ = input.readBool();
								bitField0_ |= 0x00004000;
								break;
							} // case 120
							default: {
								if (!super.parseUnknownField(input, extensionRegistry, tag)) {
									done = true; // was an endgroup tag
								}
								break;
							} // default:
							} // switch (tag)
						} // while (!done)
					} catch (InvalidProtocolBufferException e) {
						throw e.unwrapIOException();
					}
					finally {
						onChanged();
					} // finally
					return this;
				}

				private int bitField0_;

				private boolean canPlay_;

				/**
				 * <pre>
				 * Indicates that playback of the content is allowed.
				 * </pre>
				 *
				 * <code>optional bool can_play = 1 [default = false];</code>
				 * 
				 * @return Whether the canPlay field is set.
				 */
				@java.lang.Override
				public boolean hasCanPlay() {
					return ((bitField0_ & 0x00000001) != 0);
				}

				/**
				 * <pre>
				 * Indicates that playback of the content is allowed.
				 * </pre>
				 *
				 * <code>optional bool can_play = 1 [default = false];</code>
				 * 
				 * @return The canPlay.
				 */
				@java.lang.Override
				public boolean getCanPlay() {
					return canPlay_;
				}

				/**
				 * <pre>
				 * Indicates that playback of the content is allowed.
				 * </pre>
				 *
				 * <code>optional bool can_play = 1 [default = false];</code>
				 * 
				 * @param value The canPlay to set.
				 * @return This builder for chaining.
				 */
				public Builder setCanPlay(boolean value) {

					canPlay_ = value;
					bitField0_ |= 0x00000001;
					onChanged();
					return this;
				}

				/**
				 * <pre>
				 * Indicates that playback of the content is allowed.
				 * </pre>
				 *
				 * <code>optional bool can_play = 1 [default = false];</code>
				 * 
				 * @return This builder for chaining.
				 */
				public Builder clearCanPlay() {
					bitField0_ = (bitField0_ & ~0x00000001);
					canPlay_ = false;
					onChanged();
					return this;
				}

				private boolean canPersist_;

				/**
				 * <pre>
				 * Indicates that the license may be persisted to non-volatile
				 * storage for offline use.
				 * </pre>
				 *
				 * <code>optional bool can_persist = 2 [default = false];</code>
				 * 
				 * @return Whether the canPersist field is set.
				 */
				@java.lang.Override
				public boolean hasCanPersist() {
					return ((bitField0_ & 0x00000002) != 0);
				}

				/**
				 * <pre>
				 * Indicates that the license may be persisted to non-volatile
				 * storage for offline use.
				 * </pre>
				 *
				 * <code>optional bool can_persist = 2 [default = false];</code>
				 * 
				 * @return The canPersist.
				 */
				@java.lang.Override
				public boolean getCanPersist() {
					return canPersist_;
				}

				/**
				 * <pre>
				 * Indicates that the license may be persisted to non-volatile
				 * storage for offline use.
				 * </pre>
				 *
				 * <code>optional bool can_persist = 2 [default = false];</code>
				 * 
				 * @param value The canPersist to set.
				 * @return This builder for chaining.
				 */
				public Builder setCanPersist(boolean value) {

					canPersist_ = value;
					bitField0_ |= 0x00000002;
					onChanged();
					return this;
				}

				/**
				 * <pre>
				 * Indicates that the license may be persisted to non-volatile
				 * storage for offline use.
				 * </pre>
				 *
				 * <code>optional bool can_persist = 2 [default = false];</code>
				 * 
				 * @return This builder for chaining.
				 */
				public Builder clearCanPersist() {
					bitField0_ = (bitField0_ & ~0x00000002);
					canPersist_ = false;
					onChanged();
					return this;
				}

				private boolean canRenew_;

				/**
				 * <pre>
				 * Indicates that renewal of this license is allowed.
				 * </pre>
				 *
				 * <code>optional bool can_renew = 3 [default = false];</code>
				 * 
				 * @return Whether the canRenew field is set.
				 */
				@java.lang.Override
				public boolean hasCanRenew() {
					return ((bitField0_ & 0x00000004) != 0);
				}

				/**
				 * <pre>
				 * Indicates that renewal of this license is allowed.
				 * </pre>
				 *
				 * <code>optional bool can_renew = 3 [default = false];</code>
				 * 
				 * @return The canRenew.
				 */
				@java.lang.Override
				public boolean getCanRenew() {
					return canRenew_;
				}

				/**
				 * <pre>
				 * Indicates that renewal of this license is allowed.
				 * </pre>
				 *
				 * <code>optional bool can_renew = 3 [default = false];</code>
				 * 
				 * @param value The canRenew to set.
				 * @return This builder for chaining.
				 */
				public Builder setCanRenew(boolean value) {

					canRenew_ = value;
					bitField0_ |= 0x00000004;
					onChanged();
					return this;
				}

				/**
				 * <pre>
				 * Indicates that renewal of this license is allowed.
				 * </pre>
				 *
				 * <code>optional bool can_renew = 3 [default = false];</code>
				 * 
				 * @return This builder for chaining.
				 */
				public Builder clearCanRenew() {
					bitField0_ = (bitField0_ & ~0x00000004);
					canRenew_ = false;
					onChanged();
					return this;
				}

				private long rentalDurationSeconds_;

				/**
				 * <pre>
				 * Indicates the rental window.
				 * </pre>
				 *
				 * <code>optional int64 rental_duration_seconds = 4 [default = 0];</code>
				 * 
				 * @return Whether the rentalDurationSeconds field is set.
				 */
				@java.lang.Override
				public boolean hasRentalDurationSeconds() {
					return ((bitField0_ & 0x00000008) != 0);
				}

				/**
				 * <pre>
				 * Indicates the rental window.
				 * </pre>
				 *
				 * <code>optional int64 rental_duration_seconds = 4 [default = 0];</code>
				 * 
				 * @return The rentalDurationSeconds.
				 */
				@java.lang.Override
				public long getRentalDurationSeconds() {
					return rentalDurationSeconds_;
				}

				/**
				 * <pre>
				 * Indicates the rental window.
				 * </pre>
				 *
				 * <code>optional int64 rental_duration_seconds = 4 [default = 0];</code>
				 * 
				 * @param value The rentalDurationSeconds to set.
				 * @return This builder for chaining.
				 */
				public Builder setRentalDurationSeconds(long value) {

					rentalDurationSeconds_ = value;
					bitField0_ |= 0x00000008;
					onChanged();
					return this;
				}

				/**
				 * <pre>
				 * Indicates the rental window.
				 * </pre>
				 *
				 * <code>optional int64 rental_duration_seconds = 4 [default = 0];</code>
				 * 
				 * @return This builder for chaining.
				 */
				public Builder clearRentalDurationSeconds() {
					bitField0_ = (bitField0_ & ~0x00000008);
					rentalDurationSeconds_ = 0L;
					onChanged();
					return this;
				}

				private long playbackDurationSeconds_;

				/**
				 * <pre>
				 * Indicates the viewing window, once playback has begun.
				 * </pre>
				 *
				 * <code>optional int64 playback_duration_seconds = 5 [default = 0];</code>
				 * 
				 * @return Whether the playbackDurationSeconds field is set.
				 */
				@java.lang.Override
				public boolean hasPlaybackDurationSeconds() {
					return ((bitField0_ & 0x00000010) != 0);
				}

				/**
				 * <pre>
				 * Indicates the viewing window, once playback has begun.
				 * </pre>
				 *
				 * <code>optional int64 playback_duration_seconds = 5 [default = 0];</code>
				 * 
				 * @return The playbackDurationSeconds.
				 */
				@java.lang.Override
				public long getPlaybackDurationSeconds() {
					return playbackDurationSeconds_;
				}

				/**
				 * <pre>
				 * Indicates the viewing window, once playback has begun.
				 * </pre>
				 *
				 * <code>optional int64 playback_duration_seconds = 5 [default = 0];</code>
				 * 
				 * @param value The playbackDurationSeconds to set.
				 * @return This builder for chaining.
				 */
				public Builder setPlaybackDurationSeconds(long value) {

					playbackDurationSeconds_ = value;
					bitField0_ |= 0x00000010;
					onChanged();
					return this;
				}

				/**
				 * <pre>
				 * Indicates the viewing window, once playback has begun.
				 * </pre>
				 *
				 * <code>optional int64 playback_duration_seconds = 5 [default = 0];</code>
				 * 
				 * @return This builder for chaining.
				 */
				public Builder clearPlaybackDurationSeconds() {
					bitField0_ = (bitField0_ & ~0x00000010);
					playbackDurationSeconds_ = 0L;
					onChanged();
					return this;
				}

				private long licenseDurationSeconds_;

				/**
				 * <pre>
				 * Indicates the time window for this specific license.
				 * </pre>
				 *
				 * <code>optional int64 license_duration_seconds = 6 [default = 0];</code>
				 * 
				 * @return Whether the licenseDurationSeconds field is set.
				 */
				@java.lang.Override
				public boolean hasLicenseDurationSeconds() {
					return ((bitField0_ & 0x00000020) != 0);
				}

				/**
				 * <pre>
				 * Indicates the time window for this specific license.
				 * </pre>
				 *
				 * <code>optional int64 license_duration_seconds = 6 [default = 0];</code>
				 * 
				 * @return The licenseDurationSeconds.
				 */
				@java.lang.Override
				public long getLicenseDurationSeconds() {
					return licenseDurationSeconds_;
				}

				/**
				 * <pre>
				 * Indicates the time window for this specific license.
				 * </pre>
				 *
				 * <code>optional int64 license_duration_seconds = 6 [default = 0];</code>
				 * 
				 * @param value The licenseDurationSeconds to set.
				 * @return This builder for chaining.
				 */
				public Builder setLicenseDurationSeconds(long value) {

					licenseDurationSeconds_ = value;
					bitField0_ |= 0x00000020;
					onChanged();
					return this;
				}

				/**
				 * <pre>
				 * Indicates the time window for this specific license.
				 * </pre>
				 *
				 * <code>optional int64 license_duration_seconds = 6 [default = 0];</code>
				 * 
				 * @return This builder for chaining.
				 */
				public Builder clearLicenseDurationSeconds() {
					bitField0_ = (bitField0_ & ~0x00000020);
					licenseDurationSeconds_ = 0L;
					onChanged();
					return this;
				}

				private long renewalRecoveryDurationSeconds_;

				/**
				 * <pre>
				 * The window of time, in which playback is allowed to continue while
				 * renewal is attempted, yet unsuccessful due to backend problems with
				 * the license server.
				 * </pre>
				 *
				 * <code>optional int64 renewal_recovery_duration_seconds = 7 [default = 0];</code>
				 * 
				 * @return Whether the renewalRecoveryDurationSeconds field is set.
				 */
				@java.lang.Override
				public boolean hasRenewalRecoveryDurationSeconds() {
					return ((bitField0_ & 0x00000040) != 0);
				}

				/**
				 * <pre>
				 * The window of time, in which playback is allowed to continue while
				 * renewal is attempted, yet unsuccessful due to backend problems with
				 * the license server.
				 * </pre>
				 *
				 * <code>optional int64 renewal_recovery_duration_seconds = 7 [default = 0];</code>
				 * 
				 * @return The renewalRecoveryDurationSeconds.
				 */
				@java.lang.Override
				public long getRenewalRecoveryDurationSeconds() {
					return renewalRecoveryDurationSeconds_;
				}

				/**
				 * <pre>
				 * The window of time, in which playback is allowed to continue while
				 * renewal is attempted, yet unsuccessful due to backend problems with
				 * the license server.
				 * </pre>
				 *
				 * <code>optional int64 renewal_recovery_duration_seconds = 7 [default = 0];</code>
				 * 
				 * @param value The renewalRecoveryDurationSeconds to set.
				 * @return This builder for chaining.
				 */
				public Builder setRenewalRecoveryDurationSeconds(long value) {

					renewalRecoveryDurationSeconds_ = value;
					bitField0_ |= 0x00000040;
					onChanged();
					return this;
				}

				/**
				 * <pre>
				 * The window of time, in which playback is allowed to continue while
				 * renewal is attempted, yet unsuccessful due to backend problems with
				 * the license server.
				 * </pre>
				 *
				 * <code>optional int64 renewal_recovery_duration_seconds = 7 [default = 0];</code>
				 * 
				 * @return This builder for chaining.
				 */
				public Builder clearRenewalRecoveryDurationSeconds() {
					bitField0_ = (bitField0_ & ~0x00000040);
					renewalRecoveryDurationSeconds_ = 0L;
					onChanged();
					return this;
				}

				private java.lang.Object renewalServerUrl_ = "";

				/**
				 * <pre>
				 * All renewal requests for this license shall be directed to the
				 * specified URL.
				 * </pre>
				 *
				 * <code>optional string renewal_server_url = 8;</code>
				 * 
				 * @return Whether the renewalServerUrl field is set.
				 */
				@Override
				public boolean hasRenewalServerUrl() {
					return ((bitField0_ & 0x00000080) != 0);
				}

				/**
				 * <pre>
				 * All renewal requests for this license shall be directed to the
				 * specified URL.
				 * </pre>
				 *
				 * <code>optional string renewal_server_url = 8;</code>
				 * 
				 * @return The renewalServerUrl.
				 */
				@Override
				public java.lang.String getRenewalServerUrl() {
					java.lang.Object ref = renewalServerUrl_;
					if (!(ref instanceof java.lang.String)) {
						ByteString bs = (ByteString) ref;
						java.lang.String s = bs.toStringUtf8();
						if (bs.isValidUtf8()) {
							renewalServerUrl_ = s;
						}
						return s;
					}
					return (java.lang.String) ref;
				}

				/**
				 * <pre>
				 * All renewal requests for this license shall be directed to the
				 * specified URL.
				 * </pre>
				 *
				 * <code>optional string renewal_server_url = 8;</code>
				 * 
				 * @return The bytes for renewalServerUrl.
				 */
				@Override
				public ByteString getRenewalServerUrlBytes() {
					java.lang.Object ref = renewalServerUrl_;
					if (ref instanceof String) {
						ByteString b = ByteString.copyFromUtf8((java.lang.String) ref);
						renewalServerUrl_ = b;
						return b;
					}
					return (ByteString) ref;
				}

				/**
				 * <pre>
				 * All renewal requests for this license shall be directed to the
				 * specified URL.
				 * </pre>
				 *
				 * <code>optional string renewal_server_url = 8;</code>
				 * 
				 * @param value The renewalServerUrl to set.
				 * @return This builder for chaining.
				 */
				public Builder setRenewalServerUrl(java.lang.String value) {
					if (value == null) {
						throw new NullPointerException();
					}
					renewalServerUrl_ = value;
					bitField0_ |= 0x00000080;
					onChanged();
					return this;
				}

				/**
				 * <pre>
				 * All renewal requests for this license shall be directed to the
				 * specified URL.
				 * </pre>
				 *
				 * <code>optional string renewal_server_url = 8;</code>
				 * 
				 * @return This builder for chaining.
				 */
				public Builder clearRenewalServerUrl() {
					renewalServerUrl_ = getDefaultInstance().getRenewalServerUrl();
					bitField0_ = (bitField0_ & ~0x00000080);
					onChanged();
					return this;
				}

				/**
				 * <pre>
				 * All renewal requests for this license shall be directed to the
				 * specified URL.
				 * </pre>
				 *
				 * <code>optional string renewal_server_url = 8;</code>
				 * 
				 * @param value The bytes for renewalServerUrl to set.
				 * @return This builder for chaining.
				 */
				public Builder setRenewalServerUrlBytes(ByteString value) {
					if (value == null) {
						throw new NullPointerException();
					}
					renewalServerUrl_ = value;
					bitField0_ |= 0x00000080;
					onChanged();
					return this;
				}

				private long renewalDelaySeconds_;

				/**
				 * <pre>
				 * How many seconds after license_start_time, before renewal is first
				 * attempted.
				 * </pre>
				 *
				 * <code>optional int64 renewal_delay_seconds = 9 [default = 0];</code>
				 * 
				 * @return Whether the renewalDelaySeconds field is set.
				 */
				@java.lang.Override
				public boolean hasRenewalDelaySeconds() {
					return ((bitField0_ & 0x00000100) != 0);
				}

				/**
				 * <pre>
				 * How many seconds after license_start_time, before renewal is first
				 * attempted.
				 * </pre>
				 *
				 * <code>optional int64 renewal_delay_seconds = 9 [default = 0];</code>
				 * 
				 * @return The renewalDelaySeconds.
				 */
				@java.lang.Override
				public long getRenewalDelaySeconds() {
					return renewalDelaySeconds_;
				}

				/**
				 * <pre>
				 * How many seconds after license_start_time, before renewal is first
				 * attempted.
				 * </pre>
				 *
				 * <code>optional int64 renewal_delay_seconds = 9 [default = 0];</code>
				 * 
				 * @param value The renewalDelaySeconds to set.
				 * @return This builder for chaining.
				 */
				public Builder setRenewalDelaySeconds(long value) {

					renewalDelaySeconds_ = value;
					bitField0_ |= 0x00000100;
					onChanged();
					return this;
				}

				/**
				 * <pre>
				 * How many seconds after license_start_time, before renewal is first
				 * attempted.
				 * </pre>
				 *
				 * <code>optional int64 renewal_delay_seconds = 9 [default = 0];</code>
				 * 
				 * @return This builder for chaining.
				 */
				public Builder clearRenewalDelaySeconds() {
					bitField0_ = (bitField0_ & ~0x00000100);
					renewalDelaySeconds_ = 0L;
					onChanged();
					return this;
				}

				private long renewalRetryIntervalSeconds_;

				/**
				 * <pre>
				 * Specifies the delay in seconds between subsequent license
				 * renewal requests, in case of failure.
				 * </pre>
				 *
				 * <code>optional int64 renewal_retry_interval_seconds = 10 [default = 0];</code>
				 * 
				 * @return Whether the renewalRetryIntervalSeconds field is set.
				 */
				@java.lang.Override
				public boolean hasRenewalRetryIntervalSeconds() {
					return ((bitField0_ & 0x00000200) != 0);
				}

				/**
				 * <pre>
				 * Specifies the delay in seconds between subsequent license
				 * renewal requests, in case of failure.
				 * </pre>
				 *
				 * <code>optional int64 renewal_retry_interval_seconds = 10 [default = 0];</code>
				 * 
				 * @return The renewalRetryIntervalSeconds.
				 */
				@java.lang.Override
				public long getRenewalRetryIntervalSeconds() {
					return renewalRetryIntervalSeconds_;
				}

				/**
				 * <pre>
				 * Specifies the delay in seconds between subsequent license
				 * renewal requests, in case of failure.
				 * </pre>
				 *
				 * <code>optional int64 renewal_retry_interval_seconds = 10 [default = 0];</code>
				 * 
				 * @param value The renewalRetryIntervalSeconds to set.
				 * @return This builder for chaining.
				 */
				public Builder setRenewalRetryIntervalSeconds(long value) {

					renewalRetryIntervalSeconds_ = value;
					bitField0_ |= 0x00000200;
					onChanged();
					return this;
				}

				/**
				 * <pre>
				 * Specifies the delay in seconds between subsequent license
				 * renewal requests, in case of failure.
				 * </pre>
				 *
				 * <code>optional int64 renewal_retry_interval_seconds = 10 [default = 0];</code>
				 * 
				 * @return This builder for chaining.
				 */
				public Builder clearRenewalRetryIntervalSeconds() {
					bitField0_ = (bitField0_ & ~0x00000200);
					renewalRetryIntervalSeconds_ = 0L;
					onChanged();
					return this;
				}

				private boolean renewWithUsage_;

				/**
				 * <pre>
				 * Indicates that the license shall be sent for renewal when usage is
				 * started.
				 * </pre>
				 *
				 * <code>optional bool renew_with_usage = 11 [default = false];</code>
				 * 
				 * @return Whether the renewWithUsage field is set.
				 */
				@java.lang.Override
				public boolean hasRenewWithUsage() {
					return ((bitField0_ & 0x00000400) != 0);
				}

				/**
				 * <pre>
				 * Indicates that the license shall be sent for renewal when usage is
				 * started.
				 * </pre>
				 *
				 * <code>optional bool renew_with_usage = 11 [default = false];</code>
				 * 
				 * @return The renewWithUsage.
				 */
				@java.lang.Override
				public boolean getRenewWithUsage() {
					return renewWithUsage_;
				}

				/**
				 * <pre>
				 * Indicates that the license shall be sent for renewal when usage is
				 * started.
				 * </pre>
				 *
				 * <code>optional bool renew_with_usage = 11 [default = false];</code>
				 * 
				 * @param value The renewWithUsage to set.
				 * @return This builder for chaining.
				 */
				public Builder setRenewWithUsage(boolean value) {

					renewWithUsage_ = value;
					bitField0_ |= 0x00000400;
					onChanged();
					return this;
				}

				/**
				 * <pre>
				 * Indicates that the license shall be sent for renewal when usage is
				 * started.
				 * </pre>
				 *
				 * <code>optional bool renew_with_usage = 11 [default = false];</code>
				 * 
				 * @return This builder for chaining.
				 */
				public Builder clearRenewWithUsage() {
					bitField0_ = (bitField0_ & ~0x00000400);
					renewWithUsage_ = false;
					onChanged();
					return this;
				}

				private boolean alwaysIncludeClientId_;

				/**
				 * <pre>
				 * Indicates to client that license renewal and release requests ought to
				 * include ClientIdentification (client_id).
				 * </pre>
				 *
				 * <code>optional bool always_include_client_id = 12 [default = false];</code>
				 * 
				 * @return Whether the alwaysIncludeClientId field is set.
				 */
				@java.lang.Override
				public boolean hasAlwaysIncludeClientId() {
					return ((bitField0_ & 0x00000800) != 0);
				}

				/**
				 * <pre>
				 * Indicates to client that license renewal and release requests ought to
				 * include ClientIdentification (client_id).
				 * </pre>
				 *
				 * <code>optional bool always_include_client_id = 12 [default = false];</code>
				 * 
				 * @return The alwaysIncludeClientId.
				 */
				@java.lang.Override
				public boolean getAlwaysIncludeClientId() {
					return alwaysIncludeClientId_;
				}

				/**
				 * <pre>
				 * Indicates to client that license renewal and release requests ought to
				 * include ClientIdentification (client_id).
				 * </pre>
				 *
				 * <code>optional bool always_include_client_id = 12 [default = false];</code>
				 * 
				 * @param value The alwaysIncludeClientId to set.
				 * @return This builder for chaining.
				 */
				public Builder setAlwaysIncludeClientId(boolean value) {

					alwaysIncludeClientId_ = value;
					bitField0_ |= 0x00000800;
					onChanged();
					return this;
				}

				/**
				 * <pre>
				 * Indicates to client that license renewal and release requests ought to
				 * include ClientIdentification (client_id).
				 * </pre>
				 *
				 * <code>optional bool always_include_client_id = 12 [default = false];</code>
				 * 
				 * @return This builder for chaining.
				 */
				public Builder clearAlwaysIncludeClientId() {
					bitField0_ = (bitField0_ & ~0x00000800);
					alwaysIncludeClientId_ = false;
					onChanged();
					return this;
				}

				private long playStartGracePeriodSeconds_;

				/**
				 * <pre>
				 * Duration of grace period before playback_duration_seconds (short window)
				 * goes into effect. Optional.
				 * </pre>
				 *
				 * <code>optional int64 play_start_grace_period_seconds = 13 [default = 0];</code>
				 * 
				 * @return Whether the playStartGracePeriodSeconds field is set.
				 */
				@java.lang.Override
				public boolean hasPlayStartGracePeriodSeconds() {
					return ((bitField0_ & 0x00001000) != 0);
				}

				/**
				 * <pre>
				 * Duration of grace period before playback_duration_seconds (short window)
				 * goes into effect. Optional.
				 * </pre>
				 *
				 * <code>optional int64 play_start_grace_period_seconds = 13 [default = 0];</code>
				 * 
				 * @return The playStartGracePeriodSeconds.
				 */
				@java.lang.Override
				public long getPlayStartGracePeriodSeconds() {
					return playStartGracePeriodSeconds_;
				}

				/**
				 * <pre>
				 * Duration of grace period before playback_duration_seconds (short window)
				 * goes into effect. Optional.
				 * </pre>
				 *
				 * <code>optional int64 play_start_grace_period_seconds = 13 [default = 0];</code>
				 * 
				 * @param value The playStartGracePeriodSeconds to set.
				 * @return This builder for chaining.
				 */
				public Builder setPlayStartGracePeriodSeconds(long value) {

					playStartGracePeriodSeconds_ = value;
					bitField0_ |= 0x00001000;
					onChanged();
					return this;
				}

				/**
				 * <pre>
				 * Duration of grace period before playback_duration_seconds (short window)
				 * goes into effect. Optional.
				 * </pre>
				 *
				 * <code>optional int64 play_start_grace_period_seconds = 13 [default = 0];</code>
				 * 
				 * @return This builder for chaining.
				 */
				public Builder clearPlayStartGracePeriodSeconds() {
					bitField0_ = (bitField0_ & ~0x00001000);
					playStartGracePeriodSeconds_ = 0L;
					onChanged();
					return this;
				}

				private boolean softEnforcePlaybackDuration_;

				/**
				 * <pre>
				 * Enables "soft enforcement" of playback_duration_seconds, letting the user
				 * finish playback even if short window expires. Optional.
				 * </pre>
				 *
				 * <code>optional bool soft_enforce_playback_duration = 14 [default = false];</code>
				 * 
				 * @return Whether the softEnforcePlaybackDuration field is set.
				 */
				@java.lang.Override
				public boolean hasSoftEnforcePlaybackDuration() {
					return ((bitField0_ & 0x00002000) != 0);
				}

				/**
				 * <pre>
				 * Enables "soft enforcement" of playback_duration_seconds, letting the user
				 * finish playback even if short window expires. Optional.
				 * </pre>
				 *
				 * <code>optional bool soft_enforce_playback_duration = 14 [default = false];</code>
				 * 
				 * @return The softEnforcePlaybackDuration.
				 */
				@java.lang.Override
				public boolean getSoftEnforcePlaybackDuration() {
					return softEnforcePlaybackDuration_;
				}

				/**
				 * <pre>
				 * Enables "soft enforcement" of playback_duration_seconds, letting the user
				 * finish playback even if short window expires. Optional.
				 * </pre>
				 *
				 * <code>optional bool soft_enforce_playback_duration = 14 [default = false];</code>
				 * 
				 * @param value The softEnforcePlaybackDuration to set.
				 * @return This builder for chaining.
				 */
				public Builder setSoftEnforcePlaybackDuration(boolean value) {

					softEnforcePlaybackDuration_ = value;
					bitField0_ |= 0x00002000;
					onChanged();
					return this;
				}

				/**
				 * <pre>
				 * Enables "soft enforcement" of playback_duration_seconds, letting the user
				 * finish playback even if short window expires. Optional.
				 * </pre>
				 *
				 * <code>optional bool soft_enforce_playback_duration = 14 [default = false];</code>
				 * 
				 * @return This builder for chaining.
				 */
				public Builder clearSoftEnforcePlaybackDuration() {
					bitField0_ = (bitField0_ & ~0x00002000);
					softEnforcePlaybackDuration_ = false;
					onChanged();
					return this;
				}

				private boolean softEnforceRentalDuration_ = true;

				/**
				 * <pre>
				 * Enables "soft enforcement" of rental_duration_seconds. Initial playback
				 * must always start before rental duration expires.  In order to allow
				 * subsequent playbacks to start after the rental duration expires,
				 * soft_enforce_playback_duration must be true. Otherwise, subsequent
				 * playbacks will not be allowed once rental duration expires. Optional.
				 * </pre>
				 *
				 * <code>optional bool soft_enforce_rental_duration = 15 [default = true];</code>
				 * 
				 * @return Whether the softEnforceRentalDuration field is set.
				 */
				@java.lang.Override
				public boolean hasSoftEnforceRentalDuration() {
					return ((bitField0_ & 0x00004000) != 0);
				}

				/**
				 * <pre>
				 * Enables "soft enforcement" of rental_duration_seconds. Initial playback
				 * must always start before rental duration expires.  In order to allow
				 * subsequent playbacks to start after the rental duration expires,
				 * soft_enforce_playback_duration must be true. Otherwise, subsequent
				 * playbacks will not be allowed once rental duration expires. Optional.
				 * </pre>
				 *
				 * <code>optional bool soft_enforce_rental_duration = 15 [default = true];</code>
				 * 
				 * @return The softEnforceRentalDuration.
				 */
				@java.lang.Override
				public boolean getSoftEnforceRentalDuration() {
					return softEnforceRentalDuration_;
				}

				/**
				 * <pre>
				 * Enables "soft enforcement" of rental_duration_seconds. Initial playback
				 * must always start before rental duration expires.  In order to allow
				 * subsequent playbacks to start after the rental duration expires,
				 * soft_enforce_playback_duration must be true. Otherwise, subsequent
				 * playbacks will not be allowed once rental duration expires. Optional.
				 * </pre>
				 *
				 * <code>optional bool soft_enforce_rental_duration = 15 [default = true];</code>
				 * 
				 * @param value The softEnforceRentalDuration to set.
				 * @return This builder for chaining.
				 */
				public Builder setSoftEnforceRentalDuration(boolean value) {

					softEnforceRentalDuration_ = value;
					bitField0_ |= 0x00004000;
					onChanged();
					return this;
				}

				/**
				 * <pre>
				 * Enables "soft enforcement" of rental_duration_seconds. Initial playback
				 * must always start before rental duration expires.  In order to allow
				 * subsequent playbacks to start after the rental duration expires,
				 * soft_enforce_playback_duration must be true. Otherwise, subsequent
				 * playbacks will not be allowed once rental duration expires. Optional.
				 * </pre>
				 *
				 * <code>optional bool soft_enforce_rental_duration = 15 [default = true];</code>
				 * 
				 * @return This builder for chaining.
				 */
				public Builder clearSoftEnforceRentalDuration() {
					bitField0_ = (bitField0_ & ~0x00004000);
					softEnforceRentalDuration_ = true;
					onChanged();
					return this;
				}

				@java.lang.Override
				public final Builder setUnknownFields(final UnknownFieldSet unknownFields) {
					return super.setUnknownFields(unknownFields);
				}

				@java.lang.Override
				public final Builder mergeUnknownFields(final UnknownFieldSet unknownFields) {
					return super.mergeUnknownFields(unknownFields);
				}

				// @@protoc_insertion_point(builder_scope:License.Policy)
			}

			// @@protoc_insertion_point(class_scope:License.Policy)
			private static final WvProto2.License.Policy DEFAULT_INSTANCE;
			static {
				DEFAULT_INSTANCE = new WvProto2.License.Policy();
			}

			public static WvProto2.License.Policy getDefaultInstance() {
				return DEFAULT_INSTANCE;
			}

			@java.lang.Deprecated public static final Parser<Policy> PARSER = new AbstractParser<>() {
				@java.lang.Override
				public Policy parsePartialFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
						throws InvalidProtocolBufferException {
					Builder builder = newBuilder();
					try {
						builder.mergeFrom(input, extensionRegistry);
					} catch (InvalidProtocolBufferException e) {
						throw e.setUnfinishedMessage(builder.buildPartial());
					} catch (UninitializedMessageException e) {
						throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
					} catch (java.io.IOException e) {
						throw new InvalidProtocolBufferException(e).setUnfinishedMessage(builder.buildPartial());
					}
					return builder.buildPartial();
				}
			};

			public static Parser<Policy> parser() {
				return PARSER;
			}

			@java.lang.Override
			public Parser<Policy> getParserForType() {
				return PARSER;
			}

			@java.lang.Override
			public WvProto2.License.Policy getDefaultInstanceForType() {
				return DEFAULT_INSTANCE;
			}

		}

		public interface KeyContainerOrBuilder extends
				// @@protoc_insertion_point(interface_extends:License.KeyContainer)
				MessageOrBuilder {

			/**
			 * <code>optional bytes id = 1;</code>
			 * 
			 * @return Whether the id field is set.
			 */
			boolean hasId();

			/**
			 * <code>optional bytes id = 1;</code>
			 * 
			 * @return The id.
			 */
			ByteString getId();

			/**
			 * <code>optional bytes iv = 2;</code>
			 * 
			 * @return Whether the iv field is set.
			 */
			boolean hasIv();

			/**
			 * <code>optional bytes iv = 2;</code>
			 * 
			 * @return The iv.
			 */
			ByteString getIv();

			/**
			 * <code>optional bytes key = 3;</code>
			 * 
			 * @return Whether the key field is set.
			 */
			boolean hasKey();

			/**
			 * <code>optional bytes key = 3;</code>
			 * 
			 * @return The key.
			 */
			ByteString getKey();

			/**
			 * <code>optional .License.KeyContainer.KeyType type = 4;</code>
			 * 
			 * @return Whether the type field is set.
			 */
			boolean hasType();

			/**
			 * <code>optional .License.KeyContainer.KeyType type = 4;</code>
			 * 
			 * @return The type.
			 */
			WvProto2.License.KeyContainer.KeyType getType();

			/**
			 * <code>optional .License.KeyContainer.SecurityLevel level = 5 [default = SW_SECURE_CRYPTO];</code>
			 * 
			 * @return Whether the level field is set.
			 */
			boolean hasLevel();

			/**
			 * <code>optional .License.KeyContainer.SecurityLevel level = 5 [default = SW_SECURE_CRYPTO];</code>
			 * 
			 * @return The level.
			 */
			WvProto2.License.KeyContainer.SecurityLevel getLevel();

			/**
			 * <code>optional .License.KeyContainer.OutputProtection required_protection = 6;</code>
			 * 
			 * @return Whether the requiredProtection field is set.
			 */
			boolean hasRequiredProtection();

			/**
			 * <code>optional .License.KeyContainer.OutputProtection required_protection = 6;</code>
			 * 
			 * @return The requiredProtection.
			 */
			WvProto2.License.KeyContainer.OutputProtection getRequiredProtection();

			/**
			 * <code>optional .License.KeyContainer.OutputProtection required_protection = 6;</code>
			 */
			WvProto2.License.KeyContainer.OutputProtectionOrBuilder getRequiredProtectionOrBuilder();

			/**
			 * <pre>
			 * NOTE: Use of requested_protection is not recommended as it is only
			 * supported on a small number of platforms.
			 * </pre>
			 *
			 * <code>optional .License.KeyContainer.OutputProtection requested_protection = 7;</code>
			 * 
			 * @return Whether the requestedProtection field is set.
			 */
			boolean hasRequestedProtection();

			/**
			 * <pre>
			 * NOTE: Use of requested_protection is not recommended as it is only
			 * supported on a small number of platforms.
			 * </pre>
			 *
			 * <code>optional .License.KeyContainer.OutputProtection requested_protection = 7;</code>
			 * 
			 * @return The requestedProtection.
			 */
			WvProto2.License.KeyContainer.OutputProtection getRequestedProtection();

			/**
			 * <pre>
			 * NOTE: Use of requested_protection is not recommended as it is only
			 * supported on a small number of platforms.
			 * </pre>
			 *
			 * <code>optional .License.KeyContainer.OutputProtection requested_protection = 7;</code>
			 */
			WvProto2.License.KeyContainer.OutputProtectionOrBuilder getRequestedProtectionOrBuilder();

			/**
			 * <code>optional .License.KeyContainer.KeyControl key_control = 8;</code>
			 * 
			 * @return Whether the keyControl field is set.
			 */
			boolean hasKeyControl();

			/**
			 * <code>optional .License.KeyContainer.KeyControl key_control = 8;</code>
			 * 
			 * @return The keyControl.
			 */
			WvProto2.License.KeyContainer.KeyControl getKeyControl();

			/**
			 * <code>optional .License.KeyContainer.KeyControl key_control = 8;</code>
			 */
			WvProto2.License.KeyContainer.KeyControlOrBuilder getKeyControlOrBuilder();

			/**
			 * <code>optional .License.KeyContainer.OperatorSessionKeyPermissions operator_session_key_permissions = 9;</code>
			 * 
			 * @return Whether the operatorSessionKeyPermissions field is set.
			 */
			boolean hasOperatorSessionKeyPermissions();

			/**
			 * <code>optional .License.KeyContainer.OperatorSessionKeyPermissions operator_session_key_permissions = 9;</code>
			 * 
			 * @return The operatorSessionKeyPermissions.
			 */
			WvProto2.License.KeyContainer.OperatorSessionKeyPermissions getOperatorSessionKeyPermissions();

			/**
			 * <code>optional .License.KeyContainer.OperatorSessionKeyPermissions operator_session_key_permissions = 9;</code>
			 */
			WvProto2.License.KeyContainer.OperatorSessionKeyPermissionsOrBuilder getOperatorSessionKeyPermissionsOrBuilder();

			/**
			 * <pre>
			 * Optional video resolution constraints. If the video resolution of the
			 * content being decrypted/decoded falls within one of the specified ranges,
			 * the optional required_protections may be applied. Otherwise an error will
			 * be reported.
			 * NOTE: Use of this feature is not recommended, as it is only supported on
			 * a small number of platforms.
			 * </pre>
			 *
			 * <code>repeated .License.KeyContainer.VideoResolutionConstraint video_resolution_constraints = 10;</code>
			 */
			java.util.List<WvProto2.License.KeyContainer.VideoResolutionConstraint> getVideoResolutionConstraintsList();

			/**
			 * <pre>
			 * Optional video resolution constraints. If the video resolution of the
			 * content being decrypted/decoded falls within one of the specified ranges,
			 * the optional required_protections may be applied. Otherwise an error will
			 * be reported.
			 * NOTE: Use of this feature is not recommended, as it is only supported on
			 * a small number of platforms.
			 * </pre>
			 *
			 * <code>repeated .License.KeyContainer.VideoResolutionConstraint video_resolution_constraints = 10;</code>
			 */
			WvProto2.License.KeyContainer.VideoResolutionConstraint getVideoResolutionConstraints(
					int index);

			/**
			 * <pre>
			 * Optional video resolution constraints. If the video resolution of the
			 * content being decrypted/decoded falls within one of the specified ranges,
			 * the optional required_protections may be applied. Otherwise an error will
			 * be reported.
			 * NOTE: Use of this feature is not recommended, as it is only supported on
			 * a small number of platforms.
			 * </pre>
			 *
			 * <code>repeated .License.KeyContainer.VideoResolutionConstraint video_resolution_constraints = 10;</code>
			 */
			int getVideoResolutionConstraintsCount();

			/**
			 * <pre>
			 * Optional video resolution constraints. If the video resolution of the
			 * content being decrypted/decoded falls within one of the specified ranges,
			 * the optional required_protections may be applied. Otherwise an error will
			 * be reported.
			 * NOTE: Use of this feature is not recommended, as it is only supported on
			 * a small number of platforms.
			 * </pre>
			 *
			 * <code>repeated .License.KeyContainer.VideoResolutionConstraint video_resolution_constraints = 10;</code>
			 */
			java.util.List<? extends WvProto2.License.KeyContainer.VideoResolutionConstraintOrBuilder> getVideoResolutionConstraintsOrBuilderList();

			/**
			 * <pre>
			 * Optional video resolution constraints. If the video resolution of the
			 * content being decrypted/decoded falls within one of the specified ranges,
			 * the optional required_protections may be applied. Otherwise an error will
			 * be reported.
			 * NOTE: Use of this feature is not recommended, as it is only supported on
			 * a small number of platforms.
			 * </pre>
			 *
			 * <code>repeated .License.KeyContainer.VideoResolutionConstraint video_resolution_constraints = 10;</code>
			 */
			WvProto2.License.KeyContainer.VideoResolutionConstraintOrBuilder getVideoResolutionConstraintsOrBuilder(
					int index);

			/**
			 * <pre>
			 * Optional flag to indicate the key must only be used if the client
			 * supports anti rollback of the user table.  Content provider can query the
			 * client capabilities to determine if the client support this feature.
			 * </pre>
			 *
			 * <code>optional bool anti_rollback_usage_table = 11 [default = false];</code>
			 * 
			 * @return Whether the antiRollbackUsageTable field is set.
			 */
			boolean hasAntiRollbackUsageTable();

			/**
			 * <pre>
			 * Optional flag to indicate the key must only be used if the client
			 * supports anti rollback of the user table.  Content provider can query the
			 * client capabilities to determine if the client support this feature.
			 * </pre>
			 *
			 * <code>optional bool anti_rollback_usage_table = 11 [default = false];</code>
			 * 
			 * @return The antiRollbackUsageTable.
			 */
			boolean getAntiRollbackUsageTable();

			/**
			 * <pre>
			 * Optional not limited to commonly known track types such as SD, HD.
			 * It can be some provider defined label to identify the track.
			 * </pre>
			 *
			 * <code>optional string track_label = 12;</code>
			 * 
			 * @return Whether the trackLabel field is set.
			 */
			boolean hasTrackLabel();

			/**
			 * <pre>
			 * Optional not limited to commonly known track types such as SD, HD.
			 * It can be some provider defined label to identify the track.
			 * </pre>
			 *
			 * <code>optional string track_label = 12;</code>
			 * 
			 * @return The trackLabel.
			 */
			java.lang.String getTrackLabel();

			/**
			 * <pre>
			 * Optional not limited to commonly known track types such as SD, HD.
			 * It can be some provider defined label to identify the track.
			 * </pre>
			 *
			 * <code>optional string track_label = 12;</code>
			 * 
			 * @return The bytes for trackLabel.
			 */
			ByteString getTrackLabelBytes();
		}

		/**
		 * Protobuf type {@code License.KeyContainer}
		 */
		public static final class KeyContainer extends GeneratedMessageV3 implements
				// @@protoc_insertion_point(message_implements:License.KeyContainer)
				KeyContainerOrBuilder {
			private static final long serialVersionUID = 0L;

			// Use KeyContainer.newBuilder() to construct.
			private KeyContainer(GeneratedMessageV3.Builder<?> builder) {
				super(builder);
			}

			private KeyContainer() {
				id_ = ByteString.EMPTY;
				iv_ = ByteString.EMPTY;
				key_ = ByteString.EMPTY;
				type_ = 1;
				level_ = 1;
				videoResolutionConstraints_ = java.util.Collections.emptyList();
				trackLabel_ = "";
			}

			@java.lang.Override
			@SuppressWarnings({})
			protected java.lang.Object newInstance(UnusedPrivateParameter unused) {
				return new KeyContainer();
			}

			public static final Descriptors.Descriptor getDescriptor() {
				return WvProto2.internal_static_License_KeyContainer_descriptor;
			}

			@java.lang.Override
			protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
				return WvProto2.internal_static_License_KeyContainer_fieldAccessorTable
						.ensureFieldAccessorsInitialized(WvProto2.License.KeyContainer.class,
								WvProto2.License.KeyContainer.Builder.class);
			}

			/**
			 * Protobuf enum {@code License.KeyContainer.KeyType}
			 */
			public enum KeyType implements ProtocolMessageEnum {
				/**
				 * <pre>
				 * Exactly one key of this type must appear.
				 * </pre>
				 *
				 * <code>SIGNING = 1;</code>
				 */
				SIGNING(1),
				/**
				 * <pre>
				 * Content key.
				 * </pre>
				 *
				 * <code>CONTENT = 2;</code>
				 */
				CONTENT(2),
				/**
				 * <pre>
				 * Key control block for license renewals. No key.
				 * </pre>
				 *
				 * <code>KEY_CONTROL = 3;</code>
				 */
				KEY_CONTROL(3),
				/**
				 * <pre>
				 * wrapped keys for auxiliary crypto operations.
				 * </pre>
				 *
				 * <code>OPERATOR_SESSION = 4;</code>
				 */
				OPERATOR_SESSION(4),
				/**
				 * <pre>
				 * Entitlement keys.
				 * </pre>
				 *
				 * <code>ENTITLEMENT = 5;</code>
				 */
				ENTITLEMENT(5),
				/**
				 * <pre>
				 * Partner-specific content key.
				 * </pre>
				 *
				 * <code>OEM_CONTENT = 6;</code>
				 */
				OEM_CONTENT(6),;

				/**
				 * <pre>
				 * Exactly one key of this type must appear.
				 * </pre>
				 *
				 * <code>SIGNING = 1;</code>
				 */
				public static final int SIGNING_VALUE = 1;
				/**
				 * <pre>
				 * Content key.
				 * </pre>
				 *
				 * <code>CONTENT = 2;</code>
				 */
				public static final int CONTENT_VALUE = 2;
				/**
				 * <pre>
				 * Key control block for license renewals. No key.
				 * </pre>
				 *
				 * <code>KEY_CONTROL = 3;</code>
				 */
				public static final int KEY_CONTROL_VALUE = 3;
				/**
				 * <pre>
				 * wrapped keys for auxiliary crypto operations.
				 * </pre>
				 *
				 * <code>OPERATOR_SESSION = 4;</code>
				 */
				public static final int OPERATOR_SESSION_VALUE = 4;
				/**
				 * <pre>
				 * Entitlement keys.
				 * </pre>
				 *
				 * <code>ENTITLEMENT = 5;</code>
				 */
				public static final int ENTITLEMENT_VALUE = 5;
				/**
				 * <pre>
				 * Partner-specific content key.
				 * </pre>
				 *
				 * <code>OEM_CONTENT = 6;</code>
				 */
				public static final int OEM_CONTENT_VALUE = 6;

				@Override
				public final int getNumber() {
					return value;
				}

				/**
				 * @param value The numeric wire value of the corresponding enum entry.
				 * @return The enum associated with the given numeric wire value.
				 * @deprecated Use {@link #forNumber(int)} instead.
				 */
				@java.lang.Deprecated
				public static KeyType valueOf(int value) {
					return forNumber(value);
				}

				/**
				 * @param value The numeric wire value of the corresponding enum entry.
				 * @return The enum associated with the given numeric wire value.
				 */
				public static KeyType forNumber(int value) {
					switch (value) {
					case 1:
						return SIGNING;
					case 2:
						return CONTENT;
					case 3:
						return KEY_CONTROL;
					case 4:
						return OPERATOR_SESSION;
					case 5:
						return ENTITLEMENT;
					case 6:
						return OEM_CONTENT;
					default:
						return null;
					}
				}

				public static Internal.EnumLiteMap<KeyType> internalGetValueMap() {
					return internalValueMap;
				}

				private static final Internal.EnumLiteMap<KeyType> internalValueMap = new Internal.EnumLiteMap<>() {
					@Override
					public KeyType findValueByNumber(int number) {
						return KeyType.forNumber(number);
					}
				};

				@Override
				public final Descriptors.EnumValueDescriptor getValueDescriptor() {
					return getDescriptor().getValues().get(ordinal());
				}

				@Override
				public final Descriptors.EnumDescriptor getDescriptorForType() {
					return getDescriptor();
				}

				public static final Descriptors.EnumDescriptor getDescriptor() {
					return WvProto2.License.KeyContainer.getDescriptor().getEnumTypes().get(0);
				}

				private static final KeyType[] VALUES = values();

				public static KeyType valueOf(Descriptors.EnumValueDescriptor desc) {
					if (desc.getType() != getDescriptor()) {
						throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
					}
					return VALUES[desc.getIndex()];
				}

				private final int value;

				private KeyType(int value) {
					this.value = value;
				}

				// @@protoc_insertion_point(enum_scope:License.KeyContainer.KeyType)
			}

			/**
			 * <pre>
			 * The SecurityLevel enumeration allows the server to communicate the level
			 * of robustness required by the client, in order to use the key.
			 * </pre>
			 *
			 * Protobuf enum {@code License.KeyContainer.SecurityLevel}
			 */
			public enum SecurityLevel implements ProtocolMessageEnum {
				/**
				 * <pre>
				 * Software-based whitebox crypto is required.
				 * </pre>
				 *
				 * <code>SW_SECURE_CRYPTO = 1;</code>
				 */
				SW_SECURE_CRYPTO(1),
				/**
				 * <pre>
				 * Software crypto and an obfuscated decoder is required.
				 * </pre>
				 *
				 * <code>SW_SECURE_DECODE = 2;</code>
				 */
				SW_SECURE_DECODE(2),
				/**
				 * <pre>
				 * The key material and crypto operations must be performed within a
				 * hardware backed trusted execution environment.
				 * </pre>
				 *
				 * <code>HW_SECURE_CRYPTO = 3;</code>
				 */
				HW_SECURE_CRYPTO(3),
				/**
				 * <pre>
				 * The crypto and decoding of content must be performed within a hardware
				 * backed trusted execution environment.
				 * </pre>
				 *
				 * <code>HW_SECURE_DECODE = 4;</code>
				 */
				HW_SECURE_DECODE(4),
				/**
				 * <pre>
				 * The crypto, decoding and all handling of the media (compressed and
				 * uncompressed) must be handled within a hardware backed trusted
				 * execution environment.
				 * </pre>
				 *
				 * <code>HW_SECURE_ALL = 5;</code>
				 */
				HW_SECURE_ALL(5),;

				/**
				 * <pre>
				 * Software-based whitebox crypto is required.
				 * </pre>
				 *
				 * <code>SW_SECURE_CRYPTO = 1;</code>
				 */
				public static final int SW_SECURE_CRYPTO_VALUE = 1;
				/**
				 * <pre>
				 * Software crypto and an obfuscated decoder is required.
				 * </pre>
				 *
				 * <code>SW_SECURE_DECODE = 2;</code>
				 */
				public static final int SW_SECURE_DECODE_VALUE = 2;
				/**
				 * <pre>
				 * The key material and crypto operations must be performed within a
				 * hardware backed trusted execution environment.
				 * </pre>
				 *
				 * <code>HW_SECURE_CRYPTO = 3;</code>
				 */
				public static final int HW_SECURE_CRYPTO_VALUE = 3;
				/**
				 * <pre>
				 * The crypto and decoding of content must be performed within a hardware
				 * backed trusted execution environment.
				 * </pre>
				 *
				 * <code>HW_SECURE_DECODE = 4;</code>
				 */
				public static final int HW_SECURE_DECODE_VALUE = 4;
				/**
				 * <pre>
				 * The crypto, decoding and all handling of the media (compressed and
				 * uncompressed) must be handled within a hardware backed trusted
				 * execution environment.
				 * </pre>
				 *
				 * <code>HW_SECURE_ALL = 5;</code>
				 */
				public static final int HW_SECURE_ALL_VALUE = 5;

				@Override
				public final int getNumber() {
					return value;
				}

				/**
				 * @param value The numeric wire value of the corresponding enum entry.
				 * @return The enum associated with the given numeric wire value.
				 * @deprecated Use {@link #forNumber(int)} instead.
				 */
				@java.lang.Deprecated
				public static SecurityLevel valueOf(int value) {
					return forNumber(value);
				}

				/**
				 * @param value The numeric wire value of the corresponding enum entry.
				 * @return The enum associated with the given numeric wire value.
				 */
				public static SecurityLevel forNumber(int value) {
					switch (value) {
					case 1:
						return SW_SECURE_CRYPTO;
					case 2:
						return SW_SECURE_DECODE;
					case 3:
						return HW_SECURE_CRYPTO;
					case 4:
						return HW_SECURE_DECODE;
					case 5:
						return HW_SECURE_ALL;
					default:
						return null;
					}
				}

				public static Internal.EnumLiteMap<SecurityLevel> internalGetValueMap() {
					return internalValueMap;
				}

				private static final Internal.EnumLiteMap<SecurityLevel> internalValueMap = new Internal.EnumLiteMap<>() {
					@Override
					public SecurityLevel findValueByNumber(int number) {
						return SecurityLevel.forNumber(number);
					}
				};

				@Override
				public final Descriptors.EnumValueDescriptor getValueDescriptor() {
					return getDescriptor().getValues().get(ordinal());
				}

				@Override
				public final Descriptors.EnumDescriptor getDescriptorForType() {
					return getDescriptor();
				}

				public static final Descriptors.EnumDescriptor getDescriptor() {
					return WvProto2.License.KeyContainer.getDescriptor().getEnumTypes().get(1);
				}

				private static final SecurityLevel[] VALUES = values();

				public static SecurityLevel valueOf(Descriptors.EnumValueDescriptor desc) {
					if (desc.getType() != getDescriptor()) {
						throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
					}
					return VALUES[desc.getIndex()];
				}

				private final int value;

				private SecurityLevel(int value) {
					this.value = value;
				}

				// @@protoc_insertion_point(enum_scope:License.KeyContainer.SecurityLevel)
			}

			public interface KeyControlOrBuilder extends
					// @@protoc_insertion_point(interface_extends:License.KeyContainer.KeyControl)
					MessageOrBuilder {

				/**
				 * <pre>
				 * |key_control| is documented in:
				 * Widevine Modular DRM Security Integration Guide for CENC
				 * If present, the key control must be communicated to the secure
				 * environment prior to any usage. This message is automatically generated
				 * by the Widevine License Server SDK.
				 * </pre>
				 *
				 * <code>optional bytes key_control_block = 1;</code>
				 * 
				 * @return Whether the keyControlBlock field is set.
				 */
				boolean hasKeyControlBlock();

				/**
				 * <pre>
				 * |key_control| is documented in:
				 * Widevine Modular DRM Security Integration Guide for CENC
				 * If present, the key control must be communicated to the secure
				 * environment prior to any usage. This message is automatically generated
				 * by the Widevine License Server SDK.
				 * </pre>
				 *
				 * <code>optional bytes key_control_block = 1;</code>
				 * 
				 * @return The keyControlBlock.
				 */
				ByteString getKeyControlBlock();

				/**
				 * <code>optional bytes iv = 2;</code>
				 * 
				 * @return Whether the iv field is set.
				 */
				boolean hasIv();

				/**
				 * <code>optional bytes iv = 2;</code>
				 * 
				 * @return The iv.
				 */
				ByteString getIv();
			}

			/**
			 * Protobuf type {@code License.KeyContainer.KeyControl}
			 */
			public static final class KeyControl extends GeneratedMessageV3 implements
					// @@protoc_insertion_point(message_implements:License.KeyContainer.KeyControl)
					KeyControlOrBuilder {
				private static final long serialVersionUID = 0L;

				// Use KeyControl.newBuilder() to construct.
				private KeyControl(GeneratedMessageV3.Builder<?> builder) {
					super(builder);
				}

				private KeyControl() {
					keyControlBlock_ = ByteString.EMPTY;
					iv_ = ByteString.EMPTY;
				}

				@java.lang.Override
				@SuppressWarnings({})
				protected java.lang.Object newInstance(UnusedPrivateParameter unused) {
					return new KeyControl();
				}

				public static final Descriptors.Descriptor getDescriptor() {
					return WvProto2.internal_static_License_KeyContainer_KeyControl_descriptor;
				}

				@java.lang.Override
				protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
					return WvProto2.internal_static_License_KeyContainer_KeyControl_fieldAccessorTable
							.ensureFieldAccessorsInitialized(
									WvProto2.License.KeyContainer.KeyControl.class,
									WvProto2.License.KeyContainer.KeyControl.Builder.class);
				}

				private int bitField0_;
				public static final int KEY_CONTROL_BLOCK_FIELD_NUMBER = 1;
				private ByteString keyControlBlock_ = ByteString.EMPTY;

				/**
				 * <pre>
				 * |key_control| is documented in:
				 * Widevine Modular DRM Security Integration Guide for CENC
				 * If present, the key control must be communicated to the secure
				 * environment prior to any usage. This message is automatically generated
				 * by the Widevine License Server SDK.
				 * </pre>
				 *
				 * <code>optional bytes key_control_block = 1;</code>
				 * 
				 * @return Whether the keyControlBlock field is set.
				 */
				@java.lang.Override
				public boolean hasKeyControlBlock() {
					return ((bitField0_ & 0x00000001) != 0);
				}

				/**
				 * <pre>
				 * |key_control| is documented in:
				 * Widevine Modular DRM Security Integration Guide for CENC
				 * If present, the key control must be communicated to the secure
				 * environment prior to any usage. This message is automatically generated
				 * by the Widevine License Server SDK.
				 * </pre>
				 *
				 * <code>optional bytes key_control_block = 1;</code>
				 * 
				 * @return The keyControlBlock.
				 */
				@java.lang.Override
				public ByteString getKeyControlBlock() {
					return keyControlBlock_;
				}

				public static final int IV_FIELD_NUMBER = 2;
				private ByteString iv_ = ByteString.EMPTY;

				/**
				 * <code>optional bytes iv = 2;</code>
				 * 
				 * @return Whether the iv field is set.
				 */
				@java.lang.Override
				public boolean hasIv() {
					return ((bitField0_ & 0x00000002) != 0);
				}

				/**
				 * <code>optional bytes iv = 2;</code>
				 * 
				 * @return The iv.
				 */
				@java.lang.Override
				public ByteString getIv() {
					return iv_;
				}

				private byte memoizedIsInitialized = -1;

				@java.lang.Override
				public final boolean isInitialized() {
					byte isInitialized = memoizedIsInitialized;
					if (isInitialized == 1)
						return true;
					if (isInitialized == 0)
						return false;

					memoizedIsInitialized = 1;
					return true;
				}

				@java.lang.Override
				public void writeTo(CodedOutputStream output) throws java.io.IOException {
					if (((bitField0_ & 0x00000001) != 0)) {
						output.writeBytes(1, keyControlBlock_);
					}
					if (((bitField0_ & 0x00000002) != 0)) {
						output.writeBytes(2, iv_);
					}
					getUnknownFields().writeTo(output);
				}

				@java.lang.Override
				public int getSerializedSize() {
					int size = memoizedSize;
					if (size != -1)
						return size;

					size = 0;
					if (((bitField0_ & 0x00000001) != 0)) {
						size += CodedOutputStream.computeBytesSize(1, keyControlBlock_);
					}
					if (((bitField0_ & 0x00000002) != 0)) {
						size += CodedOutputStream.computeBytesSize(2, iv_);
					}
					size += getUnknownFields().getSerializedSize();
					memoizedSize = size;
					return size;
				}

				@java.lang.Override
				public boolean equals(final java.lang.Object obj) {
					if (obj == this) {
						return true;
					}
					if (!(obj instanceof WvProto2.License.KeyContainer.KeyControl)) {
						return super.equals(obj);
					}
					WvProto2.License.KeyContainer.KeyControl other = (WvProto2.License.KeyContainer.KeyControl) obj;

					if (hasKeyControlBlock() != other.hasKeyControlBlock())
						return false;
					if (hasKeyControlBlock()) {
						if (!getKeyControlBlock().equals(other.getKeyControlBlock()))
							return false;
					}
					if (hasIv() != other.hasIv())
						return false;
					if (hasIv()) {
						if (!getIv().equals(other.getIv()))
							return false;
					}
					if (!getUnknownFields().equals(other.getUnknownFields()))
						return false;
					return true;
				}

				@SuppressWarnings("unchecked")
				@java.lang.Override
				public int hashCode() {
					if (memoizedHashCode != 0) {
						return memoizedHashCode;
					}
					int hash = 41;
					hash = (19 * hash) + getDescriptor().hashCode();
					if (hasKeyControlBlock()) {
						hash = (37 * hash) + KEY_CONTROL_BLOCK_FIELD_NUMBER;
						hash = (53 * hash) + getKeyControlBlock().hashCode();
					}
					if (hasIv()) {
						hash = (37 * hash) + IV_FIELD_NUMBER;
						hash = (53 * hash) + getIv().hashCode();
					}
					hash = (29 * hash) + getUnknownFields().hashCode();
					memoizedHashCode = hash;
					return hash;
				}

				public static WvProto2.License.KeyContainer.KeyControl parseFrom(
						java.nio.ByteBuffer data) throws InvalidProtocolBufferException {
					return PARSER.parseFrom(data);
				}

				public static WvProto2.License.KeyContainer.KeyControl parseFrom(
						java.nio.ByteBuffer data, ExtensionRegistryLite extensionRegistry)
						throws InvalidProtocolBufferException {
					return PARSER.parseFrom(data, extensionRegistry);
				}

				public static WvProto2.License.KeyContainer.KeyControl parseFrom(
						ByteString data) throws InvalidProtocolBufferException {
					return PARSER.parseFrom(data);
				}

				public static WvProto2.License.KeyContainer.KeyControl parseFrom(
						ByteString data, ExtensionRegistryLite extensionRegistry)
						throws InvalidProtocolBufferException {
					return PARSER.parseFrom(data, extensionRegistry);
				}

				public static WvProto2.License.KeyContainer.KeyControl parseFrom(byte[] data)
						throws InvalidProtocolBufferException {
					return PARSER.parseFrom(data);
				}

				public static WvProto2.License.KeyContainer.KeyControl parseFrom(byte[] data,
						ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
					return PARSER.parseFrom(data, extensionRegistry);
				}

				public static WvProto2.License.KeyContainer.KeyControl parseFrom(
						java.io.InputStream input) throws java.io.IOException {
					return GeneratedMessageV3.parseWithIOException(PARSER, input);
				}

				public static WvProto2.License.KeyContainer.KeyControl parseFrom(
						java.io.InputStream input, ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
					return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
				}

				public static WvProto2.License.KeyContainer.KeyControl parseDelimitedFrom(
						java.io.InputStream input) throws java.io.IOException {
					return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
				}

				public static WvProto2.License.KeyContainer.KeyControl parseDelimitedFrom(
						java.io.InputStream input, ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
					return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input, extensionRegistry);
				}

				public static WvProto2.License.KeyContainer.KeyControl parseFrom(
						CodedInputStream input) throws java.io.IOException {
					return GeneratedMessageV3.parseWithIOException(PARSER, input);
				}

				public static WvProto2.License.KeyContainer.KeyControl parseFrom(
						CodedInputStream input, ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
					return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
				}

				@java.lang.Override
				public Builder newBuilderForType() {
					return newBuilder();
				}

				public static Builder newBuilder() {
					return DEFAULT_INSTANCE.toBuilder();
				}

				public static Builder newBuilder(
						WvProto2.License.KeyContainer.KeyControl prototype) {
					return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
				}

				@java.lang.Override
				public Builder toBuilder() {
					return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
				}

				@java.lang.Override
				protected Builder newBuilderForType(GeneratedMessageV3.BuilderParent parent) {
					Builder builder = new Builder(parent);
					return builder;
				}

				/**
				 * Protobuf type {@code License.KeyContainer.KeyControl}
				 */
				public static final class Builder extends GeneratedMessageV3.Builder<Builder> implements
						// @@protoc_insertion_point(builder_implements:License.KeyContainer.KeyControl)
						WvProto2.License.KeyContainer.KeyControlOrBuilder {
					public static final Descriptors.Descriptor getDescriptor() {
						return WvProto2.internal_static_License_KeyContainer_KeyControl_descriptor;
					}

					@java.lang.Override
					protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
						return WvProto2.internal_static_License_KeyContainer_KeyControl_fieldAccessorTable
								.ensureFieldAccessorsInitialized(
										WvProto2.License.KeyContainer.KeyControl.class,
										WvProto2.License.KeyContainer.KeyControl.Builder.class);
					}

					// Construct using
					// WvProto2.License.KeyContainer.KeyControl.newBuilder()
					private Builder() {

					}

					private Builder(GeneratedMessageV3.BuilderParent parent) {
						super(parent);

					}

					@java.lang.Override
					public Builder clear() {
						super.clear();
						bitField0_ = 0;
						keyControlBlock_ = ByteString.EMPTY;
						iv_ = ByteString.EMPTY;
						return this;
					}

					@java.lang.Override
					public Descriptors.Descriptor getDescriptorForType() {
						return WvProto2.internal_static_License_KeyContainer_KeyControl_descriptor;
					}

					@java.lang.Override
					public WvProto2.License.KeyContainer.KeyControl getDefaultInstanceForType() {
						return WvProto2.License.KeyContainer.KeyControl.getDefaultInstance();
					}

					@java.lang.Override
					public WvProto2.License.KeyContainer.KeyControl build() {
						WvProto2.License.KeyContainer.KeyControl result = buildPartial();
						if (!result.isInitialized()) {
							throw newUninitializedMessageException(result);
						}
						return result;
					}

					@java.lang.Override
					public WvProto2.License.KeyContainer.KeyControl buildPartial() {
						WvProto2.License.KeyContainer.KeyControl result = new WvProto2.License.KeyContainer.KeyControl(
								this);
						if (bitField0_ != 0) {
							buildPartial0(result);
						}
						onBuilt();
						return result;
					}

					private void buildPartial0(
							WvProto2.License.KeyContainer.KeyControl result) {
						int from_bitField0_ = bitField0_;
						int to_bitField0_ = 0;
						if (((from_bitField0_ & 0x00000001) != 0)) {
							result.keyControlBlock_ = keyControlBlock_;
							to_bitField0_ |= 0x00000001;
						}
						if (((from_bitField0_ & 0x00000002) != 0)) {
							result.iv_ = iv_;
							to_bitField0_ |= 0x00000002;
						}
						result.bitField0_ |= to_bitField0_;
					}

					@java.lang.Override
					public Builder mergeFrom(Message other) {
						if (other instanceof WvProto2.License.KeyContainer.KeyControl) {
							return mergeFrom((WvProto2.License.KeyContainer.KeyControl) other);
						}
						super.mergeFrom(other);
						return this;
					}

					public Builder mergeFrom(WvProto2.License.KeyContainer.KeyControl other) {
						if (other == WvProto2.License.KeyContainer.KeyControl
								.getDefaultInstance())
							return this;
						if (other.hasKeyControlBlock()) {
							setKeyControlBlock(other.getKeyControlBlock());
						}
						if (other.hasIv()) {
							setIv(other.getIv());
						}
						this.mergeUnknownFields(other.getUnknownFields());
						onChanged();
						return this;
					}

					@java.lang.Override
					public final boolean isInitialized() {
						return true;
					}

					@java.lang.Override
					public Builder mergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
							throws java.io.IOException {
						if (extensionRegistry == null) {
							throw new java.lang.NullPointerException();
						}
						try {
							boolean done = false;
							while (!done) {
								int tag = input.readTag();
								switch (tag) {
								case 0:
									done = true;
									break;
								case 10: {
									keyControlBlock_ = input.readBytes();
									bitField0_ |= 0x00000001;
									break;
								} // case 10
								case 18: {
									iv_ = input.readBytes();
									bitField0_ |= 0x00000002;
									break;
								} // case 18
								default: {
									if (!super.parseUnknownField(input, extensionRegistry, tag)) {
										done = true; // was an endgroup tag
									}
									break;
								} // default:
								} // switch (tag)
							} // while (!done)
						} catch (InvalidProtocolBufferException e) {
							throw e.unwrapIOException();
						}
						finally {
							onChanged();
						} // finally
						return this;
					}

					private int bitField0_;

					private ByteString keyControlBlock_ = ByteString.EMPTY;

					/**
					 * <pre>
					 * |key_control| is documented in:
					 * Widevine Modular DRM Security Integration Guide for CENC
					 * If present, the key control must be communicated to the secure
					 * environment prior to any usage. This message is automatically generated
					 * by the Widevine License Server SDK.
					 * </pre>
					 *
					 * <code>optional bytes key_control_block = 1;</code>
					 * 
					 * @return Whether the keyControlBlock field is set.
					 */
					@java.lang.Override
					public boolean hasKeyControlBlock() {
						return ((bitField0_ & 0x00000001) != 0);
					}

					/**
					 * <pre>
					 * |key_control| is documented in:
					 * Widevine Modular DRM Security Integration Guide for CENC
					 * If present, the key control must be communicated to the secure
					 * environment prior to any usage. This message is automatically generated
					 * by the Widevine License Server SDK.
					 * </pre>
					 *
					 * <code>optional bytes key_control_block = 1;</code>
					 * 
					 * @return The keyControlBlock.
					 */
					@java.lang.Override
					public ByteString getKeyControlBlock() {
						return keyControlBlock_;
					}

					/**
					 * <pre>
					 * |key_control| is documented in:
					 * Widevine Modular DRM Security Integration Guide for CENC
					 * If present, the key control must be communicated to the secure
					 * environment prior to any usage. This message is automatically generated
					 * by the Widevine License Server SDK.
					 * </pre>
					 *
					 * <code>optional bytes key_control_block = 1;</code>
					 * 
					 * @param value The keyControlBlock to set.
					 * @return This builder for chaining.
					 */
					public Builder setKeyControlBlock(ByteString value) {
						if (value == null) {
							throw new NullPointerException();
						}
						keyControlBlock_ = value;
						bitField0_ |= 0x00000001;
						onChanged();
						return this;
					}

					/**
					 * <pre>
					 * |key_control| is documented in:
					 * Widevine Modular DRM Security Integration Guide for CENC
					 * If present, the key control must be communicated to the secure
					 * environment prior to any usage. This message is automatically generated
					 * by the Widevine License Server SDK.
					 * </pre>
					 *
					 * <code>optional bytes key_control_block = 1;</code>
					 * 
					 * @return This builder for chaining.
					 */
					public Builder clearKeyControlBlock() {
						bitField0_ = (bitField0_ & ~0x00000001);
						keyControlBlock_ = getDefaultInstance().getKeyControlBlock();
						onChanged();
						return this;
					}

					private ByteString iv_ = ByteString.EMPTY;

					/**
					 * <code>optional bytes iv = 2;</code>
					 * 
					 * @return Whether the iv field is set.
					 */
					@java.lang.Override
					public boolean hasIv() {
						return ((bitField0_ & 0x00000002) != 0);
					}

					/**
					 * <code>optional bytes iv = 2;</code>
					 * 
					 * @return The iv.
					 */
					@java.lang.Override
					public ByteString getIv() {
						return iv_;
					}

					/**
					 * <code>optional bytes iv = 2;</code>
					 * 
					 * @param value The iv to set.
					 * @return This builder for chaining.
					 */
					public Builder setIv(ByteString value) {
						if (value == null) {
							throw new NullPointerException();
						}
						iv_ = value;
						bitField0_ |= 0x00000002;
						onChanged();
						return this;
					}

					/**
					 * <code>optional bytes iv = 2;</code>
					 * 
					 * @return This builder for chaining.
					 */
					public Builder clearIv() {
						bitField0_ = (bitField0_ & ~0x00000002);
						iv_ = getDefaultInstance().getIv();
						onChanged();
						return this;
					}

					@java.lang.Override
					public final Builder setUnknownFields(final UnknownFieldSet unknownFields) {
						return super.setUnknownFields(unknownFields);
					}

					@java.lang.Override
					public final Builder mergeUnknownFields(final UnknownFieldSet unknownFields) {
						return super.mergeUnknownFields(unknownFields);
					}

					// @@protoc_insertion_point(builder_scope:License.KeyContainer.KeyControl)
				}

				// @@protoc_insertion_point(class_scope:License.KeyContainer.KeyControl)
				private static final WvProto2.License.KeyContainer.KeyControl DEFAULT_INSTANCE;
				static {
					DEFAULT_INSTANCE = new WvProto2.License.KeyContainer.KeyControl();
				}

				public static WvProto2.License.KeyContainer.KeyControl getDefaultInstance() {
					return DEFAULT_INSTANCE;
				}

				@java.lang.Deprecated public static final Parser<KeyControl> PARSER = new AbstractParser<>() {
					@java.lang.Override
					public KeyControl parsePartialFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
							throws InvalidProtocolBufferException {
						Builder builder = newBuilder();
						try {
							builder.mergeFrom(input, extensionRegistry);
						} catch (InvalidProtocolBufferException e) {
							throw e.setUnfinishedMessage(builder.buildPartial());
						} catch (UninitializedMessageException e) {
							throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
						} catch (java.io.IOException e) {
							throw new InvalidProtocolBufferException(e).setUnfinishedMessage(builder.buildPartial());
						}
						return builder.buildPartial();
					}
				};

				public static Parser<KeyControl> parser() {
					return PARSER;
				}

				@java.lang.Override
				public Parser<KeyControl> getParserForType() {
					return PARSER;
				}

				@java.lang.Override
				public WvProto2.License.KeyContainer.KeyControl getDefaultInstanceForType() {
					return DEFAULT_INSTANCE;
				}

			}

			public interface OutputProtectionOrBuilder extends
					// @@protoc_insertion_point(interface_extends:License.KeyContainer.OutputProtection)
					MessageOrBuilder {

				/**
				 * <code>optional .License.KeyContainer.OutputProtection.HDCP hdcp = 1 [default = HDCP_NONE];</code>
				 * 
				 * @return Whether the hdcp field is set.
				 */
				boolean hasHdcp();

				/**
				 * <code>optional .License.KeyContainer.OutputProtection.HDCP hdcp = 1 [default = HDCP_NONE];</code>
				 * 
				 * @return The hdcp.
				 */
				WvProto2.License.KeyContainer.OutputProtection.HDCP getHdcp();

				/**
				 * <code>optional .License.KeyContainer.OutputProtection.CGMS cgms_flags = 2 [default = CGMS_NONE];</code>
				 * 
				 * @return Whether the cgmsFlags field is set.
				 */
				boolean hasCgmsFlags();

				/**
				 * <code>optional .License.KeyContainer.OutputProtection.CGMS cgms_flags = 2 [default = CGMS_NONE];</code>
				 * 
				 * @return The cgmsFlags.
				 */
				WvProto2.License.KeyContainer.OutputProtection.CGMS getCgmsFlags();

				/**
				 * <code>optional .License.KeyContainer.OutputProtection.HdcpSrmRule hdcp_srm_rule = 3 [default = HDCP_SRM_RULE_NONE];</code>
				 * 
				 * @return Whether the hdcpSrmRule field is set.
				 */
				boolean hasHdcpSrmRule();

				/**
				 * <code>optional .License.KeyContainer.OutputProtection.HdcpSrmRule hdcp_srm_rule = 3 [default = HDCP_SRM_RULE_NONE];</code>
				 * 
				 * @return The hdcpSrmRule.
				 */
				WvProto2.License.KeyContainer.OutputProtection.HdcpSrmRule getHdcpSrmRule();

				/**
				 * <pre>
				 * Optional requirement to indicate analog output is not allowed.
				 * </pre>
				 *
				 * <code>optional bool disable_analog_output = 4 [default = false];</code>
				 * 
				 * @return Whether the disableAnalogOutput field is set.
				 */
				boolean hasDisableAnalogOutput();

				/**
				 * <pre>
				 * Optional requirement to indicate analog output is not allowed.
				 * </pre>
				 *
				 * <code>optional bool disable_analog_output = 4 [default = false];</code>
				 * 
				 * @return The disableAnalogOutput.
				 */
				boolean getDisableAnalogOutput();

				/**
				 * <pre>
				 * Optional requirement to indicate digital output is not allowed.
				 * </pre>
				 *
				 * <code>optional bool disable_digital_output = 5 [default = false];</code>
				 * 
				 * @return Whether the disableDigitalOutput field is set.
				 */
				boolean hasDisableDigitalOutput();

				/**
				 * <pre>
				 * Optional requirement to indicate digital output is not allowed.
				 * </pre>
				 *
				 * <code>optional bool disable_digital_output = 5 [default = false];</code>
				 * 
				 * @return The disableDigitalOutput.
				 */
				boolean getDisableDigitalOutput();
			}

			/**
			 * Protobuf type {@code License.KeyContainer.OutputProtection}
			 */
			public static final class OutputProtection extends GeneratedMessageV3 implements
					// @@protoc_insertion_point(message_implements:License.KeyContainer.OutputProtection)
					OutputProtectionOrBuilder {
				private static final long serialVersionUID = 0L;

				// Use OutputProtection.newBuilder() to construct.
				private OutputProtection(GeneratedMessageV3.Builder<?> builder) {
					super(builder);
				}

				private OutputProtection() {
					hdcp_ = 0;
					cgmsFlags_ = 42;
					hdcpSrmRule_ = 0;
				}

				@java.lang.Override

				protected java.lang.Object newInstance(UnusedPrivateParameter unused) {
					return new OutputProtection();
				}

				public static final Descriptors.Descriptor getDescriptor() {
					return WvProto2.internal_static_License_KeyContainer_OutputProtection_descriptor;
				}

				@java.lang.Override
				protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
					return WvProto2.internal_static_License_KeyContainer_OutputProtection_fieldAccessorTable
							.ensureFieldAccessorsInitialized(
									WvProto2.License.KeyContainer.OutputProtection.class,
									WvProto2.License.KeyContainer.OutputProtection.Builder.class);
				}

				/**
				 * <pre>
				 * Indicates whether HDCP is required on digital outputs, and which
				 * version should be used.
				 * </pre>
				 *
				 * Protobuf enum {@code License.KeyContainer.OutputProtection.HDCP}
				 */
				public enum HDCP implements ProtocolMessageEnum {
					/**
					 * <code>HDCP_NONE = 0;</code>
					 */
					HDCP_NONE(0),
					/**
					 * <code>HDCP_V1 = 1;</code>
					 */
					HDCP_V1(1),
					/**
					 * <code>HDCP_V2 = 2;</code>
					 */
					HDCP_V2(2),
					/**
					 * <code>HDCP_V2_1 = 3;</code>
					 */
					HDCP_V2_1(3),
					/**
					 * <code>HDCP_V2_2 = 4;</code>
					 */
					HDCP_V2_2(4),
					/**
					 * <code>HDCP_V2_3 = 5;</code>
					 */
					HDCP_V2_3(5),
					/**
					 * <code>HDCP_NO_DIGITAL_OUTPUT = 255;</code>
					 */
					HDCP_NO_DIGITAL_OUTPUT(255),;

					/**
					 * <code>HDCP_NONE = 0;</code>
					 */
					public static final int HDCP_NONE_VALUE = 0;
					/**
					 * <code>HDCP_V1 = 1;</code>
					 */
					public static final int HDCP_V1_VALUE = 1;
					/**
					 * <code>HDCP_V2 = 2;</code>
					 */
					public static final int HDCP_V2_VALUE = 2;
					/**
					 * <code>HDCP_V2_1 = 3;</code>
					 */
					public static final int HDCP_V2_1_VALUE = 3;
					/**
					 * <code>HDCP_V2_2 = 4;</code>
					 */
					public static final int HDCP_V2_2_VALUE = 4;
					/**
					 * <code>HDCP_V2_3 = 5;</code>
					 */
					public static final int HDCP_V2_3_VALUE = 5;
					/**
					 * <code>HDCP_NO_DIGITAL_OUTPUT = 255;</code>
					 */
					public static final int HDCP_NO_DIGITAL_OUTPUT_VALUE = 255;

					@Override
					public final int getNumber() {
						return value;
					}

					/**
					 * @param value The numeric wire value of the corresponding enum entry.
					 * @return The enum associated with the given numeric wire value.
					 * @deprecated Use {@link #forNumber(int)} instead.
					 */
					@java.lang.Deprecated
					public static HDCP valueOf(int value) {
						return forNumber(value);
					}

					/**
					 * @param value The numeric wire value of the corresponding enum entry.
					 * @return The enum associated with the given numeric wire value.
					 */
					public static HDCP forNumber(int value) {
						switch (value) {
						case 0:
							return HDCP_NONE;
						case 1:
							return HDCP_V1;
						case 2:
							return HDCP_V2;
						case 3:
							return HDCP_V2_1;
						case 4:
							return HDCP_V2_2;
						case 5:
							return HDCP_V2_3;
						case 255:
							return HDCP_NO_DIGITAL_OUTPUT;
						default:
							return null;
						}
					}

					public static Internal.EnumLiteMap<HDCP> internalGetValueMap() {
						return internalValueMap;
					}

					private static final Internal.EnumLiteMap<HDCP> internalValueMap = new Internal.EnumLiteMap<>() {
						@Override
						public HDCP findValueByNumber(int number) {
							return HDCP.forNumber(number);
						}
					};

					@Override
					public final Descriptors.EnumValueDescriptor getValueDescriptor() {
						return getDescriptor().getValues().get(ordinal());
					}

					@Override
					public final Descriptors.EnumDescriptor getDescriptorForType() {
						return getDescriptor();
					}

					public static final Descriptors.EnumDescriptor getDescriptor() {
						return WvProto2.License.KeyContainer.OutputProtection.getDescriptor()
								.getEnumTypes().get(0);
					}

					private static final HDCP[] VALUES = values();

					public static HDCP valueOf(Descriptors.EnumValueDescriptor desc) {
						if (desc.getType() != getDescriptor()) {
							throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
						}
						return VALUES[desc.getIndex()];
					}

					private final int value;

					private HDCP(int value) {
						this.value = value;
					}

					// @@protoc_insertion_point(enum_scope:License.KeyContainer.OutputProtection.HDCP)
				}

				/**
				 * <pre>
				 * Indicate the CGMS setting to be inserted on analog output.
				 * </pre>
				 *
				 * Protobuf enum {@code License.KeyContainer.OutputProtection.CGMS}
				 */
				public enum CGMS implements ProtocolMessageEnum {
					/**
					 * <code>CGMS_NONE = 42;</code>
					 */
					CGMS_NONE(42),
					/**
					 * <code>COPY_FREE = 0;</code>
					 */
					COPY_FREE(0),
					/**
					 * <code>COPY_ONCE = 2;</code>
					 */
					COPY_ONCE(2),
					/**
					 * <code>COPY_NEVER = 3;</code>
					 */
					COPY_NEVER(3),;

					/**
					 * <code>CGMS_NONE = 42;</code>
					 */
					public static final int CGMS_NONE_VALUE = 42;
					/**
					 * <code>COPY_FREE = 0;</code>
					 */
					public static final int COPY_FREE_VALUE = 0;
					/**
					 * <code>COPY_ONCE = 2;</code>
					 */
					public static final int COPY_ONCE_VALUE = 2;
					/**
					 * <code>COPY_NEVER = 3;</code>
					 */
					public static final int COPY_NEVER_VALUE = 3;

					@Override
					public final int getNumber() {
						return value;
					}

					/**
					 * @param value The numeric wire value of the corresponding enum entry.
					 * @return The enum associated with the given numeric wire value.
					 * @deprecated Use {@link #forNumber(int)} instead.
					 */
					@java.lang.Deprecated
					public static CGMS valueOf(int value) {
						return forNumber(value);
					}

					/**
					 * @param value The numeric wire value of the corresponding enum entry.
					 * @return The enum associated with the given numeric wire value.
					 */
					public static CGMS forNumber(int value) {
						switch (value) {
						case 42:
							return CGMS_NONE;
						case 0:
							return COPY_FREE;
						case 2:
							return COPY_ONCE;
						case 3:
							return COPY_NEVER;
						default:
							return null;
						}
					}

					public static Internal.EnumLiteMap<CGMS> internalGetValueMap() {
						return internalValueMap;
					}

					private static final Internal.EnumLiteMap<CGMS> internalValueMap = new Internal.EnumLiteMap<>() {
						@Override
						public CGMS findValueByNumber(int number) {
							return CGMS.forNumber(number);
						}
					};

					@Override
					public final Descriptors.EnumValueDescriptor getValueDescriptor() {
						return getDescriptor().getValues().get(ordinal());
					}

					@Override
					public final Descriptors.EnumDescriptor getDescriptorForType() {
						return getDescriptor();
					}

					public static final Descriptors.EnumDescriptor getDescriptor() {
						return WvProto2.License.KeyContainer.OutputProtection.getDescriptor()
								.getEnumTypes().get(1);
					}

					private static final CGMS[] VALUES = values();

					public static CGMS valueOf(Descriptors.EnumValueDescriptor desc) {
						if (desc.getType() != getDescriptor()) {
							throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
						}
						return VALUES[desc.getIndex()];
					}

					private final int value;

					private CGMS(int value) {
						this.value = value;
					}

					// @@protoc_insertion_point(enum_scope:License.KeyContainer.OutputProtection.CGMS)
				}

				/**
				 * Protobuf enum {@code License.KeyContainer.OutputProtection.HdcpSrmRule}
				 */
				public enum HdcpSrmRule implements ProtocolMessageEnum {
					/**
					 * <code>HDCP_SRM_RULE_NONE = 0;</code>
					 */
					HDCP_SRM_RULE_NONE(0),
					/**
					 * <pre>
					 * In 'required_protection', this means most current SRM is required.
					 * Update the SRM on the device. If update cannot happen,
					 * do not allow the key.
					 * In 'requested_protection', this means most current SRM is requested.
					 * Update the SRM on the device. If update cannot happen,
					 * allow use of the key anyway.
					 * </pre>
					 *
					 * <code>CURRENT_SRM = 1;</code>
					 */
					CURRENT_SRM(1),;

					/**
					 * <code>HDCP_SRM_RULE_NONE = 0;</code>
					 */
					public static final int HDCP_SRM_RULE_NONE_VALUE = 0;
					/**
					 * <pre>
					 * In 'required_protection', this means most current SRM is required.
					 * Update the SRM on the device. If update cannot happen,
					 * do not allow the key.
					 * In 'requested_protection', this means most current SRM is requested.
					 * Update the SRM on the device. If update cannot happen,
					 * allow use of the key anyway.
					 * </pre>
					 *
					 * <code>CURRENT_SRM = 1;</code>
					 */
					public static final int CURRENT_SRM_VALUE = 1;

					@Override
					public final int getNumber() {
						return value;
					}

					/**
					 * @param value The numeric wire value of the corresponding enum entry.
					 * @return The enum associated with the given numeric wire value.
					 * @deprecated Use {@link #forNumber(int)} instead.
					 */
					@java.lang.Deprecated
					public static HdcpSrmRule valueOf(int value) {
						return forNumber(value);
					}

					/**
					 * @param value The numeric wire value of the corresponding enum entry.
					 * @return The enum associated with the given numeric wire value.
					 */
					public static HdcpSrmRule forNumber(int value) {
						switch (value) {
						case 0:
							return HDCP_SRM_RULE_NONE;
						case 1:
							return CURRENT_SRM;
						default:
							return null;
						}
					}

					public static Internal.EnumLiteMap<HdcpSrmRule> internalGetValueMap() {
						return internalValueMap;
					}

					private static final Internal.EnumLiteMap<HdcpSrmRule> internalValueMap = new Internal.EnumLiteMap<>() {
						@Override
						public HdcpSrmRule findValueByNumber(int number) {
							return HdcpSrmRule.forNumber(number);
						}
					};

					@Override
					public final Descriptors.EnumValueDescriptor getValueDescriptor() {
						return getDescriptor().getValues().get(ordinal());
					}

					@Override
					public final Descriptors.EnumDescriptor getDescriptorForType() {
						return getDescriptor();
					}

					public static final Descriptors.EnumDescriptor getDescriptor() {
						return WvProto2.License.KeyContainer.OutputProtection.getDescriptor()
								.getEnumTypes().get(2);
					}

					private static final HdcpSrmRule[] VALUES = values();

					public static HdcpSrmRule valueOf(Descriptors.EnumValueDescriptor desc) {
						if (desc.getType() != getDescriptor()) {
							throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
						}
						return VALUES[desc.getIndex()];
					}

					private final int value;

					private HdcpSrmRule(int value) {
						this.value = value;
					}

					// @@protoc_insertion_point(enum_scope:License.KeyContainer.OutputProtection.HdcpSrmRule)
				}

				private int bitField0_;
				public static final int HDCP_FIELD_NUMBER = 1;
				private int hdcp_ = 0;

				/**
				 * <code>optional .License.KeyContainer.OutputProtection.HDCP hdcp = 1 [default = HDCP_NONE];</code>
				 * 
				 * @return Whether the hdcp field is set.
				 */
				@java.lang.Override
				public boolean hasHdcp() {
					return ((bitField0_ & 0x00000001) != 0);
				}

				/**
				 * <code>optional .License.KeyContainer.OutputProtection.HDCP hdcp = 1 [default = HDCP_NONE];</code>
				 * 
				 * @return The hdcp.
				 */
				@java.lang.Override
				public WvProto2.License.KeyContainer.OutputProtection.HDCP getHdcp() {
					WvProto2.License.KeyContainer.OutputProtection.HDCP result = WvProto2.License.KeyContainer.OutputProtection.HDCP
							.forNumber(hdcp_);
					return result == null
							? WvProto2.License.KeyContainer.OutputProtection.HDCP.HDCP_NONE
							: result;
				}

				public static final int CGMS_FLAGS_FIELD_NUMBER = 2;
				private int cgmsFlags_ = 42;

				/**
				 * <code>optional .License.KeyContainer.OutputProtection.CGMS cgms_flags = 2 [default = CGMS_NONE];</code>
				 * 
				 * @return Whether the cgmsFlags field is set.
				 */
				@java.lang.Override
				public boolean hasCgmsFlags() {
					return ((bitField0_ & 0x00000002) != 0);
				}

				/**
				 * <code>optional .License.KeyContainer.OutputProtection.CGMS cgms_flags = 2 [default = CGMS_NONE];</code>
				 * 
				 * @return The cgmsFlags.
				 */
				@java.lang.Override
				public WvProto2.License.KeyContainer.OutputProtection.CGMS getCgmsFlags() {
					WvProto2.License.KeyContainer.OutputProtection.CGMS result = WvProto2.License.KeyContainer.OutputProtection.CGMS
							.forNumber(cgmsFlags_);
					return result == null
							? WvProto2.License.KeyContainer.OutputProtection.CGMS.CGMS_NONE
							: result;
				}

				public static final int HDCP_SRM_RULE_FIELD_NUMBER = 3;
				private int hdcpSrmRule_ = 0;

				/**
				 * <code>optional .License.KeyContainer.OutputProtection.HdcpSrmRule hdcp_srm_rule = 3 [default = HDCP_SRM_RULE_NONE];</code>
				 * 
				 * @return Whether the hdcpSrmRule field is set.
				 */
				@java.lang.Override
				public boolean hasHdcpSrmRule() {
					return ((bitField0_ & 0x00000004) != 0);
				}

				/**
				 * <code>optional .License.KeyContainer.OutputProtection.HdcpSrmRule hdcp_srm_rule = 3 [default = HDCP_SRM_RULE_NONE];</code>
				 * 
				 * @return The hdcpSrmRule.
				 */
				@java.lang.Override
				public WvProto2.License.KeyContainer.OutputProtection.HdcpSrmRule getHdcpSrmRule() {
					WvProto2.License.KeyContainer.OutputProtection.HdcpSrmRule result = WvProto2.License.KeyContainer.OutputProtection.HdcpSrmRule
							.forNumber(hdcpSrmRule_);
					return result == null
							? WvProto2.License.KeyContainer.OutputProtection.HdcpSrmRule.HDCP_SRM_RULE_NONE
							: result;
				}

				public static final int DISABLE_ANALOG_OUTPUT_FIELD_NUMBER = 4;
				private boolean disableAnalogOutput_ = false;

				/**
				 * <pre>
				 * Optional requirement to indicate analog output is not allowed.
				 * </pre>
				 *
				 * <code>optional bool disable_analog_output = 4 [default = false];</code>
				 * 
				 * @return Whether the disableAnalogOutput field is set.
				 */
				@java.lang.Override
				public boolean hasDisableAnalogOutput() {
					return ((bitField0_ & 0x00000008) != 0);
				}

				/**
				 * <pre>
				 * Optional requirement to indicate analog output is not allowed.
				 * </pre>
				 *
				 * <code>optional bool disable_analog_output = 4 [default = false];</code>
				 * 
				 * @return The disableAnalogOutput.
				 */
				@java.lang.Override
				public boolean getDisableAnalogOutput() {
					return disableAnalogOutput_;
				}

				public static final int DISABLE_DIGITAL_OUTPUT_FIELD_NUMBER = 5;
				private boolean disableDigitalOutput_ = false;

				/**
				 * <pre>
				 * Optional requirement to indicate digital output is not allowed.
				 * </pre>
				 *
				 * <code>optional bool disable_digital_output = 5 [default = false];</code>
				 * 
				 * @return Whether the disableDigitalOutput field is set.
				 */
				@java.lang.Override
				public boolean hasDisableDigitalOutput() {
					return ((bitField0_ & 0x00000010) != 0);
				}

				/**
				 * <pre>
				 * Optional requirement to indicate digital output is not allowed.
				 * </pre>
				 *
				 * <code>optional bool disable_digital_output = 5 [default = false];</code>
				 * 
				 * @return The disableDigitalOutput.
				 */
				@java.lang.Override
				public boolean getDisableDigitalOutput() {
					return disableDigitalOutput_;
				}

				private byte memoizedIsInitialized = -1;

				@java.lang.Override
				public final boolean isInitialized() {
					byte isInitialized = memoizedIsInitialized;
					if (isInitialized == 1)
						return true;
					if (isInitialized == 0)
						return false;

					memoizedIsInitialized = 1;
					return true;
				}

				@java.lang.Override
				public void writeTo(CodedOutputStream output) throws java.io.IOException {
					if (((bitField0_ & 0x00000001) != 0)) {
						output.writeEnum(1, hdcp_);
					}
					if (((bitField0_ & 0x00000002) != 0)) {
						output.writeEnum(2, cgmsFlags_);
					}
					if (((bitField0_ & 0x00000004) != 0)) {
						output.writeEnum(3, hdcpSrmRule_);
					}
					if (((bitField0_ & 0x00000008) != 0)) {
						output.writeBool(4, disableAnalogOutput_);
					}
					if (((bitField0_ & 0x00000010) != 0)) {
						output.writeBool(5, disableDigitalOutput_);
					}
					getUnknownFields().writeTo(output);
				}

				@java.lang.Override
				public int getSerializedSize() {
					int size = memoizedSize;
					if (size != -1)
						return size;

					size = 0;
					if (((bitField0_ & 0x00000001) != 0)) {
						size += CodedOutputStream.computeEnumSize(1, hdcp_);
					}
					if (((bitField0_ & 0x00000002) != 0)) {
						size += CodedOutputStream.computeEnumSize(2, cgmsFlags_);
					}
					if (((bitField0_ & 0x00000004) != 0)) {
						size += CodedOutputStream.computeEnumSize(3, hdcpSrmRule_);
					}
					if (((bitField0_ & 0x00000008) != 0)) {
						size += CodedOutputStream.computeBoolSize(4, disableAnalogOutput_);
					}
					if (((bitField0_ & 0x00000010) != 0)) {
						size += CodedOutputStream.computeBoolSize(5, disableDigitalOutput_);
					}
					size += getUnknownFields().getSerializedSize();
					memoizedSize = size;
					return size;
				}

				@java.lang.Override
				public boolean equals(final java.lang.Object obj) {
					if (obj == this) {
						return true;
					}
					if (!(obj instanceof WvProto2.License.KeyContainer.OutputProtection)) {
						return super.equals(obj);
					}
					WvProto2.License.KeyContainer.OutputProtection other = (WvProto2.License.KeyContainer.OutputProtection) obj;

					if (hasHdcp() != other.hasHdcp())
						return false;
					if (hasHdcp()) {
						if (hdcp_ != other.hdcp_)
							return false;
					}
					if (hasCgmsFlags() != other.hasCgmsFlags())
						return false;
					if (hasCgmsFlags()) {
						if (cgmsFlags_ != other.cgmsFlags_)
							return false;
					}
					if (hasHdcpSrmRule() != other.hasHdcpSrmRule())
						return false;
					if (hasHdcpSrmRule()) {
						if (hdcpSrmRule_ != other.hdcpSrmRule_)
							return false;
					}
					if (hasDisableAnalogOutput() != other.hasDisableAnalogOutput())
						return false;
					if (hasDisableAnalogOutput()) {
						if (getDisableAnalogOutput() != other.getDisableAnalogOutput())
							return false;
					}
					if (hasDisableDigitalOutput() != other.hasDisableDigitalOutput())
						return false;
					if (hasDisableDigitalOutput()) {
						if (getDisableDigitalOutput() != other.getDisableDigitalOutput())
							return false;
					}
					if (!getUnknownFields().equals(other.getUnknownFields()))
						return false;
					return true;
				}

				@SuppressWarnings("unchecked")
				@java.lang.Override
				public int hashCode() {
					if (memoizedHashCode != 0) {
						return memoizedHashCode;
					}
					int hash = 41;
					hash = (19 * hash) + getDescriptor().hashCode();
					if (hasHdcp()) {
						hash = (37 * hash) + HDCP_FIELD_NUMBER;
						hash = (53 * hash) + hdcp_;
					}
					if (hasCgmsFlags()) {
						hash = (37 * hash) + CGMS_FLAGS_FIELD_NUMBER;
						hash = (53 * hash) + cgmsFlags_;
					}
					if (hasHdcpSrmRule()) {
						hash = (37 * hash) + HDCP_SRM_RULE_FIELD_NUMBER;
						hash = (53 * hash) + hdcpSrmRule_;
					}
					if (hasDisableAnalogOutput()) {
						hash = (37 * hash) + DISABLE_ANALOG_OUTPUT_FIELD_NUMBER;
						hash = (53 * hash) + Internal.hashBoolean(getDisableAnalogOutput());
					}
					if (hasDisableDigitalOutput()) {
						hash = (37 * hash) + DISABLE_DIGITAL_OUTPUT_FIELD_NUMBER;
						hash = (53 * hash) + Internal.hashBoolean(getDisableDigitalOutput());
					}
					hash = (29 * hash) + getUnknownFields().hashCode();
					memoizedHashCode = hash;
					return hash;
				}

				public static WvProto2.License.KeyContainer.OutputProtection parseFrom(
						java.nio.ByteBuffer data) throws InvalidProtocolBufferException {
					return PARSER.parseFrom(data);
				}

				public static WvProto2.License.KeyContainer.OutputProtection parseFrom(
						java.nio.ByteBuffer data, ExtensionRegistryLite extensionRegistry)
						throws InvalidProtocolBufferException {
					return PARSER.parseFrom(data, extensionRegistry);
				}

				public static WvProto2.License.KeyContainer.OutputProtection parseFrom(
						ByteString data) throws InvalidProtocolBufferException {
					return PARSER.parseFrom(data);
				}

				public static WvProto2.License.KeyContainer.OutputProtection parseFrom(
						ByteString data, ExtensionRegistryLite extensionRegistry)
						throws InvalidProtocolBufferException {
					return PARSER.parseFrom(data, extensionRegistry);
				}

				public static WvProto2.License.KeyContainer.OutputProtection parseFrom(
						byte[] data) throws InvalidProtocolBufferException {
					return PARSER.parseFrom(data);
				}

				public static WvProto2.License.KeyContainer.OutputProtection parseFrom(
						byte[] data, ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
					return PARSER.parseFrom(data, extensionRegistry);
				}

				public static WvProto2.License.KeyContainer.OutputProtection parseFrom(
						java.io.InputStream input) throws java.io.IOException {
					return GeneratedMessageV3.parseWithIOException(PARSER, input);
				}

				public static WvProto2.License.KeyContainer.OutputProtection parseFrom(
						java.io.InputStream input, ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
					return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
				}

				public static WvProto2.License.KeyContainer.OutputProtection parseDelimitedFrom(
						java.io.InputStream input) throws java.io.IOException {
					return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
				}

				public static WvProto2.License.KeyContainer.OutputProtection parseDelimitedFrom(
						java.io.InputStream input, ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
					return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input, extensionRegistry);
				}

				public static WvProto2.License.KeyContainer.OutputProtection parseFrom(
						CodedInputStream input) throws java.io.IOException {
					return GeneratedMessageV3.parseWithIOException(PARSER, input);
				}

				public static WvProto2.License.KeyContainer.OutputProtection parseFrom(
						CodedInputStream input, ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
					return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
				}

				@java.lang.Override
				public Builder newBuilderForType() {
					return newBuilder();
				}

				public static Builder newBuilder() {
					return DEFAULT_INSTANCE.toBuilder();
				}

				public static Builder newBuilder(
						WvProto2.License.KeyContainer.OutputProtection prototype) {
					return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
				}

				@java.lang.Override
				public Builder toBuilder() {
					return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
				}

				@java.lang.Override
				protected Builder newBuilderForType(GeneratedMessageV3.BuilderParent parent) {
					Builder builder = new Builder(parent);
					return builder;
				}

				/**
				 * Protobuf type {@code License.KeyContainer.OutputProtection}
				 */
				public static final class Builder extends GeneratedMessageV3.Builder<Builder> implements
						// @@protoc_insertion_point(builder_implements:License.KeyContainer.OutputProtection)
						WvProto2.License.KeyContainer.OutputProtectionOrBuilder {
					public static final Descriptors.Descriptor getDescriptor() {
						return WvProto2.internal_static_License_KeyContainer_OutputProtection_descriptor;
					}

					@java.lang.Override
					protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
						return WvProto2.internal_static_License_KeyContainer_OutputProtection_fieldAccessorTable
								.ensureFieldAccessorsInitialized(
										WvProto2.License.KeyContainer.OutputProtection.class,
										WvProto2.License.KeyContainer.OutputProtection.Builder.class);
					}

					// Construct using
					// WvProto2.License.KeyContainer.OutputProtection.newBuilder()
					private Builder() {

					}

					private Builder(GeneratedMessageV3.BuilderParent parent) {
						super(parent);

					}

					@java.lang.Override
					public Builder clear() {
						super.clear();
						bitField0_ = 0;
						hdcp_ = 0;
						cgmsFlags_ = 42;
						hdcpSrmRule_ = 0;
						disableAnalogOutput_ = false;
						disableDigitalOutput_ = false;
						return this;
					}

					@java.lang.Override
					public Descriptors.Descriptor getDescriptorForType() {
						return WvProto2.internal_static_License_KeyContainer_OutputProtection_descriptor;
					}

					@java.lang.Override
					public WvProto2.License.KeyContainer.OutputProtection getDefaultInstanceForType() {
						return WvProto2.License.KeyContainer.OutputProtection
								.getDefaultInstance();
					}

					@java.lang.Override
					public WvProto2.License.KeyContainer.OutputProtection build() {
						WvProto2.License.KeyContainer.OutputProtection result = buildPartial();
						if (!result.isInitialized()) {
							throw newUninitializedMessageException(result);
						}
						return result;
					}

					@java.lang.Override
					public WvProto2.License.KeyContainer.OutputProtection buildPartial() {
						WvProto2.License.KeyContainer.OutputProtection result = new WvProto2.License.KeyContainer.OutputProtection(
								this);
						if (bitField0_ != 0) {
							buildPartial0(result);
						}
						onBuilt();
						return result;
					}

					private void buildPartial0(
							WvProto2.License.KeyContainer.OutputProtection result) {
						int from_bitField0_ = bitField0_;
						int to_bitField0_ = 0;
						if (((from_bitField0_ & 0x00000001) != 0)) {
							result.hdcp_ = hdcp_;
							to_bitField0_ |= 0x00000001;
						}
						if (((from_bitField0_ & 0x00000002) != 0)) {
							result.cgmsFlags_ = cgmsFlags_;
							to_bitField0_ |= 0x00000002;
						}
						if (((from_bitField0_ & 0x00000004) != 0)) {
							result.hdcpSrmRule_ = hdcpSrmRule_;
							to_bitField0_ |= 0x00000004;
						}
						if (((from_bitField0_ & 0x00000008) != 0)) {
							result.disableAnalogOutput_ = disableAnalogOutput_;
							to_bitField0_ |= 0x00000008;
						}
						if (((from_bitField0_ & 0x00000010) != 0)) {
							result.disableDigitalOutput_ = disableDigitalOutput_;
							to_bitField0_ |= 0x00000010;
						}
						result.bitField0_ |= to_bitField0_;
					}

					@java.lang.Override
					public Builder mergeFrom(Message other) {
						if (other instanceof WvProto2.License.KeyContainer.OutputProtection) {
							return mergeFrom(
									(WvProto2.License.KeyContainer.OutputProtection) other);
						}
						super.mergeFrom(other);
						return this;
					}

					public Builder mergeFrom(
							WvProto2.License.KeyContainer.OutputProtection other) {
						if (other == WvProto2.License.KeyContainer.OutputProtection
								.getDefaultInstance())
							return this;
						if (other.hasHdcp()) {
							setHdcp(other.getHdcp());
						}
						if (other.hasCgmsFlags()) {
							setCgmsFlags(other.getCgmsFlags());
						}
						if (other.hasHdcpSrmRule()) {
							setHdcpSrmRule(other.getHdcpSrmRule());
						}
						if (other.hasDisableAnalogOutput()) {
							setDisableAnalogOutput(other.getDisableAnalogOutput());
						}
						if (other.hasDisableDigitalOutput()) {
							setDisableDigitalOutput(other.getDisableDigitalOutput());
						}
						this.mergeUnknownFields(other.getUnknownFields());
						onChanged();
						return this;
					}

					@java.lang.Override
					public final boolean isInitialized() {
						return true;
					}

					@java.lang.Override
					public Builder mergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
							throws java.io.IOException {
						if (extensionRegistry == null) {
							throw new java.lang.NullPointerException();
						}
						try {
							boolean done = false;
							while (!done) {
								int tag = input.readTag();
								switch (tag) {
								case 0:
									done = true;
									break;
								case 8: {
									int tmpRaw = input.readEnum();
									WvProto2.License.KeyContainer.OutputProtection.HDCP tmpValue = WvProto2.License.KeyContainer.OutputProtection.HDCP
											.forNumber(tmpRaw);
									if (tmpValue == null) {
										mergeUnknownVarintField(1, tmpRaw);
									} else {
										hdcp_ = tmpRaw;
										bitField0_ |= 0x00000001;
									}
									break;
								} // case 8
								case 16: {
									int tmpRaw = input.readEnum();
									WvProto2.License.KeyContainer.OutputProtection.CGMS tmpValue = WvProto2.License.KeyContainer.OutputProtection.CGMS
											.forNumber(tmpRaw);
									if (tmpValue == null) {
										mergeUnknownVarintField(2, tmpRaw);
									} else {
										cgmsFlags_ = tmpRaw;
										bitField0_ |= 0x00000002;
									}
									break;
								} // case 16
								case 24: {
									int tmpRaw = input.readEnum();
									WvProto2.License.KeyContainer.OutputProtection.HdcpSrmRule tmpValue = WvProto2.License.KeyContainer.OutputProtection.HdcpSrmRule
											.forNumber(tmpRaw);
									if (tmpValue == null) {
										mergeUnknownVarintField(3, tmpRaw);
									} else {
										hdcpSrmRule_ = tmpRaw;
										bitField0_ |= 0x00000004;
									}
									break;
								} // case 24
								case 32: {
									disableAnalogOutput_ = input.readBool();
									bitField0_ |= 0x00000008;
									break;
								} // case 32
								case 40: {
									disableDigitalOutput_ = input.readBool();
									bitField0_ |= 0x00000010;
									break;
								} // case 40
								default: {
									if (!super.parseUnknownField(input, extensionRegistry, tag)) {
										done = true; // was an endgroup tag
									}
									break;
								} // default:
								} // switch (tag)
							} // while (!done)
						} catch (InvalidProtocolBufferException e) {
							throw e.unwrapIOException();
						}
						finally {
							onChanged();
						} // finally
						return this;
					}

					private int bitField0_;

					private int hdcp_ = 0;

					/**
					 * <code>optional .License.KeyContainer.OutputProtection.HDCP hdcp = 1 [default = HDCP_NONE];</code>
					 * 
					 * @return Whether the hdcp field is set.
					 */
					@java.lang.Override
					public boolean hasHdcp() {
						return ((bitField0_ & 0x00000001) != 0);
					}

					/**
					 * <code>optional .License.KeyContainer.OutputProtection.HDCP hdcp = 1 [default = HDCP_NONE];</code>
					 * 
					 * @return The hdcp.
					 */
					@java.lang.Override
					public WvProto2.License.KeyContainer.OutputProtection.HDCP getHdcp() {
						WvProto2.License.KeyContainer.OutputProtection.HDCP result = WvProto2.License.KeyContainer.OutputProtection.HDCP
								.forNumber(hdcp_);
						return result == null
								? WvProto2.License.KeyContainer.OutputProtection.HDCP.HDCP_NONE
								: result;
					}

					/**
					 * <code>optional .License.KeyContainer.OutputProtection.HDCP hdcp = 1 [default = HDCP_NONE];</code>
					 * 
					 * @param value The hdcp to set.
					 * @return This builder for chaining.
					 */
					public Builder setHdcp(
							WvProto2.License.KeyContainer.OutputProtection.HDCP value) {
						if (value == null) {
							throw new NullPointerException();
						}
						bitField0_ |= 0x00000001;
						hdcp_ = value.getNumber();
						onChanged();
						return this;
					}

					/**
					 * <code>optional .License.KeyContainer.OutputProtection.HDCP hdcp = 1 [default = HDCP_NONE];</code>
					 * 
					 * @return This builder for chaining.
					 */
					public Builder clearHdcp() {
						bitField0_ = (bitField0_ & ~0x00000001);
						hdcp_ = 0;
						onChanged();
						return this;
					}

					private int cgmsFlags_ = 42;

					/**
					 * <code>optional .License.KeyContainer.OutputProtection.CGMS cgms_flags = 2 [default = CGMS_NONE];</code>
					 * 
					 * @return Whether the cgmsFlags field is set.
					 */
					@java.lang.Override
					public boolean hasCgmsFlags() {
						return ((bitField0_ & 0x00000002) != 0);
					}

					/**
					 * <code>optional .License.KeyContainer.OutputProtection.CGMS cgms_flags = 2 [default = CGMS_NONE];</code>
					 * 
					 * @return The cgmsFlags.
					 */
					@java.lang.Override
					public WvProto2.License.KeyContainer.OutputProtection.CGMS getCgmsFlags() {
						WvProto2.License.KeyContainer.OutputProtection.CGMS result = WvProto2.License.KeyContainer.OutputProtection.CGMS
								.forNumber(cgmsFlags_);
						return result == null
								? WvProto2.License.KeyContainer.OutputProtection.CGMS.CGMS_NONE
								: result;
					}

					/**
					 * <code>optional .License.KeyContainer.OutputProtection.CGMS cgms_flags = 2 [default = CGMS_NONE];</code>
					 * 
					 * @param value The cgmsFlags to set.
					 * @return This builder for chaining.
					 */
					public Builder setCgmsFlags(
							WvProto2.License.KeyContainer.OutputProtection.CGMS value) {
						if (value == null) {
							throw new NullPointerException();
						}
						bitField0_ |= 0x00000002;
						cgmsFlags_ = value.getNumber();
						onChanged();
						return this;
					}

					/**
					 * <code>optional .License.KeyContainer.OutputProtection.CGMS cgms_flags = 2 [default = CGMS_NONE];</code>
					 * 
					 * @return This builder for chaining.
					 */
					public Builder clearCgmsFlags() {
						bitField0_ = (bitField0_ & ~0x00000002);
						cgmsFlags_ = 42;
						onChanged();
						return this;
					}

					private int hdcpSrmRule_ = 0;

					/**
					 * <code>optional .License.KeyContainer.OutputProtection.HdcpSrmRule hdcp_srm_rule = 3 [default = HDCP_SRM_RULE_NONE];</code>
					 * 
					 * @return Whether the hdcpSrmRule field is set.
					 */
					@java.lang.Override
					public boolean hasHdcpSrmRule() {
						return ((bitField0_ & 0x00000004) != 0);
					}

					/**
					 * <code>optional .License.KeyContainer.OutputProtection.HdcpSrmRule hdcp_srm_rule = 3 [default = HDCP_SRM_RULE_NONE];</code>
					 * 
					 * @return The hdcpSrmRule.
					 */
					@java.lang.Override
					public WvProto2.License.KeyContainer.OutputProtection.HdcpSrmRule getHdcpSrmRule() {
						WvProto2.License.KeyContainer.OutputProtection.HdcpSrmRule result = WvProto2.License.KeyContainer.OutputProtection.HdcpSrmRule
								.forNumber(hdcpSrmRule_);
						return result == null
								? WvProto2.License.KeyContainer.OutputProtection.HdcpSrmRule.HDCP_SRM_RULE_NONE
								: result;
					}

					/**
					 * <code>optional .License.KeyContainer.OutputProtection.HdcpSrmRule hdcp_srm_rule = 3 [default = HDCP_SRM_RULE_NONE];</code>
					 * 
					 * @param value The hdcpSrmRule to set.
					 * @return This builder for chaining.
					 */
					public Builder setHdcpSrmRule(
							WvProto2.License.KeyContainer.OutputProtection.HdcpSrmRule value) {
						if (value == null) {
							throw new NullPointerException();
						}
						bitField0_ |= 0x00000004;
						hdcpSrmRule_ = value.getNumber();
						onChanged();
						return this;
					}

					/**
					 * <code>optional .License.KeyContainer.OutputProtection.HdcpSrmRule hdcp_srm_rule = 3 [default = HDCP_SRM_RULE_NONE];</code>
					 * 
					 * @return This builder for chaining.
					 */
					public Builder clearHdcpSrmRule() {
						bitField0_ = (bitField0_ & ~0x00000004);
						hdcpSrmRule_ = 0;
						onChanged();
						return this;
					}

					private boolean disableAnalogOutput_;

					/**
					 * <pre>
					 * Optional requirement to indicate analog output is not allowed.
					 * </pre>
					 *
					 * <code>optional bool disable_analog_output = 4 [default = false];</code>
					 * 
					 * @return Whether the disableAnalogOutput field is set.
					 */
					@java.lang.Override
					public boolean hasDisableAnalogOutput() {
						return ((bitField0_ & 0x00000008) != 0);
					}

					/**
					 * <pre>
					 * Optional requirement to indicate analog output is not allowed.
					 * </pre>
					 *
					 * <code>optional bool disable_analog_output = 4 [default = false];</code>
					 * 
					 * @return The disableAnalogOutput.
					 */
					@java.lang.Override
					public boolean getDisableAnalogOutput() {
						return disableAnalogOutput_;
					}

					/**
					 * <pre>
					 * Optional requirement to indicate analog output is not allowed.
					 * </pre>
					 *
					 * <code>optional bool disable_analog_output = 4 [default = false];</code>
					 * 
					 * @param value The disableAnalogOutput to set.
					 * @return This builder for chaining.
					 */
					public Builder setDisableAnalogOutput(boolean value) {

						disableAnalogOutput_ = value;
						bitField0_ |= 0x00000008;
						onChanged();
						return this;
					}

					/**
					 * <pre>
					 * Optional requirement to indicate analog output is not allowed.
					 * </pre>
					 *
					 * <code>optional bool disable_analog_output = 4 [default = false];</code>
					 * 
					 * @return This builder for chaining.
					 */
					public Builder clearDisableAnalogOutput() {
						bitField0_ = (bitField0_ & ~0x00000008);
						disableAnalogOutput_ = false;
						onChanged();
						return this;
					}

					private boolean disableDigitalOutput_;

					/**
					 * <pre>
					 * Optional requirement to indicate digital output is not allowed.
					 * </pre>
					 *
					 * <code>optional bool disable_digital_output = 5 [default = false];</code>
					 * 
					 * @return Whether the disableDigitalOutput field is set.
					 */
					@java.lang.Override
					public boolean hasDisableDigitalOutput() {
						return ((bitField0_ & 0x00000010) != 0);
					}

					/**
					 * <pre>
					 * Optional requirement to indicate digital output is not allowed.
					 * </pre>
					 *
					 * <code>optional bool disable_digital_output = 5 [default = false];</code>
					 * 
					 * @return The disableDigitalOutput.
					 */
					@java.lang.Override
					public boolean getDisableDigitalOutput() {
						return disableDigitalOutput_;
					}

					/**
					 * <pre>
					 * Optional requirement to indicate digital output is not allowed.
					 * </pre>
					 *
					 * <code>optional bool disable_digital_output = 5 [default = false];</code>
					 * 
					 * @param value The disableDigitalOutput to set.
					 * @return This builder for chaining.
					 */
					public Builder setDisableDigitalOutput(boolean value) {

						disableDigitalOutput_ = value;
						bitField0_ |= 0x00000010;
						onChanged();
						return this;
					}

					/**
					 * <pre>
					 * Optional requirement to indicate digital output is not allowed.
					 * </pre>
					 *
					 * <code>optional bool disable_digital_output = 5 [default = false];</code>
					 * 
					 * @return This builder for chaining.
					 */
					public Builder clearDisableDigitalOutput() {
						bitField0_ = (bitField0_ & ~0x00000010);
						disableDigitalOutput_ = false;
						onChanged();
						return this;
					}

					@java.lang.Override
					public final Builder setUnknownFields(final UnknownFieldSet unknownFields) {
						return super.setUnknownFields(unknownFields);
					}

					@java.lang.Override
					public final Builder mergeUnknownFields(final UnknownFieldSet unknownFields) {
						return super.mergeUnknownFields(unknownFields);
					}

					// @@protoc_insertion_point(builder_scope:License.KeyContainer.OutputProtection)
				}

				// @@protoc_insertion_point(class_scope:License.KeyContainer.OutputProtection)
				private static final WvProto2.License.KeyContainer.OutputProtection DEFAULT_INSTANCE;
				static {
					DEFAULT_INSTANCE = new WvProto2.License.KeyContainer.OutputProtection();
				}

				public static WvProto2.License.KeyContainer.OutputProtection getDefaultInstance() {
					return DEFAULT_INSTANCE;
				}

				@java.lang.Deprecated public static final Parser<OutputProtection> PARSER = new AbstractParser<>() {
					@java.lang.Override
					public OutputProtection parsePartialFrom(CodedInputStream input,
							ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
						Builder builder = newBuilder();
						try {
							builder.mergeFrom(input, extensionRegistry);
						} catch (InvalidProtocolBufferException e) {
							throw e.setUnfinishedMessage(builder.buildPartial());
						} catch (UninitializedMessageException e) {
							throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
						} catch (java.io.IOException e) {
							throw new InvalidProtocolBufferException(e).setUnfinishedMessage(builder.buildPartial());
						}
						return builder.buildPartial();
					}
				};

				public static Parser<OutputProtection> parser() {
					return PARSER;
				}

				@java.lang.Override
				public Parser<OutputProtection> getParserForType() {
					return PARSER;
				}

				@java.lang.Override
				public WvProto2.License.KeyContainer.OutputProtection getDefaultInstanceForType() {
					return DEFAULT_INSTANCE;
				}

			}

			public interface VideoResolutionConstraintOrBuilder extends
					// @@protoc_insertion_point(interface_extends:License.KeyContainer.VideoResolutionConstraint)
					MessageOrBuilder {

				/**
				 * <pre>
				 * Minimum and maximum video resolutions in the range (height x width).
				 * </pre>
				 *
				 * <code>optional uint32 min_resolution_pixels = 1;</code>
				 * 
				 * @return Whether the minResolutionPixels field is set.
				 */
				boolean hasMinResolutionPixels();

				/**
				 * <pre>
				 * Minimum and maximum video resolutions in the range (height x width).
				 * </pre>
				 *
				 * <code>optional uint32 min_resolution_pixels = 1;</code>
				 * 
				 * @return The minResolutionPixels.
				 */
				int getMinResolutionPixels();

				/**
				 * <code>optional uint32 max_resolution_pixels = 2;</code>
				 * 
				 * @return Whether the maxResolutionPixels field is set.
				 */
				boolean hasMaxResolutionPixels();

				/**
				 * <code>optional uint32 max_resolution_pixels = 2;</code>
				 * 
				 * @return The maxResolutionPixels.
				 */
				int getMaxResolutionPixels();

				/**
				 * <pre>
				 * Optional output protection requirements for this range. If not
				 * specified, the OutputProtection in the KeyContainer applies.
				 * </pre>
				 *
				 * <code>optional .License.KeyContainer.OutputProtection required_protection = 3;</code>
				 * 
				 * @return Whether the requiredProtection field is set.
				 */
				boolean hasRequiredProtection();

				/**
				 * <pre>
				 * Optional output protection requirements for this range. If not
				 * specified, the OutputProtection in the KeyContainer applies.
				 * </pre>
				 *
				 * <code>optional .License.KeyContainer.OutputProtection required_protection = 3;</code>
				 * 
				 * @return The requiredProtection.
				 */
				WvProto2.License.KeyContainer.OutputProtection getRequiredProtection();

				/**
				 * <pre>
				 * Optional output protection requirements for this range. If not
				 * specified, the OutputProtection in the KeyContainer applies.
				 * </pre>
				 *
				 * <code>optional .License.KeyContainer.OutputProtection required_protection = 3;</code>
				 */
				WvProto2.License.KeyContainer.OutputProtectionOrBuilder getRequiredProtectionOrBuilder();
			}

			/**
			 * Protobuf type {@code License.KeyContainer.VideoResolutionConstraint}
			 */
			public static final class VideoResolutionConstraint extends GeneratedMessageV3 implements
					// @@protoc_insertion_point(message_implements:License.KeyContainer.VideoResolutionConstraint)
					VideoResolutionConstraintOrBuilder {
				private static final long serialVersionUID = 0L;

				// Use VideoResolutionConstraint.newBuilder() to construct.
				private VideoResolutionConstraint(GeneratedMessageV3.Builder<?> builder) {
					super(builder);
				}

				private VideoResolutionConstraint() {
				}

				@java.lang.Override

				protected java.lang.Object newInstance(UnusedPrivateParameter unused) {
					return new VideoResolutionConstraint();
				}

				public static final Descriptors.Descriptor getDescriptor() {
					return WvProto2.internal_static_License_KeyContainer_VideoResolutionConstraint_descriptor;
				}

				@java.lang.Override
				protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
					return WvProto2.internal_static_License_KeyContainer_VideoResolutionConstraint_fieldAccessorTable
							.ensureFieldAccessorsInitialized(
									WvProto2.License.KeyContainer.VideoResolutionConstraint.class,
									WvProto2.License.KeyContainer.VideoResolutionConstraint.Builder.class);
				}

				private int bitField0_;
				public static final int MIN_RESOLUTION_PIXELS_FIELD_NUMBER = 1;
				private int minResolutionPixels_ = 0;

				/**
				 * <pre>
				 * Minimum and maximum video resolutions in the range (height x width).
				 * </pre>
				 *
				 * <code>optional uint32 min_resolution_pixels = 1;</code>
				 * 
				 * @return Whether the minResolutionPixels field is set.
				 */
				@java.lang.Override
				public boolean hasMinResolutionPixels() {
					return ((bitField0_ & 0x00000001) != 0);
				}

				/**
				 * <pre>
				 * Minimum and maximum video resolutions in the range (height x width).
				 * </pre>
				 *
				 * <code>optional uint32 min_resolution_pixels = 1;</code>
				 * 
				 * @return The minResolutionPixels.
				 */
				@java.lang.Override
				public int getMinResolutionPixels() {
					return minResolutionPixels_;
				}

				public static final int MAX_RESOLUTION_PIXELS_FIELD_NUMBER = 2;
				private int maxResolutionPixels_ = 0;

				/**
				 * <code>optional uint32 max_resolution_pixels = 2;</code>
				 * 
				 * @return Whether the maxResolutionPixels field is set.
				 */
				@java.lang.Override
				public boolean hasMaxResolutionPixels() {
					return ((bitField0_ & 0x00000002) != 0);
				}

				/**
				 * <code>optional uint32 max_resolution_pixels = 2;</code>
				 * 
				 * @return The maxResolutionPixels.
				 */
				@java.lang.Override
				public int getMaxResolutionPixels() {
					return maxResolutionPixels_;
				}

				public static final int REQUIRED_PROTECTION_FIELD_NUMBER = 3;
				private WvProto2.License.KeyContainer.OutputProtection requiredProtection_;

				/**
				 * <pre>
				 * Optional output protection requirements for this range. If not
				 * specified, the OutputProtection in the KeyContainer applies.
				 * </pre>
				 *
				 * <code>optional .License.KeyContainer.OutputProtection required_protection = 3;</code>
				 * 
				 * @return Whether the requiredProtection field is set.
				 */
				@java.lang.Override
				public boolean hasRequiredProtection() {
					return ((bitField0_ & 0x00000004) != 0);
				}

				/**
				 * <pre>
				 * Optional output protection requirements for this range. If not
				 * specified, the OutputProtection in the KeyContainer applies.
				 * </pre>
				 *
				 * <code>optional .License.KeyContainer.OutputProtection required_protection = 3;</code>
				 * 
				 * @return The requiredProtection.
				 */
				@java.lang.Override
				public WvProto2.License.KeyContainer.OutputProtection getRequiredProtection() {
					return requiredProtection_ == null
							? WvProto2.License.KeyContainer.OutputProtection
									.getDefaultInstance()
							: requiredProtection_;
				}

				/**
				 * <pre>
				 * Optional output protection requirements for this range. If not
				 * specified, the OutputProtection in the KeyContainer applies.
				 * </pre>
				 *
				 * <code>optional .License.KeyContainer.OutputProtection required_protection = 3;</code>
				 */
				@java.lang.Override
				public WvProto2.License.KeyContainer.OutputProtectionOrBuilder getRequiredProtectionOrBuilder() {
					return requiredProtection_ == null
							? WvProto2.License.KeyContainer.OutputProtection
									.getDefaultInstance()
							: requiredProtection_;
				}

				private byte memoizedIsInitialized = -1;

				@java.lang.Override
				public final boolean isInitialized() {
					byte isInitialized = memoizedIsInitialized;
					if (isInitialized == 1)
						return true;
					if (isInitialized == 0)
						return false;

					memoizedIsInitialized = 1;
					return true;
				}

				@java.lang.Override
				public void writeTo(CodedOutputStream output) throws java.io.IOException {
					if (((bitField0_ & 0x00000001) != 0)) {
						output.writeUInt32(1, minResolutionPixels_);
					}
					if (((bitField0_ & 0x00000002) != 0)) {
						output.writeUInt32(2, maxResolutionPixels_);
					}
					if (((bitField0_ & 0x00000004) != 0)) {
						output.writeMessage(3, getRequiredProtection());
					}
					getUnknownFields().writeTo(output);
				}

				@java.lang.Override
				public int getSerializedSize() {
					int size = memoizedSize;
					if (size != -1)
						return size;

					size = 0;
					if (((bitField0_ & 0x00000001) != 0)) {
						size += CodedOutputStream.computeUInt32Size(1, minResolutionPixels_);
					}
					if (((bitField0_ & 0x00000002) != 0)) {
						size += CodedOutputStream.computeUInt32Size(2, maxResolutionPixels_);
					}
					if (((bitField0_ & 0x00000004) != 0)) {
						size += CodedOutputStream.computeMessageSize(3, getRequiredProtection());
					}
					size += getUnknownFields().getSerializedSize();
					memoizedSize = size;
					return size;
				}

				@java.lang.Override
				public boolean equals(final java.lang.Object obj) {
					if (obj == this) {
						return true;
					}
					if (!(obj instanceof WvProto2.License.KeyContainer.VideoResolutionConstraint)) {
						return super.equals(obj);
					}
					WvProto2.License.KeyContainer.VideoResolutionConstraint other = (WvProto2.License.KeyContainer.VideoResolutionConstraint) obj;

					if (hasMinResolutionPixels() != other.hasMinResolutionPixels())
						return false;
					if (hasMinResolutionPixels()) {
						if (getMinResolutionPixels() != other.getMinResolutionPixels())
							return false;
					}
					if (hasMaxResolutionPixels() != other.hasMaxResolutionPixels())
						return false;
					if (hasMaxResolutionPixels()) {
						if (getMaxResolutionPixels() != other.getMaxResolutionPixels())
							return false;
					}
					if (hasRequiredProtection() != other.hasRequiredProtection())
						return false;
					if (hasRequiredProtection()) {
						if (!getRequiredProtection().equals(other.getRequiredProtection()))
							return false;
					}
					if (!getUnknownFields().equals(other.getUnknownFields()))
						return false;
					return true;
				}

				@SuppressWarnings("unchecked")
				@java.lang.Override
				public int hashCode() {
					if (memoizedHashCode != 0) {
						return memoizedHashCode;
					}
					int hash = 41;
					hash = (19 * hash) + getDescriptor().hashCode();
					if (hasMinResolutionPixels()) {
						hash = (37 * hash) + MIN_RESOLUTION_PIXELS_FIELD_NUMBER;
						hash = (53 * hash) + getMinResolutionPixels();
					}
					if (hasMaxResolutionPixels()) {
						hash = (37 * hash) + MAX_RESOLUTION_PIXELS_FIELD_NUMBER;
						hash = (53 * hash) + getMaxResolutionPixels();
					}
					if (hasRequiredProtection()) {
						hash = (37 * hash) + REQUIRED_PROTECTION_FIELD_NUMBER;
						hash = (53 * hash) + getRequiredProtection().hashCode();
					}
					hash = (29 * hash) + getUnknownFields().hashCode();
					memoizedHashCode = hash;
					return hash;
				}

				public static WvProto2.License.KeyContainer.VideoResolutionConstraint parseFrom(
						java.nio.ByteBuffer data) throws InvalidProtocolBufferException {
					return PARSER.parseFrom(data);
				}

				public static WvProto2.License.KeyContainer.VideoResolutionConstraint parseFrom(
						java.nio.ByteBuffer data, ExtensionRegistryLite extensionRegistry)
						throws InvalidProtocolBufferException {
					return PARSER.parseFrom(data, extensionRegistry);
				}

				public static WvProto2.License.KeyContainer.VideoResolutionConstraint parseFrom(
						ByteString data) throws InvalidProtocolBufferException {
					return PARSER.parseFrom(data);
				}

				public static WvProto2.License.KeyContainer.VideoResolutionConstraint parseFrom(
						ByteString data, ExtensionRegistryLite extensionRegistry)
						throws InvalidProtocolBufferException {
					return PARSER.parseFrom(data, extensionRegistry);
				}

				public static WvProto2.License.KeyContainer.VideoResolutionConstraint parseFrom(
						byte[] data) throws InvalidProtocolBufferException {
					return PARSER.parseFrom(data);
				}

				public static WvProto2.License.KeyContainer.VideoResolutionConstraint parseFrom(
						byte[] data, ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
					return PARSER.parseFrom(data, extensionRegistry);
				}

				public static WvProto2.License.KeyContainer.VideoResolutionConstraint parseFrom(
						java.io.InputStream input) throws java.io.IOException {
					return GeneratedMessageV3.parseWithIOException(PARSER, input);
				}

				public static WvProto2.License.KeyContainer.VideoResolutionConstraint parseFrom(
						java.io.InputStream input, ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
					return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
				}

				public static WvProto2.License.KeyContainer.VideoResolutionConstraint parseDelimitedFrom(
						java.io.InputStream input) throws java.io.IOException {
					return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
				}

				public static WvProto2.License.KeyContainer.VideoResolutionConstraint parseDelimitedFrom(
						java.io.InputStream input, ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
					return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input, extensionRegistry);
				}

				public static WvProto2.License.KeyContainer.VideoResolutionConstraint parseFrom(
						CodedInputStream input) throws java.io.IOException {
					return GeneratedMessageV3.parseWithIOException(PARSER, input);
				}

				public static WvProto2.License.KeyContainer.VideoResolutionConstraint parseFrom(
						CodedInputStream input, ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
					return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
				}

				@java.lang.Override
				public Builder newBuilderForType() {
					return newBuilder();
				}

				public static Builder newBuilder() {
					return DEFAULT_INSTANCE.toBuilder();
				}

				public static Builder newBuilder(
						WvProto2.License.KeyContainer.VideoResolutionConstraint prototype) {
					return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
				}

				@java.lang.Override
				public Builder toBuilder() {
					return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
				}

				@java.lang.Override
				protected Builder newBuilderForType(GeneratedMessageV3.BuilderParent parent) {
					Builder builder = new Builder(parent);
					return builder;
				}

				/**
				 * Protobuf type {@code License.KeyContainer.VideoResolutionConstraint}
				 */
				public static final class Builder extends GeneratedMessageV3.Builder<Builder> implements
						// @@protoc_insertion_point(builder_implements:License.KeyContainer.VideoResolutionConstraint)
						WvProto2.License.KeyContainer.VideoResolutionConstraintOrBuilder {
					public static final Descriptors.Descriptor getDescriptor() {
						return WvProto2.internal_static_License_KeyContainer_VideoResolutionConstraint_descriptor;
					}

					@java.lang.Override
					protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
						return WvProto2.internal_static_License_KeyContainer_VideoResolutionConstraint_fieldAccessorTable
								.ensureFieldAccessorsInitialized(
										WvProto2.License.KeyContainer.VideoResolutionConstraint.class,
										WvProto2.License.KeyContainer.VideoResolutionConstraint.Builder.class);
					}

					// Construct using
					// WvProto2.License.KeyContainer.VideoResolutionConstraint.newBuilder()
					private Builder() {
						maybeForceBuilderInitialization();
					}

					private Builder(GeneratedMessageV3.BuilderParent parent) {
						super(parent);
						maybeForceBuilderInitialization();
					}

					private void maybeForceBuilderInitialization() {
						if (GeneratedMessageV3.alwaysUseFieldBuilders) {
							getRequiredProtectionFieldBuilder();
						}
					}

					@java.lang.Override
					public Builder clear() {
						super.clear();
						bitField0_ = 0;
						minResolutionPixels_ = 0;
						maxResolutionPixels_ = 0;
						requiredProtection_ = null;
						if (requiredProtectionBuilder_ != null) {
							requiredProtectionBuilder_.dispose();
							requiredProtectionBuilder_ = null;
						}
						return this;
					}

					@java.lang.Override
					public Descriptors.Descriptor getDescriptorForType() {
						return WvProto2.internal_static_License_KeyContainer_VideoResolutionConstraint_descriptor;
					}

					@java.lang.Override
					public WvProto2.License.KeyContainer.VideoResolutionConstraint getDefaultInstanceForType() {
						return WvProto2.License.KeyContainer.VideoResolutionConstraint
								.getDefaultInstance();
					}

					@java.lang.Override
					public WvProto2.License.KeyContainer.VideoResolutionConstraint build() {
						WvProto2.License.KeyContainer.VideoResolutionConstraint result = buildPartial();
						if (!result.isInitialized()) {
							throw newUninitializedMessageException(result);
						}
						return result;
					}

					@java.lang.Override
					public WvProto2.License.KeyContainer.VideoResolutionConstraint buildPartial() {
						WvProto2.License.KeyContainer.VideoResolutionConstraint result = new WvProto2.License.KeyContainer.VideoResolutionConstraint(
								this);
						if (bitField0_ != 0) {
							buildPartial0(result);
						}
						onBuilt();
						return result;
					}

					private void buildPartial0(
							WvProto2.License.KeyContainer.VideoResolutionConstraint result) {
						int from_bitField0_ = bitField0_;
						int to_bitField0_ = 0;
						if (((from_bitField0_ & 0x00000001) != 0)) {
							result.minResolutionPixels_ = minResolutionPixels_;
							to_bitField0_ |= 0x00000001;
						}
						if (((from_bitField0_ & 0x00000002) != 0)) {
							result.maxResolutionPixels_ = maxResolutionPixels_;
							to_bitField0_ |= 0x00000002;
						}
						if (((from_bitField0_ & 0x00000004) != 0)) {
							result.requiredProtection_ = requiredProtectionBuilder_ == null ? requiredProtection_
									: requiredProtectionBuilder_.build();
							to_bitField0_ |= 0x00000004;
						}
						result.bitField0_ |= to_bitField0_;
					}

					@java.lang.Override
					public Builder mergeFrom(Message other) {
						if (other instanceof WvProto2.License.KeyContainer.VideoResolutionConstraint) {
							return mergeFrom(
									(WvProto2.License.KeyContainer.VideoResolutionConstraint) other);
						}
						super.mergeFrom(other);
						return this;
					}

					public Builder mergeFrom(
							WvProto2.License.KeyContainer.VideoResolutionConstraint other) {
						if (other == WvProto2.License.KeyContainer.VideoResolutionConstraint
								.getDefaultInstance())
							return this;
						if (other.hasMinResolutionPixels()) {
							setMinResolutionPixels(other.getMinResolutionPixels());
						}
						if (other.hasMaxResolutionPixels()) {
							setMaxResolutionPixels(other.getMaxResolutionPixels());
						}
						if (other.hasRequiredProtection()) {
							mergeRequiredProtection(other.getRequiredProtection());
						}
						this.mergeUnknownFields(other.getUnknownFields());
						onChanged();
						return this;
					}

					@java.lang.Override
					public final boolean isInitialized() {
						return true;
					}

					@java.lang.Override
					public Builder mergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
							throws java.io.IOException {
						if (extensionRegistry == null) {
							throw new java.lang.NullPointerException();
						}
						try {
							boolean done = false;
							while (!done) {
								int tag = input.readTag();
								switch (tag) {
								case 0:
									done = true;
									break;
								case 8: {
									minResolutionPixels_ = input.readUInt32();
									bitField0_ |= 0x00000001;
									break;
								} // case 8
								case 16: {
									maxResolutionPixels_ = input.readUInt32();
									bitField0_ |= 0x00000002;
									break;
								} // case 16
								case 26: {
									input.readMessage(getRequiredProtectionFieldBuilder().getBuilder(),
											extensionRegistry);
									bitField0_ |= 0x00000004;
									break;
								} // case 26
								default: {
									if (!super.parseUnknownField(input, extensionRegistry, tag)) {
										done = true; // was an endgroup tag
									}
									break;
								} // default:
								} // switch (tag)
							} // while (!done)
						} catch (InvalidProtocolBufferException e) {
							throw e.unwrapIOException();
						}
						finally {
							onChanged();
						} // finally
						return this;
					}

					private int bitField0_;

					private int minResolutionPixels_;

					/**
					 * <pre>
					 * Minimum and maximum video resolutions in the range (height x width).
					 * </pre>
					 *
					 * <code>optional uint32 min_resolution_pixels = 1;</code>
					 * 
					 * @return Whether the minResolutionPixels field is set.
					 */
					@java.lang.Override
					public boolean hasMinResolutionPixels() {
						return ((bitField0_ & 0x00000001) != 0);
					}

					/**
					 * <pre>
					 * Minimum and maximum video resolutions in the range (height x width).
					 * </pre>
					 *
					 * <code>optional uint32 min_resolution_pixels = 1;</code>
					 * 
					 * @return The minResolutionPixels.
					 */
					@java.lang.Override
					public int getMinResolutionPixels() {
						return minResolutionPixels_;
					}

					/**
					 * <pre>
					 * Minimum and maximum video resolutions in the range (height x width).
					 * </pre>
					 *
					 * <code>optional uint32 min_resolution_pixels = 1;</code>
					 * 
					 * @param value The minResolutionPixels to set.
					 * @return This builder for chaining.
					 */
					public Builder setMinResolutionPixels(int value) {

						minResolutionPixels_ = value;
						bitField0_ |= 0x00000001;
						onChanged();
						return this;
					}

					/**
					 * <pre>
					 * Minimum and maximum video resolutions in the range (height x width).
					 * </pre>
					 *
					 * <code>optional uint32 min_resolution_pixels = 1;</code>
					 * 
					 * @return This builder for chaining.
					 */
					public Builder clearMinResolutionPixels() {
						bitField0_ = (bitField0_ & ~0x00000001);
						minResolutionPixels_ = 0;
						onChanged();
						return this;
					}

					private int maxResolutionPixels_;

					/**
					 * <code>optional uint32 max_resolution_pixels = 2;</code>
					 * 
					 * @return Whether the maxResolutionPixels field is set.
					 */
					@java.lang.Override
					public boolean hasMaxResolutionPixels() {
						return ((bitField0_ & 0x00000002) != 0);
					}

					/**
					 * <code>optional uint32 max_resolution_pixels = 2;</code>
					 * 
					 * @return The maxResolutionPixels.
					 */
					@java.lang.Override
					public int getMaxResolutionPixels() {
						return maxResolutionPixels_;
					}

					/**
					 * <code>optional uint32 max_resolution_pixels = 2;</code>
					 * 
					 * @param value The maxResolutionPixels to set.
					 * @return This builder for chaining.
					 */
					public Builder setMaxResolutionPixels(int value) {

						maxResolutionPixels_ = value;
						bitField0_ |= 0x00000002;
						onChanged();
						return this;
					}

					/**
					 * <code>optional uint32 max_resolution_pixels = 2;</code>
					 * 
					 * @return This builder for chaining.
					 */
					public Builder clearMaxResolutionPixels() {
						bitField0_ = (bitField0_ & ~0x00000002);
						maxResolutionPixels_ = 0;
						onChanged();
						return this;
					}

					private WvProto2.License.KeyContainer.OutputProtection requiredProtection_;
					private SingleFieldBuilderV3<WvProto2.License.KeyContainer.OutputProtection, WvProto2.License.KeyContainer.OutputProtection.Builder, WvProto2.License.KeyContainer.OutputProtectionOrBuilder> requiredProtectionBuilder_;

					/**
					 * <pre>
					 * Optional output protection requirements for this range. If not
					 * specified, the OutputProtection in the KeyContainer applies.
					 * </pre>
					 *
					 * <code>optional .License.KeyContainer.OutputProtection required_protection = 3;</code>
					 * 
					 * @return Whether the requiredProtection field is set.
					 */
					@Override
					public boolean hasRequiredProtection() {
						return ((bitField0_ & 0x00000004) != 0);
					}

					/**
					 * <pre>
					 * Optional output protection requirements for this range. If not
					 * specified, the OutputProtection in the KeyContainer applies.
					 * </pre>
					 *
					 * <code>optional .License.KeyContainer.OutputProtection required_protection = 3;</code>
					 * 
					 * @return The requiredProtection.
					 */
					@Override
					public WvProto2.License.KeyContainer.OutputProtection getRequiredProtection() {
						if (requiredProtectionBuilder_ == null) {
							return requiredProtection_ == null
									? WvProto2.License.KeyContainer.OutputProtection
											.getDefaultInstance()
									: requiredProtection_;
						}
						return requiredProtectionBuilder_.getMessage();
					}

					/**
					 * <pre>
					 * Optional output protection requirements for this range. If not
					 * specified, the OutputProtection in the KeyContainer applies.
					 * </pre>
					 *
					 * <code>optional .License.KeyContainer.OutputProtection required_protection = 3;</code>
					 */
					public Builder setRequiredProtection(
							WvProto2.License.KeyContainer.OutputProtection value) {
						if (requiredProtectionBuilder_ == null) {
							if (value == null) {
								throw new NullPointerException();
							}
							requiredProtection_ = value;
						} else {
							requiredProtectionBuilder_.setMessage(value);
						}
						bitField0_ |= 0x00000004;
						onChanged();
						return this;
					}

					/**
					 * <pre>
					 * Optional output protection requirements for this range. If not
					 * specified, the OutputProtection in the KeyContainer applies.
					 * </pre>
					 *
					 * <code>optional .License.KeyContainer.OutputProtection required_protection = 3;</code>
					 */
					public Builder setRequiredProtection(
							WvProto2.License.KeyContainer.OutputProtection.Builder builderForValue) {
						if (requiredProtectionBuilder_ == null) {
							requiredProtection_ = builderForValue.build();
						} else {
							requiredProtectionBuilder_.setMessage(builderForValue.build());
						}
						bitField0_ |= 0x00000004;
						onChanged();
						return this;
					}

					/**
					 * <pre>
					 * Optional output protection requirements for this range. If not
					 * specified, the OutputProtection in the KeyContainer applies.
					 * </pre>
					 *
					 * <code>optional .License.KeyContainer.OutputProtection required_protection = 3;</code>
					 */
					public Builder mergeRequiredProtection(
							WvProto2.License.KeyContainer.OutputProtection value) {
						if (requiredProtectionBuilder_ == null) {
							if (((bitField0_ & 0x00000004) != 0) && requiredProtection_ != null
									&& requiredProtection_ != WvProto2.License.KeyContainer.OutputProtection
											.getDefaultInstance()) {
								getRequiredProtectionBuilder().mergeFrom(value);
							} else {
								requiredProtection_ = value;
							}
						} else {
							requiredProtectionBuilder_.mergeFrom(value);
						}
						bitField0_ |= 0x00000004;
						onChanged();
						return this;
					}

					/**
					 * <pre>
					 * Optional output protection requirements for this range. If not
					 * specified, the OutputProtection in the KeyContainer applies.
					 * </pre>
					 *
					 * <code>optional .License.KeyContainer.OutputProtection required_protection = 3;</code>
					 */
					public Builder clearRequiredProtection() {
						bitField0_ = (bitField0_ & ~0x00000004);
						requiredProtection_ = null;
						if (requiredProtectionBuilder_ != null) {
							requiredProtectionBuilder_.dispose();
							requiredProtectionBuilder_ = null;
						}
						onChanged();
						return this;
					}

					/**
					 * <pre>
					 * Optional output protection requirements for this range. If not
					 * specified, the OutputProtection in the KeyContainer applies.
					 * </pre>
					 *
					 * <code>optional .License.KeyContainer.OutputProtection required_protection = 3;</code>
					 */
					public WvProto2.License.KeyContainer.OutputProtection.Builder getRequiredProtectionBuilder() {
						bitField0_ |= 0x00000004;
						onChanged();
						return getRequiredProtectionFieldBuilder().getBuilder();
					}

					/**
					 * <pre>
					 * Optional output protection requirements for this range. If not
					 * specified, the OutputProtection in the KeyContainer applies.
					 * </pre>
					 *
					 * <code>optional .License.KeyContainer.OutputProtection required_protection = 3;</code>
					 */
					@Override
					public WvProto2.License.KeyContainer.OutputProtectionOrBuilder getRequiredProtectionOrBuilder() {
						if (requiredProtectionBuilder_ != null) {
							return requiredProtectionBuilder_.getMessageOrBuilder();
						}
						return requiredProtection_ == null
								? WvProto2.License.KeyContainer.OutputProtection
										.getDefaultInstance()
								: requiredProtection_;
					}

					/**
					 * <pre>
					 * Optional output protection requirements for this range. If not
					 * specified, the OutputProtection in the KeyContainer applies.
					 * </pre>
					 *
					 * <code>optional .License.KeyContainer.OutputProtection required_protection = 3;</code>
					 */
					private SingleFieldBuilderV3<WvProto2.License.KeyContainer.OutputProtection, WvProto2.License.KeyContainer.OutputProtection.Builder, WvProto2.License.KeyContainer.OutputProtectionOrBuilder> getRequiredProtectionFieldBuilder() {
						if (requiredProtectionBuilder_ == null) {
							requiredProtectionBuilder_ = new SingleFieldBuilderV3<>(getRequiredProtection(),
									getParentForChildren(), isClean());
							requiredProtection_ = null;
						}
						return requiredProtectionBuilder_;
					}

					@java.lang.Override
					public final Builder setUnknownFields(final UnknownFieldSet unknownFields) {
						return super.setUnknownFields(unknownFields);
					}

					@java.lang.Override
					public final Builder mergeUnknownFields(final UnknownFieldSet unknownFields) {
						return super.mergeUnknownFields(unknownFields);
					}

					// @@protoc_insertion_point(builder_scope:License.KeyContainer.VideoResolutionConstraint)
				}

				// @@protoc_insertion_point(class_scope:License.KeyContainer.VideoResolutionConstraint)
				private static final WvProto2.License.KeyContainer.VideoResolutionConstraint DEFAULT_INSTANCE;
				static {
					DEFAULT_INSTANCE = new WvProto2.License.KeyContainer.VideoResolutionConstraint();
				}

				public static WvProto2.License.KeyContainer.VideoResolutionConstraint getDefaultInstance() {
					return DEFAULT_INSTANCE;
				}

				@java.lang.Deprecated public static final Parser<VideoResolutionConstraint> PARSER = new AbstractParser<>() {
					@java.lang.Override
					public VideoResolutionConstraint parsePartialFrom(CodedInputStream input,
							ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
						Builder builder = newBuilder();
						try {
							builder.mergeFrom(input, extensionRegistry);
						} catch (InvalidProtocolBufferException e) {
							throw e.setUnfinishedMessage(builder.buildPartial());
						} catch (UninitializedMessageException e) {
							throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
						} catch (java.io.IOException e) {
							throw new InvalidProtocolBufferException(e).setUnfinishedMessage(builder.buildPartial());
						}
						return builder.buildPartial();
					}
				};

				public static Parser<VideoResolutionConstraint> parser() {
					return PARSER;
				}

				@java.lang.Override
				public Parser<VideoResolutionConstraint> getParserForType() {
					return PARSER;
				}

				@java.lang.Override
				public WvProto2.License.KeyContainer.VideoResolutionConstraint getDefaultInstanceForType() {
					return DEFAULT_INSTANCE;
				}

			}

			public interface OperatorSessionKeyPermissionsOrBuilder extends
					// @@protoc_insertion_point(interface_extends:License.KeyContainer.OperatorSessionKeyPermissions)
					MessageOrBuilder {

				/**
				 * <pre>
				 * Permissions/key usage flags for operator service keys
				 * (type = OPERATOR_SESSION).
				 * </pre>
				 *
				 * <code>optional bool allow_encrypt = 1 [default = false];</code>
				 * 
				 * @return Whether the allowEncrypt field is set.
				 */
				boolean hasAllowEncrypt();

				/**
				 * <pre>
				 * Permissions/key usage flags for operator service keys
				 * (type = OPERATOR_SESSION).
				 * </pre>
				 *
				 * <code>optional bool allow_encrypt = 1 [default = false];</code>
				 * 
				 * @return The allowEncrypt.
				 */
				boolean getAllowEncrypt();

				/**
				 * <code>optional bool allow_decrypt = 2 [default = false];</code>
				 * 
				 * @return Whether the allowDecrypt field is set.
				 */
				boolean hasAllowDecrypt();

				/**
				 * <code>optional bool allow_decrypt = 2 [default = false];</code>
				 * 
				 * @return The allowDecrypt.
				 */
				boolean getAllowDecrypt();

				/**
				 * <code>optional bool allow_sign = 3 [default = false];</code>
				 * 
				 * @return Whether the allowSign field is set.
				 */
				boolean hasAllowSign();

				/**
				 * <code>optional bool allow_sign = 3 [default = false];</code>
				 * 
				 * @return The allowSign.
				 */
				boolean getAllowSign();

				/**
				 * <code>optional bool allow_signature_verify = 4 [default = false];</code>
				 * 
				 * @return Whether the allowSignatureVerify field is set.
				 */
				boolean hasAllowSignatureVerify();

				/**
				 * <code>optional bool allow_signature_verify = 4 [default = false];</code>
				 * 
				 * @return The allowSignatureVerify.
				 */
				boolean getAllowSignatureVerify();
			}

			/**
			 * Protobuf type {@code License.KeyContainer.OperatorSessionKeyPermissions}
			 */
			public static final class OperatorSessionKeyPermissions extends GeneratedMessageV3 implements
					// @@protoc_insertion_point(message_implements:License.KeyContainer.OperatorSessionKeyPermissions)
					OperatorSessionKeyPermissionsOrBuilder {
				private static final long serialVersionUID = 0L;

				// Use OperatorSessionKeyPermissions.newBuilder() to construct.
				private OperatorSessionKeyPermissions(GeneratedMessageV3.Builder<?> builder) {
					super(builder);
				}

				private OperatorSessionKeyPermissions() {
				}

				@java.lang.Override

				protected java.lang.Object newInstance(UnusedPrivateParameter unused) {
					return new OperatorSessionKeyPermissions();
				}

				public static final Descriptors.Descriptor getDescriptor() {
					return WvProto2.internal_static_License_KeyContainer_OperatorSessionKeyPermissions_descriptor;
				}

				@java.lang.Override
				protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
					return WvProto2.internal_static_License_KeyContainer_OperatorSessionKeyPermissions_fieldAccessorTable
							.ensureFieldAccessorsInitialized(
									WvProto2.License.KeyContainer.OperatorSessionKeyPermissions.class,
									WvProto2.License.KeyContainer.OperatorSessionKeyPermissions.Builder.class);
				}

				private int bitField0_;
				public static final int ALLOW_ENCRYPT_FIELD_NUMBER = 1;
				private boolean allowEncrypt_ = false;

				/**
				 * <pre>
				 * Permissions/key usage flags for operator service keys
				 * (type = OPERATOR_SESSION).
				 * </pre>
				 *
				 * <code>optional bool allow_encrypt = 1 [default = false];</code>
				 * 
				 * @return Whether the allowEncrypt field is set.
				 */
				@java.lang.Override
				public boolean hasAllowEncrypt() {
					return ((bitField0_ & 0x00000001) != 0);
				}

				/**
				 * <pre>
				 * Permissions/key usage flags for operator service keys
				 * (type = OPERATOR_SESSION).
				 * </pre>
				 *
				 * <code>optional bool allow_encrypt = 1 [default = false];</code>
				 * 
				 * @return The allowEncrypt.
				 */
				@java.lang.Override
				public boolean getAllowEncrypt() {
					return allowEncrypt_;
				}

				public static final int ALLOW_DECRYPT_FIELD_NUMBER = 2;
				private boolean allowDecrypt_ = false;

				/**
				 * <code>optional bool allow_decrypt = 2 [default = false];</code>
				 * 
				 * @return Whether the allowDecrypt field is set.
				 */
				@java.lang.Override
				public boolean hasAllowDecrypt() {
					return ((bitField0_ & 0x00000002) != 0);
				}

				/**
				 * <code>optional bool allow_decrypt = 2 [default = false];</code>
				 * 
				 * @return The allowDecrypt.
				 */
				@java.lang.Override
				public boolean getAllowDecrypt() {
					return allowDecrypt_;
				}

				public static final int ALLOW_SIGN_FIELD_NUMBER = 3;
				private boolean allowSign_ = false;

				/**
				 * <code>optional bool allow_sign = 3 [default = false];</code>
				 * 
				 * @return Whether the allowSign field is set.
				 */
				@java.lang.Override
				public boolean hasAllowSign() {
					return ((bitField0_ & 0x00000004) != 0);
				}

				/**
				 * <code>optional bool allow_sign = 3 [default = false];</code>
				 * 
				 * @return The allowSign.
				 */
				@java.lang.Override
				public boolean getAllowSign() {
					return allowSign_;
				}

				public static final int ALLOW_SIGNATURE_VERIFY_FIELD_NUMBER = 4;
				private boolean allowSignatureVerify_ = false;

				/**
				 * <code>optional bool allow_signature_verify = 4 [default = false];</code>
				 * 
				 * @return Whether the allowSignatureVerify field is set.
				 */
				@java.lang.Override
				public boolean hasAllowSignatureVerify() {
					return ((bitField0_ & 0x00000008) != 0);
				}

				/**
				 * <code>optional bool allow_signature_verify = 4 [default = false];</code>
				 * 
				 * @return The allowSignatureVerify.
				 */
				@java.lang.Override
				public boolean getAllowSignatureVerify() {
					return allowSignatureVerify_;
				}

				private byte memoizedIsInitialized = -1;

				@java.lang.Override
				public final boolean isInitialized() {
					byte isInitialized = memoizedIsInitialized;
					if (isInitialized == 1)
						return true;
					if (isInitialized == 0)
						return false;

					memoizedIsInitialized = 1;
					return true;
				}

				@java.lang.Override
				public void writeTo(CodedOutputStream output) throws java.io.IOException {
					if (((bitField0_ & 0x00000001) != 0)) {
						output.writeBool(1, allowEncrypt_);
					}
					if (((bitField0_ & 0x00000002) != 0)) {
						output.writeBool(2, allowDecrypt_);
					}
					if (((bitField0_ & 0x00000004) != 0)) {
						output.writeBool(3, allowSign_);
					}
					if (((bitField0_ & 0x00000008) != 0)) {
						output.writeBool(4, allowSignatureVerify_);
					}
					getUnknownFields().writeTo(output);
				}

				@java.lang.Override
				public int getSerializedSize() {
					int size = memoizedSize;
					if (size != -1)
						return size;

					size = 0;
					if (((bitField0_ & 0x00000001) != 0)) {
						size += CodedOutputStream.computeBoolSize(1, allowEncrypt_);
					}
					if (((bitField0_ & 0x00000002) != 0)) {
						size += CodedOutputStream.computeBoolSize(2, allowDecrypt_);
					}
					if (((bitField0_ & 0x00000004) != 0)) {
						size += CodedOutputStream.computeBoolSize(3, allowSign_);
					}
					if (((bitField0_ & 0x00000008) != 0)) {
						size += CodedOutputStream.computeBoolSize(4, allowSignatureVerify_);
					}
					size += getUnknownFields().getSerializedSize();
					memoizedSize = size;
					return size;
				}

				@java.lang.Override
				public boolean equals(final java.lang.Object obj) {
					if (obj == this) {
						return true;
					}
					if (!(obj instanceof WvProto2.License.KeyContainer.OperatorSessionKeyPermissions)) {
						return super.equals(obj);
					}
					WvProto2.License.KeyContainer.OperatorSessionKeyPermissions other = (WvProto2.License.KeyContainer.OperatorSessionKeyPermissions) obj;

					if (hasAllowEncrypt() != other.hasAllowEncrypt())
						return false;
					if (hasAllowEncrypt()) {
						if (getAllowEncrypt() != other.getAllowEncrypt())
							return false;
					}
					if (hasAllowDecrypt() != other.hasAllowDecrypt())
						return false;
					if (hasAllowDecrypt()) {
						if (getAllowDecrypt() != other.getAllowDecrypt())
							return false;
					}
					if (hasAllowSign() != other.hasAllowSign())
						return false;
					if (hasAllowSign()) {
						if (getAllowSign() != other.getAllowSign())
							return false;
					}
					if (hasAllowSignatureVerify() != other.hasAllowSignatureVerify())
						return false;
					if (hasAllowSignatureVerify()) {
						if (getAllowSignatureVerify() != other.getAllowSignatureVerify())
							return false;
					}
					if (!getUnknownFields().equals(other.getUnknownFields()))
						return false;
					return true;
				}

				@SuppressWarnings("unchecked")
				@java.lang.Override
				public int hashCode() {
					if (memoizedHashCode != 0) {
						return memoizedHashCode;
					}
					int hash = 41;
					hash = (19 * hash) + getDescriptor().hashCode();
					if (hasAllowEncrypt()) {
						hash = (37 * hash) + ALLOW_ENCRYPT_FIELD_NUMBER;
						hash = (53 * hash) + Internal.hashBoolean(getAllowEncrypt());
					}
					if (hasAllowDecrypt()) {
						hash = (37 * hash) + ALLOW_DECRYPT_FIELD_NUMBER;
						hash = (53 * hash) + Internal.hashBoolean(getAllowDecrypt());
					}
					if (hasAllowSign()) {
						hash = (37 * hash) + ALLOW_SIGN_FIELD_NUMBER;
						hash = (53 * hash) + Internal.hashBoolean(getAllowSign());
					}
					if (hasAllowSignatureVerify()) {
						hash = (37 * hash) + ALLOW_SIGNATURE_VERIFY_FIELD_NUMBER;
						hash = (53 * hash) + Internal.hashBoolean(getAllowSignatureVerify());
					}
					hash = (29 * hash) + getUnknownFields().hashCode();
					memoizedHashCode = hash;
					return hash;
				}

				public static WvProto2.License.KeyContainer.OperatorSessionKeyPermissions parseFrom(
						java.nio.ByteBuffer data) throws InvalidProtocolBufferException {
					return PARSER.parseFrom(data);
				}

				public static WvProto2.License.KeyContainer.OperatorSessionKeyPermissions parseFrom(
						java.nio.ByteBuffer data, ExtensionRegistryLite extensionRegistry)
						throws InvalidProtocolBufferException {
					return PARSER.parseFrom(data, extensionRegistry);
				}

				public static WvProto2.License.KeyContainer.OperatorSessionKeyPermissions parseFrom(
						ByteString data) throws InvalidProtocolBufferException {
					return PARSER.parseFrom(data);
				}

				public static WvProto2.License.KeyContainer.OperatorSessionKeyPermissions parseFrom(
						ByteString data, ExtensionRegistryLite extensionRegistry)
						throws InvalidProtocolBufferException {
					return PARSER.parseFrom(data, extensionRegistry);
				}

				public static WvProto2.License.KeyContainer.OperatorSessionKeyPermissions parseFrom(
						byte[] data) throws InvalidProtocolBufferException {
					return PARSER.parseFrom(data);
				}

				public static WvProto2.License.KeyContainer.OperatorSessionKeyPermissions parseFrom(
						byte[] data, ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
					return PARSER.parseFrom(data, extensionRegistry);
				}

				public static WvProto2.License.KeyContainer.OperatorSessionKeyPermissions parseFrom(
						java.io.InputStream input) throws java.io.IOException {
					return GeneratedMessageV3.parseWithIOException(PARSER, input);
				}

				public static WvProto2.License.KeyContainer.OperatorSessionKeyPermissions parseFrom(
						java.io.InputStream input, ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
					return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
				}

				public static WvProto2.License.KeyContainer.OperatorSessionKeyPermissions parseDelimitedFrom(
						java.io.InputStream input) throws java.io.IOException {
					return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
				}

				public static WvProto2.License.KeyContainer.OperatorSessionKeyPermissions parseDelimitedFrom(
						java.io.InputStream input, ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
					return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input, extensionRegistry);
				}

				public static WvProto2.License.KeyContainer.OperatorSessionKeyPermissions parseFrom(
						CodedInputStream input) throws java.io.IOException {
					return GeneratedMessageV3.parseWithIOException(PARSER, input);
				}

				public static WvProto2.License.KeyContainer.OperatorSessionKeyPermissions parseFrom(
						CodedInputStream input, ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
					return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
				}

				@java.lang.Override
				public Builder newBuilderForType() {
					return newBuilder();
				}

				public static Builder newBuilder() {
					return DEFAULT_INSTANCE.toBuilder();
				}

				public static Builder newBuilder(
						WvProto2.License.KeyContainer.OperatorSessionKeyPermissions prototype) {
					return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
				}

				@java.lang.Override
				public Builder toBuilder() {
					return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
				}

				@java.lang.Override
				protected Builder newBuilderForType(GeneratedMessageV3.BuilderParent parent) {
					Builder builder = new Builder(parent);
					return builder;
				}

				/**
				 * Protobuf type {@code License.KeyContainer.OperatorSessionKeyPermissions}
				 */
				public static final class Builder extends GeneratedMessageV3.Builder<Builder> implements
						// @@protoc_insertion_point(builder_implements:License.KeyContainer.OperatorSessionKeyPermissions)
						WvProto2.License.KeyContainer.OperatorSessionKeyPermissionsOrBuilder {
					public static final Descriptors.Descriptor getDescriptor() {
						return WvProto2.internal_static_License_KeyContainer_OperatorSessionKeyPermissions_descriptor;
					}

					@java.lang.Override
					protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
						return WvProto2.internal_static_License_KeyContainer_OperatorSessionKeyPermissions_fieldAccessorTable
								.ensureFieldAccessorsInitialized(
										WvProto2.License.KeyContainer.OperatorSessionKeyPermissions.class,
										WvProto2.License.KeyContainer.OperatorSessionKeyPermissions.Builder.class);
					}

					// Construct using
					// WvProto2.License.KeyContainer.OperatorSessionKeyPermissions.newBuilder()
					private Builder() {

					}

					private Builder(GeneratedMessageV3.BuilderParent parent) {
						super(parent);

					}

					@java.lang.Override
					public Builder clear() {
						super.clear();
						bitField0_ = 0;
						allowEncrypt_ = false;
						allowDecrypt_ = false;
						allowSign_ = false;
						allowSignatureVerify_ = false;
						return this;
					}

					@java.lang.Override
					public Descriptors.Descriptor getDescriptorForType() {
						return WvProto2.internal_static_License_KeyContainer_OperatorSessionKeyPermissions_descriptor;
					}

					@java.lang.Override
					public WvProto2.License.KeyContainer.OperatorSessionKeyPermissions getDefaultInstanceForType() {
						return WvProto2.License.KeyContainer.OperatorSessionKeyPermissions
								.getDefaultInstance();
					}

					@java.lang.Override
					public WvProto2.License.KeyContainer.OperatorSessionKeyPermissions build() {
						WvProto2.License.KeyContainer.OperatorSessionKeyPermissions result = buildPartial();
						if (!result.isInitialized()) {
							throw newUninitializedMessageException(result);
						}
						return result;
					}

					@java.lang.Override
					public WvProto2.License.KeyContainer.OperatorSessionKeyPermissions buildPartial() {
						WvProto2.License.KeyContainer.OperatorSessionKeyPermissions result = new WvProto2.License.KeyContainer.OperatorSessionKeyPermissions(
								this);
						if (bitField0_ != 0) {
							buildPartial0(result);
						}
						onBuilt();
						return result;
					}

					private void buildPartial0(
							WvProto2.License.KeyContainer.OperatorSessionKeyPermissions result) {
						int from_bitField0_ = bitField0_;
						int to_bitField0_ = 0;
						if (((from_bitField0_ & 0x00000001) != 0)) {
							result.allowEncrypt_ = allowEncrypt_;
							to_bitField0_ |= 0x00000001;
						}
						if (((from_bitField0_ & 0x00000002) != 0)) {
							result.allowDecrypt_ = allowDecrypt_;
							to_bitField0_ |= 0x00000002;
						}
						if (((from_bitField0_ & 0x00000004) != 0)) {
							result.allowSign_ = allowSign_;
							to_bitField0_ |= 0x00000004;
						}
						if (((from_bitField0_ & 0x00000008) != 0)) {
							result.allowSignatureVerify_ = allowSignatureVerify_;
							to_bitField0_ |= 0x00000008;
						}
						result.bitField0_ |= to_bitField0_;
					}

					@java.lang.Override
					public Builder mergeFrom(Message other) {
						if (other instanceof WvProto2.License.KeyContainer.OperatorSessionKeyPermissions) {
							return mergeFrom(
									(WvProto2.License.KeyContainer.OperatorSessionKeyPermissions) other);
						}
						super.mergeFrom(other);
						return this;
					}

					public Builder mergeFrom(
							WvProto2.License.KeyContainer.OperatorSessionKeyPermissions other) {
						if (other == WvProto2.License.KeyContainer.OperatorSessionKeyPermissions
								.getDefaultInstance())
							return this;
						if (other.hasAllowEncrypt()) {
							setAllowEncrypt(other.getAllowEncrypt());
						}
						if (other.hasAllowDecrypt()) {
							setAllowDecrypt(other.getAllowDecrypt());
						}
						if (other.hasAllowSign()) {
							setAllowSign(other.getAllowSign());
						}
						if (other.hasAllowSignatureVerify()) {
							setAllowSignatureVerify(other.getAllowSignatureVerify());
						}
						this.mergeUnknownFields(other.getUnknownFields());
						onChanged();
						return this;
					}

					@java.lang.Override
					public final boolean isInitialized() {
						return true;
					}

					@java.lang.Override
					public Builder mergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
							throws java.io.IOException {
						if (extensionRegistry == null) {
							throw new java.lang.NullPointerException();
						}
						try {
							boolean done = false;
							while (!done) {
								int tag = input.readTag();
								switch (tag) {
								case 0:
									done = true;
									break;
								case 8: {
									allowEncrypt_ = input.readBool();
									bitField0_ |= 0x00000001;
									break;
								} // case 8
								case 16: {
									allowDecrypt_ = input.readBool();
									bitField0_ |= 0x00000002;
									break;
								} // case 16
								case 24: {
									allowSign_ = input.readBool();
									bitField0_ |= 0x00000004;
									break;
								} // case 24
								case 32: {
									allowSignatureVerify_ = input.readBool();
									bitField0_ |= 0x00000008;
									break;
								} // case 32
								default: {
									if (!super.parseUnknownField(input, extensionRegistry, tag)) {
										done = true; // was an endgroup tag
									}
									break;
								} // default:
								} // switch (tag)
							} // while (!done)
						} catch (InvalidProtocolBufferException e) {
							throw e.unwrapIOException();
						}
						finally {
							onChanged();
						} // finally
						return this;
					}

					private int bitField0_;

					private boolean allowEncrypt_;

					/**
					 * <pre>
					 * Permissions/key usage flags for operator service keys
					 * (type = OPERATOR_SESSION).
					 * </pre>
					 *
					 * <code>optional bool allow_encrypt = 1 [default = false];</code>
					 * 
					 * @return Whether the allowEncrypt field is set.
					 */
					@java.lang.Override
					public boolean hasAllowEncrypt() {
						return ((bitField0_ & 0x00000001) != 0);
					}

					/**
					 * <pre>
					 * Permissions/key usage flags for operator service keys
					 * (type = OPERATOR_SESSION).
					 * </pre>
					 *
					 * <code>optional bool allow_encrypt = 1 [default = false];</code>
					 * 
					 * @return The allowEncrypt.
					 */
					@java.lang.Override
					public boolean getAllowEncrypt() {
						return allowEncrypt_;
					}

					/**
					 * <pre>
					 * Permissions/key usage flags for operator service keys
					 * (type = OPERATOR_SESSION).
					 * </pre>
					 *
					 * <code>optional bool allow_encrypt = 1 [default = false];</code>
					 * 
					 * @param value The allowEncrypt to set.
					 * @return This builder for chaining.
					 */
					public Builder setAllowEncrypt(boolean value) {

						allowEncrypt_ = value;
						bitField0_ |= 0x00000001;
						onChanged();
						return this;
					}

					/**
					 * <pre>
					 * Permissions/key usage flags for operator service keys
					 * (type = OPERATOR_SESSION).
					 * </pre>
					 *
					 * <code>optional bool allow_encrypt = 1 [default = false];</code>
					 * 
					 * @return This builder for chaining.
					 */
					public Builder clearAllowEncrypt() {
						bitField0_ = (bitField0_ & ~0x00000001);
						allowEncrypt_ = false;
						onChanged();
						return this;
					}

					private boolean allowDecrypt_;

					/**
					 * <code>optional bool allow_decrypt = 2 [default = false];</code>
					 * 
					 * @return Whether the allowDecrypt field is set.
					 */
					@java.lang.Override
					public boolean hasAllowDecrypt() {
						return ((bitField0_ & 0x00000002) != 0);
					}

					/**
					 * <code>optional bool allow_decrypt = 2 [default = false];</code>
					 * 
					 * @return The allowDecrypt.
					 */
					@java.lang.Override
					public boolean getAllowDecrypt() {
						return allowDecrypt_;
					}

					/**
					 * <code>optional bool allow_decrypt = 2 [default = false];</code>
					 * 
					 * @param value The allowDecrypt to set.
					 * @return This builder for chaining.
					 */
					public Builder setAllowDecrypt(boolean value) {

						allowDecrypt_ = value;
						bitField0_ |= 0x00000002;
						onChanged();
						return this;
					}

					/**
					 * <code>optional bool allow_decrypt = 2 [default = false];</code>
					 * 
					 * @return This builder for chaining.
					 */
					public Builder clearAllowDecrypt() {
						bitField0_ = (bitField0_ & ~0x00000002);
						allowDecrypt_ = false;
						onChanged();
						return this;
					}

					private boolean allowSign_;

					/**
					 * <code>optional bool allow_sign = 3 [default = false];</code>
					 * 
					 * @return Whether the allowSign field is set.
					 */
					@java.lang.Override
					public boolean hasAllowSign() {
						return ((bitField0_ & 0x00000004) != 0);
					}

					/**
					 * <code>optional bool allow_sign = 3 [default = false];</code>
					 * 
					 * @return The allowSign.
					 */
					@java.lang.Override
					public boolean getAllowSign() {
						return allowSign_;
					}

					/**
					 * <code>optional bool allow_sign = 3 [default = false];</code>
					 * 
					 * @param value The allowSign to set.
					 * @return This builder for chaining.
					 */
					public Builder setAllowSign(boolean value) {

						allowSign_ = value;
						bitField0_ |= 0x00000004;
						onChanged();
						return this;
					}

					/**
					 * <code>optional bool allow_sign = 3 [default = false];</code>
					 * 
					 * @return This builder for chaining.
					 */
					public Builder clearAllowSign() {
						bitField0_ = (bitField0_ & ~0x00000004);
						allowSign_ = false;
						onChanged();
						return this;
					}

					private boolean allowSignatureVerify_;

					/**
					 * <code>optional bool allow_signature_verify = 4 [default = false];</code>
					 * 
					 * @return Whether the allowSignatureVerify field is set.
					 */
					@java.lang.Override
					public boolean hasAllowSignatureVerify() {
						return ((bitField0_ & 0x00000008) != 0);
					}

					/**
					 * <code>optional bool allow_signature_verify = 4 [default = false];</code>
					 * 
					 * @return The allowSignatureVerify.
					 */
					@java.lang.Override
					public boolean getAllowSignatureVerify() {
						return allowSignatureVerify_;
					}

					/**
					 * <code>optional bool allow_signature_verify = 4 [default = false];</code>
					 * 
					 * @param value The allowSignatureVerify to set.
					 * @return This builder for chaining.
					 */
					public Builder setAllowSignatureVerify(boolean value) {

						allowSignatureVerify_ = value;
						bitField0_ |= 0x00000008;
						onChanged();
						return this;
					}

					/**
					 * <code>optional bool allow_signature_verify = 4 [default = false];</code>
					 * 
					 * @return This builder for chaining.
					 */
					public Builder clearAllowSignatureVerify() {
						bitField0_ = (bitField0_ & ~0x00000008);
						allowSignatureVerify_ = false;
						onChanged();
						return this;
					}

					@java.lang.Override
					public final Builder setUnknownFields(final UnknownFieldSet unknownFields) {
						return super.setUnknownFields(unknownFields);
					}

					@java.lang.Override
					public final Builder mergeUnknownFields(final UnknownFieldSet unknownFields) {
						return super.mergeUnknownFields(unknownFields);
					}

					// @@protoc_insertion_point(builder_scope:License.KeyContainer.OperatorSessionKeyPermissions)
				}

				// @@protoc_insertion_point(class_scope:License.KeyContainer.OperatorSessionKeyPermissions)
				private static final WvProto2.License.KeyContainer.OperatorSessionKeyPermissions DEFAULT_INSTANCE;
				static {
					DEFAULT_INSTANCE = new WvProto2.License.KeyContainer.OperatorSessionKeyPermissions();
				}

				public static WvProto2.License.KeyContainer.OperatorSessionKeyPermissions getDefaultInstance() {
					return DEFAULT_INSTANCE;
				}

				@java.lang.Deprecated public static final Parser<OperatorSessionKeyPermissions> PARSER = new AbstractParser<>() {
					@java.lang.Override
					public OperatorSessionKeyPermissions parsePartialFrom(CodedInputStream input,
							ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
						Builder builder = newBuilder();
						try {
							builder.mergeFrom(input, extensionRegistry);
						} catch (InvalidProtocolBufferException e) {
							throw e.setUnfinishedMessage(builder.buildPartial());
						} catch (UninitializedMessageException e) {
							throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
						} catch (java.io.IOException e) {
							throw new InvalidProtocolBufferException(e).setUnfinishedMessage(builder.buildPartial());
						}
						return builder.buildPartial();
					}
				};

				public static Parser<OperatorSessionKeyPermissions> parser() {
					return PARSER;
				}

				@java.lang.Override
				public Parser<OperatorSessionKeyPermissions> getParserForType() {
					return PARSER;
				}

				@java.lang.Override
				public WvProto2.License.KeyContainer.OperatorSessionKeyPermissions getDefaultInstanceForType() {
					return DEFAULT_INSTANCE;
				}

			}

			private int bitField0_;
			public static final int ID_FIELD_NUMBER = 1;
			private ByteString id_ = ByteString.EMPTY;

			/**
			 * <code>optional bytes id = 1;</code>
			 * 
			 * @return Whether the id field is set.
			 */
			@java.lang.Override
			public boolean hasId() {
				return ((bitField0_ & 0x00000001) != 0);
			}

			/**
			 * <code>optional bytes id = 1;</code>
			 * 
			 * @return The id.
			 */
			@java.lang.Override
			public ByteString getId() {
				return id_;
			}

			public static final int IV_FIELD_NUMBER = 2;
			private ByteString iv_ = ByteString.EMPTY;

			/**
			 * <code>optional bytes iv = 2;</code>
			 * 
			 * @return Whether the iv field is set.
			 */
			@java.lang.Override
			public boolean hasIv() {
				return ((bitField0_ & 0x00000002) != 0);
			}

			/**
			 * <code>optional bytes iv = 2;</code>
			 * 
			 * @return The iv.
			 */
			@java.lang.Override
			public ByteString getIv() {
				return iv_;
			}

			public static final int KEY_FIELD_NUMBER = 3;
			private ByteString key_ = ByteString.EMPTY;

			/**
			 * <code>optional bytes key = 3;</code>
			 * 
			 * @return Whether the key field is set.
			 */
			@java.lang.Override
			public boolean hasKey() {
				return ((bitField0_ & 0x00000004) != 0);
			}

			/**
			 * <code>optional bytes key = 3;</code>
			 * 
			 * @return The key.
			 */
			@java.lang.Override
			public ByteString getKey() {
				return key_;
			}

			public static final int TYPE_FIELD_NUMBER = 4;
			private int type_ = 1;

			/**
			 * <code>optional .License.KeyContainer.KeyType type = 4;</code>
			 * 
			 * @return Whether the type field is set.
			 */
			@java.lang.Override
			public boolean hasType() {
				return ((bitField0_ & 0x00000008) != 0);
			}

			/**
			 * <code>optional .License.KeyContainer.KeyType type = 4;</code>
			 * 
			 * @return The type.
			 */
			@java.lang.Override
			public WvProto2.License.KeyContainer.KeyType getType() {
				WvProto2.License.KeyContainer.KeyType result = WvProto2.License.KeyContainer.KeyType
						.forNumber(type_);
				return result == null ? WvProto2.License.KeyContainer.KeyType.SIGNING : result;
			}

			public static final int LEVEL_FIELD_NUMBER = 5;
			private int level_ = 1;

			/**
			 * <code>optional .License.KeyContainer.SecurityLevel level = 5 [default = SW_SECURE_CRYPTO];</code>
			 * 
			 * @return Whether the level field is set.
			 */
			@java.lang.Override
			public boolean hasLevel() {
				return ((bitField0_ & 0x00000010) != 0);
			}

			/**
			 * <code>optional .License.KeyContainer.SecurityLevel level = 5 [default = SW_SECURE_CRYPTO];</code>
			 * 
			 * @return The level.
			 */
			@java.lang.Override
			public WvProto2.License.KeyContainer.SecurityLevel getLevel() {
				WvProto2.License.KeyContainer.SecurityLevel result = WvProto2.License.KeyContainer.SecurityLevel
						.forNumber(level_);
				return result == null
						? WvProto2.License.KeyContainer.SecurityLevel.SW_SECURE_CRYPTO
						: result;
			}

			public static final int REQUIRED_PROTECTION_FIELD_NUMBER = 6;
			private WvProto2.License.KeyContainer.OutputProtection requiredProtection_;

			/**
			 * <code>optional .License.KeyContainer.OutputProtection required_protection = 6;</code>
			 * 
			 * @return Whether the requiredProtection field is set.
			 */
			@java.lang.Override
			public boolean hasRequiredProtection() {
				return ((bitField0_ & 0x00000020) != 0);
			}

			/**
			 * <code>optional .License.KeyContainer.OutputProtection required_protection = 6;</code>
			 * 
			 * @return The requiredProtection.
			 */
			@java.lang.Override
			public WvProto2.License.KeyContainer.OutputProtection getRequiredProtection() {
				return requiredProtection_ == null
						? WvProto2.License.KeyContainer.OutputProtection.getDefaultInstance()
						: requiredProtection_;
			}

			/**
			 * <code>optional .License.KeyContainer.OutputProtection required_protection = 6;</code>
			 */
			@java.lang.Override
			public WvProto2.License.KeyContainer.OutputProtectionOrBuilder getRequiredProtectionOrBuilder() {
				return requiredProtection_ == null
						? WvProto2.License.KeyContainer.OutputProtection.getDefaultInstance()
						: requiredProtection_;
			}

			public static final int REQUESTED_PROTECTION_FIELD_NUMBER = 7;
			private WvProto2.License.KeyContainer.OutputProtection requestedProtection_;

			/**
			 * <pre>
			 * NOTE: Use of requested_protection is not recommended as it is only
			 * supported on a small number of platforms.
			 * </pre>
			 *
			 * <code>optional .License.KeyContainer.OutputProtection requested_protection = 7;</code>
			 * 
			 * @return Whether the requestedProtection field is set.
			 */
			@java.lang.Override
			public boolean hasRequestedProtection() {
				return ((bitField0_ & 0x00000040) != 0);
			}

			/**
			 * <pre>
			 * NOTE: Use of requested_protection is not recommended as it is only
			 * supported on a small number of platforms.
			 * </pre>
			 *
			 * <code>optional .License.KeyContainer.OutputProtection requested_protection = 7;</code>
			 * 
			 * @return The requestedProtection.
			 */
			@java.lang.Override
			public WvProto2.License.KeyContainer.OutputProtection getRequestedProtection() {
				return requestedProtection_ == null
						? WvProto2.License.KeyContainer.OutputProtection.getDefaultInstance()
						: requestedProtection_;
			}

			/**
			 * <pre>
			 * NOTE: Use of requested_protection is not recommended as it is only
			 * supported on a small number of platforms.
			 * </pre>
			 *
			 * <code>optional .License.KeyContainer.OutputProtection requested_protection = 7;</code>
			 */
			@java.lang.Override
			public WvProto2.License.KeyContainer.OutputProtectionOrBuilder getRequestedProtectionOrBuilder() {
				return requestedProtection_ == null
						? WvProto2.License.KeyContainer.OutputProtection.getDefaultInstance()
						: requestedProtection_;
			}

			public static final int KEY_CONTROL_FIELD_NUMBER = 8;
			private WvProto2.License.KeyContainer.KeyControl keyControl_;

			/**
			 * <code>optional .License.KeyContainer.KeyControl key_control = 8;</code>
			 * 
			 * @return Whether the keyControl field is set.
			 */
			@java.lang.Override
			public boolean hasKeyControl() {
				return ((bitField0_ & 0x00000080) != 0);
			}

			/**
			 * <code>optional .License.KeyContainer.KeyControl key_control = 8;</code>
			 * 
			 * @return The keyControl.
			 */
			@java.lang.Override
			public WvProto2.License.KeyContainer.KeyControl getKeyControl() {
				return keyControl_ == null
						? WvProto2.License.KeyContainer.KeyControl.getDefaultInstance()
						: keyControl_;
			}

			/**
			 * <code>optional .License.KeyContainer.KeyControl key_control = 8;</code>
			 */
			@java.lang.Override
			public WvProto2.License.KeyContainer.KeyControlOrBuilder getKeyControlOrBuilder() {
				return keyControl_ == null
						? WvProto2.License.KeyContainer.KeyControl.getDefaultInstance()
						: keyControl_;
			}

			public static final int OPERATOR_SESSION_KEY_PERMISSIONS_FIELD_NUMBER = 9;
			private WvProto2.License.KeyContainer.OperatorSessionKeyPermissions operatorSessionKeyPermissions_;

			/**
			 * <code>optional .License.KeyContainer.OperatorSessionKeyPermissions operator_session_key_permissions = 9;</code>
			 * 
			 * @return Whether the operatorSessionKeyPermissions field is set.
			 */
			@java.lang.Override
			public boolean hasOperatorSessionKeyPermissions() {
				return ((bitField0_ & 0x00000100) != 0);
			}

			/**
			 * <code>optional .License.KeyContainer.OperatorSessionKeyPermissions operator_session_key_permissions = 9;</code>
			 * 
			 * @return The operatorSessionKeyPermissions.
			 */
			@java.lang.Override
			public WvProto2.License.KeyContainer.OperatorSessionKeyPermissions getOperatorSessionKeyPermissions() {
				return operatorSessionKeyPermissions_ == null
						? WvProto2.License.KeyContainer.OperatorSessionKeyPermissions
								.getDefaultInstance()
						: operatorSessionKeyPermissions_;
			}

			/**
			 * <code>optional .License.KeyContainer.OperatorSessionKeyPermissions operator_session_key_permissions = 9;</code>
			 */
			@java.lang.Override
			public WvProto2.License.KeyContainer.OperatorSessionKeyPermissionsOrBuilder getOperatorSessionKeyPermissionsOrBuilder() {
				return operatorSessionKeyPermissions_ == null
						? WvProto2.License.KeyContainer.OperatorSessionKeyPermissions
								.getDefaultInstance()
						: operatorSessionKeyPermissions_;
			}

			public static final int VIDEO_RESOLUTION_CONSTRAINTS_FIELD_NUMBER = 10;

			private java.util.List<WvProto2.License.KeyContainer.VideoResolutionConstraint> videoResolutionConstraints_;

			/**
			 * <pre>
			 * Optional video resolution constraints. If the video resolution of the
			 * content being decrypted/decoded falls within one of the specified ranges,
			 * the optional required_protections may be applied. Otherwise an error will
			 * be reported.
			 * NOTE: Use of this feature is not recommended, as it is only supported on
			 * a small number of platforms.
			 * </pre>
			 *
			 * <code>repeated .License.KeyContainer.VideoResolutionConstraint video_resolution_constraints = 10;</code>
			 */
			@java.lang.Override
			public java.util.List<WvProto2.License.KeyContainer.VideoResolutionConstraint> getVideoResolutionConstraintsList() {
				return videoResolutionConstraints_;
			}

			/**
			 * <pre>
			 * Optional video resolution constraints. If the video resolution of the
			 * content being decrypted/decoded falls within one of the specified ranges,
			 * the optional required_protections may be applied. Otherwise an error will
			 * be reported.
			 * NOTE: Use of this feature is not recommended, as it is only supported on
			 * a small number of platforms.
			 * </pre>
			 *
			 * <code>repeated .License.KeyContainer.VideoResolutionConstraint video_resolution_constraints = 10;</code>
			 */
			@java.lang.Override
			public java.util.List<? extends WvProto2.License.KeyContainer.VideoResolutionConstraintOrBuilder> getVideoResolutionConstraintsOrBuilderList() {
				return videoResolutionConstraints_;
			}

			/**
			 * <pre>
			 * Optional video resolution constraints. If the video resolution of the
			 * content being decrypted/decoded falls within one of the specified ranges,
			 * the optional required_protections may be applied. Otherwise an error will
			 * be reported.
			 * NOTE: Use of this feature is not recommended, as it is only supported on
			 * a small number of platforms.
			 * </pre>
			 *
			 * <code>repeated .License.KeyContainer.VideoResolutionConstraint video_resolution_constraints = 10;</code>
			 */
			@java.lang.Override
			public int getVideoResolutionConstraintsCount() {
				return videoResolutionConstraints_.size();
			}

			/**
			 * <pre>
			 * Optional video resolution constraints. If the video resolution of the
			 * content being decrypted/decoded falls within one of the specified ranges,
			 * the optional required_protections may be applied. Otherwise an error will
			 * be reported.
			 * NOTE: Use of this feature is not recommended, as it is only supported on
			 * a small number of platforms.
			 * </pre>
			 *
			 * <code>repeated .License.KeyContainer.VideoResolutionConstraint video_resolution_constraints = 10;</code>
			 */
			@java.lang.Override
			public WvProto2.License.KeyContainer.VideoResolutionConstraint getVideoResolutionConstraints(
					int index) {
				return videoResolutionConstraints_.get(index);
			}

			/**
			 * <pre>
			 * Optional video resolution constraints. If the video resolution of the
			 * content being decrypted/decoded falls within one of the specified ranges,
			 * the optional required_protections may be applied. Otherwise an error will
			 * be reported.
			 * NOTE: Use of this feature is not recommended, as it is only supported on
			 * a small number of platforms.
			 * </pre>
			 *
			 * <code>repeated .License.KeyContainer.VideoResolutionConstraint video_resolution_constraints = 10;</code>
			 */
			@java.lang.Override
			public WvProto2.License.KeyContainer.VideoResolutionConstraintOrBuilder getVideoResolutionConstraintsOrBuilder(
					int index) {
				return videoResolutionConstraints_.get(index);
			}

			public static final int ANTI_ROLLBACK_USAGE_TABLE_FIELD_NUMBER = 11;
			private boolean antiRollbackUsageTable_ = false;

			/**
			 * <pre>
			 * Optional flag to indicate the key must only be used if the client
			 * supports anti rollback of the user table.  Content provider can query the
			 * client capabilities to determine if the client support this feature.
			 * </pre>
			 *
			 * <code>optional bool anti_rollback_usage_table = 11 [default = false];</code>
			 * 
			 * @return Whether the antiRollbackUsageTable field is set.
			 */
			@java.lang.Override
			public boolean hasAntiRollbackUsageTable() {
				return ((bitField0_ & 0x00000200) != 0);
			}

			/**
			 * <pre>
			 * Optional flag to indicate the key must only be used if the client
			 * supports anti rollback of the user table.  Content provider can query the
			 * client capabilities to determine if the client support this feature.
			 * </pre>
			 *
			 * <code>optional bool anti_rollback_usage_table = 11 [default = false];</code>
			 * 
			 * @return The antiRollbackUsageTable.
			 */
			@java.lang.Override
			public boolean getAntiRollbackUsageTable() {
				return antiRollbackUsageTable_;
			}

			public static final int TRACK_LABEL_FIELD_NUMBER = 12;

			private volatile java.lang.Object trackLabel_ = "";

			/**
			 * <pre>
			 * Optional not limited to commonly known track types such as SD, HD.
			 * It can be some provider defined label to identify the track.
			 * </pre>
			 *
			 * <code>optional string track_label = 12;</code>
			 * 
			 * @return Whether the trackLabel field is set.
			 */
			@java.lang.Override
			public boolean hasTrackLabel() {
				return ((bitField0_ & 0x00000400) != 0);
			}

			/**
			 * <pre>
			 * Optional not limited to commonly known track types such as SD, HD.
			 * It can be some provider defined label to identify the track.
			 * </pre>
			 *
			 * <code>optional string track_label = 12;</code>
			 * 
			 * @return The trackLabel.
			 */
			@java.lang.Override
			public java.lang.String getTrackLabel() {
				java.lang.Object ref = trackLabel_;
				if (ref instanceof java.lang.String) {
					return (java.lang.String) ref;
				}
				ByteString bs = (ByteString) ref;
				java.lang.String s = bs.toStringUtf8();
				if (bs.isValidUtf8()) {
					trackLabel_ = s;
				}
				return s;
			}

			/**
			 * <pre>
			 * Optional not limited to commonly known track types such as SD, HD.
			 * It can be some provider defined label to identify the track.
			 * </pre>
			 *
			 * <code>optional string track_label = 12;</code>
			 * 
			 * @return The bytes for trackLabel.
			 */
			@java.lang.Override
			public ByteString getTrackLabelBytes() {
				java.lang.Object ref = trackLabel_;
				if (ref instanceof java.lang.String) {
					ByteString b = ByteString.copyFromUtf8((java.lang.String) ref);
					trackLabel_ = b;
					return b;
				}
				return (ByteString) ref;
			}

			private byte memoizedIsInitialized = -1;

			@java.lang.Override
			public final boolean isInitialized() {
				byte isInitialized = memoizedIsInitialized;
				if (isInitialized == 1)
					return true;
				if (isInitialized == 0)
					return false;

				memoizedIsInitialized = 1;
				return true;
			}

			@java.lang.Override
			public void writeTo(CodedOutputStream output) throws java.io.IOException {
				if (((bitField0_ & 0x00000001) != 0)) {
					output.writeBytes(1, id_);
				}
				if (((bitField0_ & 0x00000002) != 0)) {
					output.writeBytes(2, iv_);
				}
				if (((bitField0_ & 0x00000004) != 0)) {
					output.writeBytes(3, key_);
				}
				if (((bitField0_ & 0x00000008) != 0)) {
					output.writeEnum(4, type_);
				}
				if (((bitField0_ & 0x00000010) != 0)) {
					output.writeEnum(5, level_);
				}
				if (((bitField0_ & 0x00000020) != 0)) {
					output.writeMessage(6, getRequiredProtection());
				}
				if (((bitField0_ & 0x00000040) != 0)) {
					output.writeMessage(7, getRequestedProtection());
				}
				if (((bitField0_ & 0x00000080) != 0)) {
					output.writeMessage(8, getKeyControl());
				}
				if (((bitField0_ & 0x00000100) != 0)) {
					output.writeMessage(9, getOperatorSessionKeyPermissions());
				}
				for (int i = 0; i < videoResolutionConstraints_.size(); i++) {
					output.writeMessage(10, videoResolutionConstraints_.get(i));
				}
				if (((bitField0_ & 0x00000200) != 0)) {
					output.writeBool(11, antiRollbackUsageTable_);
				}
				if (((bitField0_ & 0x00000400) != 0)) {
					GeneratedMessageV3.writeString(output, 12, trackLabel_);
				}
				getUnknownFields().writeTo(output);
			}

			@java.lang.Override
			public int getSerializedSize() {
				int size = memoizedSize;
				if (size != -1)
					return size;

				size = 0;
				if (((bitField0_ & 0x00000001) != 0)) {
					size += CodedOutputStream.computeBytesSize(1, id_);
				}
				if (((bitField0_ & 0x00000002) != 0)) {
					size += CodedOutputStream.computeBytesSize(2, iv_);
				}
				if (((bitField0_ & 0x00000004) != 0)) {
					size += CodedOutputStream.computeBytesSize(3, key_);
				}
				if (((bitField0_ & 0x00000008) != 0)) {
					size += CodedOutputStream.computeEnumSize(4, type_);
				}
				if (((bitField0_ & 0x00000010) != 0)) {
					size += CodedOutputStream.computeEnumSize(5, level_);
				}
				if (((bitField0_ & 0x00000020) != 0)) {
					size += CodedOutputStream.computeMessageSize(6, getRequiredProtection());
				}
				if (((bitField0_ & 0x00000040) != 0)) {
					size += CodedOutputStream.computeMessageSize(7, getRequestedProtection());
				}
				if (((bitField0_ & 0x00000080) != 0)) {
					size += CodedOutputStream.computeMessageSize(8, getKeyControl());
				}
				if (((bitField0_ & 0x00000100) != 0)) {
					size += CodedOutputStream.computeMessageSize(9, getOperatorSessionKeyPermissions());
				}
				for (int i = 0; i < videoResolutionConstraints_.size(); i++) {
					size += CodedOutputStream.computeMessageSize(10, videoResolutionConstraints_.get(i));
				}
				if (((bitField0_ & 0x00000200) != 0)) {
					size += CodedOutputStream.computeBoolSize(11, antiRollbackUsageTable_);
				}
				if (((bitField0_ & 0x00000400) != 0)) {
					size += GeneratedMessageV3.computeStringSize(12, trackLabel_);
				}
				size += getUnknownFields().getSerializedSize();
				memoizedSize = size;
				return size;
			}

			@java.lang.Override
			public boolean equals(final java.lang.Object obj) {
				if (obj == this) {
					return true;
				}
				if (!(obj instanceof WvProto2.License.KeyContainer)) {
					return super.equals(obj);
				}
				WvProto2.License.KeyContainer other = (WvProto2.License.KeyContainer) obj;

				if (hasId() != other.hasId())
					return false;
				if (hasId()) {
					if (!getId().equals(other.getId()))
						return false;
				}
				if (hasIv() != other.hasIv())
					return false;
				if (hasIv()) {
					if (!getIv().equals(other.getIv()))
						return false;
				}
				if (hasKey() != other.hasKey())
					return false;
				if (hasKey()) {
					if (!getKey().equals(other.getKey()))
						return false;
				}
				if (hasType() != other.hasType())
					return false;
				if (hasType()) {
					if (type_ != other.type_)
						return false;
				}
				if (hasLevel() != other.hasLevel())
					return false;
				if (hasLevel()) {
					if (level_ != other.level_)
						return false;
				}
				if (hasRequiredProtection() != other.hasRequiredProtection())
					return false;
				if (hasRequiredProtection()) {
					if (!getRequiredProtection().equals(other.getRequiredProtection()))
						return false;
				}
				if (hasRequestedProtection() != other.hasRequestedProtection())
					return false;
				if (hasRequestedProtection()) {
					if (!getRequestedProtection().equals(other.getRequestedProtection()))
						return false;
				}
				if (hasKeyControl() != other.hasKeyControl())
					return false;
				if (hasKeyControl()) {
					if (!getKeyControl().equals(other.getKeyControl()))
						return false;
				}
				if (hasOperatorSessionKeyPermissions() != other.hasOperatorSessionKeyPermissions())
					return false;
				if (hasOperatorSessionKeyPermissions()) {
					if (!getOperatorSessionKeyPermissions().equals(other.getOperatorSessionKeyPermissions()))
						return false;
				}
				if (!getVideoResolutionConstraintsList().equals(other.getVideoResolutionConstraintsList()))
					return false;
				if (hasAntiRollbackUsageTable() != other.hasAntiRollbackUsageTable())
					return false;
				if (hasAntiRollbackUsageTable()) {
					if (getAntiRollbackUsageTable() != other.getAntiRollbackUsageTable())
						return false;
				}
				if (hasTrackLabel() != other.hasTrackLabel())
					return false;
				if (hasTrackLabel()) {
					if (!getTrackLabel().equals(other.getTrackLabel()))
						return false;
				}
				if (!getUnknownFields().equals(other.getUnknownFields()))
					return false;
				return true;
			}

			@SuppressWarnings("unchecked")
			@java.lang.Override
			public int hashCode() {
				if (memoizedHashCode != 0) {
					return memoizedHashCode;
				}
				int hash = 41;
				hash = (19 * hash) + getDescriptor().hashCode();
				if (hasId()) {
					hash = (37 * hash) + ID_FIELD_NUMBER;
					hash = (53 * hash) + getId().hashCode();
				}
				if (hasIv()) {
					hash = (37 * hash) + IV_FIELD_NUMBER;
					hash = (53 * hash) + getIv().hashCode();
				}
				if (hasKey()) {
					hash = (37 * hash) + KEY_FIELD_NUMBER;
					hash = (53 * hash) + getKey().hashCode();
				}
				if (hasType()) {
					hash = (37 * hash) + TYPE_FIELD_NUMBER;
					hash = (53 * hash) + type_;
				}
				if (hasLevel()) {
					hash = (37 * hash) + LEVEL_FIELD_NUMBER;
					hash = (53 * hash) + level_;
				}
				if (hasRequiredProtection()) {
					hash = (37 * hash) + REQUIRED_PROTECTION_FIELD_NUMBER;
					hash = (53 * hash) + getRequiredProtection().hashCode();
				}
				if (hasRequestedProtection()) {
					hash = (37 * hash) + REQUESTED_PROTECTION_FIELD_NUMBER;
					hash = (53 * hash) + getRequestedProtection().hashCode();
				}
				if (hasKeyControl()) {
					hash = (37 * hash) + KEY_CONTROL_FIELD_NUMBER;
					hash = (53 * hash) + getKeyControl().hashCode();
				}
				if (hasOperatorSessionKeyPermissions()) {
					hash = (37 * hash) + OPERATOR_SESSION_KEY_PERMISSIONS_FIELD_NUMBER;
					hash = (53 * hash) + getOperatorSessionKeyPermissions().hashCode();
				}
				if (getVideoResolutionConstraintsCount() > 0) {
					hash = (37 * hash) + VIDEO_RESOLUTION_CONSTRAINTS_FIELD_NUMBER;
					hash = (53 * hash) + getVideoResolutionConstraintsList().hashCode();
				}
				if (hasAntiRollbackUsageTable()) {
					hash = (37 * hash) + ANTI_ROLLBACK_USAGE_TABLE_FIELD_NUMBER;
					hash = (53 * hash) + Internal.hashBoolean(getAntiRollbackUsageTable());
				}
				if (hasTrackLabel()) {
					hash = (37 * hash) + TRACK_LABEL_FIELD_NUMBER;
					hash = (53 * hash) + getTrackLabel().hashCode();
				}
				hash = (29 * hash) + getUnknownFields().hashCode();
				memoizedHashCode = hash;
				return hash;
			}

			public static WvProto2.License.KeyContainer parseFrom(java.nio.ByteBuffer data)
					throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data);
			}

			public static WvProto2.License.KeyContainer parseFrom(java.nio.ByteBuffer data,
					ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data, extensionRegistry);
			}

			public static WvProto2.License.KeyContainer parseFrom(ByteString data)
					throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data);
			}

			public static WvProto2.License.KeyContainer parseFrom(ByteString data,
					ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data, extensionRegistry);
			}

			public static WvProto2.License.KeyContainer parseFrom(byte[] data)
					throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data);
			}

			public static WvProto2.License.KeyContainer parseFrom(byte[] data,
					ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data, extensionRegistry);
			}

			public static WvProto2.License.KeyContainer parseFrom(java.io.InputStream input)
					throws java.io.IOException {
				return GeneratedMessageV3.parseWithIOException(PARSER, input);
			}

			public static WvProto2.License.KeyContainer parseFrom(java.io.InputStream input,
					ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
				return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
			}

			public static WvProto2.License.KeyContainer parseDelimitedFrom(
					java.io.InputStream input) throws java.io.IOException {
				return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
			}

			public static WvProto2.License.KeyContainer parseDelimitedFrom(
					java.io.InputStream input, ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
				return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input, extensionRegistry);
			}

			public static WvProto2.License.KeyContainer parseFrom(CodedInputStream input)
					throws java.io.IOException {
				return GeneratedMessageV3.parseWithIOException(PARSER, input);
			}

			public static WvProto2.License.KeyContainer parseFrom(CodedInputStream input,
					ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
				return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
			}

			@java.lang.Override
			public Builder newBuilderForType() {
				return newBuilder();
			}

			public static Builder newBuilder() {
				return DEFAULT_INSTANCE.toBuilder();
			}

			public static Builder newBuilder(WvProto2.License.KeyContainer prototype) {
				return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
			}

			@java.lang.Override
			public Builder toBuilder() {
				return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
			}

			@java.lang.Override
			protected Builder newBuilderForType(GeneratedMessageV3.BuilderParent parent) {
				Builder builder = new Builder(parent);
				return builder;
			}

			/**
			 * Protobuf type {@code License.KeyContainer}
			 */
			public static final class Builder extends GeneratedMessageV3.Builder<Builder> implements
					// @@protoc_insertion_point(builder_implements:License.KeyContainer)
					WvProto2.License.KeyContainerOrBuilder {
				public static final Descriptors.Descriptor getDescriptor() {
					return WvProto2.internal_static_License_KeyContainer_descriptor;
				}

				@java.lang.Override
				protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
					return WvProto2.internal_static_License_KeyContainer_fieldAccessorTable
							.ensureFieldAccessorsInitialized(
									WvProto2.License.KeyContainer.class,
									WvProto2.License.KeyContainer.Builder.class);
				}

				// Construct using
				// WvProto2.License.KeyContainer.newBuilder()
				private Builder() {
					maybeForceBuilderInitialization();
				}

				private Builder(GeneratedMessageV3.BuilderParent parent) {
					super(parent);
					maybeForceBuilderInitialization();
				}

				private void maybeForceBuilderInitialization() {
					if (GeneratedMessageV3.alwaysUseFieldBuilders) {
						getRequiredProtectionFieldBuilder();
						getRequestedProtectionFieldBuilder();
						getKeyControlFieldBuilder();
						getOperatorSessionKeyPermissionsFieldBuilder();
						getVideoResolutionConstraintsFieldBuilder();
					}
				}

				@java.lang.Override
				public Builder clear() {
					super.clear();
					bitField0_ = 0;
					id_ = ByteString.EMPTY;
					iv_ = ByteString.EMPTY;
					key_ = ByteString.EMPTY;
					type_ = 1;
					level_ = 1;
					requiredProtection_ = null;
					if (requiredProtectionBuilder_ != null) {
						requiredProtectionBuilder_.dispose();
						requiredProtectionBuilder_ = null;
					}
					requestedProtection_ = null;
					if (requestedProtectionBuilder_ != null) {
						requestedProtectionBuilder_.dispose();
						requestedProtectionBuilder_ = null;
					}
					keyControl_ = null;
					if (keyControlBuilder_ != null) {
						keyControlBuilder_.dispose();
						keyControlBuilder_ = null;
					}
					operatorSessionKeyPermissions_ = null;
					if (operatorSessionKeyPermissionsBuilder_ != null) {
						operatorSessionKeyPermissionsBuilder_.dispose();
						operatorSessionKeyPermissionsBuilder_ = null;
					}
					if (videoResolutionConstraintsBuilder_ == null) {
						videoResolutionConstraints_ = java.util.Collections.emptyList();
					} else {
						videoResolutionConstraints_ = null;
						videoResolutionConstraintsBuilder_.clear();
					}
					bitField0_ = (bitField0_ & ~0x00000200);
					antiRollbackUsageTable_ = false;
					trackLabel_ = "";
					return this;
				}

				@java.lang.Override
				public Descriptors.Descriptor getDescriptorForType() {
					return WvProto2.internal_static_License_KeyContainer_descriptor;
				}

				@java.lang.Override
				public WvProto2.License.KeyContainer getDefaultInstanceForType() {
					return WvProto2.License.KeyContainer.getDefaultInstance();
				}

				@java.lang.Override
				public WvProto2.License.KeyContainer build() {
					WvProto2.License.KeyContainer result = buildPartial();
					if (!result.isInitialized()) {
						throw newUninitializedMessageException(result);
					}
					return result;
				}

				@java.lang.Override
				public WvProto2.License.KeyContainer buildPartial() {
					WvProto2.License.KeyContainer result = new WvProto2.License.KeyContainer(
							this);
					buildPartialRepeatedFields(result);
					if (bitField0_ != 0) {
						buildPartial0(result);
					}
					onBuilt();
					return result;
				}

				private void buildPartialRepeatedFields(WvProto2.License.KeyContainer result) {
					if (videoResolutionConstraintsBuilder_ == null) {
						if (((bitField0_ & 0x00000200) != 0)) {
							videoResolutionConstraints_ = java.util.Collections
									.unmodifiableList(videoResolutionConstraints_);
							bitField0_ = (bitField0_ & ~0x00000200);
						}
						result.videoResolutionConstraints_ = videoResolutionConstraints_;
					} else {
						result.videoResolutionConstraints_ = videoResolutionConstraintsBuilder_.build();
					}
				}

				private void buildPartial0(WvProto2.License.KeyContainer result) {
					int from_bitField0_ = bitField0_;
					int to_bitField0_ = 0;
					if (((from_bitField0_ & 0x00000001) != 0)) {
						result.id_ = id_;
						to_bitField0_ |= 0x00000001;
					}
					if (((from_bitField0_ & 0x00000002) != 0)) {
						result.iv_ = iv_;
						to_bitField0_ |= 0x00000002;
					}
					if (((from_bitField0_ & 0x00000004) != 0)) {
						result.key_ = key_;
						to_bitField0_ |= 0x00000004;
					}
					if (((from_bitField0_ & 0x00000008) != 0)) {
						result.type_ = type_;
						to_bitField0_ |= 0x00000008;
					}
					if (((from_bitField0_ & 0x00000010) != 0)) {
						result.level_ = level_;
						to_bitField0_ |= 0x00000010;
					}
					if (((from_bitField0_ & 0x00000020) != 0)) {
						result.requiredProtection_ = requiredProtectionBuilder_ == null ? requiredProtection_
								: requiredProtectionBuilder_.build();
						to_bitField0_ |= 0x00000020;
					}
					if (((from_bitField0_ & 0x00000040) != 0)) {
						result.requestedProtection_ = requestedProtectionBuilder_ == null ? requestedProtection_
								: requestedProtectionBuilder_.build();
						to_bitField0_ |= 0x00000040;
					}
					if (((from_bitField0_ & 0x00000080) != 0)) {
						result.keyControl_ = keyControlBuilder_ == null ? keyControl_ : keyControlBuilder_.build();
						to_bitField0_ |= 0x00000080;
					}
					if (((from_bitField0_ & 0x00000100) != 0)) {
						result.operatorSessionKeyPermissions_ = operatorSessionKeyPermissionsBuilder_ == null
								? operatorSessionKeyPermissions_
								: operatorSessionKeyPermissionsBuilder_.build();
						to_bitField0_ |= 0x00000100;
					}
					if (((from_bitField0_ & 0x00000400) != 0)) {
						result.antiRollbackUsageTable_ = antiRollbackUsageTable_;
						to_bitField0_ |= 0x00000200;
					}
					if (((from_bitField0_ & 0x00000800) != 0)) {
						result.trackLabel_ = trackLabel_;
						to_bitField0_ |= 0x00000400;
					}
					result.bitField0_ |= to_bitField0_;
				}

				@java.lang.Override
				public Builder mergeFrom(Message other) {
					if (other instanceof WvProto2.License.KeyContainer) {
						return mergeFrom((WvProto2.License.KeyContainer) other);
					}
					super.mergeFrom(other);
					return this;
				}

				public Builder mergeFrom(WvProto2.License.KeyContainer other) {
					if (other == WvProto2.License.KeyContainer.getDefaultInstance())
						return this;
					if (other.hasId()) {
						setId(other.getId());
					}
					if (other.hasIv()) {
						setIv(other.getIv());
					}
					if (other.hasKey()) {
						setKey(other.getKey());
					}
					if (other.hasType()) {
						setType(other.getType());
					}
					if (other.hasLevel()) {
						setLevel(other.getLevel());
					}
					if (other.hasRequiredProtection()) {
						mergeRequiredProtection(other.getRequiredProtection());
					}
					if (other.hasRequestedProtection()) {
						mergeRequestedProtection(other.getRequestedProtection());
					}
					if (other.hasKeyControl()) {
						mergeKeyControl(other.getKeyControl());
					}
					if (other.hasOperatorSessionKeyPermissions()) {
						mergeOperatorSessionKeyPermissions(other.getOperatorSessionKeyPermissions());
					}
					if (videoResolutionConstraintsBuilder_ == null) {
						if (!other.videoResolutionConstraints_.isEmpty()) {
							if (videoResolutionConstraints_.isEmpty()) {
								videoResolutionConstraints_ = other.videoResolutionConstraints_;
								bitField0_ = (bitField0_ & ~0x00000200);
							} else {
								ensureVideoResolutionConstraintsIsMutable();
								videoResolutionConstraints_.addAll(other.videoResolutionConstraints_);
							}
							onChanged();
						}
					} else {
						if (!other.videoResolutionConstraints_.isEmpty()) {
							if (videoResolutionConstraintsBuilder_.isEmpty()) {
								videoResolutionConstraintsBuilder_.dispose();
								videoResolutionConstraintsBuilder_ = null;
								videoResolutionConstraints_ = other.videoResolutionConstraints_;
								bitField0_ = (bitField0_ & ~0x00000200);
								videoResolutionConstraintsBuilder_ = GeneratedMessageV3.alwaysUseFieldBuilders
										? getVideoResolutionConstraintsFieldBuilder()
										: null;
							} else {
								videoResolutionConstraintsBuilder_.addAllMessages(other.videoResolutionConstraints_);
							}
						}
					}
					if (other.hasAntiRollbackUsageTable()) {
						setAntiRollbackUsageTable(other.getAntiRollbackUsageTable());
					}
					if (other.hasTrackLabel()) {
						trackLabel_ = other.trackLabel_;
						bitField0_ |= 0x00000800;
						onChanged();
					}
					this.mergeUnknownFields(other.getUnknownFields());
					onChanged();
					return this;
				}

				@java.lang.Override
				public final boolean isInitialized() {
					return true;
				}

				@java.lang.Override
				public Builder mergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
						throws java.io.IOException {
					if (extensionRegistry == null) {
						throw new java.lang.NullPointerException();
					}
					try {
						boolean done = false;
						while (!done) {
							int tag = input.readTag();
							switch (tag) {
							case 0:
								done = true;
								break;
							case 10: {
								id_ = input.readBytes();
								bitField0_ |= 0x00000001;
								break;
							} // case 10
							case 18: {
								iv_ = input.readBytes();
								bitField0_ |= 0x00000002;
								break;
							} // case 18
							case 26: {
								key_ = input.readBytes();
								bitField0_ |= 0x00000004;
								break;
							} // case 26
							case 32: {
								int tmpRaw = input.readEnum();
								WvProto2.License.KeyContainer.KeyType tmpValue = WvProto2.License.KeyContainer.KeyType
										.forNumber(tmpRaw);
								if (tmpValue == null) {
									mergeUnknownVarintField(4, tmpRaw);
								} else {
									type_ = tmpRaw;
									bitField0_ |= 0x00000008;
								}
								break;
							} // case 32
							case 40: {
								int tmpRaw = input.readEnum();
								WvProto2.License.KeyContainer.SecurityLevel tmpValue = WvProto2.License.KeyContainer.SecurityLevel
										.forNumber(tmpRaw);
								if (tmpValue == null) {
									mergeUnknownVarintField(5, tmpRaw);
								} else {
									level_ = tmpRaw;
									bitField0_ |= 0x00000010;
								}
								break;
							} // case 40
							case 50: {
								input.readMessage(getRequiredProtectionFieldBuilder().getBuilder(), extensionRegistry);
								bitField0_ |= 0x00000020;
								break;
							} // case 50
							case 58: {
								input.readMessage(getRequestedProtectionFieldBuilder().getBuilder(), extensionRegistry);
								bitField0_ |= 0x00000040;
								break;
							} // case 58
							case 66: {
								input.readMessage(getKeyControlFieldBuilder().getBuilder(), extensionRegistry);
								bitField0_ |= 0x00000080;
								break;
							} // case 66
							case 74: {
								input.readMessage(getOperatorSessionKeyPermissionsFieldBuilder().getBuilder(),
										extensionRegistry);
								bitField0_ |= 0x00000100;
								break;
							} // case 74
							case 82: {
								WvProto2.License.KeyContainer.VideoResolutionConstraint m = input
										.readMessage(
												WvProto2.License.KeyContainer.VideoResolutionConstraint.PARSER,
												extensionRegistry);
								if (videoResolutionConstraintsBuilder_ == null) {
									ensureVideoResolutionConstraintsIsMutable();
									videoResolutionConstraints_.add(m);
								} else {
									videoResolutionConstraintsBuilder_.addMessage(m);
								}
								break;
							} // case 82
							case 88: {
								antiRollbackUsageTable_ = input.readBool();
								bitField0_ |= 0x00000400;
								break;
							} // case 88
							case 98: {
								trackLabel_ = input.readBytes();
								bitField0_ |= 0x00000800;
								break;
							} // case 98
							default: {
								if (!super.parseUnknownField(input, extensionRegistry, tag)) {
									done = true; // was an endgroup tag
								}
								break;
							} // default:
							} // switch (tag)
						} // while (!done)
					} catch (InvalidProtocolBufferException e) {
						throw e.unwrapIOException();
					}
					finally {
						onChanged();
					} // finally
					return this;
				}

				private int bitField0_;

				private ByteString id_ = ByteString.EMPTY;

				/**
				 * <code>optional bytes id = 1;</code>
				 * 
				 * @return Whether the id field is set.
				 */
				@java.lang.Override
				public boolean hasId() {
					return ((bitField0_ & 0x00000001) != 0);
				}

				/**
				 * <code>optional bytes id = 1;</code>
				 * 
				 * @return The id.
				 */
				@java.lang.Override
				public ByteString getId() {
					return id_;
				}

				/**
				 * <code>optional bytes id = 1;</code>
				 * 
				 * @param value The id to set.
				 * @return This builder for chaining.
				 */
				public Builder setId(ByteString value) {
					if (value == null) {
						throw new NullPointerException();
					}
					id_ = value;
					bitField0_ |= 0x00000001;
					onChanged();
					return this;
				}

				/**
				 * <code>optional bytes id = 1;</code>
				 * 
				 * @return This builder for chaining.
				 */
				public Builder clearId() {
					bitField0_ = (bitField0_ & ~0x00000001);
					id_ = getDefaultInstance().getId();
					onChanged();
					return this;
				}

				private ByteString iv_ = ByteString.EMPTY;

				/**
				 * <code>optional bytes iv = 2;</code>
				 * 
				 * @return Whether the iv field is set.
				 */
				@java.lang.Override
				public boolean hasIv() {
					return ((bitField0_ & 0x00000002) != 0);
				}

				/**
				 * <code>optional bytes iv = 2;</code>
				 * 
				 * @return The iv.
				 */
				@java.lang.Override
				public ByteString getIv() {
					return iv_;
				}

				/**
				 * <code>optional bytes iv = 2;</code>
				 * 
				 * @param value The iv to set.
				 * @return This builder for chaining.
				 */
				public Builder setIv(ByteString value) {
					if (value == null) {
						throw new NullPointerException();
					}
					iv_ = value;
					bitField0_ |= 0x00000002;
					onChanged();
					return this;
				}

				/**
				 * <code>optional bytes iv = 2;</code>
				 * 
				 * @return This builder for chaining.
				 */
				public Builder clearIv() {
					bitField0_ = (bitField0_ & ~0x00000002);
					iv_ = getDefaultInstance().getIv();
					onChanged();
					return this;
				}

				private ByteString key_ = ByteString.EMPTY;

				/**
				 * <code>optional bytes key = 3;</code>
				 * 
				 * @return Whether the key field is set.
				 */
				@java.lang.Override
				public boolean hasKey() {
					return ((bitField0_ & 0x00000004) != 0);
				}

				/**
				 * <code>optional bytes key = 3;</code>
				 * 
				 * @return The key.
				 */
				@java.lang.Override
				public ByteString getKey() {
					return key_;
				}

				/**
				 * <code>optional bytes key = 3;</code>
				 * 
				 * @param value The key to set.
				 * @return This builder for chaining.
				 */
				public Builder setKey(ByteString value) {
					if (value == null) {
						throw new NullPointerException();
					}
					key_ = value;
					bitField0_ |= 0x00000004;
					onChanged();
					return this;
				}

				/**
				 * <code>optional bytes key = 3;</code>
				 * 
				 * @return This builder for chaining.
				 */
				public Builder clearKey() {
					bitField0_ = (bitField0_ & ~0x00000004);
					key_ = getDefaultInstance().getKey();
					onChanged();
					return this;
				}

				private int type_ = 1;

				/**
				 * <code>optional .License.KeyContainer.KeyType type = 4;</code>
				 * 
				 * @return Whether the type field is set.
				 */
				@java.lang.Override
				public boolean hasType() {
					return ((bitField0_ & 0x00000008) != 0);
				}

				/**
				 * <code>optional .License.KeyContainer.KeyType type = 4;</code>
				 * 
				 * @return The type.
				 */
				@java.lang.Override
				public WvProto2.License.KeyContainer.KeyType getType() {
					WvProto2.License.KeyContainer.KeyType result = WvProto2.License.KeyContainer.KeyType
							.forNumber(type_);
					return result == null ? WvProto2.License.KeyContainer.KeyType.SIGNING
							: result;
				}

				/**
				 * <code>optional .License.KeyContainer.KeyType type = 4;</code>
				 * 
				 * @param value The type to set.
				 * @return This builder for chaining.
				 */
				public Builder setType(WvProto2.License.KeyContainer.KeyType value) {
					if (value == null) {
						throw new NullPointerException();
					}
					bitField0_ |= 0x00000008;
					type_ = value.getNumber();
					onChanged();
					return this;
				}

				/**
				 * <code>optional .License.KeyContainer.KeyType type = 4;</code>
				 * 
				 * @return This builder for chaining.
				 */
				public Builder clearType() {
					bitField0_ = (bitField0_ & ~0x00000008);
					type_ = 1;
					onChanged();
					return this;
				}

				private int level_ = 1;

				/**
				 * <code>optional .License.KeyContainer.SecurityLevel level = 5 [default = SW_SECURE_CRYPTO];</code>
				 * 
				 * @return Whether the level field is set.
				 */
				@java.lang.Override
				public boolean hasLevel() {
					return ((bitField0_ & 0x00000010) != 0);
				}

				/**
				 * <code>optional .License.KeyContainer.SecurityLevel level = 5 [default = SW_SECURE_CRYPTO];</code>
				 * 
				 * @return The level.
				 */
				@java.lang.Override
				public WvProto2.License.KeyContainer.SecurityLevel getLevel() {
					WvProto2.License.KeyContainer.SecurityLevel result = WvProto2.License.KeyContainer.SecurityLevel
							.forNumber(level_);
					return result == null
							? WvProto2.License.KeyContainer.SecurityLevel.SW_SECURE_CRYPTO
							: result;
				}

				/**
				 * <code>optional .License.KeyContainer.SecurityLevel level = 5 [default = SW_SECURE_CRYPTO];</code>
				 * 
				 * @param value The level to set.
				 * @return This builder for chaining.
				 */
				public Builder setLevel(WvProto2.License.KeyContainer.SecurityLevel value) {
					if (value == null) {
						throw new NullPointerException();
					}
					bitField0_ |= 0x00000010;
					level_ = value.getNumber();
					onChanged();
					return this;
				}

				/**
				 * <code>optional .License.KeyContainer.SecurityLevel level = 5 [default = SW_SECURE_CRYPTO];</code>
				 * 
				 * @return This builder for chaining.
				 */
				public Builder clearLevel() {
					bitField0_ = (bitField0_ & ~0x00000010);
					level_ = 1;
					onChanged();
					return this;
				}

				private WvProto2.License.KeyContainer.OutputProtection requiredProtection_;
				private SingleFieldBuilderV3<WvProto2.License.KeyContainer.OutputProtection, WvProto2.License.KeyContainer.OutputProtection.Builder, WvProto2.License.KeyContainer.OutputProtectionOrBuilder> requiredProtectionBuilder_;

				/**
				 * <code>optional .License.KeyContainer.OutputProtection required_protection = 6;</code>
				 * 
				 * @return Whether the requiredProtection field is set.
				 */
				@Override
				public boolean hasRequiredProtection() {
					return ((bitField0_ & 0x00000020) != 0);
				}

				/**
				 * <code>optional .License.KeyContainer.OutputProtection required_protection = 6;</code>
				 * 
				 * @return The requiredProtection.
				 */
				@Override
				public WvProto2.License.KeyContainer.OutputProtection getRequiredProtection() {
					if (requiredProtectionBuilder_ == null) {
						return requiredProtection_ == null
								? WvProto2.License.KeyContainer.OutputProtection
										.getDefaultInstance()
								: requiredProtection_;
					}
					return requiredProtectionBuilder_.getMessage();
				}

				/**
				 * <code>optional .License.KeyContainer.OutputProtection required_protection = 6;</code>
				 */
				public Builder setRequiredProtection(
						WvProto2.License.KeyContainer.OutputProtection value) {
					if (requiredProtectionBuilder_ == null) {
						if (value == null) {
							throw new NullPointerException();
						}
						requiredProtection_ = value;
					} else {
						requiredProtectionBuilder_.setMessage(value);
					}
					bitField0_ |= 0x00000020;
					onChanged();
					return this;
				}

				/**
				 * <code>optional .License.KeyContainer.OutputProtection required_protection = 6;</code>
				 */
				public Builder setRequiredProtection(
						WvProto2.License.KeyContainer.OutputProtection.Builder builderForValue) {
					if (requiredProtectionBuilder_ == null) {
						requiredProtection_ = builderForValue.build();
					} else {
						requiredProtectionBuilder_.setMessage(builderForValue.build());
					}
					bitField0_ |= 0x00000020;
					onChanged();
					return this;
				}

				/**
				 * <code>optional .License.KeyContainer.OutputProtection required_protection = 6;</code>
				 */
				public Builder mergeRequiredProtection(
						WvProto2.License.KeyContainer.OutputProtection value) {
					if (requiredProtectionBuilder_ == null) {
						if (((bitField0_ & 0x00000020) != 0) && requiredProtection_ != null
								&& requiredProtection_ != WvProto2.License.KeyContainer.OutputProtection
										.getDefaultInstance()) {
							getRequiredProtectionBuilder().mergeFrom(value);
						} else {
							requiredProtection_ = value;
						}
					} else {
						requiredProtectionBuilder_.mergeFrom(value);
					}
					bitField0_ |= 0x00000020;
					onChanged();
					return this;
				}

				/**
				 * <code>optional .License.KeyContainer.OutputProtection required_protection = 6;</code>
				 */
				public Builder clearRequiredProtection() {
					bitField0_ = (bitField0_ & ~0x00000020);
					requiredProtection_ = null;
					if (requiredProtectionBuilder_ != null) {
						requiredProtectionBuilder_.dispose();
						requiredProtectionBuilder_ = null;
					}
					onChanged();
					return this;
				}

				/**
				 * <code>optional .License.KeyContainer.OutputProtection required_protection = 6;</code>
				 */
				public WvProto2.License.KeyContainer.OutputProtection.Builder getRequiredProtectionBuilder() {
					bitField0_ |= 0x00000020;
					onChanged();
					return getRequiredProtectionFieldBuilder().getBuilder();
				}

				/**
				 * <code>optional .License.KeyContainer.OutputProtection required_protection = 6;</code>
				 */
				@Override
				public WvProto2.License.KeyContainer.OutputProtectionOrBuilder getRequiredProtectionOrBuilder() {
					if (requiredProtectionBuilder_ != null) {
						return requiredProtectionBuilder_.getMessageOrBuilder();
					}
					return requiredProtection_ == null
							? WvProto2.License.KeyContainer.OutputProtection
									.getDefaultInstance()
							: requiredProtection_;
				}

				/**
				 * <code>optional .License.KeyContainer.OutputProtection required_protection = 6;</code>
				 */
				private SingleFieldBuilderV3<WvProto2.License.KeyContainer.OutputProtection, WvProto2.License.KeyContainer.OutputProtection.Builder, WvProto2.License.KeyContainer.OutputProtectionOrBuilder> getRequiredProtectionFieldBuilder() {
					if (requiredProtectionBuilder_ == null) {
						requiredProtectionBuilder_ = new SingleFieldBuilderV3<>(getRequiredProtection(),
								getParentForChildren(), isClean());
						requiredProtection_ = null;
					}
					return requiredProtectionBuilder_;
				}

				private WvProto2.License.KeyContainer.OutputProtection requestedProtection_;
				private SingleFieldBuilderV3<WvProto2.License.KeyContainer.OutputProtection, WvProto2.License.KeyContainer.OutputProtection.Builder, WvProto2.License.KeyContainer.OutputProtectionOrBuilder> requestedProtectionBuilder_;

				/**
				 * <pre>
				 * NOTE: Use of requested_protection is not recommended as it is only
				 * supported on a small number of platforms.
				 * </pre>
				 *
				 * <code>optional .License.KeyContainer.OutputProtection requested_protection = 7;</code>
				 * 
				 * @return Whether the requestedProtection field is set.
				 */
				@Override
				public boolean hasRequestedProtection() {
					return ((bitField0_ & 0x00000040) != 0);
				}

				/**
				 * <pre>
				 * NOTE: Use of requested_protection is not recommended as it is only
				 * supported on a small number of platforms.
				 * </pre>
				 *
				 * <code>optional .License.KeyContainer.OutputProtection requested_protection = 7;</code>
				 * 
				 * @return The requestedProtection.
				 */
				@Override
				public WvProto2.License.KeyContainer.OutputProtection getRequestedProtection() {
					if (requestedProtectionBuilder_ == null) {
						return requestedProtection_ == null
								? WvProto2.License.KeyContainer.OutputProtection
										.getDefaultInstance()
								: requestedProtection_;
					}
					return requestedProtectionBuilder_.getMessage();
				}

				/**
				 * <pre>
				 * NOTE: Use of requested_protection is not recommended as it is only
				 * supported on a small number of platforms.
				 * </pre>
				 *
				 * <code>optional .License.KeyContainer.OutputProtection requested_protection = 7;</code>
				 */
				public Builder setRequestedProtection(
						WvProto2.License.KeyContainer.OutputProtection value) {
					if (requestedProtectionBuilder_ == null) {
						if (value == null) {
							throw new NullPointerException();
						}
						requestedProtection_ = value;
					} else {
						requestedProtectionBuilder_.setMessage(value);
					}
					bitField0_ |= 0x00000040;
					onChanged();
					return this;
				}

				/**
				 * <pre>
				 * NOTE: Use of requested_protection is not recommended as it is only
				 * supported on a small number of platforms.
				 * </pre>
				 *
				 * <code>optional .License.KeyContainer.OutputProtection requested_protection = 7;</code>
				 */
				public Builder setRequestedProtection(
						WvProto2.License.KeyContainer.OutputProtection.Builder builderForValue) {
					if (requestedProtectionBuilder_ == null) {
						requestedProtection_ = builderForValue.build();
					} else {
						requestedProtectionBuilder_.setMessage(builderForValue.build());
					}
					bitField0_ |= 0x00000040;
					onChanged();
					return this;
				}

				/**
				 * <pre>
				 * NOTE: Use of requested_protection is not recommended as it is only
				 * supported on a small number of platforms.
				 * </pre>
				 *
				 * <code>optional .License.KeyContainer.OutputProtection requested_protection = 7;</code>
				 */
				public Builder mergeRequestedProtection(
						WvProto2.License.KeyContainer.OutputProtection value) {
					if (requestedProtectionBuilder_ == null) {
						if (((bitField0_ & 0x00000040) != 0) && requestedProtection_ != null
								&& requestedProtection_ != WvProto2.License.KeyContainer.OutputProtection
										.getDefaultInstance()) {
							getRequestedProtectionBuilder().mergeFrom(value);
						} else {
							requestedProtection_ = value;
						}
					} else {
						requestedProtectionBuilder_.mergeFrom(value);
					}
					bitField0_ |= 0x00000040;
					onChanged();
					return this;
				}

				/**
				 * <pre>
				 * NOTE: Use of requested_protection is not recommended as it is only
				 * supported on a small number of platforms.
				 * </pre>
				 *
				 * <code>optional .License.KeyContainer.OutputProtection requested_protection = 7;</code>
				 */
				public Builder clearRequestedProtection() {
					bitField0_ = (bitField0_ & ~0x00000040);
					requestedProtection_ = null;
					if (requestedProtectionBuilder_ != null) {
						requestedProtectionBuilder_.dispose();
						requestedProtectionBuilder_ = null;
					}
					onChanged();
					return this;
				}

				/**
				 * <pre>
				 * NOTE: Use of requested_protection is not recommended as it is only
				 * supported on a small number of platforms.
				 * </pre>
				 *
				 * <code>optional .License.KeyContainer.OutputProtection requested_protection = 7;</code>
				 */
				public WvProto2.License.KeyContainer.OutputProtection.Builder getRequestedProtectionBuilder() {
					bitField0_ |= 0x00000040;
					onChanged();
					return getRequestedProtectionFieldBuilder().getBuilder();
				}

				/**
				 * <pre>
				 * NOTE: Use of requested_protection is not recommended as it is only
				 * supported on a small number of platforms.
				 * </pre>
				 *
				 * <code>optional .License.KeyContainer.OutputProtection requested_protection = 7;</code>
				 */
				@Override
				public WvProto2.License.KeyContainer.OutputProtectionOrBuilder getRequestedProtectionOrBuilder() {
					if (requestedProtectionBuilder_ != null) {
						return requestedProtectionBuilder_.getMessageOrBuilder();
					}
					return requestedProtection_ == null
							? WvProto2.License.KeyContainer.OutputProtection
									.getDefaultInstance()
							: requestedProtection_;
				}

				/**
				 * <pre>
				 * NOTE: Use of requested_protection is not recommended as it is only
				 * supported on a small number of platforms.
				 * </pre>
				 *
				 * <code>optional .License.KeyContainer.OutputProtection requested_protection = 7;</code>
				 */
				private SingleFieldBuilderV3<WvProto2.License.KeyContainer.OutputProtection, WvProto2.License.KeyContainer.OutputProtection.Builder, WvProto2.License.KeyContainer.OutputProtectionOrBuilder> getRequestedProtectionFieldBuilder() {
					if (requestedProtectionBuilder_ == null) {
						requestedProtectionBuilder_ = new SingleFieldBuilderV3<>(getRequestedProtection(),
								getParentForChildren(), isClean());
						requestedProtection_ = null;
					}
					return requestedProtectionBuilder_;
				}

				private WvProto2.License.KeyContainer.KeyControl keyControl_;
				private SingleFieldBuilderV3<WvProto2.License.KeyContainer.KeyControl, WvProto2.License.KeyContainer.KeyControl.Builder, WvProto2.License.KeyContainer.KeyControlOrBuilder> keyControlBuilder_;

				/**
				 * <code>optional .License.KeyContainer.KeyControl key_control = 8;</code>
				 * 
				 * @return Whether the keyControl field is set.
				 */
				@Override
				public boolean hasKeyControl() {
					return ((bitField0_ & 0x00000080) != 0);
				}

				/**
				 * <code>optional .License.KeyContainer.KeyControl key_control = 8;</code>
				 * 
				 * @return The keyControl.
				 */
				@Override
				public WvProto2.License.KeyContainer.KeyControl getKeyControl() {
					if (keyControlBuilder_ == null) {
						return keyControl_ == null
								? WvProto2.License.KeyContainer.KeyControl.getDefaultInstance()
								: keyControl_;
					}
					return keyControlBuilder_.getMessage();
				}

				/**
				 * <code>optional .License.KeyContainer.KeyControl key_control = 8;</code>
				 */
				public Builder setKeyControl(WvProto2.License.KeyContainer.KeyControl value) {
					if (keyControlBuilder_ == null) {
						if (value == null) {
							throw new NullPointerException();
						}
						keyControl_ = value;
					} else {
						keyControlBuilder_.setMessage(value);
					}
					bitField0_ |= 0x00000080;
					onChanged();
					return this;
				}

				/**
				 * <code>optional .License.KeyContainer.KeyControl key_control = 8;</code>
				 */
				public Builder setKeyControl(
						WvProto2.License.KeyContainer.KeyControl.Builder builderForValue) {
					if (keyControlBuilder_ == null) {
						keyControl_ = builderForValue.build();
					} else {
						keyControlBuilder_.setMessage(builderForValue.build());
					}
					bitField0_ |= 0x00000080;
					onChanged();
					return this;
				}

				/**
				 * <code>optional .License.KeyContainer.KeyControl key_control = 8;</code>
				 */
				public Builder mergeKeyControl(WvProto2.License.KeyContainer.KeyControl value) {
					if (keyControlBuilder_ == null) {
						if (((bitField0_ & 0x00000080) != 0) && keyControl_ != null
								&& keyControl_ != WvProto2.License.KeyContainer.KeyControl
										.getDefaultInstance()) {
							getKeyControlBuilder().mergeFrom(value);
						} else {
							keyControl_ = value;
						}
					} else {
						keyControlBuilder_.mergeFrom(value);
					}
					bitField0_ |= 0x00000080;
					onChanged();
					return this;
				}

				/**
				 * <code>optional .License.KeyContainer.KeyControl key_control = 8;</code>
				 */
				public Builder clearKeyControl() {
					bitField0_ = (bitField0_ & ~0x00000080);
					keyControl_ = null;
					if (keyControlBuilder_ != null) {
						keyControlBuilder_.dispose();
						keyControlBuilder_ = null;
					}
					onChanged();
					return this;
				}

				/**
				 * <code>optional .License.KeyContainer.KeyControl key_control = 8;</code>
				 */
				public WvProto2.License.KeyContainer.KeyControl.Builder getKeyControlBuilder() {
					bitField0_ |= 0x00000080;
					onChanged();
					return getKeyControlFieldBuilder().getBuilder();
				}

				/**
				 * <code>optional .License.KeyContainer.KeyControl key_control = 8;</code>
				 */
				@Override
				public WvProto2.License.KeyContainer.KeyControlOrBuilder getKeyControlOrBuilder() {
					if (keyControlBuilder_ != null) {
						return keyControlBuilder_.getMessageOrBuilder();
					}
					return keyControl_ == null
							? WvProto2.License.KeyContainer.KeyControl.getDefaultInstance()
							: keyControl_;
				}

				/**
				 * <code>optional .License.KeyContainer.KeyControl key_control = 8;</code>
				 */
				private SingleFieldBuilderV3<WvProto2.License.KeyContainer.KeyControl, WvProto2.License.KeyContainer.KeyControl.Builder, WvProto2.License.KeyContainer.KeyControlOrBuilder> getKeyControlFieldBuilder() {
					if (keyControlBuilder_ == null) {
						keyControlBuilder_ = new SingleFieldBuilderV3<>(getKeyControl(), getParentForChildren(),
								isClean());
						keyControl_ = null;
					}
					return keyControlBuilder_;
				}

				private WvProto2.License.KeyContainer.OperatorSessionKeyPermissions operatorSessionKeyPermissions_;
				private SingleFieldBuilderV3<WvProto2.License.KeyContainer.OperatorSessionKeyPermissions, WvProto2.License.KeyContainer.OperatorSessionKeyPermissions.Builder, WvProto2.License.KeyContainer.OperatorSessionKeyPermissionsOrBuilder> operatorSessionKeyPermissionsBuilder_;

				/**
				 * <code>optional .License.KeyContainer.OperatorSessionKeyPermissions operator_session_key_permissions = 9;</code>
				 * 
				 * @return Whether the operatorSessionKeyPermissions field is set.
				 */
				@Override
				public boolean hasOperatorSessionKeyPermissions() {
					return ((bitField0_ & 0x00000100) != 0);
				}

				/**
				 * <code>optional .License.KeyContainer.OperatorSessionKeyPermissions operator_session_key_permissions = 9;</code>
				 * 
				 * @return The operatorSessionKeyPermissions.
				 */
				@Override
				public WvProto2.License.KeyContainer.OperatorSessionKeyPermissions getOperatorSessionKeyPermissions() {
					if (operatorSessionKeyPermissionsBuilder_ == null) {
						return operatorSessionKeyPermissions_ == null
								? WvProto2.License.KeyContainer.OperatorSessionKeyPermissions
										.getDefaultInstance()
								: operatorSessionKeyPermissions_;
					}
					return operatorSessionKeyPermissionsBuilder_.getMessage();
				}

				/**
				 * <code>optional .License.KeyContainer.OperatorSessionKeyPermissions operator_session_key_permissions = 9;</code>
				 */
				public Builder setOperatorSessionKeyPermissions(
						WvProto2.License.KeyContainer.OperatorSessionKeyPermissions value) {
					if (operatorSessionKeyPermissionsBuilder_ == null) {
						if (value == null) {
							throw new NullPointerException();
						}
						operatorSessionKeyPermissions_ = value;
					} else {
						operatorSessionKeyPermissionsBuilder_.setMessage(value);
					}
					bitField0_ |= 0x00000100;
					onChanged();
					return this;
				}

				/**
				 * <code>optional .License.KeyContainer.OperatorSessionKeyPermissions operator_session_key_permissions = 9;</code>
				 */
				public Builder setOperatorSessionKeyPermissions(
						WvProto2.License.KeyContainer.OperatorSessionKeyPermissions.Builder builderForValue) {
					if (operatorSessionKeyPermissionsBuilder_ == null) {
						operatorSessionKeyPermissions_ = builderForValue.build();
					} else {
						operatorSessionKeyPermissionsBuilder_.setMessage(builderForValue.build());
					}
					bitField0_ |= 0x00000100;
					onChanged();
					return this;
				}

				/**
				 * <code>optional .License.KeyContainer.OperatorSessionKeyPermissions operator_session_key_permissions = 9;</code>
				 */
				public Builder mergeOperatorSessionKeyPermissions(
						WvProto2.License.KeyContainer.OperatorSessionKeyPermissions value) {
					if (operatorSessionKeyPermissionsBuilder_ == null) {
						if (((bitField0_ & 0x00000100) != 0) && operatorSessionKeyPermissions_ != null
								&& operatorSessionKeyPermissions_ != WvProto2.License.KeyContainer.OperatorSessionKeyPermissions
										.getDefaultInstance()) {
							getOperatorSessionKeyPermissionsBuilder().mergeFrom(value);
						} else {
							operatorSessionKeyPermissions_ = value;
						}
					} else {
						operatorSessionKeyPermissionsBuilder_.mergeFrom(value);
					}
					bitField0_ |= 0x00000100;
					onChanged();
					return this;
				}

				/**
				 * <code>optional .License.KeyContainer.OperatorSessionKeyPermissions operator_session_key_permissions = 9;</code>
				 */
				public Builder clearOperatorSessionKeyPermissions() {
					bitField0_ = (bitField0_ & ~0x00000100);
					operatorSessionKeyPermissions_ = null;
					if (operatorSessionKeyPermissionsBuilder_ != null) {
						operatorSessionKeyPermissionsBuilder_.dispose();
						operatorSessionKeyPermissionsBuilder_ = null;
					}
					onChanged();
					return this;
				}

				/**
				 * <code>optional .License.KeyContainer.OperatorSessionKeyPermissions operator_session_key_permissions = 9;</code>
				 */
				public WvProto2.License.KeyContainer.OperatorSessionKeyPermissions.Builder getOperatorSessionKeyPermissionsBuilder() {
					bitField0_ |= 0x00000100;
					onChanged();
					return getOperatorSessionKeyPermissionsFieldBuilder().getBuilder();
				}

				/**
				 * <code>optional .License.KeyContainer.OperatorSessionKeyPermissions operator_session_key_permissions = 9;</code>
				 */
				@Override
				public WvProto2.License.KeyContainer.OperatorSessionKeyPermissionsOrBuilder getOperatorSessionKeyPermissionsOrBuilder() {
					if (operatorSessionKeyPermissionsBuilder_ != null) {
						return operatorSessionKeyPermissionsBuilder_.getMessageOrBuilder();
					}
					return operatorSessionKeyPermissions_ == null
							? WvProto2.License.KeyContainer.OperatorSessionKeyPermissions
									.getDefaultInstance()
							: operatorSessionKeyPermissions_;
				}

				/**
				 * <code>optional .License.KeyContainer.OperatorSessionKeyPermissions operator_session_key_permissions = 9;</code>
				 */
				private SingleFieldBuilderV3<WvProto2.License.KeyContainer.OperatorSessionKeyPermissions, WvProto2.License.KeyContainer.OperatorSessionKeyPermissions.Builder, WvProto2.License.KeyContainer.OperatorSessionKeyPermissionsOrBuilder> getOperatorSessionKeyPermissionsFieldBuilder() {
					if (operatorSessionKeyPermissionsBuilder_ == null) {
						operatorSessionKeyPermissionsBuilder_ = new SingleFieldBuilderV3<>(
								getOperatorSessionKeyPermissions(), getParentForChildren(), isClean());
						operatorSessionKeyPermissions_ = null;
					}
					return operatorSessionKeyPermissionsBuilder_;
				}

				private java.util.List<WvProto2.License.KeyContainer.VideoResolutionConstraint> videoResolutionConstraints_ = java.util.Collections
						.emptyList();

				private void ensureVideoResolutionConstraintsIsMutable() {
					if (!((bitField0_ & 0x00000200) != 0)) {
						videoResolutionConstraints_ = new java.util.ArrayList<>(videoResolutionConstraints_);
						bitField0_ |= 0x00000200;
					}
				}

				private RepeatedFieldBuilderV3<WvProto2.License.KeyContainer.VideoResolutionConstraint, WvProto2.License.KeyContainer.VideoResolutionConstraint.Builder, WvProto2.License.KeyContainer.VideoResolutionConstraintOrBuilder> videoResolutionConstraintsBuilder_;

				/**
				 * <pre>
				 * Optional video resolution constraints. If the video resolution of the
				 * content being decrypted/decoded falls within one of the specified ranges,
				 * the optional required_protections may be applied. Otherwise an error will
				 * be reported.
				 * NOTE: Use of this feature is not recommended, as it is only supported on
				 * a small number of platforms.
				 * </pre>
				 *
				 * <code>repeated .License.KeyContainer.VideoResolutionConstraint video_resolution_constraints = 10;</code>
				 */
				@Override
				public java.util.List<WvProto2.License.KeyContainer.VideoResolutionConstraint> getVideoResolutionConstraintsList() {
					if (videoResolutionConstraintsBuilder_ == null) {
						return java.util.Collections.unmodifiableList(videoResolutionConstraints_);
					}
					return videoResolutionConstraintsBuilder_.getMessageList();
				}

				/**
				 * <pre>
				 * Optional video resolution constraints. If the video resolution of the
				 * content being decrypted/decoded falls within one of the specified ranges,
				 * the optional required_protections may be applied. Otherwise an error will
				 * be reported.
				 * NOTE: Use of this feature is not recommended, as it is only supported on
				 * a small number of platforms.
				 * </pre>
				 *
				 * <code>repeated .License.KeyContainer.VideoResolutionConstraint video_resolution_constraints = 10;</code>
				 */
				@Override
				public int getVideoResolutionConstraintsCount() {
					if (videoResolutionConstraintsBuilder_ == null) {
						return videoResolutionConstraints_.size();
					}
					return videoResolutionConstraintsBuilder_.getCount();
				}

				/**
				 * <pre>
				 * Optional video resolution constraints. If the video resolution of the
				 * content being decrypted/decoded falls within one of the specified ranges,
				 * the optional required_protections may be applied. Otherwise an error will
				 * be reported.
				 * NOTE: Use of this feature is not recommended, as it is only supported on
				 * a small number of platforms.
				 * </pre>
				 *
				 * <code>repeated .License.KeyContainer.VideoResolutionConstraint video_resolution_constraints = 10;</code>
				 */
				@Override
				public WvProto2.License.KeyContainer.VideoResolutionConstraint getVideoResolutionConstraints(
						int index) {
					if (videoResolutionConstraintsBuilder_ == null) {
						return videoResolutionConstraints_.get(index);
					}
					return videoResolutionConstraintsBuilder_.getMessage(index);
				}

				/**
				 * <pre>
				 * Optional video resolution constraints. If the video resolution of the
				 * content being decrypted/decoded falls within one of the specified ranges,
				 * the optional required_protections may be applied. Otherwise an error will
				 * be reported.
				 * NOTE: Use of this feature is not recommended, as it is only supported on
				 * a small number of platforms.
				 * </pre>
				 *
				 * <code>repeated .License.KeyContainer.VideoResolutionConstraint video_resolution_constraints = 10;</code>
				 */
				public Builder setVideoResolutionConstraints(int index,
						WvProto2.License.KeyContainer.VideoResolutionConstraint value) {
					if (videoResolutionConstraintsBuilder_ == null) {
						if (value == null) {
							throw new NullPointerException();
						}
						ensureVideoResolutionConstraintsIsMutable();
						videoResolutionConstraints_.set(index, value);
						onChanged();
					} else {
						videoResolutionConstraintsBuilder_.setMessage(index, value);
					}
					return this;
				}

				/**
				 * <pre>
				 * Optional video resolution constraints. If the video resolution of the
				 * content being decrypted/decoded falls within one of the specified ranges,
				 * the optional required_protections may be applied. Otherwise an error will
				 * be reported.
				 * NOTE: Use of this feature is not recommended, as it is only supported on
				 * a small number of platforms.
				 * </pre>
				 *
				 * <code>repeated .License.KeyContainer.VideoResolutionConstraint video_resolution_constraints = 10;</code>
				 */
				public Builder setVideoResolutionConstraints(int index,
						WvProto2.License.KeyContainer.VideoResolutionConstraint.Builder builderForValue) {
					if (videoResolutionConstraintsBuilder_ == null) {
						ensureVideoResolutionConstraintsIsMutable();
						videoResolutionConstraints_.set(index, builderForValue.build());
						onChanged();
					} else {
						videoResolutionConstraintsBuilder_.setMessage(index, builderForValue.build());
					}
					return this;
				}

				/**
				 * <pre>
				 * Optional video resolution constraints. If the video resolution of the
				 * content being decrypted/decoded falls within one of the specified ranges,
				 * the optional required_protections may be applied. Otherwise an error will
				 * be reported.
				 * NOTE: Use of this feature is not recommended, as it is only supported on
				 * a small number of platforms.
				 * </pre>
				 *
				 * <code>repeated .License.KeyContainer.VideoResolutionConstraint video_resolution_constraints = 10;</code>
				 */
				public Builder addVideoResolutionConstraints(
						WvProto2.License.KeyContainer.VideoResolutionConstraint value) {
					if (videoResolutionConstraintsBuilder_ == null) {
						if (value == null) {
							throw new NullPointerException();
						}
						ensureVideoResolutionConstraintsIsMutable();
						videoResolutionConstraints_.add(value);
						onChanged();
					} else {
						videoResolutionConstraintsBuilder_.addMessage(value);
					}
					return this;
				}

				/**
				 * <pre>
				 * Optional video resolution constraints. If the video resolution of the
				 * content being decrypted/decoded falls within one of the specified ranges,
				 * the optional required_protections may be applied. Otherwise an error will
				 * be reported.
				 * NOTE: Use of this feature is not recommended, as it is only supported on
				 * a small number of platforms.
				 * </pre>
				 *
				 * <code>repeated .License.KeyContainer.VideoResolutionConstraint video_resolution_constraints = 10;</code>
				 */
				public Builder addVideoResolutionConstraints(int index,
						WvProto2.License.KeyContainer.VideoResolutionConstraint value) {
					if (videoResolutionConstraintsBuilder_ == null) {
						if (value == null) {
							throw new NullPointerException();
						}
						ensureVideoResolutionConstraintsIsMutable();
						videoResolutionConstraints_.add(index, value);
						onChanged();
					} else {
						videoResolutionConstraintsBuilder_.addMessage(index, value);
					}
					return this;
				}

				/**
				 * <pre>
				 * Optional video resolution constraints. If the video resolution of the
				 * content being decrypted/decoded falls within one of the specified ranges,
				 * the optional required_protections may be applied. Otherwise an error will
				 * be reported.
				 * NOTE: Use of this feature is not recommended, as it is only supported on
				 * a small number of platforms.
				 * </pre>
				 *
				 * <code>repeated .License.KeyContainer.VideoResolutionConstraint video_resolution_constraints = 10;</code>
				 */
				public Builder addVideoResolutionConstraints(
						WvProto2.License.KeyContainer.VideoResolutionConstraint.Builder builderForValue) {
					if (videoResolutionConstraintsBuilder_ == null) {
						ensureVideoResolutionConstraintsIsMutable();
						videoResolutionConstraints_.add(builderForValue.build());
						onChanged();
					} else {
						videoResolutionConstraintsBuilder_.addMessage(builderForValue.build());
					}
					return this;
				}

				/**
				 * <pre>
				 * Optional video resolution constraints. If the video resolution of the
				 * content being decrypted/decoded falls within one of the specified ranges,
				 * the optional required_protections may be applied. Otherwise an error will
				 * be reported.
				 * NOTE: Use of this feature is not recommended, as it is only supported on
				 * a small number of platforms.
				 * </pre>
				 *
				 * <code>repeated .License.KeyContainer.VideoResolutionConstraint video_resolution_constraints = 10;</code>
				 */
				public Builder addVideoResolutionConstraints(int index,
						WvProto2.License.KeyContainer.VideoResolutionConstraint.Builder builderForValue) {
					if (videoResolutionConstraintsBuilder_ == null) {
						ensureVideoResolutionConstraintsIsMutable();
						videoResolutionConstraints_.add(index, builderForValue.build());
						onChanged();
					} else {
						videoResolutionConstraintsBuilder_.addMessage(index, builderForValue.build());
					}
					return this;
				}

				/**
				 * <pre>
				 * Optional video resolution constraints. If the video resolution of the
				 * content being decrypted/decoded falls within one of the specified ranges,
				 * the optional required_protections may be applied. Otherwise an error will
				 * be reported.
				 * NOTE: Use of this feature is not recommended, as it is only supported on
				 * a small number of platforms.
				 * </pre>
				 *
				 * <code>repeated .License.KeyContainer.VideoResolutionConstraint video_resolution_constraints = 10;</code>
				 */
				public Builder addAllVideoResolutionConstraints(
						java.lang.Iterable<? extends WvProto2.License.KeyContainer.VideoResolutionConstraint> values) {
					if (videoResolutionConstraintsBuilder_ == null) {
						ensureVideoResolutionConstraintsIsMutable();
						AbstractMessageLite.Builder.addAll(values, videoResolutionConstraints_);
						onChanged();
					} else {
						videoResolutionConstraintsBuilder_.addAllMessages(values);
					}
					return this;
				}

				/**
				 * <pre>
				 * Optional video resolution constraints. If the video resolution of the
				 * content being decrypted/decoded falls within one of the specified ranges,
				 * the optional required_protections may be applied. Otherwise an error will
				 * be reported.
				 * NOTE: Use of this feature is not recommended, as it is only supported on
				 * a small number of platforms.
				 * </pre>
				 *
				 * <code>repeated .License.KeyContainer.VideoResolutionConstraint video_resolution_constraints = 10;</code>
				 */
				public Builder clearVideoResolutionConstraints() {
					if (videoResolutionConstraintsBuilder_ == null) {
						videoResolutionConstraints_ = java.util.Collections.emptyList();
						bitField0_ = (bitField0_ & ~0x00000200);
						onChanged();
					} else {
						videoResolutionConstraintsBuilder_.clear();
					}
					return this;
				}

				/**
				 * <pre>
				 * Optional video resolution constraints. If the video resolution of the
				 * content being decrypted/decoded falls within one of the specified ranges,
				 * the optional required_protections may be applied. Otherwise an error will
				 * be reported.
				 * NOTE: Use of this feature is not recommended, as it is only supported on
				 * a small number of platforms.
				 * </pre>
				 *
				 * <code>repeated .License.KeyContainer.VideoResolutionConstraint video_resolution_constraints = 10;</code>
				 */
				public Builder removeVideoResolutionConstraints(int index) {
					if (videoResolutionConstraintsBuilder_ == null) {
						ensureVideoResolutionConstraintsIsMutable();
						videoResolutionConstraints_.remove(index);
						onChanged();
					} else {
						videoResolutionConstraintsBuilder_.remove(index);
					}
					return this;
				}

				/**
				 * <pre>
				 * Optional video resolution constraints. If the video resolution of the
				 * content being decrypted/decoded falls within one of the specified ranges,
				 * the optional required_protections may be applied. Otherwise an error will
				 * be reported.
				 * NOTE: Use of this feature is not recommended, as it is only supported on
				 * a small number of platforms.
				 * </pre>
				 *
				 * <code>repeated .License.KeyContainer.VideoResolutionConstraint video_resolution_constraints = 10;</code>
				 */
				public WvProto2.License.KeyContainer.VideoResolutionConstraint.Builder getVideoResolutionConstraintsBuilder(
						int index) {
					return getVideoResolutionConstraintsFieldBuilder().getBuilder(index);
				}

				/**
				 * <pre>
				 * Optional video resolution constraints. If the video resolution of the
				 * content being decrypted/decoded falls within one of the specified ranges,
				 * the optional required_protections may be applied. Otherwise an error will
				 * be reported.
				 * NOTE: Use of this feature is not recommended, as it is only supported on
				 * a small number of platforms.
				 * </pre>
				 *
				 * <code>repeated .License.KeyContainer.VideoResolutionConstraint video_resolution_constraints = 10;</code>
				 */
				@Override
				public WvProto2.License.KeyContainer.VideoResolutionConstraintOrBuilder getVideoResolutionConstraintsOrBuilder(
						int index) {
					if (videoResolutionConstraintsBuilder_ == null) {
						return videoResolutionConstraints_.get(index);
					}
					return videoResolutionConstraintsBuilder_.getMessageOrBuilder(index);
				}

				/**
				 * <pre>
				 * Optional video resolution constraints. If the video resolution of the
				 * content being decrypted/decoded falls within one of the specified ranges,
				 * the optional required_protections may be applied. Otherwise an error will
				 * be reported.
				 * NOTE: Use of this feature is not recommended, as it is only supported on
				 * a small number of platforms.
				 * </pre>
				 *
				 * <code>repeated .License.KeyContainer.VideoResolutionConstraint video_resolution_constraints = 10;</code>
				 */
				@Override
				public java.util.List<? extends WvProto2.License.KeyContainer.VideoResolutionConstraintOrBuilder> getVideoResolutionConstraintsOrBuilderList() {
					if (videoResolutionConstraintsBuilder_ != null) {
						return videoResolutionConstraintsBuilder_.getMessageOrBuilderList();
					}
					return java.util.Collections.unmodifiableList(videoResolutionConstraints_);
				}

				/**
				 * <pre>
				 * Optional video resolution constraints. If the video resolution of the
				 * content being decrypted/decoded falls within one of the specified ranges,
				 * the optional required_protections may be applied. Otherwise an error will
				 * be reported.
				 * NOTE: Use of this feature is not recommended, as it is only supported on
				 * a small number of platforms.
				 * </pre>
				 *
				 * <code>repeated .License.KeyContainer.VideoResolutionConstraint video_resolution_constraints = 10;</code>
				 */
				public WvProto2.License.KeyContainer.VideoResolutionConstraint.Builder addVideoResolutionConstraintsBuilder() {
					return getVideoResolutionConstraintsFieldBuilder()
							.addBuilder(WvProto2.License.KeyContainer.VideoResolutionConstraint
									.getDefaultInstance());
				}

				/**
				 * <pre>
				 * Optional video resolution constraints. If the video resolution of the
				 * content being decrypted/decoded falls within one of the specified ranges,
				 * the optional required_protections may be applied. Otherwise an error will
				 * be reported.
				 * NOTE: Use of this feature is not recommended, as it is only supported on
				 * a small number of platforms.
				 * </pre>
				 *
				 * <code>repeated .License.KeyContainer.VideoResolutionConstraint video_resolution_constraints = 10;</code>
				 */
				public WvProto2.License.KeyContainer.VideoResolutionConstraint.Builder addVideoResolutionConstraintsBuilder(
						int index) {
					return getVideoResolutionConstraintsFieldBuilder().addBuilder(index,
							WvProto2.License.KeyContainer.VideoResolutionConstraint
									.getDefaultInstance());
				}

				/**
				 * <pre>
				 * Optional video resolution constraints. If the video resolution of the
				 * content being decrypted/decoded falls within one of the specified ranges,
				 * the optional required_protections may be applied. Otherwise an error will
				 * be reported.
				 * NOTE: Use of this feature is not recommended, as it is only supported on
				 * a small number of platforms.
				 * </pre>
				 *
				 * <code>repeated .License.KeyContainer.VideoResolutionConstraint video_resolution_constraints = 10;</code>
				 */
				public java.util.List<WvProto2.License.KeyContainer.VideoResolutionConstraint.Builder> getVideoResolutionConstraintsBuilderList() {
					return getVideoResolutionConstraintsFieldBuilder().getBuilderList();
				}

				private RepeatedFieldBuilderV3<WvProto2.License.KeyContainer.VideoResolutionConstraint, WvProto2.License.KeyContainer.VideoResolutionConstraint.Builder, WvProto2.License.KeyContainer.VideoResolutionConstraintOrBuilder> getVideoResolutionConstraintsFieldBuilder() {
					if (videoResolutionConstraintsBuilder_ == null) {
						videoResolutionConstraintsBuilder_ = new RepeatedFieldBuilderV3<>(videoResolutionConstraints_,
								((bitField0_ & 0x00000200) != 0), getParentForChildren(), isClean());
						videoResolutionConstraints_ = null;
					}
					return videoResolutionConstraintsBuilder_;
				}

				private boolean antiRollbackUsageTable_;

				/**
				 * <pre>
				 * Optional flag to indicate the key must only be used if the client
				 * supports anti rollback of the user table.  Content provider can query the
				 * client capabilities to determine if the client support this feature.
				 * </pre>
				 *
				 * <code>optional bool anti_rollback_usage_table = 11 [default = false];</code>
				 * 
				 * @return Whether the antiRollbackUsageTable field is set.
				 */
				@java.lang.Override
				public boolean hasAntiRollbackUsageTable() {
					return ((bitField0_ & 0x00000400) != 0);
				}

				/**
				 * <pre>
				 * Optional flag to indicate the key must only be used if the client
				 * supports anti rollback of the user table.  Content provider can query the
				 * client capabilities to determine if the client support this feature.
				 * </pre>
				 *
				 * <code>optional bool anti_rollback_usage_table = 11 [default = false];</code>
				 * 
				 * @return The antiRollbackUsageTable.
				 */
				@java.lang.Override
				public boolean getAntiRollbackUsageTable() {
					return antiRollbackUsageTable_;
				}

				/**
				 * <pre>
				 * Optional flag to indicate the key must only be used if the client
				 * supports anti rollback of the user table.  Content provider can query the
				 * client capabilities to determine if the client support this feature.
				 * </pre>
				 *
				 * <code>optional bool anti_rollback_usage_table = 11 [default = false];</code>
				 * 
				 * @param value The antiRollbackUsageTable to set.
				 * @return This builder for chaining.
				 */
				public Builder setAntiRollbackUsageTable(boolean value) {

					antiRollbackUsageTable_ = value;
					bitField0_ |= 0x00000400;
					onChanged();
					return this;
				}

				/**
				 * <pre>
				 * Optional flag to indicate the key must only be used if the client
				 * supports anti rollback of the user table.  Content provider can query the
				 * client capabilities to determine if the client support this feature.
				 * </pre>
				 *
				 * <code>optional bool anti_rollback_usage_table = 11 [default = false];</code>
				 * 
				 * @return This builder for chaining.
				 */
				public Builder clearAntiRollbackUsageTable() {
					bitField0_ = (bitField0_ & ~0x00000400);
					antiRollbackUsageTable_ = false;
					onChanged();
					return this;
				}

				private java.lang.Object trackLabel_ = "";

				/**
				 * <pre>
				 * Optional not limited to commonly known track types such as SD, HD.
				 * It can be some provider defined label to identify the track.
				 * </pre>
				 *
				 * <code>optional string track_label = 12;</code>
				 * 
				 * @return Whether the trackLabel field is set.
				 */
				@Override
				public boolean hasTrackLabel() {
					return ((bitField0_ & 0x00000800) != 0);
				}

				/**
				 * <pre>
				 * Optional not limited to commonly known track types such as SD, HD.
				 * It can be some provider defined label to identify the track.
				 * </pre>
				 *
				 * <code>optional string track_label = 12;</code>
				 * 
				 * @return The trackLabel.
				 */
				@Override
				public java.lang.String getTrackLabel() {
					java.lang.Object ref = trackLabel_;
					if (!(ref instanceof java.lang.String)) {
						ByteString bs = (ByteString) ref;
						java.lang.String s = bs.toStringUtf8();
						if (bs.isValidUtf8()) {
							trackLabel_ = s;
						}
						return s;
					}
					return (java.lang.String) ref;
				}

				/**
				 * <pre>
				 * Optional not limited to commonly known track types such as SD, HD.
				 * It can be some provider defined label to identify the track.
				 * </pre>
				 *
				 * <code>optional string track_label = 12;</code>
				 * 
				 * @return The bytes for trackLabel.
				 */
				@Override
				public ByteString getTrackLabelBytes() {
					java.lang.Object ref = trackLabel_;
					if (ref instanceof String) {
						ByteString b = ByteString.copyFromUtf8((java.lang.String) ref);
						trackLabel_ = b;
						return b;
					}
					return (ByteString) ref;
				}

				/**
				 * <pre>
				 * Optional not limited to commonly known track types such as SD, HD.
				 * It can be some provider defined label to identify the track.
				 * </pre>
				 *
				 * <code>optional string track_label = 12;</code>
				 * 
				 * @param value The trackLabel to set.
				 * @return This builder for chaining.
				 */
				public Builder setTrackLabel(java.lang.String value) {
					if (value == null) {
						throw new NullPointerException();
					}
					trackLabel_ = value;
					bitField0_ |= 0x00000800;
					onChanged();
					return this;
				}

				/**
				 * <pre>
				 * Optional not limited to commonly known track types such as SD, HD.
				 * It can be some provider defined label to identify the track.
				 * </pre>
				 *
				 * <code>optional string track_label = 12;</code>
				 * 
				 * @return This builder for chaining.
				 */
				public Builder clearTrackLabel() {
					trackLabel_ = getDefaultInstance().getTrackLabel();
					bitField0_ = (bitField0_ & ~0x00000800);
					onChanged();
					return this;
				}

				/**
				 * <pre>
				 * Optional not limited to commonly known track types such as SD, HD.
				 * It can be some provider defined label to identify the track.
				 * </pre>
				 *
				 * <code>optional string track_label = 12;</code>
				 * 
				 * @param value The bytes for trackLabel to set.
				 * @return This builder for chaining.
				 */
				public Builder setTrackLabelBytes(ByteString value) {
					if (value == null) {
						throw new NullPointerException();
					}
					trackLabel_ = value;
					bitField0_ |= 0x00000800;
					onChanged();
					return this;
				}

				@java.lang.Override
				public final Builder setUnknownFields(final UnknownFieldSet unknownFields) {
					return super.setUnknownFields(unknownFields);
				}

				@java.lang.Override
				public final Builder mergeUnknownFields(final UnknownFieldSet unknownFields) {
					return super.mergeUnknownFields(unknownFields);
				}

				// @@protoc_insertion_point(builder_scope:License.KeyContainer)
			}

			// @@protoc_insertion_point(class_scope:License.KeyContainer)
			private static final WvProto2.License.KeyContainer DEFAULT_INSTANCE;
			static {
				DEFAULT_INSTANCE = new WvProto2.License.KeyContainer();
			}

			public static WvProto2.License.KeyContainer getDefaultInstance() {
				return DEFAULT_INSTANCE;
			}

			@java.lang.Deprecated public static final Parser<KeyContainer> PARSER = new AbstractParser<>() {
				@java.lang.Override
				public KeyContainer parsePartialFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
						throws InvalidProtocolBufferException {
					Builder builder = newBuilder();
					try {
						builder.mergeFrom(input, extensionRegistry);
					} catch (InvalidProtocolBufferException e) {
						throw e.setUnfinishedMessage(builder.buildPartial());
					} catch (UninitializedMessageException e) {
						throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
					} catch (java.io.IOException e) {
						throw new InvalidProtocolBufferException(e).setUnfinishedMessage(builder.buildPartial());
					}
					return builder.buildPartial();
				}
			};

			public static Parser<KeyContainer> parser() {
				return PARSER;
			}

			@java.lang.Override
			public Parser<KeyContainer> getParserForType() {
				return PARSER;
			}

			@java.lang.Override
			public WvProto2.License.KeyContainer getDefaultInstanceForType() {
				return DEFAULT_INSTANCE;
			}

		}

		private int bitField0_;
		public static final int ID_FIELD_NUMBER = 1;
		private WvProto2.LicenseIdentification id_;

		/**
		 * <code>optional .LicenseIdentification id = 1;</code>
		 * 
		 * @return Whether the id field is set.
		 */
		@java.lang.Override
		public boolean hasId() {
			return ((bitField0_ & 0x00000001) != 0);
		}

		/**
		 * <code>optional .LicenseIdentification id = 1;</code>
		 * 
		 * @return The id.
		 */
		@java.lang.Override
		public WvProto2.LicenseIdentification getId() {
			return id_ == null ? WvProto2.LicenseIdentification.getDefaultInstance() : id_;
		}

		/**
		 * <code>optional .LicenseIdentification id = 1;</code>
		 */
		@java.lang.Override
		public WvProto2.LicenseIdentificationOrBuilder getIdOrBuilder() {
			return id_ == null ? WvProto2.LicenseIdentification.getDefaultInstance() : id_;
		}

		public static final int POLICY_FIELD_NUMBER = 2;
		private WvProto2.License.Policy policy_;

		/**
		 * <code>optional .License.Policy policy = 2;</code>
		 * 
		 * @return Whether the policy field is set.
		 */
		@java.lang.Override
		public boolean hasPolicy() {
			return ((bitField0_ & 0x00000002) != 0);
		}

		/**
		 * <code>optional .License.Policy policy = 2;</code>
		 * 
		 * @return The policy.
		 */
		@java.lang.Override
		public WvProto2.License.Policy getPolicy() {
			return policy_ == null ? WvProto2.License.Policy.getDefaultInstance() : policy_;
		}

		/**
		 * <code>optional .License.Policy policy = 2;</code>
		 */
		@java.lang.Override
		public WvProto2.License.PolicyOrBuilder getPolicyOrBuilder() {
			return policy_ == null ? WvProto2.License.Policy.getDefaultInstance() : policy_;
		}

		public static final int KEY_FIELD_NUMBER = 3;

		private java.util.List<WvProto2.License.KeyContainer> key_;

		/**
		 * <code>repeated .License.KeyContainer key = 3;</code>
		 */
		@java.lang.Override
		public java.util.List<WvProto2.License.KeyContainer> getKeyList() {
			return key_;
		}

		/**
		 * <code>repeated .License.KeyContainer key = 3;</code>
		 */
		@java.lang.Override
		public java.util.List<? extends WvProto2.License.KeyContainerOrBuilder> getKeyOrBuilderList() {
			return key_;
		}

		/**
		 * <code>repeated .License.KeyContainer key = 3;</code>
		 */
		@java.lang.Override
		public int getKeyCount() {
			return key_.size();
		}

		/**
		 * <code>repeated .License.KeyContainer key = 3;</code>
		 */
		@java.lang.Override
		public WvProto2.License.KeyContainer getKey(int index) {
			return key_.get(index);
		}

		/**
		 * <code>repeated .License.KeyContainer key = 3;</code>
		 */
		@java.lang.Override
		public WvProto2.License.KeyContainerOrBuilder getKeyOrBuilder(int index) {
			return key_.get(index);
		}

		public static final int LICENSE_START_TIME_FIELD_NUMBER = 4;
		private long licenseStartTime_ = 0L;

		/**
		 * <pre>
		 * Time of the request in seconds (UTC) as set in
		 * LicenseRequest.request_time.  If this time is not set in the request,
		 * the local time at the license service is used in this field.
		 * </pre>
		 *
		 * <code>optional int64 license_start_time = 4;</code>
		 * 
		 * @return Whether the licenseStartTime field is set.
		 */
		@java.lang.Override
		public boolean hasLicenseStartTime() {
			return ((bitField0_ & 0x00000004) != 0);
		}

		/**
		 * <pre>
		 * Time of the request in seconds (UTC) as set in
		 * LicenseRequest.request_time.  If this time is not set in the request,
		 * the local time at the license service is used in this field.
		 * </pre>
		 *
		 * <code>optional int64 license_start_time = 4;</code>
		 * 
		 * @return The licenseStartTime.
		 */
		@java.lang.Override
		public long getLicenseStartTime() {
			return licenseStartTime_;
		}

		public static final int REMOTE_ATTESTATION_VERIFIED_FIELD_NUMBER = 5;
		private boolean remoteAttestationVerified_ = false;

		/**
		 * <code>optional bool remote_attestation_verified = 5 [default = false];</code>
		 * 
		 * @return Whether the remoteAttestationVerified field is set.
		 */
		@java.lang.Override
		public boolean hasRemoteAttestationVerified() {
			return ((bitField0_ & 0x00000008) != 0);
		}

		/**
		 * <code>optional bool remote_attestation_verified = 5 [default = false];</code>
		 * 
		 * @return The remoteAttestationVerified.
		 */
		@java.lang.Override
		public boolean getRemoteAttestationVerified() {
			return remoteAttestationVerified_;
		}

		public static final int PROVIDER_CLIENT_TOKEN_FIELD_NUMBER = 6;
		private ByteString providerClientToken_ = ByteString.EMPTY;

		/**
		 * <pre>
		 * Client token generated by the content provider. Optional.
		 * </pre>
		 *
		 * <code>optional bytes provider_client_token = 6;</code>
		 * 
		 * @return Whether the providerClientToken field is set.
		 */
		@java.lang.Override
		public boolean hasProviderClientToken() {
			return ((bitField0_ & 0x00000010) != 0);
		}

		/**
		 * <pre>
		 * Client token generated by the content provider. Optional.
		 * </pre>
		 *
		 * <code>optional bytes provider_client_token = 6;</code>
		 * 
		 * @return The providerClientToken.
		 */
		@java.lang.Override
		public ByteString getProviderClientToken() {
			return providerClientToken_;
		}

		public static final int PROTECTION_SCHEME_FIELD_NUMBER = 7;
		private int protectionScheme_ = 0;

		/**
		 * <pre>
		 * 4cc code specifying the CENC protection scheme as defined in the CENC 3.0
		 * specification. Propagated from Widevine PSSH box. Optional.
		 * </pre>
		 *
		 * <code>optional uint32 protection_scheme = 7;</code>
		 * 
		 * @return Whether the protectionScheme field is set.
		 */
		@java.lang.Override
		public boolean hasProtectionScheme() {
			return ((bitField0_ & 0x00000020) != 0);
		}

		/**
		 * <pre>
		 * 4cc code specifying the CENC protection scheme as defined in the CENC 3.0
		 * specification. Propagated from Widevine PSSH box. Optional.
		 * </pre>
		 *
		 * <code>optional uint32 protection_scheme = 7;</code>
		 * 
		 * @return The protectionScheme.
		 */
		@java.lang.Override
		public int getProtectionScheme() {
			return protectionScheme_;
		}

		public static final int SRM_REQUIREMENT_FIELD_NUMBER = 8;
		private ByteString srmRequirement_ = ByteString.EMPTY;

		/**
		 * <pre>
		 * 8 byte verification field "HDCPDATA" followed by unsigned 32 bit minimum
		 * HDCP SRM version (whether the version is for HDCP1 SRM or HDCP2 SRM
		 * depends on client max_hdcp_version).
		 * Additional details can be found in Widevine Modular DRM Security
		 * Integration Guide for CENC.
		 * </pre>
		 *
		 * <code>optional bytes srm_requirement = 8;</code>
		 * 
		 * @return Whether the srmRequirement field is set.
		 */
		@java.lang.Override
		public boolean hasSrmRequirement() {
			return ((bitField0_ & 0x00000040) != 0);
		}

		/**
		 * <pre>
		 * 8 byte verification field "HDCPDATA" followed by unsigned 32 bit minimum
		 * HDCP SRM version (whether the version is for HDCP1 SRM or HDCP2 SRM
		 * depends on client max_hdcp_version).
		 * Additional details can be found in Widevine Modular DRM Security
		 * Integration Guide for CENC.
		 * </pre>
		 *
		 * <code>optional bytes srm_requirement = 8;</code>
		 * 
		 * @return The srmRequirement.
		 */
		@java.lang.Override
		public ByteString getSrmRequirement() {
			return srmRequirement_;
		}

		public static final int SRM_UPDATE_FIELD_NUMBER = 9;
		private ByteString srmUpdate_ = ByteString.EMPTY;

		/**
		 * <pre>
		 * If present this contains a signed SRM file (either HDCP1 SRM or HDCP2 SRM
		 * depending on client max_hdcp_version) that should be installed on the
		 * client device.
		 * </pre>
		 *
		 * <code>optional bytes srm_update = 9;</code>
		 * 
		 * @return Whether the srmUpdate field is set.
		 */
		@java.lang.Override
		public boolean hasSrmUpdate() {
			return ((bitField0_ & 0x00000080) != 0);
		}

		/**
		 * <pre>
		 * If present this contains a signed SRM file (either HDCP1 SRM or HDCP2 SRM
		 * depending on client max_hdcp_version) that should be installed on the
		 * client device.
		 * </pre>
		 *
		 * <code>optional bytes srm_update = 9;</code>
		 * 
		 * @return The srmUpdate.
		 */
		@java.lang.Override
		public ByteString getSrmUpdate() {
			return srmUpdate_;
		}

		public static final int PLATFORM_VERIFICATION_STATUS_FIELD_NUMBER = 10;
		private int platformVerificationStatus_ = 4;

		/**
		 * <pre>
		 * Indicates the status of any type of platform verification performed by the
		 * server.
		 * </pre>
		 *
		 * <code>optional .PlatformVerificationStatus platform_verification_status = 10 [default = PLATFORM_NO_VERIFICATION];</code>
		 * 
		 * @return Whether the platformVerificationStatus field is set.
		 */
		@java.lang.Override
		public boolean hasPlatformVerificationStatus() {
			return ((bitField0_ & 0x00000100) != 0);
		}

		/**
		 * <pre>
		 * Indicates the status of any type of platform verification performed by the
		 * server.
		 * </pre>
		 *
		 * <code>optional .PlatformVerificationStatus platform_verification_status = 10 [default = PLATFORM_NO_VERIFICATION];</code>
		 * 
		 * @return The platformVerificationStatus.
		 */
		@java.lang.Override
		public WvProto2.PlatformVerificationStatus getPlatformVerificationStatus() {
			WvProto2.PlatformVerificationStatus result = WvProto2.PlatformVerificationStatus
					.forNumber(platformVerificationStatus_);
			return result == null ? WvProto2.PlatformVerificationStatus.PLATFORM_NO_VERIFICATION
					: result;
		}

		public static final int GROUP_IDS_FIELD_NUMBER = 11;

		private java.util.List<ByteString> groupIds_;

		/**
		 * <pre>
		 * IDs of the groups for which keys are delivered in this license, if any.
		 * </pre>
		 *
		 * <code>repeated bytes group_ids = 11;</code>
		 * 
		 * @return A list containing the groupIds.
		 */
		@java.lang.Override
		public java.util.List<ByteString> getGroupIdsList() {
			return groupIds_;
		}

		/**
		 * <pre>
		 * IDs of the groups for which keys are delivered in this license, if any.
		 * </pre>
		 *
		 * <code>repeated bytes group_ids = 11;</code>
		 * 
		 * @return The count of groupIds.
		 */
		@Override
		public int getGroupIdsCount() {
			return groupIds_.size();
		}

		/**
		 * <pre>
		 * IDs of the groups for which keys are delivered in this license, if any.
		 * </pre>
		 *
		 * <code>repeated bytes group_ids = 11;</code>
		 * 
		 * @param index The index of the element to return.
		 * @return The groupIds at the given index.
		 */
		@Override
		public ByteString getGroupIds(int index) {
			return groupIds_.get(index);
		}

		private byte memoizedIsInitialized = -1;

		@java.lang.Override
		public final boolean isInitialized() {
			byte isInitialized = memoizedIsInitialized;
			if (isInitialized == 1)
				return true;
			if (isInitialized == 0)
				return false;

			memoizedIsInitialized = 1;
			return true;
		}

		@java.lang.Override
		public void writeTo(CodedOutputStream output) throws java.io.IOException {
			if (((bitField0_ & 0x00000001) != 0)) {
				output.writeMessage(1, getId());
			}
			if (((bitField0_ & 0x00000002) != 0)) {
				output.writeMessage(2, getPolicy());
			}
			for (int i = 0; i < key_.size(); i++) {
				output.writeMessage(3, key_.get(i));
			}
			if (((bitField0_ & 0x00000004) != 0)) {
				output.writeInt64(4, licenseStartTime_);
			}
			if (((bitField0_ & 0x00000008) != 0)) {
				output.writeBool(5, remoteAttestationVerified_);
			}
			if (((bitField0_ & 0x00000010) != 0)) {
				output.writeBytes(6, providerClientToken_);
			}
			if (((bitField0_ & 0x00000020) != 0)) {
				output.writeUInt32(7, protectionScheme_);
			}
			if (((bitField0_ & 0x00000040) != 0)) {
				output.writeBytes(8, srmRequirement_);
			}
			if (((bitField0_ & 0x00000080) != 0)) {
				output.writeBytes(9, srmUpdate_);
			}
			if (((bitField0_ & 0x00000100) != 0)) {
				output.writeEnum(10, platformVerificationStatus_);
			}
			for (int i = 0; i < groupIds_.size(); i++) {
				output.writeBytes(11, groupIds_.get(i));
			}
			getUnknownFields().writeTo(output);
		}

		@java.lang.Override
		public int getSerializedSize() {
			int size = memoizedSize;
			if (size != -1)
				return size;

			size = 0;
			if (((bitField0_ & 0x00000001) != 0)) {
				size += CodedOutputStream.computeMessageSize(1, getId());
			}
			if (((bitField0_ & 0x00000002) != 0)) {
				size += CodedOutputStream.computeMessageSize(2, getPolicy());
			}
			for (int i = 0; i < key_.size(); i++) {
				size += CodedOutputStream.computeMessageSize(3, key_.get(i));
			}
			if (((bitField0_ & 0x00000004) != 0)) {
				size += CodedOutputStream.computeInt64Size(4, licenseStartTime_);
			}
			if (((bitField0_ & 0x00000008) != 0)) {
				size += CodedOutputStream.computeBoolSize(5, remoteAttestationVerified_);
			}
			if (((bitField0_ & 0x00000010) != 0)) {
				size += CodedOutputStream.computeBytesSize(6, providerClientToken_);
			}
			if (((bitField0_ & 0x00000020) != 0)) {
				size += CodedOutputStream.computeUInt32Size(7, protectionScheme_);
			}
			if (((bitField0_ & 0x00000040) != 0)) {
				size += CodedOutputStream.computeBytesSize(8, srmRequirement_);
			}
			if (((bitField0_ & 0x00000080) != 0)) {
				size += CodedOutputStream.computeBytesSize(9, srmUpdate_);
			}
			if (((bitField0_ & 0x00000100) != 0)) {
				size += CodedOutputStream.computeEnumSize(10, platformVerificationStatus_);
			}
			{
				int dataSize = 0;
				for (int i = 0; i < groupIds_.size(); i++) {
					dataSize += CodedOutputStream.computeBytesSizeNoTag(groupIds_.get(i));
				}
				size += dataSize;
				size += 1 * getGroupIdsList().size();
			}
			size += getUnknownFields().getSerializedSize();
			memoizedSize = size;
			return size;
		}

		@java.lang.Override
		public boolean equals(final java.lang.Object obj) {
			if (obj == this) {
				return true;
			}
			if (!(obj instanceof WvProto2.License)) {
				return super.equals(obj);
			}
			WvProto2.License other = (WvProto2.License) obj;

			if (hasId() != other.hasId())
				return false;
			if (hasId()) {
				if (!getId().equals(other.getId()))
					return false;
			}
			if (hasPolicy() != other.hasPolicy())
				return false;
			if (hasPolicy()) {
				if (!getPolicy().equals(other.getPolicy()))
					return false;
			}
			if (!getKeyList().equals(other.getKeyList()))
				return false;
			if (hasLicenseStartTime() != other.hasLicenseStartTime())
				return false;
			if (hasLicenseStartTime()) {
				if (getLicenseStartTime() != other.getLicenseStartTime())
					return false;
			}
			if (hasRemoteAttestationVerified() != other.hasRemoteAttestationVerified())
				return false;
			if (hasRemoteAttestationVerified()) {
				if (getRemoteAttestationVerified() != other.getRemoteAttestationVerified())
					return false;
			}
			if (hasProviderClientToken() != other.hasProviderClientToken())
				return false;
			if (hasProviderClientToken()) {
				if (!getProviderClientToken().equals(other.getProviderClientToken()))
					return false;
			}
			if (hasProtectionScheme() != other.hasProtectionScheme())
				return false;
			if (hasProtectionScheme()) {
				if (getProtectionScheme() != other.getProtectionScheme())
					return false;
			}
			if (hasSrmRequirement() != other.hasSrmRequirement())
				return false;
			if (hasSrmRequirement()) {
				if (!getSrmRequirement().equals(other.getSrmRequirement()))
					return false;
			}
			if (hasSrmUpdate() != other.hasSrmUpdate())
				return false;
			if (hasSrmUpdate()) {
				if (!getSrmUpdate().equals(other.getSrmUpdate()))
					return false;
			}
			if (hasPlatformVerificationStatus() != other.hasPlatformVerificationStatus())
				return false;
			if (hasPlatformVerificationStatus()) {
				if (platformVerificationStatus_ != other.platformVerificationStatus_)
					return false;
			}
			if (!getGroupIdsList().equals(other.getGroupIdsList()))
				return false;
			if (!getUnknownFields().equals(other.getUnknownFields()))
				return false;
			return true;
		}

		@SuppressWarnings("unchecked")
		@java.lang.Override
		public int hashCode() {
			if (memoizedHashCode != 0) {
				return memoizedHashCode;
			}
			int hash = 41;
			hash = (19 * hash) + getDescriptor().hashCode();
			if (hasId()) {
				hash = (37 * hash) + ID_FIELD_NUMBER;
				hash = (53 * hash) + getId().hashCode();
			}
			if (hasPolicy()) {
				hash = (37 * hash) + POLICY_FIELD_NUMBER;
				hash = (53 * hash) + getPolicy().hashCode();
			}
			if (getKeyCount() > 0) {
				hash = (37 * hash) + KEY_FIELD_NUMBER;
				hash = (53 * hash) + getKeyList().hashCode();
			}
			if (hasLicenseStartTime()) {
				hash = (37 * hash) + LICENSE_START_TIME_FIELD_NUMBER;
				hash = (53 * hash) + Internal.hashLong(getLicenseStartTime());
			}
			if (hasRemoteAttestationVerified()) {
				hash = (37 * hash) + REMOTE_ATTESTATION_VERIFIED_FIELD_NUMBER;
				hash = (53 * hash) + Internal.hashBoolean(getRemoteAttestationVerified());
			}
			if (hasProviderClientToken()) {
				hash = (37 * hash) + PROVIDER_CLIENT_TOKEN_FIELD_NUMBER;
				hash = (53 * hash) + getProviderClientToken().hashCode();
			}
			if (hasProtectionScheme()) {
				hash = (37 * hash) + PROTECTION_SCHEME_FIELD_NUMBER;
				hash = (53 * hash) + getProtectionScheme();
			}
			if (hasSrmRequirement()) {
				hash = (37 * hash) + SRM_REQUIREMENT_FIELD_NUMBER;
				hash = (53 * hash) + getSrmRequirement().hashCode();
			}
			if (hasSrmUpdate()) {
				hash = (37 * hash) + SRM_UPDATE_FIELD_NUMBER;
				hash = (53 * hash) + getSrmUpdate().hashCode();
			}
			if (hasPlatformVerificationStatus()) {
				hash = (37 * hash) + PLATFORM_VERIFICATION_STATUS_FIELD_NUMBER;
				hash = (53 * hash) + platformVerificationStatus_;
			}
			if (getGroupIdsCount() > 0) {
				hash = (37 * hash) + GROUP_IDS_FIELD_NUMBER;
				hash = (53 * hash) + getGroupIdsList().hashCode();
			}
			hash = (29 * hash) + getUnknownFields().hashCode();
			memoizedHashCode = hash;
			return hash;
		}

		public static WvProto2.License parseFrom(java.nio.ByteBuffer data)
				throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data);
		}

		public static WvProto2.License parseFrom(java.nio.ByteBuffer data,
				ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data, extensionRegistry);
		}

		public static WvProto2.License parseFrom(ByteString data)
				throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data);
		}

		public static WvProto2.License parseFrom(ByteString data,
				ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data, extensionRegistry);
		}

		public static WvProto2.License parseFrom(byte[] data)
				throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data);
		}

		public static WvProto2.License parseFrom(byte[] data,
				ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data, extensionRegistry);
		}

		public static WvProto2.License parseFrom(java.io.InputStream input)
				throws java.io.IOException {
			return GeneratedMessageV3.parseWithIOException(PARSER, input);
		}

		public static WvProto2.License parseFrom(java.io.InputStream input,
				ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
			return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
		}

		public static WvProto2.License parseDelimitedFrom(java.io.InputStream input)
				throws java.io.IOException {
			return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
		}

		public static WvProto2.License parseDelimitedFrom(java.io.InputStream input,
				ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
			return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input, extensionRegistry);
		}

		public static WvProto2.License parseFrom(CodedInputStream input)
				throws java.io.IOException {
			return GeneratedMessageV3.parseWithIOException(PARSER, input);
		}

		public static WvProto2.License parseFrom(CodedInputStream input,
				ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
			return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
		}

		@java.lang.Override
		public Builder newBuilderForType() {
			return newBuilder();
		}

		public static Builder newBuilder() {
			return DEFAULT_INSTANCE.toBuilder();
		}

		public static Builder newBuilder(WvProto2.License prototype) {
			return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
		}

		@java.lang.Override
		public Builder toBuilder() {
			return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
		}

		@java.lang.Override
		protected Builder newBuilderForType(GeneratedMessageV3.BuilderParent parent) {
			Builder builder = new Builder(parent);
			return builder;
		}

		/**
		 * Protobuf type {@code License}
		 */
		public static final class Builder extends GeneratedMessageV3.Builder<Builder> implements
				// @@protoc_insertion_point(builder_implements:License)
				WvProto2.LicenseOrBuilder {
			public static final Descriptors.Descriptor getDescriptor() {
				return WvProto2.internal_static_License_descriptor;
			}

			@java.lang.Override
			protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
				return WvProto2.internal_static_License_fieldAccessorTable
						.ensureFieldAccessorsInitialized(WvProto2.License.class,
								WvProto2.License.Builder.class);
			}

			// Construct using WvProto2.License.newBuilder()
			private Builder() {
				maybeForceBuilderInitialization();
			}

			private Builder(GeneratedMessageV3.BuilderParent parent) {
				super(parent);
				maybeForceBuilderInitialization();
			}

			private void maybeForceBuilderInitialization() {
				if (GeneratedMessageV3.alwaysUseFieldBuilders) {
					getIdFieldBuilder();
					getPolicyFieldBuilder();
					getKeyFieldBuilder();
				}
			}

			@java.lang.Override
			public Builder clear() {
				super.clear();
				bitField0_ = 0;
				id_ = null;
				if (idBuilder_ != null) {
					idBuilder_.dispose();
					idBuilder_ = null;
				}
				policy_ = null;
				if (policyBuilder_ != null) {
					policyBuilder_.dispose();
					policyBuilder_ = null;
				}
				if (keyBuilder_ == null) {
					key_ = java.util.Collections.emptyList();
				} else {
					key_ = null;
					keyBuilder_.clear();
				}
				bitField0_ = (bitField0_ & ~0x00000004);
				licenseStartTime_ = 0L;
				remoteAttestationVerified_ = false;
				providerClientToken_ = ByteString.EMPTY;
				protectionScheme_ = 0;
				srmRequirement_ = ByteString.EMPTY;
				srmUpdate_ = ByteString.EMPTY;
				platformVerificationStatus_ = 4;
				groupIds_ = java.util.Collections.emptyList();
				return this;
			}

			@java.lang.Override
			public Descriptors.Descriptor getDescriptorForType() {
				return WvProto2.internal_static_License_descriptor;
			}

			@java.lang.Override
			public WvProto2.License getDefaultInstanceForType() {
				return WvProto2.License.getDefaultInstance();
			}

			@java.lang.Override
			public WvProto2.License build() {
				WvProto2.License result = buildPartial();
				if (!result.isInitialized()) {
					throw newUninitializedMessageException(result);
				}
				return result;
			}

			@java.lang.Override
			public WvProto2.License buildPartial() {
				WvProto2.License result = new WvProto2.License(this);
				buildPartialRepeatedFields(result);
				if (bitField0_ != 0) {
					buildPartial0(result);
				}
				onBuilt();
				return result;
			}

			private void buildPartialRepeatedFields(WvProto2.License result) {
				if (keyBuilder_ == null) {
					if (((bitField0_ & 0x00000004) != 0)) {
						key_ = java.util.Collections.unmodifiableList(key_);
						bitField0_ = (bitField0_ & ~0x00000004);
					}
					result.key_ = key_;
				} else {
					result.key_ = keyBuilder_.build();
				}
				if (((bitField0_ & 0x00000400) != 0)) {
					groupIds_ = java.util.Collections.unmodifiableList(groupIds_);
					bitField0_ = (bitField0_ & ~0x00000400);
				}
				result.groupIds_ = groupIds_;
			}

			private void buildPartial0(WvProto2.License result) {
				int from_bitField0_ = bitField0_;
				int to_bitField0_ = 0;
				if (((from_bitField0_ & 0x00000001) != 0)) {
					result.id_ = idBuilder_ == null ? id_ : idBuilder_.build();
					to_bitField0_ |= 0x00000001;
				}
				if (((from_bitField0_ & 0x00000002) != 0)) {
					result.policy_ = policyBuilder_ == null ? policy_ : policyBuilder_.build();
					to_bitField0_ |= 0x00000002;
				}
				if (((from_bitField0_ & 0x00000008) != 0)) {
					result.licenseStartTime_ = licenseStartTime_;
					to_bitField0_ |= 0x00000004;
				}
				if (((from_bitField0_ & 0x00000010) != 0)) {
					result.remoteAttestationVerified_ = remoteAttestationVerified_;
					to_bitField0_ |= 0x00000008;
				}
				if (((from_bitField0_ & 0x00000020) != 0)) {
					result.providerClientToken_ = providerClientToken_;
					to_bitField0_ |= 0x00000010;
				}
				if (((from_bitField0_ & 0x00000040) != 0)) {
					result.protectionScheme_ = protectionScheme_;
					to_bitField0_ |= 0x00000020;
				}
				if (((from_bitField0_ & 0x00000080) != 0)) {
					result.srmRequirement_ = srmRequirement_;
					to_bitField0_ |= 0x00000040;
				}
				if (((from_bitField0_ & 0x00000100) != 0)) {
					result.srmUpdate_ = srmUpdate_;
					to_bitField0_ |= 0x00000080;
				}
				if (((from_bitField0_ & 0x00000200) != 0)) {
					result.platformVerificationStatus_ = platformVerificationStatus_;
					to_bitField0_ |= 0x00000100;
				}
				result.bitField0_ |= to_bitField0_;
			}

			@java.lang.Override
			public Builder mergeFrom(Message other) {
				if (other instanceof WvProto2.License) {
					return mergeFrom((WvProto2.License) other);
				}
				super.mergeFrom(other);
				return this;
			}

			public Builder mergeFrom(WvProto2.License other) {
				if (other == WvProto2.License.getDefaultInstance())
					return this;
				if (other.hasId()) {
					mergeId(other.getId());
				}
				if (other.hasPolicy()) {
					mergePolicy(other.getPolicy());
				}
				if (keyBuilder_ == null) {
					if (!other.key_.isEmpty()) {
						if (key_.isEmpty()) {
							key_ = other.key_;
							bitField0_ = (bitField0_ & ~0x00000004);
						} else {
							ensureKeyIsMutable();
							key_.addAll(other.key_);
						}
						onChanged();
					}
				} else {
					if (!other.key_.isEmpty()) {
						if (keyBuilder_.isEmpty()) {
							keyBuilder_.dispose();
							keyBuilder_ = null;
							key_ = other.key_;
							bitField0_ = (bitField0_ & ~0x00000004);
							keyBuilder_ = GeneratedMessageV3.alwaysUseFieldBuilders ? getKeyFieldBuilder() : null;
						} else {
							keyBuilder_.addAllMessages(other.key_);
						}
					}
				}
				if (other.hasLicenseStartTime()) {
					setLicenseStartTime(other.getLicenseStartTime());
				}
				if (other.hasRemoteAttestationVerified()) {
					setRemoteAttestationVerified(other.getRemoteAttestationVerified());
				}
				if (other.hasProviderClientToken()) {
					setProviderClientToken(other.getProviderClientToken());
				}
				if (other.hasProtectionScheme()) {
					setProtectionScheme(other.getProtectionScheme());
				}
				if (other.hasSrmRequirement()) {
					setSrmRequirement(other.getSrmRequirement());
				}
				if (other.hasSrmUpdate()) {
					setSrmUpdate(other.getSrmUpdate());
				}
				if (other.hasPlatformVerificationStatus()) {
					setPlatformVerificationStatus(other.getPlatformVerificationStatus());
				}
				if (!other.groupIds_.isEmpty()) {
					if (groupIds_.isEmpty()) {
						groupIds_ = other.groupIds_;
						bitField0_ = (bitField0_ & ~0x00000400);
					} else {
						ensureGroupIdsIsMutable();
						groupIds_.addAll(other.groupIds_);
					}
					onChanged();
				}
				this.mergeUnknownFields(other.getUnknownFields());
				onChanged();
				return this;
			}

			@java.lang.Override
			public final boolean isInitialized() {
				return true;
			}

			@java.lang.Override
			public Builder mergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
					throws java.io.IOException {
				if (extensionRegistry == null) {
					throw new java.lang.NullPointerException();
				}
				try {
					boolean done = false;
					while (!done) {
						int tag = input.readTag();
						switch (tag) {
						case 0:
							done = true;
							break;
						case 10: {
							input.readMessage(getIdFieldBuilder().getBuilder(), extensionRegistry);
							bitField0_ |= 0x00000001;
							break;
						} // case 10
						case 18: {
							input.readMessage(getPolicyFieldBuilder().getBuilder(), extensionRegistry);
							bitField0_ |= 0x00000002;
							break;
						} // case 18
						case 26: {
							WvProto2.License.KeyContainer m = input.readMessage(
									WvProto2.License.KeyContainer.PARSER, extensionRegistry);
							if (keyBuilder_ == null) {
								ensureKeyIsMutable();
								key_.add(m);
							} else {
								keyBuilder_.addMessage(m);
							}
							break;
						} // case 26
						case 32: {
							licenseStartTime_ = input.readInt64();
							bitField0_ |= 0x00000008;
							break;
						} // case 32
						case 40: {
							remoteAttestationVerified_ = input.readBool();
							bitField0_ |= 0x00000010;
							break;
						} // case 40
						case 50: {
							providerClientToken_ = input.readBytes();
							bitField0_ |= 0x00000020;
							break;
						} // case 50
						case 56: {
							protectionScheme_ = input.readUInt32();
							bitField0_ |= 0x00000040;
							break;
						} // case 56
						case 66: {
							srmRequirement_ = input.readBytes();
							bitField0_ |= 0x00000080;
							break;
						} // case 66
						case 74: {
							srmUpdate_ = input.readBytes();
							bitField0_ |= 0x00000100;
							break;
						} // case 74
						case 80: {
							int tmpRaw = input.readEnum();
							WvProto2.PlatformVerificationStatus tmpValue = WvProto2.PlatformVerificationStatus
									.forNumber(tmpRaw);
							if (tmpValue == null) {
								mergeUnknownVarintField(10, tmpRaw);
							} else {
								platformVerificationStatus_ = tmpRaw;
								bitField0_ |= 0x00000200;
							}
							break;
						} // case 80
						case 90: {
							ByteString v = input.readBytes();
							ensureGroupIdsIsMutable();
							groupIds_.add(v);
							break;
						} // case 90
						default: {
							if (!super.parseUnknownField(input, extensionRegistry, tag)) {
								done = true; // was an endgroup tag
							}
							break;
						} // default:
						} // switch (tag)
					} // while (!done)
				} catch (InvalidProtocolBufferException e) {
					throw e.unwrapIOException();
				}
				finally {
					onChanged();
				} // finally
				return this;
			}

			private int bitField0_;

			private WvProto2.LicenseIdentification id_;
			private SingleFieldBuilderV3<WvProto2.LicenseIdentification, WvProto2.LicenseIdentification.Builder, WvProto2.LicenseIdentificationOrBuilder> idBuilder_;

			/**
			 * <code>optional .LicenseIdentification id = 1;</code>
			 * 
			 * @return Whether the id field is set.
			 */
			@Override
			public boolean hasId() {
				return ((bitField0_ & 0x00000001) != 0);
			}

			/**
			 * <code>optional .LicenseIdentification id = 1;</code>
			 * 
			 * @return The id.
			 */
			@Override
			public WvProto2.LicenseIdentification getId() {
				if (idBuilder_ == null) {
					return id_ == null ? WvProto2.LicenseIdentification.getDefaultInstance()
							: id_;
				}
				return idBuilder_.getMessage();
			}

			/**
			 * <code>optional .LicenseIdentification id = 1;</code>
			 */
			public Builder setId(WvProto2.LicenseIdentification value) {
				if (idBuilder_ == null) {
					if (value == null) {
						throw new NullPointerException();
					}
					id_ = value;
				} else {
					idBuilder_.setMessage(value);
				}
				bitField0_ |= 0x00000001;
				onChanged();
				return this;
			}

			/**
			 * <code>optional .LicenseIdentification id = 1;</code>
			 */
			public Builder setId(WvProto2.LicenseIdentification.Builder builderForValue) {
				if (idBuilder_ == null) {
					id_ = builderForValue.build();
				} else {
					idBuilder_.setMessage(builderForValue.build());
				}
				bitField0_ |= 0x00000001;
				onChanged();
				return this;
			}

			/**
			 * <code>optional .LicenseIdentification id = 1;</code>
			 */
			public Builder mergeId(WvProto2.LicenseIdentification value) {
				if (idBuilder_ == null) {
					if (((bitField0_ & 0x00000001) != 0) && id_ != null
							&& id_ != WvProto2.LicenseIdentification.getDefaultInstance()) {
						getIdBuilder().mergeFrom(value);
					} else {
						id_ = value;
					}
				} else {
					idBuilder_.mergeFrom(value);
				}
				bitField0_ |= 0x00000001;
				onChanged();
				return this;
			}

			/**
			 * <code>optional .LicenseIdentification id = 1;</code>
			 */
			public Builder clearId() {
				bitField0_ = (bitField0_ & ~0x00000001);
				id_ = null;
				if (idBuilder_ != null) {
					idBuilder_.dispose();
					idBuilder_ = null;
				}
				onChanged();
				return this;
			}

			/**
			 * <code>optional .LicenseIdentification id = 1;</code>
			 */
			public WvProto2.LicenseIdentification.Builder getIdBuilder() {
				bitField0_ |= 0x00000001;
				onChanged();
				return getIdFieldBuilder().getBuilder();
			}

			/**
			 * <code>optional .LicenseIdentification id = 1;</code>
			 */
			@Override
			public WvProto2.LicenseIdentificationOrBuilder getIdOrBuilder() {
				if (idBuilder_ != null) {
					return idBuilder_.getMessageOrBuilder();
				}
				return id_ == null ? WvProto2.LicenseIdentification.getDefaultInstance()
						: id_;
			}

			/**
			 * <code>optional .LicenseIdentification id = 1;</code>
			 */
			private SingleFieldBuilderV3<WvProto2.LicenseIdentification, WvProto2.LicenseIdentification.Builder, WvProto2.LicenseIdentificationOrBuilder> getIdFieldBuilder() {
				if (idBuilder_ == null) {
					idBuilder_ = new SingleFieldBuilderV3<>(getId(), getParentForChildren(), isClean());
					id_ = null;
				}
				return idBuilder_;
			}

			private WvProto2.License.Policy policy_;
			private SingleFieldBuilderV3<WvProto2.License.Policy, WvProto2.License.Policy.Builder, WvProto2.License.PolicyOrBuilder> policyBuilder_;

			/**
			 * <code>optional .License.Policy policy = 2;</code>
			 * 
			 * @return Whether the policy field is set.
			 */
			@Override
			public boolean hasPolicy() {
				return ((bitField0_ & 0x00000002) != 0);
			}

			/**
			 * <code>optional .License.Policy policy = 2;</code>
			 * 
			 * @return The policy.
			 */
			@Override
			public WvProto2.License.Policy getPolicy() {
				if (policyBuilder_ == null) {
					return policy_ == null ? WvProto2.License.Policy.getDefaultInstance()
							: policy_;
				}
				return policyBuilder_.getMessage();
			}

			/**
			 * <code>optional .License.Policy policy = 2;</code>
			 */
			public Builder setPolicy(WvProto2.License.Policy value) {
				if (policyBuilder_ == null) {
					if (value == null) {
						throw new NullPointerException();
					}
					policy_ = value;
				} else {
					policyBuilder_.setMessage(value);
				}
				bitField0_ |= 0x00000002;
				onChanged();
				return this;
			}

			/**
			 * <code>optional .License.Policy policy = 2;</code>
			 */
			public Builder setPolicy(WvProto2.License.Policy.Builder builderForValue) {
				if (policyBuilder_ == null) {
					policy_ = builderForValue.build();
				} else {
					policyBuilder_.setMessage(builderForValue.build());
				}
				bitField0_ |= 0x00000002;
				onChanged();
				return this;
			}

			/**
			 * <code>optional .License.Policy policy = 2;</code>
			 */
			public Builder mergePolicy(WvProto2.License.Policy value) {
				if (policyBuilder_ == null) {
					if (((bitField0_ & 0x00000002) != 0) && policy_ != null
							&& policy_ != WvProto2.License.Policy.getDefaultInstance()) {
						getPolicyBuilder().mergeFrom(value);
					} else {
						policy_ = value;
					}
				} else {
					policyBuilder_.mergeFrom(value);
				}
				bitField0_ |= 0x00000002;
				onChanged();
				return this;
			}

			/**
			 * <code>optional .License.Policy policy = 2;</code>
			 */
			public Builder clearPolicy() {
				bitField0_ = (bitField0_ & ~0x00000002);
				policy_ = null;
				if (policyBuilder_ != null) {
					policyBuilder_.dispose();
					policyBuilder_ = null;
				}
				onChanged();
				return this;
			}

			/**
			 * <code>optional .License.Policy policy = 2;</code>
			 */
			public WvProto2.License.Policy.Builder getPolicyBuilder() {
				bitField0_ |= 0x00000002;
				onChanged();
				return getPolicyFieldBuilder().getBuilder();
			}

			/**
			 * <code>optional .License.Policy policy = 2;</code>
			 */
			@Override
			public WvProto2.License.PolicyOrBuilder getPolicyOrBuilder() {
				if (policyBuilder_ != null) {
					return policyBuilder_.getMessageOrBuilder();
				}
				return policy_ == null ? WvProto2.License.Policy.getDefaultInstance()
						: policy_;
			}

			/**
			 * <code>optional .License.Policy policy = 2;</code>
			 */
			private SingleFieldBuilderV3<WvProto2.License.Policy, WvProto2.License.Policy.Builder, WvProto2.License.PolicyOrBuilder> getPolicyFieldBuilder() {
				if (policyBuilder_ == null) {
					policyBuilder_ = new SingleFieldBuilderV3<>(getPolicy(), getParentForChildren(), isClean());
					policy_ = null;
				}
				return policyBuilder_;
			}

			private java.util.List<WvProto2.License.KeyContainer> key_ = java.util.Collections
					.emptyList();

			private void ensureKeyIsMutable() {
				if (!((bitField0_ & 0x00000004) != 0)) {
					key_ = new java.util.ArrayList<>(key_);
					bitField0_ |= 0x00000004;
				}
			}

			private RepeatedFieldBuilderV3<WvProto2.License.KeyContainer, WvProto2.License.KeyContainer.Builder, WvProto2.License.KeyContainerOrBuilder> keyBuilder_;

			/**
			 * <code>repeated .License.KeyContainer key = 3;</code>
			 */
			@Override
			public java.util.List<WvProto2.License.KeyContainer> getKeyList() {
				if (keyBuilder_ == null) {
					return java.util.Collections.unmodifiableList(key_);
				}
				return keyBuilder_.getMessageList();
			}

			/**
			 * <code>repeated .License.KeyContainer key = 3;</code>
			 */
			@Override
			public int getKeyCount() {
				if (keyBuilder_ == null) {
					return key_.size();
				}
				return keyBuilder_.getCount();
			}

			/**
			 * <code>repeated .License.KeyContainer key = 3;</code>
			 */
			@Override
			public WvProto2.License.KeyContainer getKey(int index) {
				if (keyBuilder_ == null) {
					return key_.get(index);
				}
				return keyBuilder_.getMessage(index);
			}

			/**
			 * <code>repeated .License.KeyContainer key = 3;</code>
			 */
			public Builder setKey(int index, WvProto2.License.KeyContainer value) {
				if (keyBuilder_ == null) {
					if (value == null) {
						throw new NullPointerException();
					}
					ensureKeyIsMutable();
					key_.set(index, value);
					onChanged();
				} else {
					keyBuilder_.setMessage(index, value);
				}
				return this;
			}

			/**
			 * <code>repeated .License.KeyContainer key = 3;</code>
			 */
			public Builder setKey(int index,
					WvProto2.License.KeyContainer.Builder builderForValue) {
				if (keyBuilder_ == null) {
					ensureKeyIsMutable();
					key_.set(index, builderForValue.build());
					onChanged();
				} else {
					keyBuilder_.setMessage(index, builderForValue.build());
				}
				return this;
			}

			/**
			 * <code>repeated .License.KeyContainer key = 3;</code>
			 */
			public Builder addKey(WvProto2.License.KeyContainer value) {
				if (keyBuilder_ == null) {
					if (value == null) {
						throw new NullPointerException();
					}
					ensureKeyIsMutable();
					key_.add(value);
					onChanged();
				} else {
					keyBuilder_.addMessage(value);
				}
				return this;
			}

			/**
			 * <code>repeated .License.KeyContainer key = 3;</code>
			 */
			public Builder addKey(int index, WvProto2.License.KeyContainer value) {
				if (keyBuilder_ == null) {
					if (value == null) {
						throw new NullPointerException();
					}
					ensureKeyIsMutable();
					key_.add(index, value);
					onChanged();
				} else {
					keyBuilder_.addMessage(index, value);
				}
				return this;
			}

			/**
			 * <code>repeated .License.KeyContainer key = 3;</code>
			 */
			public Builder addKey(WvProto2.License.KeyContainer.Builder builderForValue) {
				if (keyBuilder_ == null) {
					ensureKeyIsMutable();
					key_.add(builderForValue.build());
					onChanged();
				} else {
					keyBuilder_.addMessage(builderForValue.build());
				}
				return this;
			}

			/**
			 * <code>repeated .License.KeyContainer key = 3;</code>
			 */
			public Builder addKey(int index,
					WvProto2.License.KeyContainer.Builder builderForValue) {
				if (keyBuilder_ == null) {
					ensureKeyIsMutable();
					key_.add(index, builderForValue.build());
					onChanged();
				} else {
					keyBuilder_.addMessage(index, builderForValue.build());
				}
				return this;
			}

			/**
			 * <code>repeated .License.KeyContainer key = 3;</code>
			 */
			public Builder addAllKey(
					java.lang.Iterable<? extends WvProto2.License.KeyContainer> values) {
				if (keyBuilder_ == null) {
					ensureKeyIsMutable();
					AbstractMessageLite.Builder.addAll(values, key_);
					onChanged();
				} else {
					keyBuilder_.addAllMessages(values);
				}
				return this;
			}

			/**
			 * <code>repeated .License.KeyContainer key = 3;</code>
			 */
			public Builder clearKey() {
				if (keyBuilder_ == null) {
					key_ = java.util.Collections.emptyList();
					bitField0_ = (bitField0_ & ~0x00000004);
					onChanged();
				} else {
					keyBuilder_.clear();
				}
				return this;
			}

			/**
			 * <code>repeated .License.KeyContainer key = 3;</code>
			 */
			public Builder removeKey(int index) {
				if (keyBuilder_ == null) {
					ensureKeyIsMutable();
					key_.remove(index);
					onChanged();
				} else {
					keyBuilder_.remove(index);
				}
				return this;
			}

			/**
			 * <code>repeated .License.KeyContainer key = 3;</code>
			 */
			public WvProto2.License.KeyContainer.Builder getKeyBuilder(int index) {
				return getKeyFieldBuilder().getBuilder(index);
			}

			/**
			 * <code>repeated .License.KeyContainer key = 3;</code>
			 */
			@Override
			public WvProto2.License.KeyContainerOrBuilder getKeyOrBuilder(int index) {
				if (keyBuilder_ == null) {
					return key_.get(index);
				}
				return keyBuilder_.getMessageOrBuilder(index);
			}

			/**
			 * <code>repeated .License.KeyContainer key = 3;</code>
			 */
			@Override
			public java.util.List<? extends WvProto2.License.KeyContainerOrBuilder> getKeyOrBuilderList() {
				if (keyBuilder_ != null) {
					return keyBuilder_.getMessageOrBuilderList();
				}
				return java.util.Collections.unmodifiableList(key_);
			}

			/**
			 * <code>repeated .License.KeyContainer key = 3;</code>
			 */
			public WvProto2.License.KeyContainer.Builder addKeyBuilder() {
				return getKeyFieldBuilder()
						.addBuilder(WvProto2.License.KeyContainer.getDefaultInstance());
			}

			/**
			 * <code>repeated .License.KeyContainer key = 3;</code>
			 */
			public WvProto2.License.KeyContainer.Builder addKeyBuilder(int index) {
				return getKeyFieldBuilder().addBuilder(index,
						WvProto2.License.KeyContainer.getDefaultInstance());
			}

			/**
			 * <code>repeated .License.KeyContainer key = 3;</code>
			 */
			public java.util.List<WvProto2.License.KeyContainer.Builder> getKeyBuilderList() {
				return getKeyFieldBuilder().getBuilderList();
			}

			private RepeatedFieldBuilderV3<WvProto2.License.KeyContainer, WvProto2.License.KeyContainer.Builder, WvProto2.License.KeyContainerOrBuilder> getKeyFieldBuilder() {
				if (keyBuilder_ == null) {
					keyBuilder_ = new RepeatedFieldBuilderV3<>(key_, ((bitField0_ & 0x00000004) != 0),
							getParentForChildren(), isClean());
					key_ = null;
				}
				return keyBuilder_;
			}

			private long licenseStartTime_;

			/**
			 * <pre>
			 * Time of the request in seconds (UTC) as set in
			 * LicenseRequest.request_time.  If this time is not set in the request,
			 * the local time at the license service is used in this field.
			 * </pre>
			 *
			 * <code>optional int64 license_start_time = 4;</code>
			 * 
			 * @return Whether the licenseStartTime field is set.
			 */
			@java.lang.Override
			public boolean hasLicenseStartTime() {
				return ((bitField0_ & 0x00000008) != 0);
			}

			/**
			 * <pre>
			 * Time of the request in seconds (UTC) as set in
			 * LicenseRequest.request_time.  If this time is not set in the request,
			 * the local time at the license service is used in this field.
			 * </pre>
			 *
			 * <code>optional int64 license_start_time = 4;</code>
			 * 
			 * @return The licenseStartTime.
			 */
			@java.lang.Override
			public long getLicenseStartTime() {
				return licenseStartTime_;
			}

			/**
			 * <pre>
			 * Time of the request in seconds (UTC) as set in
			 * LicenseRequest.request_time.  If this time is not set in the request,
			 * the local time at the license service is used in this field.
			 * </pre>
			 *
			 * <code>optional int64 license_start_time = 4;</code>
			 * 
			 * @param value The licenseStartTime to set.
			 * @return This builder for chaining.
			 */
			public Builder setLicenseStartTime(long value) {

				licenseStartTime_ = value;
				bitField0_ |= 0x00000008;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Time of the request in seconds (UTC) as set in
			 * LicenseRequest.request_time.  If this time is not set in the request,
			 * the local time at the license service is used in this field.
			 * </pre>
			 *
			 * <code>optional int64 license_start_time = 4;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearLicenseStartTime() {
				bitField0_ = (bitField0_ & ~0x00000008);
				licenseStartTime_ = 0L;
				onChanged();
				return this;
			}

			private boolean remoteAttestationVerified_;

			/**
			 * <code>optional bool remote_attestation_verified = 5 [default = false];</code>
			 * 
			 * @return Whether the remoteAttestationVerified field is set.
			 */
			@java.lang.Override
			public boolean hasRemoteAttestationVerified() {
				return ((bitField0_ & 0x00000010) != 0);
			}

			/**
			 * <code>optional bool remote_attestation_verified = 5 [default = false];</code>
			 * 
			 * @return The remoteAttestationVerified.
			 */
			@java.lang.Override
			public boolean getRemoteAttestationVerified() {
				return remoteAttestationVerified_;
			}

			/**
			 * <code>optional bool remote_attestation_verified = 5 [default = false];</code>
			 * 
			 * @param value The remoteAttestationVerified to set.
			 * @return This builder for chaining.
			 */
			public Builder setRemoteAttestationVerified(boolean value) {

				remoteAttestationVerified_ = value;
				bitField0_ |= 0x00000010;
				onChanged();
				return this;
			}

			/**
			 * <code>optional bool remote_attestation_verified = 5 [default = false];</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearRemoteAttestationVerified() {
				bitField0_ = (bitField0_ & ~0x00000010);
				remoteAttestationVerified_ = false;
				onChanged();
				return this;
			}

			private ByteString providerClientToken_ = ByteString.EMPTY;

			/**
			 * <pre>
			 * Client token generated by the content provider. Optional.
			 * </pre>
			 *
			 * <code>optional bytes provider_client_token = 6;</code>
			 * 
			 * @return Whether the providerClientToken field is set.
			 */
			@java.lang.Override
			public boolean hasProviderClientToken() {
				return ((bitField0_ & 0x00000020) != 0);
			}

			/**
			 * <pre>
			 * Client token generated by the content provider. Optional.
			 * </pre>
			 *
			 * <code>optional bytes provider_client_token = 6;</code>
			 * 
			 * @return The providerClientToken.
			 */
			@java.lang.Override
			public ByteString getProviderClientToken() {
				return providerClientToken_;
			}

			/**
			 * <pre>
			 * Client token generated by the content provider. Optional.
			 * </pre>
			 *
			 * <code>optional bytes provider_client_token = 6;</code>
			 * 
			 * @param value The providerClientToken to set.
			 * @return This builder for chaining.
			 */
			public Builder setProviderClientToken(ByteString value) {
				if (value == null) {
					throw new NullPointerException();
				}
				providerClientToken_ = value;
				bitField0_ |= 0x00000020;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Client token generated by the content provider. Optional.
			 * </pre>
			 *
			 * <code>optional bytes provider_client_token = 6;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearProviderClientToken() {
				bitField0_ = (bitField0_ & ~0x00000020);
				providerClientToken_ = getDefaultInstance().getProviderClientToken();
				onChanged();
				return this;
			}

			private int protectionScheme_;

			/**
			 * <pre>
			 * 4cc code specifying the CENC protection scheme as defined in the CENC 3.0
			 * specification. Propagated from Widevine PSSH box. Optional.
			 * </pre>
			 *
			 * <code>optional uint32 protection_scheme = 7;</code>
			 * 
			 * @return Whether the protectionScheme field is set.
			 */
			@java.lang.Override
			public boolean hasProtectionScheme() {
				return ((bitField0_ & 0x00000040) != 0);
			}

			/**
			 * <pre>
			 * 4cc code specifying the CENC protection scheme as defined in the CENC 3.0
			 * specification. Propagated from Widevine PSSH box. Optional.
			 * </pre>
			 *
			 * <code>optional uint32 protection_scheme = 7;</code>
			 * 
			 * @return The protectionScheme.
			 */
			@java.lang.Override
			public int getProtectionScheme() {
				return protectionScheme_;
			}

			/**
			 * <pre>
			 * 4cc code specifying the CENC protection scheme as defined in the CENC 3.0
			 * specification. Propagated from Widevine PSSH box. Optional.
			 * </pre>
			 *
			 * <code>optional uint32 protection_scheme = 7;</code>
			 * 
			 * @param value The protectionScheme to set.
			 * @return This builder for chaining.
			 */
			public Builder setProtectionScheme(int value) {

				protectionScheme_ = value;
				bitField0_ |= 0x00000040;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * 4cc code specifying the CENC protection scheme as defined in the CENC 3.0
			 * specification. Propagated from Widevine PSSH box. Optional.
			 * </pre>
			 *
			 * <code>optional uint32 protection_scheme = 7;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearProtectionScheme() {
				bitField0_ = (bitField0_ & ~0x00000040);
				protectionScheme_ = 0;
				onChanged();
				return this;
			}

			private ByteString srmRequirement_ = ByteString.EMPTY;

			/**
			 * <pre>
			 * 8 byte verification field "HDCPDATA" followed by unsigned 32 bit minimum
			 * HDCP SRM version (whether the version is for HDCP1 SRM or HDCP2 SRM
			 * depends on client max_hdcp_version).
			 * Additional details can be found in Widevine Modular DRM Security
			 * Integration Guide for CENC.
			 * </pre>
			 *
			 * <code>optional bytes srm_requirement = 8;</code>
			 * 
			 * @return Whether the srmRequirement field is set.
			 */
			@java.lang.Override
			public boolean hasSrmRequirement() {
				return ((bitField0_ & 0x00000080) != 0);
			}

			/**
			 * <pre>
			 * 8 byte verification field "HDCPDATA" followed by unsigned 32 bit minimum
			 * HDCP SRM version (whether the version is for HDCP1 SRM or HDCP2 SRM
			 * depends on client max_hdcp_version).
			 * Additional details can be found in Widevine Modular DRM Security
			 * Integration Guide for CENC.
			 * </pre>
			 *
			 * <code>optional bytes srm_requirement = 8;</code>
			 * 
			 * @return The srmRequirement.
			 */
			@java.lang.Override
			public ByteString getSrmRequirement() {
				return srmRequirement_;
			}

			/**
			 * <pre>
			 * 8 byte verification field "HDCPDATA" followed by unsigned 32 bit minimum
			 * HDCP SRM version (whether the version is for HDCP1 SRM or HDCP2 SRM
			 * depends on client max_hdcp_version).
			 * Additional details can be found in Widevine Modular DRM Security
			 * Integration Guide for CENC.
			 * </pre>
			 *
			 * <code>optional bytes srm_requirement = 8;</code>
			 * 
			 * @param value The srmRequirement to set.
			 * @return This builder for chaining.
			 */
			public Builder setSrmRequirement(ByteString value) {
				if (value == null) {
					throw new NullPointerException();
				}
				srmRequirement_ = value;
				bitField0_ |= 0x00000080;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * 8 byte verification field "HDCPDATA" followed by unsigned 32 bit minimum
			 * HDCP SRM version (whether the version is for HDCP1 SRM or HDCP2 SRM
			 * depends on client max_hdcp_version).
			 * Additional details can be found in Widevine Modular DRM Security
			 * Integration Guide for CENC.
			 * </pre>
			 *
			 * <code>optional bytes srm_requirement = 8;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearSrmRequirement() {
				bitField0_ = (bitField0_ & ~0x00000080);
				srmRequirement_ = getDefaultInstance().getSrmRequirement();
				onChanged();
				return this;
			}

			private ByteString srmUpdate_ = ByteString.EMPTY;

			/**
			 * <pre>
			 * If present this contains a signed SRM file (either HDCP1 SRM or HDCP2 SRM
			 * depending on client max_hdcp_version) that should be installed on the
			 * client device.
			 * </pre>
			 *
			 * <code>optional bytes srm_update = 9;</code>
			 * 
			 * @return Whether the srmUpdate field is set.
			 */
			@java.lang.Override
			public boolean hasSrmUpdate() {
				return ((bitField0_ & 0x00000100) != 0);
			}

			/**
			 * <pre>
			 * If present this contains a signed SRM file (either HDCP1 SRM or HDCP2 SRM
			 * depending on client max_hdcp_version) that should be installed on the
			 * client device.
			 * </pre>
			 *
			 * <code>optional bytes srm_update = 9;</code>
			 * 
			 * @return The srmUpdate.
			 */
			@java.lang.Override
			public ByteString getSrmUpdate() {
				return srmUpdate_;
			}

			/**
			 * <pre>
			 * If present this contains a signed SRM file (either HDCP1 SRM or HDCP2 SRM
			 * depending on client max_hdcp_version) that should be installed on the
			 * client device.
			 * </pre>
			 *
			 * <code>optional bytes srm_update = 9;</code>
			 * 
			 * @param value The srmUpdate to set.
			 * @return This builder for chaining.
			 */
			public Builder setSrmUpdate(ByteString value) {
				if (value == null) {
					throw new NullPointerException();
				}
				srmUpdate_ = value;
				bitField0_ |= 0x00000100;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * If present this contains a signed SRM file (either HDCP1 SRM or HDCP2 SRM
			 * depending on client max_hdcp_version) that should be installed on the
			 * client device.
			 * </pre>
			 *
			 * <code>optional bytes srm_update = 9;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearSrmUpdate() {
				bitField0_ = (bitField0_ & ~0x00000100);
				srmUpdate_ = getDefaultInstance().getSrmUpdate();
				onChanged();
				return this;
			}

			private int platformVerificationStatus_ = 4;

			/**
			 * <pre>
			 * Indicates the status of any type of platform verification performed by the
			 * server.
			 * </pre>
			 *
			 * <code>optional .PlatformVerificationStatus platform_verification_status = 10 [default = PLATFORM_NO_VERIFICATION];</code>
			 * 
			 * @return Whether the platformVerificationStatus field is set.
			 */
			@java.lang.Override
			public boolean hasPlatformVerificationStatus() {
				return ((bitField0_ & 0x00000200) != 0);
			}

			/**
			 * <pre>
			 * Indicates the status of any type of platform verification performed by the
			 * server.
			 * </pre>
			 *
			 * <code>optional .PlatformVerificationStatus platform_verification_status = 10 [default = PLATFORM_NO_VERIFICATION];</code>
			 * 
			 * @return The platformVerificationStatus.
			 */
			@java.lang.Override
			public WvProto2.PlatformVerificationStatus getPlatformVerificationStatus() {
				WvProto2.PlatformVerificationStatus result = WvProto2.PlatformVerificationStatus
						.forNumber(platformVerificationStatus_);
				return result == null
						? WvProto2.PlatformVerificationStatus.PLATFORM_NO_VERIFICATION
						: result;
			}

			/**
			 * <pre>
			 * Indicates the status of any type of platform verification performed by the
			 * server.
			 * </pre>
			 *
			 * <code>optional .PlatformVerificationStatus platform_verification_status = 10 [default = PLATFORM_NO_VERIFICATION];</code>
			 * 
			 * @param value The platformVerificationStatus to set.
			 * @return This builder for chaining.
			 */
			public Builder setPlatformVerificationStatus(
					WvProto2.PlatformVerificationStatus value) {
				if (value == null) {
					throw new NullPointerException();
				}
				bitField0_ |= 0x00000200;
				platformVerificationStatus_ = value.getNumber();
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Indicates the status of any type of platform verification performed by the
			 * server.
			 * </pre>
			 *
			 * <code>optional .PlatformVerificationStatus platform_verification_status = 10 [default = PLATFORM_NO_VERIFICATION];</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearPlatformVerificationStatus() {
				bitField0_ = (bitField0_ & ~0x00000200);
				platformVerificationStatus_ = 4;
				onChanged();
				return this;
			}

			private java.util.List<ByteString> groupIds_ = java.util.Collections.emptyList();

			private void ensureGroupIdsIsMutable() {
				if (!((bitField0_ & 0x00000400) != 0)) {
					groupIds_ = new java.util.ArrayList<>(groupIds_);
					bitField0_ |= 0x00000400;
				}
			}

			/**
			 * <pre>
			 * IDs of the groups for which keys are delivered in this license, if any.
			 * </pre>
			 *
			 * <code>repeated bytes group_ids = 11;</code>
			 * 
			 * @return A list containing the groupIds.
			 */
			@Override
			public java.util.List<ByteString> getGroupIdsList() {
				return ((bitField0_ & 0x00000400) != 0) ? java.util.Collections.unmodifiableList(groupIds_) : groupIds_;
			}

			/**
			 * <pre>
			 * IDs of the groups for which keys are delivered in this license, if any.
			 * </pre>
			 *
			 * <code>repeated bytes group_ids = 11;</code>
			 * 
			 * @return The count of groupIds.
			 */
			@Override
			public int getGroupIdsCount() {
				return groupIds_.size();
			}

			/**
			 * <pre>
			 * IDs of the groups for which keys are delivered in this license, if any.
			 * </pre>
			 *
			 * <code>repeated bytes group_ids = 11;</code>
			 * 
			 * @param index The index of the element to return.
			 * @return The groupIds at the given index.
			 */
			@Override
			public ByteString getGroupIds(int index) {
				return groupIds_.get(index);
			}

			/**
			 * <pre>
			 * IDs of the groups for which keys are delivered in this license, if any.
			 * </pre>
			 *
			 * <code>repeated bytes group_ids = 11;</code>
			 * 
			 * @param index The index to set the value at.
			 * @param value The groupIds to set.
			 * @return This builder for chaining.
			 */
			public Builder setGroupIds(int index, ByteString value) {
				if (value == null) {
					throw new NullPointerException();
				}
				ensureGroupIdsIsMutable();
				groupIds_.set(index, value);
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * IDs of the groups for which keys are delivered in this license, if any.
			 * </pre>
			 *
			 * <code>repeated bytes group_ids = 11;</code>
			 * 
			 * @param value The groupIds to add.
			 * @return This builder for chaining.
			 */
			public Builder addGroupIds(ByteString value) {
				if (value == null) {
					throw new NullPointerException();
				}
				ensureGroupIdsIsMutable();
				groupIds_.add(value);
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * IDs of the groups for which keys are delivered in this license, if any.
			 * </pre>
			 *
			 * <code>repeated bytes group_ids = 11;</code>
			 * 
			 * @param values The groupIds to add.
			 * @return This builder for chaining.
			 */
			public Builder addAllGroupIds(java.lang.Iterable<? extends ByteString> values) {
				ensureGroupIdsIsMutable();
				AbstractMessageLite.Builder.addAll(values, groupIds_);
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * IDs of the groups for which keys are delivered in this license, if any.
			 * </pre>
			 *
			 * <code>repeated bytes group_ids = 11;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearGroupIds() {
				groupIds_ = java.util.Collections.emptyList();
				bitField0_ = (bitField0_ & ~0x00000400);
				onChanged();
				return this;
			}

			@java.lang.Override
			public final Builder setUnknownFields(final UnknownFieldSet unknownFields) {
				return super.setUnknownFields(unknownFields);
			}

			@java.lang.Override
			public final Builder mergeUnknownFields(final UnknownFieldSet unknownFields) {
				return super.mergeUnknownFields(unknownFields);
			}

			// @@protoc_insertion_point(builder_scope:License)
		}

		// @@protoc_insertion_point(class_scope:License)
		private static final WvProto2.License DEFAULT_INSTANCE;
		static {
			DEFAULT_INSTANCE = new WvProto2.License();
		}

		public static WvProto2.License getDefaultInstance() {
			return DEFAULT_INSTANCE;
		}

		@java.lang.Deprecated public static final Parser<License> PARSER = new AbstractParser<>() {
			@java.lang.Override
			public License parsePartialFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
					throws InvalidProtocolBufferException {
				Builder builder = newBuilder();
				try {
					builder.mergeFrom(input, extensionRegistry);
				} catch (InvalidProtocolBufferException e) {
					throw e.setUnfinishedMessage(builder.buildPartial());
				} catch (UninitializedMessageException e) {
					throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
				} catch (java.io.IOException e) {
					throw new InvalidProtocolBufferException(e).setUnfinishedMessage(builder.buildPartial());
				}
				return builder.buildPartial();
			}
		};

		public static Parser<License> parser() {
			return PARSER;
		}

		@java.lang.Override
		public Parser<License> getParserForType() {
			return PARSER;
		}

		@java.lang.Override
		public WvProto2.License getDefaultInstanceForType() {
			return DEFAULT_INSTANCE;
		}

	}

	public interface LicenseRequestOrBuilder extends
			// @@protoc_insertion_point(interface_extends:LicenseRequest)
			MessageOrBuilder {

		/**
		 * <pre>
		 * The client_id provides information authenticating the calling device.  It
		 * contains the Widevine keybox token that was installed on the device at the
		 * factory.  This field or encrypted_client_id below is required for a valid
		 * license request, but both should never be present in the same request.
		 * </pre>
		 *
		 * <code>optional .ClientIdentification client_id = 1;</code>
		 * 
		 * @return Whether the clientId field is set.
		 */
		boolean hasClientId();

		/**
		 * <pre>
		 * The client_id provides information authenticating the calling device.  It
		 * contains the Widevine keybox token that was installed on the device at the
		 * factory.  This field or encrypted_client_id below is required for a valid
		 * license request, but both should never be present in the same request.
		 * </pre>
		 *
		 * <code>optional .ClientIdentification client_id = 1;</code>
		 * 
		 * @return The clientId.
		 */
		WvProto2.ClientIdentification getClientId();

		/**
		 * <pre>
		 * The client_id provides information authenticating the calling device.  It
		 * contains the Widevine keybox token that was installed on the device at the
		 * factory.  This field or encrypted_client_id below is required for a valid
		 * license request, but both should never be present in the same request.
		 * </pre>
		 *
		 * <code>optional .ClientIdentification client_id = 1;</code>
		 */
		WvProto2.ClientIdentificationOrBuilder getClientIdOrBuilder();

		/**
		 * <code>optional .LicenseRequest.ContentIdentification content_id = 2;</code>
		 * 
		 * @return Whether the contentId field is set.
		 */
		boolean hasContentId();

		/**
		 * <code>optional .LicenseRequest.ContentIdentification content_id = 2;</code>
		 * 
		 * @return The contentId.
		 */
		WvProto2.LicenseRequest.ContentIdentification getContentId();

		/**
		 * <code>optional .LicenseRequest.ContentIdentification content_id = 2;</code>
		 */
		WvProto2.LicenseRequest.ContentIdentificationOrBuilder getContentIdOrBuilder();

		/**
		 * <code>optional .LicenseRequest.RequestType type = 3;</code>
		 * 
		 * @return Whether the type field is set.
		 */
		boolean hasType();

		/**
		 * <code>optional .LicenseRequest.RequestType type = 3;</code>
		 * 
		 * @return The type.
		 */
		WvProto2.LicenseRequest.RequestType getType();

		/**
		 * <pre>
		 * Time of the request in seconds (UTC) as set by the client.
		 * </pre>
		 *
		 * <code>optional int64 request_time = 4;</code>
		 * 
		 * @return Whether the requestTime field is set.
		 */
		boolean hasRequestTime();

		/**
		 * <pre>
		 * Time of the request in seconds (UTC) as set by the client.
		 * </pre>
		 *
		 * <code>optional int64 request_time = 4;</code>
		 * 
		 * @return The requestTime.
		 */
		long getRequestTime();

		/**
		 * <pre>
		 * Old-style decimal-encoded string key control nonce.
		 * </pre>
		 *
		 * <code>optional bytes key_control_nonce_deprecated = 5;</code>
		 * 
		 * @return Whether the keyControlNonceDeprecated field is set.
		 */
		boolean hasKeyControlNonceDeprecated();

		/**
		 * <pre>
		 * Old-style decimal-encoded string key control nonce.
		 * </pre>
		 *
		 * <code>optional bytes key_control_nonce_deprecated = 5;</code>
		 * 
		 * @return The keyControlNonceDeprecated.
		 */
		ByteString getKeyControlNonceDeprecated();

		/**
		 * <code>optional .ProtocolVersion protocol_version = 6 [default = VERSION_2_0];</code>
		 * 
		 * @return Whether the protocolVersion field is set.
		 */
		boolean hasProtocolVersion();

		/**
		 * <code>optional .ProtocolVersion protocol_version = 6 [default = VERSION_2_0];</code>
		 * 
		 * @return The protocolVersion.
		 */
		WvProto2.ProtocolVersion getProtocolVersion();

		/**
		 * <pre>
		 * New-style uint32 key control nonce, please use instead of
		 * key_control_nonce_deprecated.
		 * </pre>
		 *
		 * <code>optional uint32 key_control_nonce = 7;</code>
		 * 
		 * @return Whether the keyControlNonce field is set.
		 */
		boolean hasKeyControlNonce();

		/**
		 * <pre>
		 * New-style uint32 key control nonce, please use instead of
		 * key_control_nonce_deprecated.
		 * </pre>
		 *
		 * <code>optional uint32 key_control_nonce = 7;</code>
		 * 
		 * @return The keyControlNonce.
		 */
		int getKeyControlNonce();

		/**
		 * <pre>
		 * Encrypted ClientIdentification message, used for privacy purposes.
		 * </pre>
		 *
		 * <code>optional .EncryptedClientIdentification encrypted_client_id = 8;</code>
		 * 
		 * @return Whether the encryptedClientId field is set.
		 */
		boolean hasEncryptedClientId();

		/**
		 * <pre>
		 * Encrypted ClientIdentification message, used for privacy purposes.
		 * </pre>
		 *
		 * <code>optional .EncryptedClientIdentification encrypted_client_id = 8;</code>
		 * 
		 * @return The encryptedClientId.
		 */
		WvProto2.EncryptedClientIdentification getEncryptedClientId();

		/**
		 * <pre>
		 * Encrypted ClientIdentification message, used for privacy purposes.
		 * </pre>
		 *
		 * <code>optional .EncryptedClientIdentification encrypted_client_id = 8;</code>
		 */
		WvProto2.EncryptedClientIdentificationOrBuilder getEncryptedClientIdOrBuilder();
	}

	/**
	 * Protobuf type {@code LicenseRequest}
	 */
	public static final class LicenseRequest extends GeneratedMessageV3 implements
			// @@protoc_insertion_point(message_implements:LicenseRequest)
			LicenseRequestOrBuilder {
		private static final long serialVersionUID = 0L;

		// Use LicenseRequest.newBuilder() to construct.
		private LicenseRequest(GeneratedMessageV3.Builder<?> builder) {
			super(builder);
		}

		private LicenseRequest() {
			type_ = 1;
			keyControlNonceDeprecated_ = ByteString.EMPTY;
			protocolVersion_ = 20;
		}

		@java.lang.Override

		protected java.lang.Object newInstance(UnusedPrivateParameter unused) {
			return new LicenseRequest();
		}

		public static final Descriptors.Descriptor getDescriptor() {
			return WvProto2.internal_static_LicenseRequest_descriptor;
		}

		@java.lang.Override
		protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
			return WvProto2.internal_static_LicenseRequest_fieldAccessorTable
					.ensureFieldAccessorsInitialized(WvProto2.LicenseRequest.class,
							WvProto2.LicenseRequest.Builder.class);
		}

		/**
		 * Protobuf enum {@code LicenseRequest.RequestType}
		 */
		public enum RequestType implements ProtocolMessageEnum {
			/**
			 * <code>NEW = 1;</code>
			 */
			NEW(1),
			/**
			 * <code>RENEWAL = 2;</code>
			 */
			RENEWAL(2),
			/**
			 * <code>RELEASE = 3;</code>
			 */
			RELEASE(3),;

			/**
			 * <code>NEW = 1;</code>
			 */
			public static final int NEW_VALUE = 1;
			/**
			 * <code>RENEWAL = 2;</code>
			 */
			public static final int RENEWAL_VALUE = 2;
			/**
			 * <code>RELEASE = 3;</code>
			 */
			public static final int RELEASE_VALUE = 3;

			@Override
			public final int getNumber() {
				return value;
			}

			/**
			 * @param value The numeric wire value of the corresponding enum entry.
			 * @return The enum associated with the given numeric wire value.
			 * @deprecated Use {@link #forNumber(int)} instead.
			 */
			@java.lang.Deprecated
			public static RequestType valueOf(int value) {
				return forNumber(value);
			}

			/**
			 * @param value The numeric wire value of the corresponding enum entry.
			 * @return The enum associated with the given numeric wire value.
			 */
			public static RequestType forNumber(int value) {
				switch (value) {
				case 1:
					return NEW;
				case 2:
					return RENEWAL;
				case 3:
					return RELEASE;
				default:
					return null;
				}
			}

			public static Internal.EnumLiteMap<RequestType> internalGetValueMap() {
				return internalValueMap;
			}

			private static final Internal.EnumLiteMap<RequestType> internalValueMap = new Internal.EnumLiteMap<>() {
				@Override
				public RequestType findValueByNumber(int number) {
					return RequestType.forNumber(number);
				}
			};

			@Override
			public final Descriptors.EnumValueDescriptor getValueDescriptor() {
				return getDescriptor().getValues().get(ordinal());
			}

			@Override
			public final Descriptors.EnumDescriptor getDescriptorForType() {
				return getDescriptor();
			}

			public static final Descriptors.EnumDescriptor getDescriptor() {
				return WvProto2.LicenseRequest.getDescriptor().getEnumTypes().get(0);
			}

			private static final RequestType[] VALUES = values();

			public static RequestType valueOf(Descriptors.EnumValueDescriptor desc) {
				if (desc.getType() != getDescriptor()) {
					throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
				}
				return VALUES[desc.getIndex()];
			}

			private final int value;

			private RequestType(int value) {
				this.value = value;
			}

			// @@protoc_insertion_point(enum_scope:LicenseRequest.RequestType)
		}

		public interface ContentIdentificationOrBuilder extends
				// @@protoc_insertion_point(interface_extends:LicenseRequest.ContentIdentification)
				MessageOrBuilder {

			/**
			 * <pre>
			 * Exactly one of these must be present.
			 * </pre>
			 *
			 * <code>.LicenseRequest.ContentIdentification.WidevinePsshData widevine_pssh_data = 1;</code>
			 * 
			 * @return Whether the widevinePsshData field is set.
			 */
			boolean hasWidevinePsshData();

			/**
			 * <pre>
			 * Exactly one of these must be present.
			 * </pre>
			 *
			 * <code>.LicenseRequest.ContentIdentification.WidevinePsshData widevine_pssh_data = 1;</code>
			 * 
			 * @return The widevinePsshData.
			 */
			WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData getWidevinePsshData();

			/**
			 * <pre>
			 * Exactly one of these must be present.
			 * </pre>
			 *
			 * <code>.LicenseRequest.ContentIdentification.WidevinePsshData widevine_pssh_data = 1;</code>
			 */
			WvProto2.LicenseRequest.ContentIdentification.WidevinePsshDataOrBuilder getWidevinePsshDataOrBuilder();

			/**
			 * <code>.LicenseRequest.ContentIdentification.WebmKeyId webm_key_id = 2;</code>
			 * 
			 * @return Whether the webmKeyId field is set.
			 */
			boolean hasWebmKeyId();

			/**
			 * <code>.LicenseRequest.ContentIdentification.WebmKeyId webm_key_id = 2;</code>
			 * 
			 * @return The webmKeyId.
			 */
			WvProto2.LicenseRequest.ContentIdentification.WebmKeyId getWebmKeyId();

			/**
			 * <code>.LicenseRequest.ContentIdentification.WebmKeyId webm_key_id = 2;</code>
			 */
			WvProto2.LicenseRequest.ContentIdentification.WebmKeyIdOrBuilder getWebmKeyIdOrBuilder();

			/**
			 * <code>.LicenseRequest.ContentIdentification.ExistingLicense existing_license = 3;</code>
			 * 
			 * @return Whether the existingLicense field is set.
			 */
			boolean hasExistingLicense();

			/**
			 * <code>.LicenseRequest.ContentIdentification.ExistingLicense existing_license = 3;</code>
			 * 
			 * @return The existingLicense.
			 */
			WvProto2.LicenseRequest.ContentIdentification.ExistingLicense getExistingLicense();

			/**
			 * <code>.LicenseRequest.ContentIdentification.ExistingLicense existing_license = 3;</code>
			 */
			WvProto2.LicenseRequest.ContentIdentification.ExistingLicenseOrBuilder getExistingLicenseOrBuilder();

			/**
			 * <code>.LicenseRequest.ContentIdentification.InitData init_data = 4;</code>
			 * 
			 * @return Whether the initData field is set.
			 */
			boolean hasInitData();

			/**
			 * <code>.LicenseRequest.ContentIdentification.InitData init_data = 4;</code>
			 * 
			 * @return The initData.
			 */
			WvProto2.LicenseRequest.ContentIdentification.InitData getInitData();

			/**
			 * <code>.LicenseRequest.ContentIdentification.InitData init_data = 4;</code>
			 */
			WvProto2.LicenseRequest.ContentIdentification.InitDataOrBuilder getInitDataOrBuilder();

			WvProto2.LicenseRequest.ContentIdentification.ContentIdVariantCase getContentIdVariantCase();
		}

		/**
		 * Protobuf type {@code LicenseRequest.ContentIdentification}
		 */
		public static final class ContentIdentification extends GeneratedMessageV3 implements
				// @@protoc_insertion_point(message_implements:LicenseRequest.ContentIdentification)
				ContentIdentificationOrBuilder {
			private static final long serialVersionUID = 0L;

			// Use ContentIdentification.newBuilder() to construct.
			private ContentIdentification(GeneratedMessageV3.Builder<?> builder) {
				super(builder);
			}

			private ContentIdentification() {
			}

			@java.lang.Override

			protected java.lang.Object newInstance(UnusedPrivateParameter unused) {
				return new ContentIdentification();
			}

			public static final Descriptors.Descriptor getDescriptor() {
				return WvProto2.internal_static_LicenseRequest_ContentIdentification_descriptor;
			}

			@java.lang.Override
			protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
				return WvProto2.internal_static_LicenseRequest_ContentIdentification_fieldAccessorTable
						.ensureFieldAccessorsInitialized(
								WvProto2.LicenseRequest.ContentIdentification.class,
								WvProto2.LicenseRequest.ContentIdentification.Builder.class);
			}

			public interface WidevinePsshDataOrBuilder extends
					// @@protoc_insertion_point(interface_extends:LicenseRequest.ContentIdentification.WidevinePsshData)
					MessageOrBuilder {

				/**
				 * <code>repeated bytes pssh_data = 1;</code>
				 * 
				 * @return A list containing the psshData.
				 */
				java.util.List<ByteString> getPsshDataList();

				/**
				 * <code>repeated bytes pssh_data = 1;</code>
				 * 
				 * @return The count of psshData.
				 */
				int getPsshDataCount();

				/**
				 * <code>repeated bytes pssh_data = 1;</code>
				 * 
				 * @param index The index of the element to return.
				 * @return The psshData at the given index.
				 */
				ByteString getPsshData(int index);

				/**
				 * <code>optional .LicenseType license_type = 2;</code>
				 * 
				 * @return Whether the licenseType field is set.
				 */
				boolean hasLicenseType();

				/**
				 * <code>optional .LicenseType license_type = 2;</code>
				 * 
				 * @return The licenseType.
				 */
				WvProto2.LicenseType getLicenseType();

				/**
				 * <pre>
				 * Opaque, client-specified.
				 * </pre>
				 *
				 * <code>optional bytes request_id = 3;</code>
				 * 
				 * @return Whether the requestId field is set.
				 */
				boolean hasRequestId();

				/**
				 * <pre>
				 * Opaque, client-specified.
				 * </pre>
				 *
				 * <code>optional bytes request_id = 3;</code>
				 * 
				 * @return The requestId.
				 */
				ByteString getRequestId();
			}

			/**
			 * Protobuf type {@code LicenseRequest.ContentIdentification.WidevinePsshData}
			 */
			public static final class WidevinePsshData extends GeneratedMessageV3 implements
					// @@protoc_insertion_point(message_implements:LicenseRequest.ContentIdentification.WidevinePsshData)
					WidevinePsshDataOrBuilder {
				private static final long serialVersionUID = 0L;

				// Use WidevinePsshData.newBuilder() to construct.
				private WidevinePsshData(GeneratedMessageV3.Builder<?> builder) {
					super(builder);
				}

				private WidevinePsshData() {
					psshData_ = java.util.Collections.emptyList();
					licenseType_ = 1;
					requestId_ = ByteString.EMPTY;
				}

				@java.lang.Override

				protected java.lang.Object newInstance(UnusedPrivateParameter unused) {
					return new WidevinePsshData();
				}

				public static final Descriptors.Descriptor getDescriptor() {
					return WvProto2.internal_static_LicenseRequest_ContentIdentification_WidevinePsshData_descriptor;
				}

				@java.lang.Override
				protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
					return WvProto2.internal_static_LicenseRequest_ContentIdentification_WidevinePsshData_fieldAccessorTable
							.ensureFieldAccessorsInitialized(
									WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData.class,
									WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData.Builder.class);
				}

				private int bitField0_;
				public static final int PSSH_DATA_FIELD_NUMBER = 1;

				private java.util.List<ByteString> psshData_;

				/**
				 * <code>repeated bytes pssh_data = 1;</code>
				 * 
				 * @return A list containing the psshData.
				 */
				@java.lang.Override
				public java.util.List<ByteString> getPsshDataList() {
					return psshData_;
				}

				/**
				 * <code>repeated bytes pssh_data = 1;</code>
				 * 
				 * @return The count of psshData.
				 */
				@Override
				public int getPsshDataCount() {
					return psshData_.size();
				}

				/**
				 * <code>repeated bytes pssh_data = 1;</code>
				 * 
				 * @param index The index of the element to return.
				 * @return The psshData at the given index.
				 */
				@Override
				public ByteString getPsshData(int index) {
					return psshData_.get(index);
				}

				public static final int LICENSE_TYPE_FIELD_NUMBER = 2;
				private int licenseType_ = 1;

				/**
				 * <code>optional .LicenseType license_type = 2;</code>
				 * 
				 * @return Whether the licenseType field is set.
				 */
				@java.lang.Override
				public boolean hasLicenseType() {
					return ((bitField0_ & 0x00000001) != 0);
				}

				/**
				 * <code>optional .LicenseType license_type = 2;</code>
				 * 
				 * @return The licenseType.
				 */
				@java.lang.Override
				public WvProto2.LicenseType getLicenseType() {
					WvProto2.LicenseType result = WvProto2.LicenseType
							.forNumber(licenseType_);
					return result == null ? WvProto2.LicenseType.STREAMING : result;
				}

				public static final int REQUEST_ID_FIELD_NUMBER = 3;
				private ByteString requestId_ = ByteString.EMPTY;

				/**
				 * <pre>
				 * Opaque, client-specified.
				 * </pre>
				 *
				 * <code>optional bytes request_id = 3;</code>
				 * 
				 * @return Whether the requestId field is set.
				 */
				@java.lang.Override
				public boolean hasRequestId() {
					return ((bitField0_ & 0x00000002) != 0);
				}

				/**
				 * <pre>
				 * Opaque, client-specified.
				 * </pre>
				 *
				 * <code>optional bytes request_id = 3;</code>
				 * 
				 * @return The requestId.
				 */
				@java.lang.Override
				public ByteString getRequestId() {
					return requestId_;
				}

				private byte memoizedIsInitialized = -1;

				@java.lang.Override
				public final boolean isInitialized() {
					byte isInitialized = memoizedIsInitialized;
					if (isInitialized == 1)
						return true;
					if (isInitialized == 0)
						return false;

					memoizedIsInitialized = 1;
					return true;
				}

				@java.lang.Override
				public void writeTo(CodedOutputStream output) throws java.io.IOException {
					for (int i = 0; i < psshData_.size(); i++) {
						output.writeBytes(1, psshData_.get(i));
					}
					if (((bitField0_ & 0x00000001) != 0)) {
						output.writeEnum(2, licenseType_);
					}
					if (((bitField0_ & 0x00000002) != 0)) {
						output.writeBytes(3, requestId_);
					}
					getUnknownFields().writeTo(output);
				}

				@java.lang.Override
				public int getSerializedSize() {
					int size = memoizedSize;
					if (size != -1)
						return size;

					size = 0;
					{
						int dataSize = 0;
						for (int i = 0; i < psshData_.size(); i++) {
							dataSize += CodedOutputStream.computeBytesSizeNoTag(psshData_.get(i));
						}
						size += dataSize;
						size += 1 * getPsshDataList().size();
					}
					if (((bitField0_ & 0x00000001) != 0)) {
						size += CodedOutputStream.computeEnumSize(2, licenseType_);
					}
					if (((bitField0_ & 0x00000002) != 0)) {
						size += CodedOutputStream.computeBytesSize(3, requestId_);
					}
					size += getUnknownFields().getSerializedSize();
					memoizedSize = size;
					return size;
				}

				@java.lang.Override
				public boolean equals(final java.lang.Object obj) {
					if (obj == this) {
						return true;
					}
					if (!(obj instanceof WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData)) {
						return super.equals(obj);
					}
					WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData other = (WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData) obj;

					if (!getPsshDataList().equals(other.getPsshDataList()))
						return false;
					if (hasLicenseType() != other.hasLicenseType())
						return false;
					if (hasLicenseType()) {
						if (licenseType_ != other.licenseType_)
							return false;
					}
					if (hasRequestId() != other.hasRequestId())
						return false;
					if (hasRequestId()) {
						if (!getRequestId().equals(other.getRequestId()))
							return false;
					}
					if (!getUnknownFields().equals(other.getUnknownFields()))
						return false;
					return true;
				}

				@SuppressWarnings("unchecked")
				@java.lang.Override
				public int hashCode() {
					if (memoizedHashCode != 0) {
						return memoizedHashCode;
					}
					int hash = 41;
					hash = (19 * hash) + getDescriptor().hashCode();
					if (getPsshDataCount() > 0) {
						hash = (37 * hash) + PSSH_DATA_FIELD_NUMBER;
						hash = (53 * hash) + getPsshDataList().hashCode();
					}
					if (hasLicenseType()) {
						hash = (37 * hash) + LICENSE_TYPE_FIELD_NUMBER;
						hash = (53 * hash) + licenseType_;
					}
					if (hasRequestId()) {
						hash = (37 * hash) + REQUEST_ID_FIELD_NUMBER;
						hash = (53 * hash) + getRequestId().hashCode();
					}
					hash = (29 * hash) + getUnknownFields().hashCode();
					memoizedHashCode = hash;
					return hash;
				}

				public static WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData parseFrom(
						java.nio.ByteBuffer data) throws InvalidProtocolBufferException {
					return PARSER.parseFrom(data);
				}

				public static WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData parseFrom(
						java.nio.ByteBuffer data, ExtensionRegistryLite extensionRegistry)
						throws InvalidProtocolBufferException {
					return PARSER.parseFrom(data, extensionRegistry);
				}

				public static WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData parseFrom(
						ByteString data) throws InvalidProtocolBufferException {
					return PARSER.parseFrom(data);
				}

				public static WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData parseFrom(
						ByteString data, ExtensionRegistryLite extensionRegistry)
						throws InvalidProtocolBufferException {
					return PARSER.parseFrom(data, extensionRegistry);
				}

				public static WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData parseFrom(
						byte[] data) throws InvalidProtocolBufferException {
					return PARSER.parseFrom(data);
				}

				public static WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData parseFrom(
						byte[] data, ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
					return PARSER.parseFrom(data, extensionRegistry);
				}

				public static WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData parseFrom(
						java.io.InputStream input) throws java.io.IOException {
					return GeneratedMessageV3.parseWithIOException(PARSER, input);
				}

				public static WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData parseFrom(
						java.io.InputStream input, ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
					return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
				}

				public static WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData parseDelimitedFrom(
						java.io.InputStream input) throws java.io.IOException {
					return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
				}

				public static WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData parseDelimitedFrom(
						java.io.InputStream input, ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
					return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input, extensionRegistry);
				}

				public static WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData parseFrom(
						CodedInputStream input) throws java.io.IOException {
					return GeneratedMessageV3.parseWithIOException(PARSER, input);
				}

				public static WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData parseFrom(
						CodedInputStream input, ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
					return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
				}

				@java.lang.Override
				public Builder newBuilderForType() {
					return newBuilder();
				}

				public static Builder newBuilder() {
					return DEFAULT_INSTANCE.toBuilder();
				}

				public static Builder newBuilder(
						WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData prototype) {
					return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
				}

				@java.lang.Override
				public Builder toBuilder() {
					return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
				}

				@java.lang.Override
				protected Builder newBuilderForType(GeneratedMessageV3.BuilderParent parent) {
					Builder builder = new Builder(parent);
					return builder;
				}

				/**
				 * Protobuf type {@code LicenseRequest.ContentIdentification.WidevinePsshData}
				 */
				public static final class Builder extends GeneratedMessageV3.Builder<Builder> implements
						// @@protoc_insertion_point(builder_implements:LicenseRequest.ContentIdentification.WidevinePsshData)
						WvProto2.LicenseRequest.ContentIdentification.WidevinePsshDataOrBuilder {
					public static final Descriptors.Descriptor getDescriptor() {
						return WvProto2.internal_static_LicenseRequest_ContentIdentification_WidevinePsshData_descriptor;
					}

					@java.lang.Override
					protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
						return WvProto2.internal_static_LicenseRequest_ContentIdentification_WidevinePsshData_fieldAccessorTable
								.ensureFieldAccessorsInitialized(
										WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData.class,
										WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData.Builder.class);
					}

					// Construct using
					// WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData.newBuilder()
					private Builder() {

					}

					private Builder(GeneratedMessageV3.BuilderParent parent) {
						super(parent);

					}

					@java.lang.Override
					public Builder clear() {
						super.clear();
						bitField0_ = 0;
						psshData_ = java.util.Collections.emptyList();
						licenseType_ = 1;
						requestId_ = ByteString.EMPTY;
						return this;
					}

					@java.lang.Override
					public Descriptors.Descriptor getDescriptorForType() {
						return WvProto2.internal_static_LicenseRequest_ContentIdentification_WidevinePsshData_descriptor;
					}

					@java.lang.Override
					public WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData getDefaultInstanceForType() {
						return WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData
								.getDefaultInstance();
					}

					@java.lang.Override
					public WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData build() {
						WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData result = buildPartial();
						if (!result.isInitialized()) {
							throw newUninitializedMessageException(result);
						}
						return result;
					}

					@java.lang.Override
					public WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData buildPartial() {
						WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData result = new WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData(
								this);
						buildPartialRepeatedFields(result);
						if (bitField0_ != 0) {
							buildPartial0(result);
						}
						onBuilt();
						return result;
					}

					private void buildPartialRepeatedFields(
							WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData result) {
						if (((bitField0_ & 0x00000001) != 0)) {
							psshData_ = java.util.Collections.unmodifiableList(psshData_);
							bitField0_ = (bitField0_ & ~0x00000001);
						}
						result.psshData_ = psshData_;
					}

					private void buildPartial0(
							WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData result) {
						int from_bitField0_ = bitField0_;
						int to_bitField0_ = 0;
						if (((from_bitField0_ & 0x00000002) != 0)) {
							result.licenseType_ = licenseType_;
							to_bitField0_ |= 0x00000001;
						}
						if (((from_bitField0_ & 0x00000004) != 0)) {
							result.requestId_ = requestId_;
							to_bitField0_ |= 0x00000002;
						}
						result.bitField0_ |= to_bitField0_;
					}

					@java.lang.Override
					public Builder mergeFrom(Message other) {
						if (other instanceof WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData) {
							return mergeFrom(
									(WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData) other);
						}
						super.mergeFrom(other);
						return this;
					}

					public Builder mergeFrom(
							WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData other) {
						if (other == WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData
								.getDefaultInstance())
							return this;
						if (!other.psshData_.isEmpty()) {
							if (psshData_.isEmpty()) {
								psshData_ = other.psshData_;
								bitField0_ = (bitField0_ & ~0x00000001);
							} else {
								ensurePsshDataIsMutable();
								psshData_.addAll(other.psshData_);
							}
							onChanged();
						}
						if (other.hasLicenseType()) {
							setLicenseType(other.getLicenseType());
						}
						if (other.hasRequestId()) {
							setRequestId(other.getRequestId());
						}
						this.mergeUnknownFields(other.getUnknownFields());
						onChanged();
						return this;
					}

					@java.lang.Override
					public final boolean isInitialized() {
						return true;
					}

					@java.lang.Override
					public Builder mergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
							throws java.io.IOException {
						if (extensionRegistry == null) {
							throw new java.lang.NullPointerException();
						}
						try {
							boolean done = false;
							while (!done) {
								int tag = input.readTag();
								switch (tag) {
								case 0:
									done = true;
									break;
								case 10: {
									ByteString v = input.readBytes();
									ensurePsshDataIsMutable();
									psshData_.add(v);
									break;
								} // case 10
								case 16: {
									int tmpRaw = input.readEnum();
									WvProto2.LicenseType tmpValue = WvProto2.LicenseType
											.forNumber(tmpRaw);
									if (tmpValue == null) {
										mergeUnknownVarintField(2, tmpRaw);
									} else {
										licenseType_ = tmpRaw;
										bitField0_ |= 0x00000002;
									}
									break;
								} // case 16
								case 26: {
									requestId_ = input.readBytes();
									bitField0_ |= 0x00000004;
									break;
								} // case 26
								default: {
									if (!super.parseUnknownField(input, extensionRegistry, tag)) {
										done = true; // was an endgroup tag
									}
									break;
								} // default:
								} // switch (tag)
							} // while (!done)
						} catch (InvalidProtocolBufferException e) {
							throw e.unwrapIOException();
						}
						finally {
							onChanged();
						} // finally
						return this;
					}

					private int bitField0_;

					private java.util.List<ByteString> psshData_ = java.util.Collections.emptyList();

					private void ensurePsshDataIsMutable() {
						if (!((bitField0_ & 0x00000001) != 0)) {
							psshData_ = new java.util.ArrayList<>(psshData_);
							bitField0_ |= 0x00000001;
						}
					}

					/**
					 * <code>repeated bytes pssh_data = 1;</code>
					 * 
					 * @return A list containing the psshData.
					 */
					@Override
					public java.util.List<ByteString> getPsshDataList() {
						return ((bitField0_ & 0x00000001) != 0) ? java.util.Collections.unmodifiableList(psshData_)
								: psshData_;
					}

					/**
					 * <code>repeated bytes pssh_data = 1;</code>
					 * 
					 * @return The count of psshData.
					 */
					@Override
					public int getPsshDataCount() {
						return psshData_.size();
					}

					/**
					 * <code>repeated bytes pssh_data = 1;</code>
					 * 
					 * @param index The index of the element to return.
					 * @return The psshData at the given index.
					 */
					@Override
					public ByteString getPsshData(int index) {
						return psshData_.get(index);
					}

					/**
					 * <code>repeated bytes pssh_data = 1;</code>
					 * 
					 * @param index The index to set the value at.
					 * @param value The psshData to set.
					 * @return This builder for chaining.
					 */
					public Builder setPsshData(int index, ByteString value) {
						if (value == null) {
							throw new NullPointerException();
						}
						ensurePsshDataIsMutable();
						psshData_.set(index, value);
						onChanged();
						return this;
					}

					/**
					 * <code>repeated bytes pssh_data = 1;</code>
					 * 
					 * @param value The psshData to add.
					 * @return This builder for chaining.
					 */
					public Builder addPsshData(ByteString value) {
						if (value == null) {
							throw new NullPointerException();
						}
						ensurePsshDataIsMutable();
						psshData_.add(value);
						onChanged();
						return this;
					}

					/**
					 * <code>repeated bytes pssh_data = 1;</code>
					 * 
					 * @param values The psshData to add.
					 * @return This builder for chaining.
					 */
					public Builder addAllPsshData(java.lang.Iterable<? extends ByteString> values) {
						ensurePsshDataIsMutable();
						AbstractMessageLite.Builder.addAll(values, psshData_);
						onChanged();
						return this;
					}

					/**
					 * <code>repeated bytes pssh_data = 1;</code>
					 * 
					 * @return This builder for chaining.
					 */
					public Builder clearPsshData() {
						psshData_ = java.util.Collections.emptyList();
						bitField0_ = (bitField0_ & ~0x00000001);
						onChanged();
						return this;
					}

					private int licenseType_ = 1;

					/**
					 * <code>optional .LicenseType license_type = 2;</code>
					 * 
					 * @return Whether the licenseType field is set.
					 */
					@java.lang.Override
					public boolean hasLicenseType() {
						return ((bitField0_ & 0x00000002) != 0);
					}

					/**
					 * <code>optional .LicenseType license_type = 2;</code>
					 * 
					 * @return The licenseType.
					 */
					@java.lang.Override
					public WvProto2.LicenseType getLicenseType() {
						WvProto2.LicenseType result = WvProto2.LicenseType
								.forNumber(licenseType_);
						return result == null ? WvProto2.LicenseType.STREAMING : result;
					}

					/**
					 * <code>optional .LicenseType license_type = 2;</code>
					 * 
					 * @param value The licenseType to set.
					 * @return This builder for chaining.
					 */
					public Builder setLicenseType(WvProto2.LicenseType value) {
						if (value == null) {
							throw new NullPointerException();
						}
						bitField0_ |= 0x00000002;
						licenseType_ = value.getNumber();
						onChanged();
						return this;
					}

					/**
					 * <code>optional .LicenseType license_type = 2;</code>
					 * 
					 * @return This builder for chaining.
					 */
					public Builder clearLicenseType() {
						bitField0_ = (bitField0_ & ~0x00000002);
						licenseType_ = 1;
						onChanged();
						return this;
					}

					private ByteString requestId_ = ByteString.EMPTY;

					/**
					 * <pre>
					 * Opaque, client-specified.
					 * </pre>
					 *
					 * <code>optional bytes request_id = 3;</code>
					 * 
					 * @return Whether the requestId field is set.
					 */
					@java.lang.Override
					public boolean hasRequestId() {
						return ((bitField0_ & 0x00000004) != 0);
					}

					/**
					 * <pre>
					 * Opaque, client-specified.
					 * </pre>
					 *
					 * <code>optional bytes request_id = 3;</code>
					 * 
					 * @return The requestId.
					 */
					@java.lang.Override
					public ByteString getRequestId() {
						return requestId_;
					}

					/**
					 * <pre>
					 * Opaque, client-specified.
					 * </pre>
					 *
					 * <code>optional bytes request_id = 3;</code>
					 * 
					 * @param value The requestId to set.
					 * @return This builder for chaining.
					 */
					public Builder setRequestId(ByteString value) {
						if (value == null) {
							throw new NullPointerException();
						}
						requestId_ = value;
						bitField0_ |= 0x00000004;
						onChanged();
						return this;
					}

					/**
					 * <pre>
					 * Opaque, client-specified.
					 * </pre>
					 *
					 * <code>optional bytes request_id = 3;</code>
					 * 
					 * @return This builder for chaining.
					 */
					public Builder clearRequestId() {
						bitField0_ = (bitField0_ & ~0x00000004);
						requestId_ = getDefaultInstance().getRequestId();
						onChanged();
						return this;
					}

					@java.lang.Override
					public final Builder setUnknownFields(final UnknownFieldSet unknownFields) {
						return super.setUnknownFields(unknownFields);
					}

					@java.lang.Override
					public final Builder mergeUnknownFields(final UnknownFieldSet unknownFields) {
						return super.mergeUnknownFields(unknownFields);
					}

					// @@protoc_insertion_point(builder_scope:LicenseRequest.ContentIdentification.WidevinePsshData)
				}

				// @@protoc_insertion_point(class_scope:LicenseRequest.ContentIdentification.WidevinePsshData)
				private static final WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData DEFAULT_INSTANCE;
				static {
					DEFAULT_INSTANCE = new WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData();
				}

				public static WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData getDefaultInstance() {
					return DEFAULT_INSTANCE;
				}

				@java.lang.Deprecated public static final Parser<WidevinePsshData> PARSER = new AbstractParser<>() {
					@java.lang.Override
					public WidevinePsshData parsePartialFrom(CodedInputStream input,
							ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
						Builder builder = newBuilder();
						try {
							builder.mergeFrom(input, extensionRegistry);
						} catch (InvalidProtocolBufferException e) {
							throw e.setUnfinishedMessage(builder.buildPartial());
						} catch (UninitializedMessageException e) {
							throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
						} catch (java.io.IOException e) {
							throw new InvalidProtocolBufferException(e).setUnfinishedMessage(builder.buildPartial());
						}
						return builder.buildPartial();
					}
				};

				public static Parser<WidevinePsshData> parser() {
					return PARSER;
				}

				@java.lang.Override
				public Parser<WidevinePsshData> getParserForType() {
					return PARSER;
				}

				@java.lang.Override
				public WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData getDefaultInstanceForType() {
					return DEFAULT_INSTANCE;
				}

			}

			public interface WebmKeyIdOrBuilder extends
					// @@protoc_insertion_point(interface_extends:LicenseRequest.ContentIdentification.WebmKeyId)
					MessageOrBuilder {

				/**
				 * <code>optional bytes header = 1;</code>
				 * 
				 * @return Whether the header field is set.
				 */
				boolean hasHeader();

				/**
				 * <code>optional bytes header = 1;</code>
				 * 
				 * @return The header.
				 */
				ByteString getHeader();

				/**
				 * <code>optional .LicenseType license_type = 2;</code>
				 * 
				 * @return Whether the licenseType field is set.
				 */
				boolean hasLicenseType();

				/**
				 * <code>optional .LicenseType license_type = 2;</code>
				 * 
				 * @return The licenseType.
				 */
				WvProto2.LicenseType getLicenseType();

				/**
				 * <pre>
				 * Opaque, client-specified.
				 * </pre>
				 *
				 * <code>optional bytes request_id = 3;</code>
				 * 
				 * @return Whether the requestId field is set.
				 */
				boolean hasRequestId();

				/**
				 * <pre>
				 * Opaque, client-specified.
				 * </pre>
				 *
				 * <code>optional bytes request_id = 3;</code>
				 * 
				 * @return The requestId.
				 */
				ByteString getRequestId();
			}

			/**
			 * Protobuf type {@code LicenseRequest.ContentIdentification.WebmKeyId}
			 */
			public static final class WebmKeyId extends GeneratedMessageV3 implements
					// @@protoc_insertion_point(message_implements:LicenseRequest.ContentIdentification.WebmKeyId)
					WebmKeyIdOrBuilder {
				private static final long serialVersionUID = 0L;

				// Use WebmKeyId.newBuilder() to construct.
				private WebmKeyId(GeneratedMessageV3.Builder<?> builder) {
					super(builder);
				}

				private WebmKeyId() {
					header_ = ByteString.EMPTY;
					licenseType_ = 1;
					requestId_ = ByteString.EMPTY;
				}

				@java.lang.Override

				protected java.lang.Object newInstance(UnusedPrivateParameter unused) {
					return new WebmKeyId();
				}

				public static final Descriptors.Descriptor getDescriptor() {
					return WvProto2.internal_static_LicenseRequest_ContentIdentification_WebmKeyId_descriptor;
				}

				@java.lang.Override
				protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
					return WvProto2.internal_static_LicenseRequest_ContentIdentification_WebmKeyId_fieldAccessorTable
							.ensureFieldAccessorsInitialized(
									WvProto2.LicenseRequest.ContentIdentification.WebmKeyId.class,
									WvProto2.LicenseRequest.ContentIdentification.WebmKeyId.Builder.class);
				}

				private int bitField0_;
				public static final int HEADER_FIELD_NUMBER = 1;
				private ByteString header_ = ByteString.EMPTY;

				/**
				 * <code>optional bytes header = 1;</code>
				 * 
				 * @return Whether the header field is set.
				 */
				@java.lang.Override
				public boolean hasHeader() {
					return ((bitField0_ & 0x00000001) != 0);
				}

				/**
				 * <code>optional bytes header = 1;</code>
				 * 
				 * @return The header.
				 */
				@java.lang.Override
				public ByteString getHeader() {
					return header_;
				}

				public static final int LICENSE_TYPE_FIELD_NUMBER = 2;
				private int licenseType_ = 1;

				/**
				 * <code>optional .LicenseType license_type = 2;</code>
				 * 
				 * @return Whether the licenseType field is set.
				 */
				@java.lang.Override
				public boolean hasLicenseType() {
					return ((bitField0_ & 0x00000002) != 0);
				}

				/**
				 * <code>optional .LicenseType license_type = 2;</code>
				 * 
				 * @return The licenseType.
				 */
				@java.lang.Override
				public WvProto2.LicenseType getLicenseType() {
					WvProto2.LicenseType result = WvProto2.LicenseType
							.forNumber(licenseType_);
					return result == null ? WvProto2.LicenseType.STREAMING : result;
				}

				public static final int REQUEST_ID_FIELD_NUMBER = 3;
				private ByteString requestId_ = ByteString.EMPTY;

				/**
				 * <pre>
				 * Opaque, client-specified.
				 * </pre>
				 *
				 * <code>optional bytes request_id = 3;</code>
				 * 
				 * @return Whether the requestId field is set.
				 */
				@java.lang.Override
				public boolean hasRequestId() {
					return ((bitField0_ & 0x00000004) != 0);
				}

				/**
				 * <pre>
				 * Opaque, client-specified.
				 * </pre>
				 *
				 * <code>optional bytes request_id = 3;</code>
				 * 
				 * @return The requestId.
				 */
				@java.lang.Override
				public ByteString getRequestId() {
					return requestId_;
				}

				private byte memoizedIsInitialized = -1;

				@java.lang.Override
				public final boolean isInitialized() {
					byte isInitialized = memoizedIsInitialized;
					if (isInitialized == 1)
						return true;
					if (isInitialized == 0)
						return false;

					memoizedIsInitialized = 1;
					return true;
				}

				@java.lang.Override
				public void writeTo(CodedOutputStream output) throws java.io.IOException {
					if (((bitField0_ & 0x00000001) != 0)) {
						output.writeBytes(1, header_);
					}
					if (((bitField0_ & 0x00000002) != 0)) {
						output.writeEnum(2, licenseType_);
					}
					if (((bitField0_ & 0x00000004) != 0)) {
						output.writeBytes(3, requestId_);
					}
					getUnknownFields().writeTo(output);
				}

				@java.lang.Override
				public int getSerializedSize() {
					int size = memoizedSize;
					if (size != -1)
						return size;

					size = 0;
					if (((bitField0_ & 0x00000001) != 0)) {
						size += CodedOutputStream.computeBytesSize(1, header_);
					}
					if (((bitField0_ & 0x00000002) != 0)) {
						size += CodedOutputStream.computeEnumSize(2, licenseType_);
					}
					if (((bitField0_ & 0x00000004) != 0)) {
						size += CodedOutputStream.computeBytesSize(3, requestId_);
					}
					size += getUnknownFields().getSerializedSize();
					memoizedSize = size;
					return size;
				}

				@java.lang.Override
				public boolean equals(final java.lang.Object obj) {
					if (obj == this) {
						return true;
					}
					if (!(obj instanceof WvProto2.LicenseRequest.ContentIdentification.WebmKeyId)) {
						return super.equals(obj);
					}
					WvProto2.LicenseRequest.ContentIdentification.WebmKeyId other = (WvProto2.LicenseRequest.ContentIdentification.WebmKeyId) obj;

					if (hasHeader() != other.hasHeader())
						return false;
					if (hasHeader()) {
						if (!getHeader().equals(other.getHeader()))
							return false;
					}
					if (hasLicenseType() != other.hasLicenseType())
						return false;
					if (hasLicenseType()) {
						if (licenseType_ != other.licenseType_)
							return false;
					}
					if (hasRequestId() != other.hasRequestId())
						return false;
					if (hasRequestId()) {
						if (!getRequestId().equals(other.getRequestId()))
							return false;
					}
					if (!getUnknownFields().equals(other.getUnknownFields()))
						return false;
					return true;
				}

				@SuppressWarnings("unchecked")
				@java.lang.Override
				public int hashCode() {
					if (memoizedHashCode != 0) {
						return memoizedHashCode;
					}
					int hash = 41;
					hash = (19 * hash) + getDescriptor().hashCode();
					if (hasHeader()) {
						hash = (37 * hash) + HEADER_FIELD_NUMBER;
						hash = (53 * hash) + getHeader().hashCode();
					}
					if (hasLicenseType()) {
						hash = (37 * hash) + LICENSE_TYPE_FIELD_NUMBER;
						hash = (53 * hash) + licenseType_;
					}
					if (hasRequestId()) {
						hash = (37 * hash) + REQUEST_ID_FIELD_NUMBER;
						hash = (53 * hash) + getRequestId().hashCode();
					}
					hash = (29 * hash) + getUnknownFields().hashCode();
					memoizedHashCode = hash;
					return hash;
				}

				public static WvProto2.LicenseRequest.ContentIdentification.WebmKeyId parseFrom(
						java.nio.ByteBuffer data) throws InvalidProtocolBufferException {
					return PARSER.parseFrom(data);
				}

				public static WvProto2.LicenseRequest.ContentIdentification.WebmKeyId parseFrom(
						java.nio.ByteBuffer data, ExtensionRegistryLite extensionRegistry)
						throws InvalidProtocolBufferException {
					return PARSER.parseFrom(data, extensionRegistry);
				}

				public static WvProto2.LicenseRequest.ContentIdentification.WebmKeyId parseFrom(
						ByteString data) throws InvalidProtocolBufferException {
					return PARSER.parseFrom(data);
				}

				public static WvProto2.LicenseRequest.ContentIdentification.WebmKeyId parseFrom(
						ByteString data, ExtensionRegistryLite extensionRegistry)
						throws InvalidProtocolBufferException {
					return PARSER.parseFrom(data, extensionRegistry);
				}

				public static WvProto2.LicenseRequest.ContentIdentification.WebmKeyId parseFrom(
						byte[] data) throws InvalidProtocolBufferException {
					return PARSER.parseFrom(data);
				}

				public static WvProto2.LicenseRequest.ContentIdentification.WebmKeyId parseFrom(
						byte[] data, ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
					return PARSER.parseFrom(data, extensionRegistry);
				}

				public static WvProto2.LicenseRequest.ContentIdentification.WebmKeyId parseFrom(
						java.io.InputStream input) throws java.io.IOException {
					return GeneratedMessageV3.parseWithIOException(PARSER, input);
				}

				public static WvProto2.LicenseRequest.ContentIdentification.WebmKeyId parseFrom(
						java.io.InputStream input, ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
					return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
				}

				public static WvProto2.LicenseRequest.ContentIdentification.WebmKeyId parseDelimitedFrom(
						java.io.InputStream input) throws java.io.IOException {
					return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
				}

				public static WvProto2.LicenseRequest.ContentIdentification.WebmKeyId parseDelimitedFrom(
						java.io.InputStream input, ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
					return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input, extensionRegistry);
				}

				public static WvProto2.LicenseRequest.ContentIdentification.WebmKeyId parseFrom(
						CodedInputStream input) throws java.io.IOException {
					return GeneratedMessageV3.parseWithIOException(PARSER, input);
				}

				public static WvProto2.LicenseRequest.ContentIdentification.WebmKeyId parseFrom(
						CodedInputStream input, ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
					return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
				}

				@java.lang.Override
				public Builder newBuilderForType() {
					return newBuilder();
				}

				public static Builder newBuilder() {
					return DEFAULT_INSTANCE.toBuilder();
				}

				public static Builder newBuilder(
						WvProto2.LicenseRequest.ContentIdentification.WebmKeyId prototype) {
					return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
				}

				@java.lang.Override
				public Builder toBuilder() {
					return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
				}

				@java.lang.Override
				protected Builder newBuilderForType(GeneratedMessageV3.BuilderParent parent) {
					Builder builder = new Builder(parent);
					return builder;
				}

				/**
				 * Protobuf type {@code LicenseRequest.ContentIdentification.WebmKeyId}
				 */
				public static final class Builder extends GeneratedMessageV3.Builder<Builder> implements
						// @@protoc_insertion_point(builder_implements:LicenseRequest.ContentIdentification.WebmKeyId)
						WvProto2.LicenseRequest.ContentIdentification.WebmKeyIdOrBuilder {
					public static final Descriptors.Descriptor getDescriptor() {
						return WvProto2.internal_static_LicenseRequest_ContentIdentification_WebmKeyId_descriptor;
					}

					@java.lang.Override
					protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
						return WvProto2.internal_static_LicenseRequest_ContentIdentification_WebmKeyId_fieldAccessorTable
								.ensureFieldAccessorsInitialized(
										WvProto2.LicenseRequest.ContentIdentification.WebmKeyId.class,
										WvProto2.LicenseRequest.ContentIdentification.WebmKeyId.Builder.class);
					}

					// Construct using
					// WvProto2.LicenseRequest.ContentIdentification.WebmKeyId.newBuilder()
					private Builder() {

					}

					private Builder(GeneratedMessageV3.BuilderParent parent) {
						super(parent);

					}

					@java.lang.Override
					public Builder clear() {
						super.clear();
						bitField0_ = 0;
						header_ = ByteString.EMPTY;
						licenseType_ = 1;
						requestId_ = ByteString.EMPTY;
						return this;
					}

					@java.lang.Override
					public Descriptors.Descriptor getDescriptorForType() {
						return WvProto2.internal_static_LicenseRequest_ContentIdentification_WebmKeyId_descriptor;
					}

					@java.lang.Override
					public WvProto2.LicenseRequest.ContentIdentification.WebmKeyId getDefaultInstanceForType() {
						return WvProto2.LicenseRequest.ContentIdentification.WebmKeyId
								.getDefaultInstance();
					}

					@java.lang.Override
					public WvProto2.LicenseRequest.ContentIdentification.WebmKeyId build() {
						WvProto2.LicenseRequest.ContentIdentification.WebmKeyId result = buildPartial();
						if (!result.isInitialized()) {
							throw newUninitializedMessageException(result);
						}
						return result;
					}

					@java.lang.Override
					public WvProto2.LicenseRequest.ContentIdentification.WebmKeyId buildPartial() {
						WvProto2.LicenseRequest.ContentIdentification.WebmKeyId result = new WvProto2.LicenseRequest.ContentIdentification.WebmKeyId(
								this);
						if (bitField0_ != 0) {
							buildPartial0(result);
						}
						onBuilt();
						return result;
					}

					private void buildPartial0(
							WvProto2.LicenseRequest.ContentIdentification.WebmKeyId result) {
						int from_bitField0_ = bitField0_;
						int to_bitField0_ = 0;
						if (((from_bitField0_ & 0x00000001) != 0)) {
							result.header_ = header_;
							to_bitField0_ |= 0x00000001;
						}
						if (((from_bitField0_ & 0x00000002) != 0)) {
							result.licenseType_ = licenseType_;
							to_bitField0_ |= 0x00000002;
						}
						if (((from_bitField0_ & 0x00000004) != 0)) {
							result.requestId_ = requestId_;
							to_bitField0_ |= 0x00000004;
						}
						result.bitField0_ |= to_bitField0_;
					}

					@java.lang.Override
					public Builder mergeFrom(Message other) {
						if (other instanceof WvProto2.LicenseRequest.ContentIdentification.WebmKeyId) {
							return mergeFrom(
									(WvProto2.LicenseRequest.ContentIdentification.WebmKeyId) other);
						}
						super.mergeFrom(other);
						return this;
					}

					public Builder mergeFrom(
							WvProto2.LicenseRequest.ContentIdentification.WebmKeyId other) {
						if (other == WvProto2.LicenseRequest.ContentIdentification.WebmKeyId
								.getDefaultInstance())
							return this;
						if (other.hasHeader()) {
							setHeader(other.getHeader());
						}
						if (other.hasLicenseType()) {
							setLicenseType(other.getLicenseType());
						}
						if (other.hasRequestId()) {
							setRequestId(other.getRequestId());
						}
						this.mergeUnknownFields(other.getUnknownFields());
						onChanged();
						return this;
					}

					@java.lang.Override
					public final boolean isInitialized() {
						return true;
					}

					@java.lang.Override
					public Builder mergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
							throws java.io.IOException {
						if (extensionRegistry == null) {
							throw new java.lang.NullPointerException();
						}
						try {
							boolean done = false;
							while (!done) {
								int tag = input.readTag();
								switch (tag) {
								case 0:
									done = true;
									break;
								case 10: {
									header_ = input.readBytes();
									bitField0_ |= 0x00000001;
									break;
								} // case 10
								case 16: {
									int tmpRaw = input.readEnum();
									WvProto2.LicenseType tmpValue = WvProto2.LicenseType
											.forNumber(tmpRaw);
									if (tmpValue == null) {
										mergeUnknownVarintField(2, tmpRaw);
									} else {
										licenseType_ = tmpRaw;
										bitField0_ |= 0x00000002;
									}
									break;
								} // case 16
								case 26: {
									requestId_ = input.readBytes();
									bitField0_ |= 0x00000004;
									break;
								} // case 26
								default: {
									if (!super.parseUnknownField(input, extensionRegistry, tag)) {
										done = true; // was an endgroup tag
									}
									break;
								} // default:
								} // switch (tag)
							} // while (!done)
						} catch (InvalidProtocolBufferException e) {
							throw e.unwrapIOException();
						}
						finally {
							onChanged();
						} // finally
						return this;
					}

					private int bitField0_;

					private ByteString header_ = ByteString.EMPTY;

					/**
					 * <code>optional bytes header = 1;</code>
					 * 
					 * @return Whether the header field is set.
					 */
					@java.lang.Override
					public boolean hasHeader() {
						return ((bitField0_ & 0x00000001) != 0);
					}

					/**
					 * <code>optional bytes header = 1;</code>
					 * 
					 * @return The header.
					 */
					@java.lang.Override
					public ByteString getHeader() {
						return header_;
					}

					/**
					 * <code>optional bytes header = 1;</code>
					 * 
					 * @param value The header to set.
					 * @return This builder for chaining.
					 */
					public Builder setHeader(ByteString value) {
						if (value == null) {
							throw new NullPointerException();
						}
						header_ = value;
						bitField0_ |= 0x00000001;
						onChanged();
						return this;
					}

					/**
					 * <code>optional bytes header = 1;</code>
					 * 
					 * @return This builder for chaining.
					 */
					public Builder clearHeader() {
						bitField0_ = (bitField0_ & ~0x00000001);
						header_ = getDefaultInstance().getHeader();
						onChanged();
						return this;
					}

					private int licenseType_ = 1;

					/**
					 * <code>optional .LicenseType license_type = 2;</code>
					 * 
					 * @return Whether the licenseType field is set.
					 */
					@java.lang.Override
					public boolean hasLicenseType() {
						return ((bitField0_ & 0x00000002) != 0);
					}

					/**
					 * <code>optional .LicenseType license_type = 2;</code>
					 * 
					 * @return The licenseType.
					 */
					@java.lang.Override
					public WvProto2.LicenseType getLicenseType() {
						WvProto2.LicenseType result = WvProto2.LicenseType
								.forNumber(licenseType_);
						return result == null ? WvProto2.LicenseType.STREAMING : result;
					}

					/**
					 * <code>optional .LicenseType license_type = 2;</code>
					 * 
					 * @param value The licenseType to set.
					 * @return This builder for chaining.
					 */
					public Builder setLicenseType(WvProto2.LicenseType value) {
						if (value == null) {
							throw new NullPointerException();
						}
						bitField0_ |= 0x00000002;
						licenseType_ = value.getNumber();
						onChanged();
						return this;
					}

					/**
					 * <code>optional .LicenseType license_type = 2;</code>
					 * 
					 * @return This builder for chaining.
					 */
					public Builder clearLicenseType() {
						bitField0_ = (bitField0_ & ~0x00000002);
						licenseType_ = 1;
						onChanged();
						return this;
					}

					private ByteString requestId_ = ByteString.EMPTY;

					/**
					 * <pre>
					 * Opaque, client-specified.
					 * </pre>
					 *
					 * <code>optional bytes request_id = 3;</code>
					 * 
					 * @return Whether the requestId field is set.
					 */
					@java.lang.Override
					public boolean hasRequestId() {
						return ((bitField0_ & 0x00000004) != 0);
					}

					/**
					 * <pre>
					 * Opaque, client-specified.
					 * </pre>
					 *
					 * <code>optional bytes request_id = 3;</code>
					 * 
					 * @return The requestId.
					 */
					@java.lang.Override
					public ByteString getRequestId() {
						return requestId_;
					}

					/**
					 * <pre>
					 * Opaque, client-specified.
					 * </pre>
					 *
					 * <code>optional bytes request_id = 3;</code>
					 * 
					 * @param value The requestId to set.
					 * @return This builder for chaining.
					 */
					public Builder setRequestId(ByteString value) {
						if (value == null) {
							throw new NullPointerException();
						}
						requestId_ = value;
						bitField0_ |= 0x00000004;
						onChanged();
						return this;
					}

					/**
					 * <pre>
					 * Opaque, client-specified.
					 * </pre>
					 *
					 * <code>optional bytes request_id = 3;</code>
					 * 
					 * @return This builder for chaining.
					 */
					public Builder clearRequestId() {
						bitField0_ = (bitField0_ & ~0x00000004);
						requestId_ = getDefaultInstance().getRequestId();
						onChanged();
						return this;
					}

					@java.lang.Override
					public final Builder setUnknownFields(final UnknownFieldSet unknownFields) {
						return super.setUnknownFields(unknownFields);
					}

					@java.lang.Override
					public final Builder mergeUnknownFields(final UnknownFieldSet unknownFields) {
						return super.mergeUnknownFields(unknownFields);
					}

					// @@protoc_insertion_point(builder_scope:LicenseRequest.ContentIdentification.WebmKeyId)
				}

				// @@protoc_insertion_point(class_scope:LicenseRequest.ContentIdentification.WebmKeyId)
				private static final WvProto2.LicenseRequest.ContentIdentification.WebmKeyId DEFAULT_INSTANCE;
				static {
					DEFAULT_INSTANCE = new WvProto2.LicenseRequest.ContentIdentification.WebmKeyId();
				}

				public static WvProto2.LicenseRequest.ContentIdentification.WebmKeyId getDefaultInstance() {
					return DEFAULT_INSTANCE;
				}

				@java.lang.Deprecated public static final Parser<WebmKeyId> PARSER = new AbstractParser<>() {
					@java.lang.Override
					public WebmKeyId parsePartialFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
							throws InvalidProtocolBufferException {
						Builder builder = newBuilder();
						try {
							builder.mergeFrom(input, extensionRegistry);
						} catch (InvalidProtocolBufferException e) {
							throw e.setUnfinishedMessage(builder.buildPartial());
						} catch (UninitializedMessageException e) {
							throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
						} catch (java.io.IOException e) {
							throw new InvalidProtocolBufferException(e).setUnfinishedMessage(builder.buildPartial());
						}
						return builder.buildPartial();
					}
				};

				public static Parser<WebmKeyId> parser() {
					return PARSER;
				}

				@java.lang.Override
				public Parser<WebmKeyId> getParserForType() {
					return PARSER;
				}

				@java.lang.Override
				public WvProto2.LicenseRequest.ContentIdentification.WebmKeyId getDefaultInstanceForType() {
					return DEFAULT_INSTANCE;
				}

			}

			public interface ExistingLicenseOrBuilder extends
					// @@protoc_insertion_point(interface_extends:LicenseRequest.ContentIdentification.ExistingLicense)
					MessageOrBuilder {

				/**
				 * <code>optional .LicenseIdentification license_id = 1;</code>
				 * 
				 * @return Whether the licenseId field is set.
				 */
				boolean hasLicenseId();

				/**
				 * <code>optional .LicenseIdentification license_id = 1;</code>
				 * 
				 * @return The licenseId.
				 */
				WvProto2.LicenseIdentification getLicenseId();

				/**
				 * <code>optional .LicenseIdentification license_id = 1;</code>
				 */
				WvProto2.LicenseIdentificationOrBuilder getLicenseIdOrBuilder();

				/**
				 * <code>optional int64 seconds_since_started = 2;</code>
				 * 
				 * @return Whether the secondsSinceStarted field is set.
				 */
				boolean hasSecondsSinceStarted();

				/**
				 * <code>optional int64 seconds_since_started = 2;</code>
				 * 
				 * @return The secondsSinceStarted.
				 */
				long getSecondsSinceStarted();

				/**
				 * <code>optional int64 seconds_since_last_played = 3;</code>
				 * 
				 * @return Whether the secondsSinceLastPlayed field is set.
				 */
				boolean hasSecondsSinceLastPlayed();

				/**
				 * <code>optional int64 seconds_since_last_played = 3;</code>
				 * 
				 * @return The secondsSinceLastPlayed.
				 */
				long getSecondsSinceLastPlayed();

				/**
				 * <code>optional bytes session_usage_table_entry = 4;</code>
				 * 
				 * @return Whether the sessionUsageTableEntry field is set.
				 */
				boolean hasSessionUsageTableEntry();

				/**
				 * <code>optional bytes session_usage_table_entry = 4;</code>
				 * 
				 * @return The sessionUsageTableEntry.
				 */
				ByteString getSessionUsageTableEntry();
			}

			/**
			 * Protobuf type {@code LicenseRequest.ContentIdentification.ExistingLicense}
			 */
			public static final class ExistingLicense extends GeneratedMessageV3 implements
					// @@protoc_insertion_point(message_implements:LicenseRequest.ContentIdentification.ExistingLicense)
					ExistingLicenseOrBuilder {
				private static final long serialVersionUID = 0L;

				// Use ExistingLicense.newBuilder() to construct.
				private ExistingLicense(GeneratedMessageV3.Builder<?> builder) {
					super(builder);
				}

				private ExistingLicense() {
					sessionUsageTableEntry_ = ByteString.EMPTY;
				}

				@java.lang.Override

				protected java.lang.Object newInstance(UnusedPrivateParameter unused) {
					return new ExistingLicense();
				}

				public static final Descriptors.Descriptor getDescriptor() {
					return WvProto2.internal_static_LicenseRequest_ContentIdentification_ExistingLicense_descriptor;
				}

				@java.lang.Override
				protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
					return WvProto2.internal_static_LicenseRequest_ContentIdentification_ExistingLicense_fieldAccessorTable
							.ensureFieldAccessorsInitialized(
									WvProto2.LicenseRequest.ContentIdentification.ExistingLicense.class,
									WvProto2.LicenseRequest.ContentIdentification.ExistingLicense.Builder.class);
				}

				private int bitField0_;
				public static final int LICENSE_ID_FIELD_NUMBER = 1;
				private WvProto2.LicenseIdentification licenseId_;

				/**
				 * <code>optional .LicenseIdentification license_id = 1;</code>
				 * 
				 * @return Whether the licenseId field is set.
				 */
				@java.lang.Override
				public boolean hasLicenseId() {
					return ((bitField0_ & 0x00000001) != 0);
				}

				/**
				 * <code>optional .LicenseIdentification license_id = 1;</code>
				 * 
				 * @return The licenseId.
				 */
				@java.lang.Override
				public WvProto2.LicenseIdentification getLicenseId() {
					return licenseId_ == null
							? WvProto2.LicenseIdentification.getDefaultInstance()
							: licenseId_;
				}

				/**
				 * <code>optional .LicenseIdentification license_id = 1;</code>
				 */
				@java.lang.Override
				public WvProto2.LicenseIdentificationOrBuilder getLicenseIdOrBuilder() {
					return licenseId_ == null
							? WvProto2.LicenseIdentification.getDefaultInstance()
							: licenseId_;
				}

				public static final int SECONDS_SINCE_STARTED_FIELD_NUMBER = 2;
				private long secondsSinceStarted_ = 0L;

				/**
				 * <code>optional int64 seconds_since_started = 2;</code>
				 * 
				 * @return Whether the secondsSinceStarted field is set.
				 */
				@java.lang.Override
				public boolean hasSecondsSinceStarted() {
					return ((bitField0_ & 0x00000002) != 0);
				}

				/**
				 * <code>optional int64 seconds_since_started = 2;</code>
				 * 
				 * @return The secondsSinceStarted.
				 */
				@java.lang.Override
				public long getSecondsSinceStarted() {
					return secondsSinceStarted_;
				}

				public static final int SECONDS_SINCE_LAST_PLAYED_FIELD_NUMBER = 3;
				private long secondsSinceLastPlayed_ = 0L;

				/**
				 * <code>optional int64 seconds_since_last_played = 3;</code>
				 * 
				 * @return Whether the secondsSinceLastPlayed field is set.
				 */
				@java.lang.Override
				public boolean hasSecondsSinceLastPlayed() {
					return ((bitField0_ & 0x00000004) != 0);
				}

				/**
				 * <code>optional int64 seconds_since_last_played = 3;</code>
				 * 
				 * @return The secondsSinceLastPlayed.
				 */
				@java.lang.Override
				public long getSecondsSinceLastPlayed() {
					return secondsSinceLastPlayed_;
				}

				public static final int SESSION_USAGE_TABLE_ENTRY_FIELD_NUMBER = 4;
				private ByteString sessionUsageTableEntry_ = ByteString.EMPTY;

				/**
				 * <code>optional bytes session_usage_table_entry = 4;</code>
				 * 
				 * @return Whether the sessionUsageTableEntry field is set.
				 */
				@java.lang.Override
				public boolean hasSessionUsageTableEntry() {
					return ((bitField0_ & 0x00000008) != 0);
				}

				/**
				 * <code>optional bytes session_usage_table_entry = 4;</code>
				 * 
				 * @return The sessionUsageTableEntry.
				 */
				@java.lang.Override
				public ByteString getSessionUsageTableEntry() {
					return sessionUsageTableEntry_;
				}

				private byte memoizedIsInitialized = -1;

				@java.lang.Override
				public final boolean isInitialized() {
					byte isInitialized = memoizedIsInitialized;
					if (isInitialized == 1)
						return true;
					if (isInitialized == 0)
						return false;

					memoizedIsInitialized = 1;
					return true;
				}

				@java.lang.Override
				public void writeTo(CodedOutputStream output) throws java.io.IOException {
					if (((bitField0_ & 0x00000001) != 0)) {
						output.writeMessage(1, getLicenseId());
					}
					if (((bitField0_ & 0x00000002) != 0)) {
						output.writeInt64(2, secondsSinceStarted_);
					}
					if (((bitField0_ & 0x00000004) != 0)) {
						output.writeInt64(3, secondsSinceLastPlayed_);
					}
					if (((bitField0_ & 0x00000008) != 0)) {
						output.writeBytes(4, sessionUsageTableEntry_);
					}
					getUnknownFields().writeTo(output);
				}

				@java.lang.Override
				public int getSerializedSize() {
					int size = memoizedSize;
					if (size != -1)
						return size;

					size = 0;
					if (((bitField0_ & 0x00000001) != 0)) {
						size += CodedOutputStream.computeMessageSize(1, getLicenseId());
					}
					if (((bitField0_ & 0x00000002) != 0)) {
						size += CodedOutputStream.computeInt64Size(2, secondsSinceStarted_);
					}
					if (((bitField0_ & 0x00000004) != 0)) {
						size += CodedOutputStream.computeInt64Size(3, secondsSinceLastPlayed_);
					}
					if (((bitField0_ & 0x00000008) != 0)) {
						size += CodedOutputStream.computeBytesSize(4, sessionUsageTableEntry_);
					}
					size += getUnknownFields().getSerializedSize();
					memoizedSize = size;
					return size;
				}

				@java.lang.Override
				public boolean equals(final java.lang.Object obj) {
					if (obj == this) {
						return true;
					}
					if (!(obj instanceof WvProto2.LicenseRequest.ContentIdentification.ExistingLicense)) {
						return super.equals(obj);
					}
					WvProto2.LicenseRequest.ContentIdentification.ExistingLicense other = (WvProto2.LicenseRequest.ContentIdentification.ExistingLicense) obj;

					if (hasLicenseId() != other.hasLicenseId())
						return false;
					if (hasLicenseId()) {
						if (!getLicenseId().equals(other.getLicenseId()))
							return false;
					}
					if (hasSecondsSinceStarted() != other.hasSecondsSinceStarted())
						return false;
					if (hasSecondsSinceStarted()) {
						if (getSecondsSinceStarted() != other.getSecondsSinceStarted())
							return false;
					}
					if (hasSecondsSinceLastPlayed() != other.hasSecondsSinceLastPlayed())
						return false;
					if (hasSecondsSinceLastPlayed()) {
						if (getSecondsSinceLastPlayed() != other.getSecondsSinceLastPlayed())
							return false;
					}
					if (hasSessionUsageTableEntry() != other.hasSessionUsageTableEntry())
						return false;
					if (hasSessionUsageTableEntry()) {
						if (!getSessionUsageTableEntry().equals(other.getSessionUsageTableEntry()))
							return false;
					}
					if (!getUnknownFields().equals(other.getUnknownFields()))
						return false;
					return true;
				}

				@SuppressWarnings("unchecked")
				@java.lang.Override
				public int hashCode() {
					if (memoizedHashCode != 0) {
						return memoizedHashCode;
					}
					int hash = 41;
					hash = (19 * hash) + getDescriptor().hashCode();
					if (hasLicenseId()) {
						hash = (37 * hash) + LICENSE_ID_FIELD_NUMBER;
						hash = (53 * hash) + getLicenseId().hashCode();
					}
					if (hasSecondsSinceStarted()) {
						hash = (37 * hash) + SECONDS_SINCE_STARTED_FIELD_NUMBER;
						hash = (53 * hash) + Internal.hashLong(getSecondsSinceStarted());
					}
					if (hasSecondsSinceLastPlayed()) {
						hash = (37 * hash) + SECONDS_SINCE_LAST_PLAYED_FIELD_NUMBER;
						hash = (53 * hash) + Internal.hashLong(getSecondsSinceLastPlayed());
					}
					if (hasSessionUsageTableEntry()) {
						hash = (37 * hash) + SESSION_USAGE_TABLE_ENTRY_FIELD_NUMBER;
						hash = (53 * hash) + getSessionUsageTableEntry().hashCode();
					}
					hash = (29 * hash) + getUnknownFields().hashCode();
					memoizedHashCode = hash;
					return hash;
				}

				public static WvProto2.LicenseRequest.ContentIdentification.ExistingLicense parseFrom(
						java.nio.ByteBuffer data) throws InvalidProtocolBufferException {
					return PARSER.parseFrom(data);
				}

				public static WvProto2.LicenseRequest.ContentIdentification.ExistingLicense parseFrom(
						java.nio.ByteBuffer data, ExtensionRegistryLite extensionRegistry)
						throws InvalidProtocolBufferException {
					return PARSER.parseFrom(data, extensionRegistry);
				}

				public static WvProto2.LicenseRequest.ContentIdentification.ExistingLicense parseFrom(
						ByteString data) throws InvalidProtocolBufferException {
					return PARSER.parseFrom(data);
				}

				public static WvProto2.LicenseRequest.ContentIdentification.ExistingLicense parseFrom(
						ByteString data, ExtensionRegistryLite extensionRegistry)
						throws InvalidProtocolBufferException {
					return PARSER.parseFrom(data, extensionRegistry);
				}

				public static WvProto2.LicenseRequest.ContentIdentification.ExistingLicense parseFrom(
						byte[] data) throws InvalidProtocolBufferException {
					return PARSER.parseFrom(data);
				}

				public static WvProto2.LicenseRequest.ContentIdentification.ExistingLicense parseFrom(
						byte[] data, ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
					return PARSER.parseFrom(data, extensionRegistry);
				}

				public static WvProto2.LicenseRequest.ContentIdentification.ExistingLicense parseFrom(
						java.io.InputStream input) throws java.io.IOException {
					return GeneratedMessageV3.parseWithIOException(PARSER, input);
				}

				public static WvProto2.LicenseRequest.ContentIdentification.ExistingLicense parseFrom(
						java.io.InputStream input, ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
					return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
				}

				public static WvProto2.LicenseRequest.ContentIdentification.ExistingLicense parseDelimitedFrom(
						java.io.InputStream input) throws java.io.IOException {
					return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
				}

				public static WvProto2.LicenseRequest.ContentIdentification.ExistingLicense parseDelimitedFrom(
						java.io.InputStream input, ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
					return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input, extensionRegistry);
				}

				public static WvProto2.LicenseRequest.ContentIdentification.ExistingLicense parseFrom(
						CodedInputStream input) throws java.io.IOException {
					return GeneratedMessageV3.parseWithIOException(PARSER, input);
				}

				public static WvProto2.LicenseRequest.ContentIdentification.ExistingLicense parseFrom(
						CodedInputStream input, ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
					return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
				}

				@java.lang.Override
				public Builder newBuilderForType() {
					return newBuilder();
				}

				public static Builder newBuilder() {
					return DEFAULT_INSTANCE.toBuilder();
				}

				public static Builder newBuilder(
						WvProto2.LicenseRequest.ContentIdentification.ExistingLicense prototype) {
					return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
				}

				@java.lang.Override
				public Builder toBuilder() {
					return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
				}

				@java.lang.Override
				protected Builder newBuilderForType(GeneratedMessageV3.BuilderParent parent) {
					Builder builder = new Builder(parent);
					return builder;
				}

				/**
				 * Protobuf type {@code LicenseRequest.ContentIdentification.ExistingLicense}
				 */
				public static final class Builder extends GeneratedMessageV3.Builder<Builder> implements
						// @@protoc_insertion_point(builder_implements:LicenseRequest.ContentIdentification.ExistingLicense)
						WvProto2.LicenseRequest.ContentIdentification.ExistingLicenseOrBuilder {
					public static final Descriptors.Descriptor getDescriptor() {
						return WvProto2.internal_static_LicenseRequest_ContentIdentification_ExistingLicense_descriptor;
					}

					@java.lang.Override
					protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
						return WvProto2.internal_static_LicenseRequest_ContentIdentification_ExistingLicense_fieldAccessorTable
								.ensureFieldAccessorsInitialized(
										WvProto2.LicenseRequest.ContentIdentification.ExistingLicense.class,
										WvProto2.LicenseRequest.ContentIdentification.ExistingLicense.Builder.class);
					}

					// Construct using
					// WvProto2.LicenseRequest.ContentIdentification.ExistingLicense.newBuilder()
					private Builder() {
						maybeForceBuilderInitialization();
					}

					private Builder(GeneratedMessageV3.BuilderParent parent) {
						super(parent);
						maybeForceBuilderInitialization();
					}

					private void maybeForceBuilderInitialization() {
						if (GeneratedMessageV3.alwaysUseFieldBuilders) {
							getLicenseIdFieldBuilder();
						}
					}

					@java.lang.Override
					public Builder clear() {
						super.clear();
						bitField0_ = 0;
						licenseId_ = null;
						if (licenseIdBuilder_ != null) {
							licenseIdBuilder_.dispose();
							licenseIdBuilder_ = null;
						}
						secondsSinceStarted_ = 0L;
						secondsSinceLastPlayed_ = 0L;
						sessionUsageTableEntry_ = ByteString.EMPTY;
						return this;
					}

					@java.lang.Override
					public Descriptors.Descriptor getDescriptorForType() {
						return WvProto2.internal_static_LicenseRequest_ContentIdentification_ExistingLicense_descriptor;
					}

					@java.lang.Override
					public WvProto2.LicenseRequest.ContentIdentification.ExistingLicense getDefaultInstanceForType() {
						return WvProto2.LicenseRequest.ContentIdentification.ExistingLicense
								.getDefaultInstance();
					}

					@java.lang.Override
					public WvProto2.LicenseRequest.ContentIdentification.ExistingLicense build() {
						WvProto2.LicenseRequest.ContentIdentification.ExistingLicense result = buildPartial();
						if (!result.isInitialized()) {
							throw newUninitializedMessageException(result);
						}
						return result;
					}

					@java.lang.Override
					public WvProto2.LicenseRequest.ContentIdentification.ExistingLicense buildPartial() {
						WvProto2.LicenseRequest.ContentIdentification.ExistingLicense result = new WvProto2.LicenseRequest.ContentIdentification.ExistingLicense(
								this);
						if (bitField0_ != 0) {
							buildPartial0(result);
						}
						onBuilt();
						return result;
					}

					private void buildPartial0(
							WvProto2.LicenseRequest.ContentIdentification.ExistingLicense result) {
						int from_bitField0_ = bitField0_;
						int to_bitField0_ = 0;
						if (((from_bitField0_ & 0x00000001) != 0)) {
							result.licenseId_ = licenseIdBuilder_ == null ? licenseId_ : licenseIdBuilder_.build();
							to_bitField0_ |= 0x00000001;
						}
						if (((from_bitField0_ & 0x00000002) != 0)) {
							result.secondsSinceStarted_ = secondsSinceStarted_;
							to_bitField0_ |= 0x00000002;
						}
						if (((from_bitField0_ & 0x00000004) != 0)) {
							result.secondsSinceLastPlayed_ = secondsSinceLastPlayed_;
							to_bitField0_ |= 0x00000004;
						}
						if (((from_bitField0_ & 0x00000008) != 0)) {
							result.sessionUsageTableEntry_ = sessionUsageTableEntry_;
							to_bitField0_ |= 0x00000008;
						}
						result.bitField0_ |= to_bitField0_;
					}

					@java.lang.Override
					public Builder mergeFrom(Message other) {
						if (other instanceof WvProto2.LicenseRequest.ContentIdentification.ExistingLicense) {
							return mergeFrom(
									(WvProto2.LicenseRequest.ContentIdentification.ExistingLicense) other);
						}
						super.mergeFrom(other);
						return this;
					}

					public Builder mergeFrom(
							WvProto2.LicenseRequest.ContentIdentification.ExistingLicense other) {
						if (other == WvProto2.LicenseRequest.ContentIdentification.ExistingLicense
								.getDefaultInstance())
							return this;
						if (other.hasLicenseId()) {
							mergeLicenseId(other.getLicenseId());
						}
						if (other.hasSecondsSinceStarted()) {
							setSecondsSinceStarted(other.getSecondsSinceStarted());
						}
						if (other.hasSecondsSinceLastPlayed()) {
							setSecondsSinceLastPlayed(other.getSecondsSinceLastPlayed());
						}
						if (other.hasSessionUsageTableEntry()) {
							setSessionUsageTableEntry(other.getSessionUsageTableEntry());
						}
						this.mergeUnknownFields(other.getUnknownFields());
						onChanged();
						return this;
					}

					@java.lang.Override
					public final boolean isInitialized() {
						return true;
					}

					@java.lang.Override
					public Builder mergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
							throws java.io.IOException {
						if (extensionRegistry == null) {
							throw new java.lang.NullPointerException();
						}
						try {
							boolean done = false;
							while (!done) {
								int tag = input.readTag();
								switch (tag) {
								case 0:
									done = true;
									break;
								case 10: {
									input.readMessage(getLicenseIdFieldBuilder().getBuilder(), extensionRegistry);
									bitField0_ |= 0x00000001;
									break;
								} // case 10
								case 16: {
									secondsSinceStarted_ = input.readInt64();
									bitField0_ |= 0x00000002;
									break;
								} // case 16
								case 24: {
									secondsSinceLastPlayed_ = input.readInt64();
									bitField0_ |= 0x00000004;
									break;
								} // case 24
								case 34: {
									sessionUsageTableEntry_ = input.readBytes();
									bitField0_ |= 0x00000008;
									break;
								} // case 34
								default: {
									if (!super.parseUnknownField(input, extensionRegistry, tag)) {
										done = true; // was an endgroup tag
									}
									break;
								} // default:
								} // switch (tag)
							} // while (!done)
						} catch (InvalidProtocolBufferException e) {
							throw e.unwrapIOException();
						}
						finally {
							onChanged();
						} // finally
						return this;
					}

					private int bitField0_;

					private WvProto2.LicenseIdentification licenseId_;
					private SingleFieldBuilderV3<WvProto2.LicenseIdentification, WvProto2.LicenseIdentification.Builder, WvProto2.LicenseIdentificationOrBuilder> licenseIdBuilder_;

					/**
					 * <code>optional .LicenseIdentification license_id = 1;</code>
					 * 
					 * @return Whether the licenseId field is set.
					 */
					@Override
					public boolean hasLicenseId() {
						return ((bitField0_ & 0x00000001) != 0);
					}

					/**
					 * <code>optional .LicenseIdentification license_id = 1;</code>
					 * 
					 * @return The licenseId.
					 */
					@Override
					public WvProto2.LicenseIdentification getLicenseId() {
						if (licenseIdBuilder_ == null) {
							return licenseId_ == null
									? WvProto2.LicenseIdentification.getDefaultInstance()
									: licenseId_;
						}
						return licenseIdBuilder_.getMessage();
					}

					/**
					 * <code>optional .LicenseIdentification license_id = 1;</code>
					 */
					public Builder setLicenseId(WvProto2.LicenseIdentification value) {
						if (licenseIdBuilder_ == null) {
							if (value == null) {
								throw new NullPointerException();
							}
							licenseId_ = value;
						} else {
							licenseIdBuilder_.setMessage(value);
						}
						bitField0_ |= 0x00000001;
						onChanged();
						return this;
					}

					/**
					 * <code>optional .LicenseIdentification license_id = 1;</code>
					 */
					public Builder setLicenseId(
							WvProto2.LicenseIdentification.Builder builderForValue) {
						if (licenseIdBuilder_ == null) {
							licenseId_ = builderForValue.build();
						} else {
							licenseIdBuilder_.setMessage(builderForValue.build());
						}
						bitField0_ |= 0x00000001;
						onChanged();
						return this;
					}

					/**
					 * <code>optional .LicenseIdentification license_id = 1;</code>
					 */
					public Builder mergeLicenseId(WvProto2.LicenseIdentification value) {
						if (licenseIdBuilder_ == null) {
							if (((bitField0_ & 0x00000001) != 0) && licenseId_ != null
									&& licenseId_ != WvProto2.LicenseIdentification
											.getDefaultInstance()) {
								getLicenseIdBuilder().mergeFrom(value);
							} else {
								licenseId_ = value;
							}
						} else {
							licenseIdBuilder_.mergeFrom(value);
						}
						bitField0_ |= 0x00000001;
						onChanged();
						return this;
					}

					/**
					 * <code>optional .LicenseIdentification license_id = 1;</code>
					 */
					public Builder clearLicenseId() {
						bitField0_ = (bitField0_ & ~0x00000001);
						licenseId_ = null;
						if (licenseIdBuilder_ != null) {
							licenseIdBuilder_.dispose();
							licenseIdBuilder_ = null;
						}
						onChanged();
						return this;
					}

					/**
					 * <code>optional .LicenseIdentification license_id = 1;</code>
					 */
					public WvProto2.LicenseIdentification.Builder getLicenseIdBuilder() {
						bitField0_ |= 0x00000001;
						onChanged();
						return getLicenseIdFieldBuilder().getBuilder();
					}

					/**
					 * <code>optional .LicenseIdentification license_id = 1;</code>
					 */
					@Override
					public WvProto2.LicenseIdentificationOrBuilder getLicenseIdOrBuilder() {
						if (licenseIdBuilder_ != null) {
							return licenseIdBuilder_.getMessageOrBuilder();
						}
						return licenseId_ == null
								? WvProto2.LicenseIdentification.getDefaultInstance()
								: licenseId_;
					}

					/**
					 * <code>optional .LicenseIdentification license_id = 1;</code>
					 */
					private SingleFieldBuilderV3<WvProto2.LicenseIdentification, WvProto2.LicenseIdentification.Builder, WvProto2.LicenseIdentificationOrBuilder> getLicenseIdFieldBuilder() {
						if (licenseIdBuilder_ == null) {
							licenseIdBuilder_ = new SingleFieldBuilderV3<>(getLicenseId(), getParentForChildren(),
									isClean());
							licenseId_ = null;
						}
						return licenseIdBuilder_;
					}

					private long secondsSinceStarted_;

					/**
					 * <code>optional int64 seconds_since_started = 2;</code>
					 * 
					 * @return Whether the secondsSinceStarted field is set.
					 */
					@java.lang.Override
					public boolean hasSecondsSinceStarted() {
						return ((bitField0_ & 0x00000002) != 0);
					}

					/**
					 * <code>optional int64 seconds_since_started = 2;</code>
					 * 
					 * @return The secondsSinceStarted.
					 */
					@java.lang.Override
					public long getSecondsSinceStarted() {
						return secondsSinceStarted_;
					}

					/**
					 * <code>optional int64 seconds_since_started = 2;</code>
					 * 
					 * @param value The secondsSinceStarted to set.
					 * @return This builder for chaining.
					 */
					public Builder setSecondsSinceStarted(long value) {

						secondsSinceStarted_ = value;
						bitField0_ |= 0x00000002;
						onChanged();
						return this;
					}

					/**
					 * <code>optional int64 seconds_since_started = 2;</code>
					 * 
					 * @return This builder for chaining.
					 */
					public Builder clearSecondsSinceStarted() {
						bitField0_ = (bitField0_ & ~0x00000002);
						secondsSinceStarted_ = 0L;
						onChanged();
						return this;
					}

					private long secondsSinceLastPlayed_;

					/**
					 * <code>optional int64 seconds_since_last_played = 3;</code>
					 * 
					 * @return Whether the secondsSinceLastPlayed field is set.
					 */
					@java.lang.Override
					public boolean hasSecondsSinceLastPlayed() {
						return ((bitField0_ & 0x00000004) != 0);
					}

					/**
					 * <code>optional int64 seconds_since_last_played = 3;</code>
					 * 
					 * @return The secondsSinceLastPlayed.
					 */
					@java.lang.Override
					public long getSecondsSinceLastPlayed() {
						return secondsSinceLastPlayed_;
					}

					/**
					 * <code>optional int64 seconds_since_last_played = 3;</code>
					 * 
					 * @param value The secondsSinceLastPlayed to set.
					 * @return This builder for chaining.
					 */
					public Builder setSecondsSinceLastPlayed(long value) {

						secondsSinceLastPlayed_ = value;
						bitField0_ |= 0x00000004;
						onChanged();
						return this;
					}

					/**
					 * <code>optional int64 seconds_since_last_played = 3;</code>
					 * 
					 * @return This builder for chaining.
					 */
					public Builder clearSecondsSinceLastPlayed() {
						bitField0_ = (bitField0_ & ~0x00000004);
						secondsSinceLastPlayed_ = 0L;
						onChanged();
						return this;
					}

					private ByteString sessionUsageTableEntry_ = ByteString.EMPTY;

					/**
					 * <code>optional bytes session_usage_table_entry = 4;</code>
					 * 
					 * @return Whether the sessionUsageTableEntry field is set.
					 */
					@java.lang.Override
					public boolean hasSessionUsageTableEntry() {
						return ((bitField0_ & 0x00000008) != 0);
					}

					/**
					 * <code>optional bytes session_usage_table_entry = 4;</code>
					 * 
					 * @return The sessionUsageTableEntry.
					 */
					@java.lang.Override
					public ByteString getSessionUsageTableEntry() {
						return sessionUsageTableEntry_;
					}

					/**
					 * <code>optional bytes session_usage_table_entry = 4;</code>
					 * 
					 * @param value The sessionUsageTableEntry to set.
					 * @return This builder for chaining.
					 */
					public Builder setSessionUsageTableEntry(ByteString value) {
						if (value == null) {
							throw new NullPointerException();
						}
						sessionUsageTableEntry_ = value;
						bitField0_ |= 0x00000008;
						onChanged();
						return this;
					}

					/**
					 * <code>optional bytes session_usage_table_entry = 4;</code>
					 * 
					 * @return This builder for chaining.
					 */
					public Builder clearSessionUsageTableEntry() {
						bitField0_ = (bitField0_ & ~0x00000008);
						sessionUsageTableEntry_ = getDefaultInstance().getSessionUsageTableEntry();
						onChanged();
						return this;
					}

					@java.lang.Override
					public final Builder setUnknownFields(final UnknownFieldSet unknownFields) {
						return super.setUnknownFields(unknownFields);
					}

					@java.lang.Override
					public final Builder mergeUnknownFields(final UnknownFieldSet unknownFields) {
						return super.mergeUnknownFields(unknownFields);
					}

					// @@protoc_insertion_point(builder_scope:LicenseRequest.ContentIdentification.ExistingLicense)
				}

				// @@protoc_insertion_point(class_scope:LicenseRequest.ContentIdentification.ExistingLicense)
				private static final WvProto2.LicenseRequest.ContentIdentification.ExistingLicense DEFAULT_INSTANCE;
				static {
					DEFAULT_INSTANCE = new WvProto2.LicenseRequest.ContentIdentification.ExistingLicense();
				}

				public static WvProto2.LicenseRequest.ContentIdentification.ExistingLicense getDefaultInstance() {
					return DEFAULT_INSTANCE;
				}

				@java.lang.Deprecated public static final Parser<ExistingLicense> PARSER = new AbstractParser<>() {
					@java.lang.Override
					public ExistingLicense parsePartialFrom(CodedInputStream input,
							ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
						Builder builder = newBuilder();
						try {
							builder.mergeFrom(input, extensionRegistry);
						} catch (InvalidProtocolBufferException e) {
							throw e.setUnfinishedMessage(builder.buildPartial());
						} catch (UninitializedMessageException e) {
							throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
						} catch (java.io.IOException e) {
							throw new InvalidProtocolBufferException(e).setUnfinishedMessage(builder.buildPartial());
						}
						return builder.buildPartial();
					}
				};

				public static Parser<ExistingLicense> parser() {
					return PARSER;
				}

				@java.lang.Override
				public Parser<ExistingLicense> getParserForType() {
					return PARSER;
				}

				@java.lang.Override
				public WvProto2.LicenseRequest.ContentIdentification.ExistingLicense getDefaultInstanceForType() {
					return DEFAULT_INSTANCE;
				}

			}

			public interface InitDataOrBuilder extends
					// @@protoc_insertion_point(interface_extends:LicenseRequest.ContentIdentification.InitData)
					MessageOrBuilder {

				/**
				 * <code>optional .LicenseRequest.ContentIdentification.InitData.InitDataType init_data_type = 1 [default = CENC];</code>
				 * 
				 * @return Whether the initDataType field is set.
				 */
				boolean hasInitDataType();

				/**
				 * <code>optional .LicenseRequest.ContentIdentification.InitData.InitDataType init_data_type = 1 [default = CENC];</code>
				 * 
				 * @return The initDataType.
				 */
				WvProto2.LicenseRequest.ContentIdentification.InitData.InitDataType getInitDataType();

				/**
				 * <code>optional bytes init_data = 2;</code>
				 * 
				 * @return Whether the initData field is set.
				 */
				boolean hasInitData();

				/**
				 * <code>optional bytes init_data = 2;</code>
				 * 
				 * @return The initData.
				 */
				ByteString getInitData();

				/**
				 * <code>optional .LicenseType license_type = 3;</code>
				 * 
				 * @return Whether the licenseType field is set.
				 */
				boolean hasLicenseType();

				/**
				 * <code>optional .LicenseType license_type = 3;</code>
				 * 
				 * @return The licenseType.
				 */
				WvProto2.LicenseType getLicenseType();

				/**
				 * <code>optional bytes request_id = 4;</code>
				 * 
				 * @return Whether the requestId field is set.
				 */
				boolean hasRequestId();

				/**
				 * <code>optional bytes request_id = 4;</code>
				 * 
				 * @return The requestId.
				 */
				ByteString getRequestId();
			}

			/**
			 * Protobuf type {@code LicenseRequest.ContentIdentification.InitData}
			 */
			public static final class InitData extends GeneratedMessageV3 implements
					// @@protoc_insertion_point(message_implements:LicenseRequest.ContentIdentification.InitData)
					InitDataOrBuilder {
				private static final long serialVersionUID = 0L;

				// Use InitData.newBuilder() to construct.
				private InitData(GeneratedMessageV3.Builder<?> builder) {
					super(builder);
				}

				private InitData() {
					initDataType_ = 1;
					initData_ = ByteString.EMPTY;
					licenseType_ = 1;
					requestId_ = ByteString.EMPTY;
				}

				@java.lang.Override

				protected java.lang.Object newInstance(UnusedPrivateParameter unused) {
					return new InitData();
				}

				public static final Descriptors.Descriptor getDescriptor() {
					return WvProto2.internal_static_LicenseRequest_ContentIdentification_InitData_descriptor;
				}

				@java.lang.Override
				protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
					return WvProto2.internal_static_LicenseRequest_ContentIdentification_InitData_fieldAccessorTable
							.ensureFieldAccessorsInitialized(
									WvProto2.LicenseRequest.ContentIdentification.InitData.class,
									WvProto2.LicenseRequest.ContentIdentification.InitData.Builder.class);
				}

				/**
				 * Protobuf enum
				 * {@code LicenseRequest.ContentIdentification.InitData.InitDataType}
				 */
				public enum InitDataType implements ProtocolMessageEnum {
					/**
					 * <code>CENC = 1;</code>
					 */
					CENC(1),
					/**
					 * <code>WEBM = 2;</code>
					 */
					WEBM(2),;

					/**
					 * <code>CENC = 1;</code>
					 */
					public static final int CENC_VALUE = 1;
					/**
					 * <code>WEBM = 2;</code>
					 */
					public static final int WEBM_VALUE = 2;

					@Override
					public final int getNumber() {
						return value;
					}

					/**
					 * @param value The numeric wire value of the corresponding enum entry.
					 * @return The enum associated with the given numeric wire value.
					 * @deprecated Use {@link #forNumber(int)} instead.
					 */
					@java.lang.Deprecated
					public static InitDataType valueOf(int value) {
						return forNumber(value);
					}

					/**
					 * @param value The numeric wire value of the corresponding enum entry.
					 * @return The enum associated with the given numeric wire value.
					 */
					public static InitDataType forNumber(int value) {
						switch (value) {
						case 1:
							return CENC;
						case 2:
							return WEBM;
						default:
							return null;
						}
					}

					public static Internal.EnumLiteMap<InitDataType> internalGetValueMap() {
						return internalValueMap;
					}

					private static final Internal.EnumLiteMap<InitDataType> internalValueMap = new Internal.EnumLiteMap<>() {
						@Override
						public InitDataType findValueByNumber(int number) {
							return InitDataType.forNumber(number);
						}
					};

					@Override
					public final Descriptors.EnumValueDescriptor getValueDescriptor() {
						return getDescriptor().getValues().get(ordinal());
					}

					@Override
					public final Descriptors.EnumDescriptor getDescriptorForType() {
						return getDescriptor();
					}

					public static final Descriptors.EnumDescriptor getDescriptor() {
						return WvProto2.LicenseRequest.ContentIdentification.InitData
								.getDescriptor().getEnumTypes().get(0);
					}

					private static final InitDataType[] VALUES = values();

					public static InitDataType valueOf(Descriptors.EnumValueDescriptor desc) {
						if (desc.getType() != getDescriptor()) {
							throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
						}
						return VALUES[desc.getIndex()];
					}

					private final int value;

					private InitDataType(int value) {
						this.value = value;
					}

					// @@protoc_insertion_point(enum_scope:LicenseRequest.ContentIdentification.InitData.InitDataType)
				}

				private int bitField0_;
				public static final int INIT_DATA_TYPE_FIELD_NUMBER = 1;
				private int initDataType_ = 1;

				/**
				 * <code>optional .LicenseRequest.ContentIdentification.InitData.InitDataType init_data_type = 1 [default = CENC];</code>
				 * 
				 * @return Whether the initDataType field is set.
				 */
				@java.lang.Override
				public boolean hasInitDataType() {
					return ((bitField0_ & 0x00000001) != 0);
				}

				/**
				 * <code>optional .LicenseRequest.ContentIdentification.InitData.InitDataType init_data_type = 1 [default = CENC];</code>
				 * 
				 * @return The initDataType.
				 */
				@java.lang.Override
				public WvProto2.LicenseRequest.ContentIdentification.InitData.InitDataType getInitDataType() {
					WvProto2.LicenseRequest.ContentIdentification.InitData.InitDataType result = WvProto2.LicenseRequest.ContentIdentification.InitData.InitDataType
							.forNumber(initDataType_);
					return result == null
							? WvProto2.LicenseRequest.ContentIdentification.InitData.InitDataType.CENC
							: result;
				}

				public static final int INIT_DATA_FIELD_NUMBER = 2;
				private ByteString initData_ = ByteString.EMPTY;

				/**
				 * <code>optional bytes init_data = 2;</code>
				 * 
				 * @return Whether the initData field is set.
				 */
				@java.lang.Override
				public boolean hasInitData() {
					return ((bitField0_ & 0x00000002) != 0);
				}

				/**
				 * <code>optional bytes init_data = 2;</code>
				 * 
				 * @return The initData.
				 */
				@java.lang.Override
				public ByteString getInitData() {
					return initData_;
				}

				public static final int LICENSE_TYPE_FIELD_NUMBER = 3;
				private int licenseType_ = 1;

				/**
				 * <code>optional .LicenseType license_type = 3;</code>
				 * 
				 * @return Whether the licenseType field is set.
				 */
				@java.lang.Override
				public boolean hasLicenseType() {
					return ((bitField0_ & 0x00000004) != 0);
				}

				/**
				 * <code>optional .LicenseType license_type = 3;</code>
				 * 
				 * @return The licenseType.
				 */
				@java.lang.Override
				public WvProto2.LicenseType getLicenseType() {
					WvProto2.LicenseType result = WvProto2.LicenseType
							.forNumber(licenseType_);
					return result == null ? WvProto2.LicenseType.STREAMING : result;
				}

				public static final int REQUEST_ID_FIELD_NUMBER = 4;
				private ByteString requestId_ = ByteString.EMPTY;

				/**
				 * <code>optional bytes request_id = 4;</code>
				 * 
				 * @return Whether the requestId field is set.
				 */
				@java.lang.Override
				public boolean hasRequestId() {
					return ((bitField0_ & 0x00000008) != 0);
				}

				/**
				 * <code>optional bytes request_id = 4;</code>
				 * 
				 * @return The requestId.
				 */
				@java.lang.Override
				public ByteString getRequestId() {
					return requestId_;
				}

				private byte memoizedIsInitialized = -1;

				@java.lang.Override
				public final boolean isInitialized() {
					byte isInitialized = memoizedIsInitialized;
					if (isInitialized == 1)
						return true;
					if (isInitialized == 0)
						return false;

					memoizedIsInitialized = 1;
					return true;
				}

				@java.lang.Override
				public void writeTo(CodedOutputStream output) throws java.io.IOException {
					if (((bitField0_ & 0x00000001) != 0)) {
						output.writeEnum(1, initDataType_);
					}
					if (((bitField0_ & 0x00000002) != 0)) {
						output.writeBytes(2, initData_);
					}
					if (((bitField0_ & 0x00000004) != 0)) {
						output.writeEnum(3, licenseType_);
					}
					if (((bitField0_ & 0x00000008) != 0)) {
						output.writeBytes(4, requestId_);
					}
					getUnknownFields().writeTo(output);
				}

				@java.lang.Override
				public int getSerializedSize() {
					int size = memoizedSize;
					if (size != -1)
						return size;

					size = 0;
					if (((bitField0_ & 0x00000001) != 0)) {
						size += CodedOutputStream.computeEnumSize(1, initDataType_);
					}
					if (((bitField0_ & 0x00000002) != 0)) {
						size += CodedOutputStream.computeBytesSize(2, initData_);
					}
					if (((bitField0_ & 0x00000004) != 0)) {
						size += CodedOutputStream.computeEnumSize(3, licenseType_);
					}
					if (((bitField0_ & 0x00000008) != 0)) {
						size += CodedOutputStream.computeBytesSize(4, requestId_);
					}
					size += getUnknownFields().getSerializedSize();
					memoizedSize = size;
					return size;
				}

				@java.lang.Override
				public boolean equals(final java.lang.Object obj) {
					if (obj == this) {
						return true;
					}
					if (!(obj instanceof WvProto2.LicenseRequest.ContentIdentification.InitData)) {
						return super.equals(obj);
					}
					WvProto2.LicenseRequest.ContentIdentification.InitData other = (WvProto2.LicenseRequest.ContentIdentification.InitData) obj;

					if (hasInitDataType() != other.hasInitDataType())
						return false;
					if (hasInitDataType()) {
						if (initDataType_ != other.initDataType_)
							return false;
					}
					if (hasInitData() != other.hasInitData())
						return false;
					if (hasInitData()) {
						if (!getInitData().equals(other.getInitData()))
							return false;
					}
					if (hasLicenseType() != other.hasLicenseType())
						return false;
					if (hasLicenseType()) {
						if (licenseType_ != other.licenseType_)
							return false;
					}
					if (hasRequestId() != other.hasRequestId())
						return false;
					if (hasRequestId()) {
						if (!getRequestId().equals(other.getRequestId()))
							return false;
					}
					if (!getUnknownFields().equals(other.getUnknownFields()))
						return false;
					return true;
				}

				@SuppressWarnings("unchecked")
				@java.lang.Override
				public int hashCode() {
					if (memoizedHashCode != 0) {
						return memoizedHashCode;
					}
					int hash = 41;
					hash = (19 * hash) + getDescriptor().hashCode();
					if (hasInitDataType()) {
						hash = (37 * hash) + INIT_DATA_TYPE_FIELD_NUMBER;
						hash = (53 * hash) + initDataType_;
					}
					if (hasInitData()) {
						hash = (37 * hash) + INIT_DATA_FIELD_NUMBER;
						hash = (53 * hash) + getInitData().hashCode();
					}
					if (hasLicenseType()) {
						hash = (37 * hash) + LICENSE_TYPE_FIELD_NUMBER;
						hash = (53 * hash) + licenseType_;
					}
					if (hasRequestId()) {
						hash = (37 * hash) + REQUEST_ID_FIELD_NUMBER;
						hash = (53 * hash) + getRequestId().hashCode();
					}
					hash = (29 * hash) + getUnknownFields().hashCode();
					memoizedHashCode = hash;
					return hash;
				}

				public static WvProto2.LicenseRequest.ContentIdentification.InitData parseFrom(
						java.nio.ByteBuffer data) throws InvalidProtocolBufferException {
					return PARSER.parseFrom(data);
				}

				public static WvProto2.LicenseRequest.ContentIdentification.InitData parseFrom(
						java.nio.ByteBuffer data, ExtensionRegistryLite extensionRegistry)
						throws InvalidProtocolBufferException {
					return PARSER.parseFrom(data, extensionRegistry);
				}

				public static WvProto2.LicenseRequest.ContentIdentification.InitData parseFrom(
						ByteString data) throws InvalidProtocolBufferException {
					return PARSER.parseFrom(data);
				}

				public static WvProto2.LicenseRequest.ContentIdentification.InitData parseFrom(
						ByteString data, ExtensionRegistryLite extensionRegistry)
						throws InvalidProtocolBufferException {
					return PARSER.parseFrom(data, extensionRegistry);
				}

				public static WvProto2.LicenseRequest.ContentIdentification.InitData parseFrom(
						byte[] data) throws InvalidProtocolBufferException {
					return PARSER.parseFrom(data);
				}

				public static WvProto2.LicenseRequest.ContentIdentification.InitData parseFrom(
						byte[] data, ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
					return PARSER.parseFrom(data, extensionRegistry);
				}

				public static WvProto2.LicenseRequest.ContentIdentification.InitData parseFrom(
						java.io.InputStream input) throws java.io.IOException {
					return GeneratedMessageV3.parseWithIOException(PARSER, input);
				}

				public static WvProto2.LicenseRequest.ContentIdentification.InitData parseFrom(
						java.io.InputStream input, ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
					return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
				}

				public static WvProto2.LicenseRequest.ContentIdentification.InitData parseDelimitedFrom(
						java.io.InputStream input) throws java.io.IOException {
					return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
				}

				public static WvProto2.LicenseRequest.ContentIdentification.InitData parseDelimitedFrom(
						java.io.InputStream input, ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
					return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input, extensionRegistry);
				}

				public static WvProto2.LicenseRequest.ContentIdentification.InitData parseFrom(
						CodedInputStream input) throws java.io.IOException {
					return GeneratedMessageV3.parseWithIOException(PARSER, input);
				}

				public static WvProto2.LicenseRequest.ContentIdentification.InitData parseFrom(
						CodedInputStream input, ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
					return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
				}

				@java.lang.Override
				public Builder newBuilderForType() {
					return newBuilder();
				}

				public static Builder newBuilder() {
					return DEFAULT_INSTANCE.toBuilder();
				}

				public static Builder newBuilder(
						WvProto2.LicenseRequest.ContentIdentification.InitData prototype) {
					return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
				}

				@java.lang.Override
				public Builder toBuilder() {
					return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
				}

				@java.lang.Override
				protected Builder newBuilderForType(GeneratedMessageV3.BuilderParent parent) {
					Builder builder = new Builder(parent);
					return builder;
				}

				/**
				 * Protobuf type {@code LicenseRequest.ContentIdentification.InitData}
				 */
				public static final class Builder extends GeneratedMessageV3.Builder<Builder> implements
						// @@protoc_insertion_point(builder_implements:LicenseRequest.ContentIdentification.InitData)
						WvProto2.LicenseRequest.ContentIdentification.InitDataOrBuilder {
					public static final Descriptors.Descriptor getDescriptor() {
						return WvProto2.internal_static_LicenseRequest_ContentIdentification_InitData_descriptor;
					}

					@java.lang.Override
					protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
						return WvProto2.internal_static_LicenseRequest_ContentIdentification_InitData_fieldAccessorTable
								.ensureFieldAccessorsInitialized(
										WvProto2.LicenseRequest.ContentIdentification.InitData.class,
										WvProto2.LicenseRequest.ContentIdentification.InitData.Builder.class);
					}

					// Construct using
					// WvProto2.LicenseRequest.ContentIdentification.InitData.newBuilder()
					private Builder() {

					}

					private Builder(GeneratedMessageV3.BuilderParent parent) {
						super(parent);

					}

					@java.lang.Override
					public Builder clear() {
						super.clear();
						bitField0_ = 0;
						initDataType_ = 1;
						initData_ = ByteString.EMPTY;
						licenseType_ = 1;
						requestId_ = ByteString.EMPTY;
						return this;
					}

					@java.lang.Override
					public Descriptors.Descriptor getDescriptorForType() {
						return WvProto2.internal_static_LicenseRequest_ContentIdentification_InitData_descriptor;
					}

					@java.lang.Override
					public WvProto2.LicenseRequest.ContentIdentification.InitData getDefaultInstanceForType() {
						return WvProto2.LicenseRequest.ContentIdentification.InitData
								.getDefaultInstance();
					}

					@java.lang.Override
					public WvProto2.LicenseRequest.ContentIdentification.InitData build() {
						WvProto2.LicenseRequest.ContentIdentification.InitData result = buildPartial();
						if (!result.isInitialized()) {
							throw newUninitializedMessageException(result);
						}
						return result;
					}

					@java.lang.Override
					public WvProto2.LicenseRequest.ContentIdentification.InitData buildPartial() {
						WvProto2.LicenseRequest.ContentIdentification.InitData result = new WvProto2.LicenseRequest.ContentIdentification.InitData(
								this);
						if (bitField0_ != 0) {
							buildPartial0(result);
						}
						onBuilt();
						return result;
					}

					private void buildPartial0(
							WvProto2.LicenseRequest.ContentIdentification.InitData result) {
						int from_bitField0_ = bitField0_;
						int to_bitField0_ = 0;
						if (((from_bitField0_ & 0x00000001) != 0)) {
							result.initDataType_ = initDataType_;
							to_bitField0_ |= 0x00000001;
						}
						if (((from_bitField0_ & 0x00000002) != 0)) {
							result.initData_ = initData_;
							to_bitField0_ |= 0x00000002;
						}
						if (((from_bitField0_ & 0x00000004) != 0)) {
							result.licenseType_ = licenseType_;
							to_bitField0_ |= 0x00000004;
						}
						if (((from_bitField0_ & 0x00000008) != 0)) {
							result.requestId_ = requestId_;
							to_bitField0_ |= 0x00000008;
						}
						result.bitField0_ |= to_bitField0_;
					}

					@java.lang.Override
					public Builder mergeFrom(Message other) {
						if (other instanceof WvProto2.LicenseRequest.ContentIdentification.InitData) {
							return mergeFrom(
									(WvProto2.LicenseRequest.ContentIdentification.InitData) other);
						}
						super.mergeFrom(other);
						return this;
					}

					public Builder mergeFrom(
							WvProto2.LicenseRequest.ContentIdentification.InitData other) {
						if (other == WvProto2.LicenseRequest.ContentIdentification.InitData
								.getDefaultInstance())
							return this;
						if (other.hasInitDataType()) {
							setInitDataType(other.getInitDataType());
						}
						if (other.hasInitData()) {
							setInitData(other.getInitData());
						}
						if (other.hasLicenseType()) {
							setLicenseType(other.getLicenseType());
						}
						if (other.hasRequestId()) {
							setRequestId(other.getRequestId());
						}
						this.mergeUnknownFields(other.getUnknownFields());
						onChanged();
						return this;
					}

					@java.lang.Override
					public final boolean isInitialized() {
						return true;
					}

					@java.lang.Override
					public Builder mergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
							throws java.io.IOException {
						if (extensionRegistry == null) {
							throw new java.lang.NullPointerException();
						}
						try {
							boolean done = false;
							while (!done) {
								int tag = input.readTag();
								switch (tag) {
								case 0:
									done = true;
									break;
								case 8: {
									int tmpRaw = input.readEnum();
									WvProto2.LicenseRequest.ContentIdentification.InitData.InitDataType tmpValue = WvProto2.LicenseRequest.ContentIdentification.InitData.InitDataType
											.forNumber(tmpRaw);
									if (tmpValue == null) {
										mergeUnknownVarintField(1, tmpRaw);
									} else {
										initDataType_ = tmpRaw;
										bitField0_ |= 0x00000001;
									}
									break;
								} // case 8
								case 18: {
									initData_ = input.readBytes();
									bitField0_ |= 0x00000002;
									break;
								} // case 18
								case 24: {
									int tmpRaw = input.readEnum();
									WvProto2.LicenseType tmpValue = WvProto2.LicenseType
											.forNumber(tmpRaw);
									if (tmpValue == null) {
										mergeUnknownVarintField(3, tmpRaw);
									} else {
										licenseType_ = tmpRaw;
										bitField0_ |= 0x00000004;
									}
									break;
								} // case 24
								case 34: {
									requestId_ = input.readBytes();
									bitField0_ |= 0x00000008;
									break;
								} // case 34
								default: {
									if (!super.parseUnknownField(input, extensionRegistry, tag)) {
										done = true; // was an endgroup tag
									}
									break;
								} // default:
								} // switch (tag)
							} // while (!done)
						} catch (InvalidProtocolBufferException e) {
							throw e.unwrapIOException();
						}
						finally {
							onChanged();
						} // finally
						return this;
					}

					private int bitField0_;

					private int initDataType_ = 1;

					/**
					 * <code>optional .LicenseRequest.ContentIdentification.InitData.InitDataType init_data_type = 1 [default = CENC];</code>
					 * 
					 * @return Whether the initDataType field is set.
					 */
					@java.lang.Override
					public boolean hasInitDataType() {
						return ((bitField0_ & 0x00000001) != 0);
					}

					/**
					 * <code>optional .LicenseRequest.ContentIdentification.InitData.InitDataType init_data_type = 1 [default = CENC];</code>
					 * 
					 * @return The initDataType.
					 */
					@java.lang.Override
					public WvProto2.LicenseRequest.ContentIdentification.InitData.InitDataType getInitDataType() {
						WvProto2.LicenseRequest.ContentIdentification.InitData.InitDataType result = WvProto2.LicenseRequest.ContentIdentification.InitData.InitDataType
								.forNumber(initDataType_);
						return result == null
								? WvProto2.LicenseRequest.ContentIdentification.InitData.InitDataType.CENC
								: result;
					}

					/**
					 * <code>optional .LicenseRequest.ContentIdentification.InitData.InitDataType init_data_type = 1 [default = CENC];</code>
					 * 
					 * @param value The initDataType to set.
					 * @return This builder for chaining.
					 */
					public Builder setInitDataType(
							WvProto2.LicenseRequest.ContentIdentification.InitData.InitDataType value) {
						if (value == null) {
							throw new NullPointerException();
						}
						bitField0_ |= 0x00000001;
						initDataType_ = value.getNumber();
						onChanged();
						return this;
					}

					/**
					 * <code>optional .LicenseRequest.ContentIdentification.InitData.InitDataType init_data_type = 1 [default = CENC];</code>
					 * 
					 * @return This builder for chaining.
					 */
					public Builder clearInitDataType() {
						bitField0_ = (bitField0_ & ~0x00000001);
						initDataType_ = 1;
						onChanged();
						return this;
					}

					private ByteString initData_ = ByteString.EMPTY;

					/**
					 * <code>optional bytes init_data = 2;</code>
					 * 
					 * @return Whether the initData field is set.
					 */
					@java.lang.Override
					public boolean hasInitData() {
						return ((bitField0_ & 0x00000002) != 0);
					}

					/**
					 * <code>optional bytes init_data = 2;</code>
					 * 
					 * @return The initData.
					 */
					@java.lang.Override
					public ByteString getInitData() {
						return initData_;
					}

					/**
					 * <code>optional bytes init_data = 2;</code>
					 * 
					 * @param value The initData to set.
					 * @return This builder for chaining.
					 */
					public Builder setInitData(ByteString value) {
						if (value == null) {
							throw new NullPointerException();
						}
						initData_ = value;
						bitField0_ |= 0x00000002;
						onChanged();
						return this;
					}

					/**
					 * <code>optional bytes init_data = 2;</code>
					 * 
					 * @return This builder for chaining.
					 */
					public Builder clearInitData() {
						bitField0_ = (bitField0_ & ~0x00000002);
						initData_ = getDefaultInstance().getInitData();
						onChanged();
						return this;
					}

					private int licenseType_ = 1;

					/**
					 * <code>optional .LicenseType license_type = 3;</code>
					 * 
					 * @return Whether the licenseType field is set.
					 */
					@java.lang.Override
					public boolean hasLicenseType() {
						return ((bitField0_ & 0x00000004) != 0);
					}

					/**
					 * <code>optional .LicenseType license_type = 3;</code>
					 * 
					 * @return The licenseType.
					 */
					@java.lang.Override
					public WvProto2.LicenseType getLicenseType() {
						WvProto2.LicenseType result = WvProto2.LicenseType
								.forNumber(licenseType_);
						return result == null ? WvProto2.LicenseType.STREAMING : result;
					}

					/**
					 * <code>optional .LicenseType license_type = 3;</code>
					 * 
					 * @param value The licenseType to set.
					 * @return This builder for chaining.
					 */
					public Builder setLicenseType(WvProto2.LicenseType value) {
						if (value == null) {
							throw new NullPointerException();
						}
						bitField0_ |= 0x00000004;
						licenseType_ = value.getNumber();
						onChanged();
						return this;
					}

					/**
					 * <code>optional .LicenseType license_type = 3;</code>
					 * 
					 * @return This builder for chaining.
					 */
					public Builder clearLicenseType() {
						bitField0_ = (bitField0_ & ~0x00000004);
						licenseType_ = 1;
						onChanged();
						return this;
					}

					private ByteString requestId_ = ByteString.EMPTY;

					/**
					 * <code>optional bytes request_id = 4;</code>
					 * 
					 * @return Whether the requestId field is set.
					 */
					@java.lang.Override
					public boolean hasRequestId() {
						return ((bitField0_ & 0x00000008) != 0);
					}

					/**
					 * <code>optional bytes request_id = 4;</code>
					 * 
					 * @return The requestId.
					 */
					@java.lang.Override
					public ByteString getRequestId() {
						return requestId_;
					}

					/**
					 * <code>optional bytes request_id = 4;</code>
					 * 
					 * @param value The requestId to set.
					 * @return This builder for chaining.
					 */
					public Builder setRequestId(ByteString value) {
						if (value == null) {
							throw new NullPointerException();
						}
						requestId_ = value;
						bitField0_ |= 0x00000008;
						onChanged();
						return this;
					}

					/**
					 * <code>optional bytes request_id = 4;</code>
					 * 
					 * @return This builder for chaining.
					 */
					public Builder clearRequestId() {
						bitField0_ = (bitField0_ & ~0x00000008);
						requestId_ = getDefaultInstance().getRequestId();
						onChanged();
						return this;
					}

					@java.lang.Override
					public final Builder setUnknownFields(final UnknownFieldSet unknownFields) {
						return super.setUnknownFields(unknownFields);
					}

					@java.lang.Override
					public final Builder mergeUnknownFields(final UnknownFieldSet unknownFields) {
						return super.mergeUnknownFields(unknownFields);
					}

					// @@protoc_insertion_point(builder_scope:LicenseRequest.ContentIdentification.InitData)
				}

				// @@protoc_insertion_point(class_scope:LicenseRequest.ContentIdentification.InitData)
				private static final WvProto2.LicenseRequest.ContentIdentification.InitData DEFAULT_INSTANCE;
				static {
					DEFAULT_INSTANCE = new WvProto2.LicenseRequest.ContentIdentification.InitData();
				}

				public static WvProto2.LicenseRequest.ContentIdentification.InitData getDefaultInstance() {
					return DEFAULT_INSTANCE;
				}

				@java.lang.Deprecated public static final Parser<InitData> PARSER = new AbstractParser<>() {
					@java.lang.Override
					public InitData parsePartialFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
							throws InvalidProtocolBufferException {
						Builder builder = newBuilder();
						try {
							builder.mergeFrom(input, extensionRegistry);
						} catch (InvalidProtocolBufferException e) {
							throw e.setUnfinishedMessage(builder.buildPartial());
						} catch (UninitializedMessageException e) {
							throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
						} catch (java.io.IOException e) {
							throw new InvalidProtocolBufferException(e).setUnfinishedMessage(builder.buildPartial());
						}
						return builder.buildPartial();
					}
				};

				public static Parser<InitData> parser() {
					return PARSER;
				}

				@java.lang.Override
				public Parser<InitData> getParserForType() {
					return PARSER;
				}

				@java.lang.Override
				public WvProto2.LicenseRequest.ContentIdentification.InitData getDefaultInstanceForType() {
					return DEFAULT_INSTANCE;
				}

			}

			private int contentIdVariantCase_ = 0;

			private java.lang.Object contentIdVariant_;

			public enum ContentIdVariantCase implements Internal.EnumLite, AbstractMessage.InternalOneOfEnum {
				WIDEVINE_PSSH_DATA(1), WEBM_KEY_ID(2), EXISTING_LICENSE(3), INIT_DATA(4), CONTENTIDVARIANT_NOT_SET(0);

				private final int value;

				private ContentIdVariantCase(int value) {
					this.value = value;
				}

				/**
				 * @param value The number of the enum to look for.
				 * @return The enum associated with the given number.
				 * @deprecated Use {@link #forNumber(int)} instead.
				 */
				@java.lang.Deprecated
				public static ContentIdVariantCase valueOf(int value) {
					return forNumber(value);
				}

				public static ContentIdVariantCase forNumber(int value) {
					switch (value) {
					case 1:
						return WIDEVINE_PSSH_DATA;
					case 2:
						return WEBM_KEY_ID;
					case 3:
						return EXISTING_LICENSE;
					case 4:
						return INIT_DATA;
					case 0:
						return CONTENTIDVARIANT_NOT_SET;
					default:
						return null;
					}
				}

				@Override
				public int getNumber() {
					return this.value;
				}
			};

			@Override
			public ContentIdVariantCase getContentIdVariantCase() {
				return ContentIdVariantCase.forNumber(contentIdVariantCase_);
			}

			public static final int WIDEVINE_PSSH_DATA_FIELD_NUMBER = 1;

			/**
			 * <pre>
			 * Exactly one of these must be present.
			 * </pre>
			 *
			 * <code>.LicenseRequest.ContentIdentification.WidevinePsshData widevine_pssh_data = 1;</code>
			 * 
			 * @return Whether the widevinePsshData field is set.
			 */
			@java.lang.Override
			public boolean hasWidevinePsshData() {
				return contentIdVariantCase_ == 1;
			}

			/**
			 * <pre>
			 * Exactly one of these must be present.
			 * </pre>
			 *
			 * <code>.LicenseRequest.ContentIdentification.WidevinePsshData widevine_pssh_data = 1;</code>
			 * 
			 * @return The widevinePsshData.
			 */
			@java.lang.Override
			public WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData getWidevinePsshData() {
				if (contentIdVariantCase_ == 1) {
					return (WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData) contentIdVariant_;
				}
				return WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData
						.getDefaultInstance();
			}

			/**
			 * <pre>
			 * Exactly one of these must be present.
			 * </pre>
			 *
			 * <code>.LicenseRequest.ContentIdentification.WidevinePsshData widevine_pssh_data = 1;</code>
			 */
			@java.lang.Override
			public WvProto2.LicenseRequest.ContentIdentification.WidevinePsshDataOrBuilder getWidevinePsshDataOrBuilder() {
				if (contentIdVariantCase_ == 1) {
					return (WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData) contentIdVariant_;
				}
				return WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData
						.getDefaultInstance();
			}

			public static final int WEBM_KEY_ID_FIELD_NUMBER = 2;

			/**
			 * <code>.LicenseRequest.ContentIdentification.WebmKeyId webm_key_id = 2;</code>
			 * 
			 * @return Whether the webmKeyId field is set.
			 */
			@java.lang.Override
			public boolean hasWebmKeyId() {
				return contentIdVariantCase_ == 2;
			}

			/**
			 * <code>.LicenseRequest.ContentIdentification.WebmKeyId webm_key_id = 2;</code>
			 * 
			 * @return The webmKeyId.
			 */
			@java.lang.Override
			public WvProto2.LicenseRequest.ContentIdentification.WebmKeyId getWebmKeyId() {
				if (contentIdVariantCase_ == 2) {
					return (WvProto2.LicenseRequest.ContentIdentification.WebmKeyId) contentIdVariant_;
				}
				return WvProto2.LicenseRequest.ContentIdentification.WebmKeyId
						.getDefaultInstance();
			}

			/**
			 * <code>.LicenseRequest.ContentIdentification.WebmKeyId webm_key_id = 2;</code>
			 */
			@java.lang.Override
			public WvProto2.LicenseRequest.ContentIdentification.WebmKeyIdOrBuilder getWebmKeyIdOrBuilder() {
				if (contentIdVariantCase_ == 2) {
					return (WvProto2.LicenseRequest.ContentIdentification.WebmKeyId) contentIdVariant_;
				}
				return WvProto2.LicenseRequest.ContentIdentification.WebmKeyId
						.getDefaultInstance();
			}

			public static final int EXISTING_LICENSE_FIELD_NUMBER = 3;

			/**
			 * <code>.LicenseRequest.ContentIdentification.ExistingLicense existing_license = 3;</code>
			 * 
			 * @return Whether the existingLicense field is set.
			 */
			@java.lang.Override
			public boolean hasExistingLicense() {
				return contentIdVariantCase_ == 3;
			}

			/**
			 * <code>.LicenseRequest.ContentIdentification.ExistingLicense existing_license = 3;</code>
			 * 
			 * @return The existingLicense.
			 */
			@java.lang.Override
			public WvProto2.LicenseRequest.ContentIdentification.ExistingLicense getExistingLicense() {
				if (contentIdVariantCase_ == 3) {
					return (WvProto2.LicenseRequest.ContentIdentification.ExistingLicense) contentIdVariant_;
				}
				return WvProto2.LicenseRequest.ContentIdentification.ExistingLicense
						.getDefaultInstance();
			}

			/**
			 * <code>.LicenseRequest.ContentIdentification.ExistingLicense existing_license = 3;</code>
			 */
			@java.lang.Override
			public WvProto2.LicenseRequest.ContentIdentification.ExistingLicenseOrBuilder getExistingLicenseOrBuilder() {
				if (contentIdVariantCase_ == 3) {
					return (WvProto2.LicenseRequest.ContentIdentification.ExistingLicense) contentIdVariant_;
				}
				return WvProto2.LicenseRequest.ContentIdentification.ExistingLicense
						.getDefaultInstance();
			}

			public static final int INIT_DATA_FIELD_NUMBER = 4;

			/**
			 * <code>.LicenseRequest.ContentIdentification.InitData init_data = 4;</code>
			 * 
			 * @return Whether the initData field is set.
			 */
			@java.lang.Override
			public boolean hasInitData() {
				return contentIdVariantCase_ == 4;
			}

			/**
			 * <code>.LicenseRequest.ContentIdentification.InitData init_data = 4;</code>
			 * 
			 * @return The initData.
			 */
			@java.lang.Override
			public WvProto2.LicenseRequest.ContentIdentification.InitData getInitData() {
				if (contentIdVariantCase_ == 4) {
					return (WvProto2.LicenseRequest.ContentIdentification.InitData) contentIdVariant_;
				}
				return WvProto2.LicenseRequest.ContentIdentification.InitData
						.getDefaultInstance();
			}

			/**
			 * <code>.LicenseRequest.ContentIdentification.InitData init_data = 4;</code>
			 */
			@java.lang.Override
			public WvProto2.LicenseRequest.ContentIdentification.InitDataOrBuilder getInitDataOrBuilder() {
				if (contentIdVariantCase_ == 4) {
					return (WvProto2.LicenseRequest.ContentIdentification.InitData) contentIdVariant_;
				}
				return WvProto2.LicenseRequest.ContentIdentification.InitData
						.getDefaultInstance();
			}

			private byte memoizedIsInitialized = -1;

			@java.lang.Override
			public final boolean isInitialized() {
				byte isInitialized = memoizedIsInitialized;
				if (isInitialized == 1)
					return true;
				if (isInitialized == 0)
					return false;

				memoizedIsInitialized = 1;
				return true;
			}

			@java.lang.Override
			public void writeTo(CodedOutputStream output) throws java.io.IOException {
				if (contentIdVariantCase_ == 1) {
					output.writeMessage(1,
							(WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData) contentIdVariant_);
				}
				if (contentIdVariantCase_ == 2) {
					output.writeMessage(2,
							(WvProto2.LicenseRequest.ContentIdentification.WebmKeyId) contentIdVariant_);
				}
				if (contentIdVariantCase_ == 3) {
					output.writeMessage(3,
							(WvProto2.LicenseRequest.ContentIdentification.ExistingLicense) contentIdVariant_);
				}
				if (contentIdVariantCase_ == 4) {
					output.writeMessage(4,
							(WvProto2.LicenseRequest.ContentIdentification.InitData) contentIdVariant_);
				}
				getUnknownFields().writeTo(output);
			}

			@java.lang.Override
			public int getSerializedSize() {
				int size = memoizedSize;
				if (size != -1)
					return size;

				size = 0;
				if (contentIdVariantCase_ == 1) {
					size += CodedOutputStream.computeMessageSize(1,
							(WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData) contentIdVariant_);
				}
				if (contentIdVariantCase_ == 2) {
					size += CodedOutputStream.computeMessageSize(2,
							(WvProto2.LicenseRequest.ContentIdentification.WebmKeyId) contentIdVariant_);
				}
				if (contentIdVariantCase_ == 3) {
					size += CodedOutputStream.computeMessageSize(3,
							(WvProto2.LicenseRequest.ContentIdentification.ExistingLicense) contentIdVariant_);
				}
				if (contentIdVariantCase_ == 4) {
					size += CodedOutputStream.computeMessageSize(4,
							(WvProto2.LicenseRequest.ContentIdentification.InitData) contentIdVariant_);
				}
				size += getUnknownFields().getSerializedSize();
				memoizedSize = size;
				return size;
			}

			@java.lang.Override
			public boolean equals(final java.lang.Object obj) {
				if (obj == this) {
					return true;
				}
				if (!(obj instanceof WvProto2.LicenseRequest.ContentIdentification)) {
					return super.equals(obj);
				}
				WvProto2.LicenseRequest.ContentIdentification other = (WvProto2.LicenseRequest.ContentIdentification) obj;

				if (!getContentIdVariantCase().equals(other.getContentIdVariantCase()))
					return false;
				switch (contentIdVariantCase_) {
				case 1:
					if (!getWidevinePsshData().equals(other.getWidevinePsshData()))
						return false;
					break;
				case 2:
					if (!getWebmKeyId().equals(other.getWebmKeyId()))
						return false;
					break;
				case 3:
					if (!getExistingLicense().equals(other.getExistingLicense()))
						return false;
					break;
				case 4:
					if (!getInitData().equals(other.getInitData()))
						return false;
					break;
				case 0:
				default:
				}
				if (!getUnknownFields().equals(other.getUnknownFields()))
					return false;
				return true;
			}

			@SuppressWarnings("unchecked")
			@java.lang.Override
			public int hashCode() {
				if (memoizedHashCode != 0) {
					return memoizedHashCode;
				}
				int hash = 41;
				hash = (19 * hash) + getDescriptor().hashCode();
				switch (contentIdVariantCase_) {
				case 1:
					hash = (37 * hash) + WIDEVINE_PSSH_DATA_FIELD_NUMBER;
					hash = (53 * hash) + getWidevinePsshData().hashCode();
					break;
				case 2:
					hash = (37 * hash) + WEBM_KEY_ID_FIELD_NUMBER;
					hash = (53 * hash) + getWebmKeyId().hashCode();
					break;
				case 3:
					hash = (37 * hash) + EXISTING_LICENSE_FIELD_NUMBER;
					hash = (53 * hash) + getExistingLicense().hashCode();
					break;
				case 4:
					hash = (37 * hash) + INIT_DATA_FIELD_NUMBER;
					hash = (53 * hash) + getInitData().hashCode();
					break;
				case 0:
				default:
				}
				hash = (29 * hash) + getUnknownFields().hashCode();
				memoizedHashCode = hash;
				return hash;
			}

			public static WvProto2.LicenseRequest.ContentIdentification parseFrom(
					java.nio.ByteBuffer data) throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data);
			}

			public static WvProto2.LicenseRequest.ContentIdentification parseFrom(
					java.nio.ByteBuffer data, ExtensionRegistryLite extensionRegistry)
					throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data, extensionRegistry);
			}

			public static WvProto2.LicenseRequest.ContentIdentification parseFrom(
					ByteString data) throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data);
			}

			public static WvProto2.LicenseRequest.ContentIdentification parseFrom(
					ByteString data, ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data, extensionRegistry);
			}

			public static WvProto2.LicenseRequest.ContentIdentification parseFrom(byte[] data)
					throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data);
			}

			public static WvProto2.LicenseRequest.ContentIdentification parseFrom(byte[] data,
					ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data, extensionRegistry);
			}

			public static WvProto2.LicenseRequest.ContentIdentification parseFrom(
					java.io.InputStream input) throws java.io.IOException {
				return GeneratedMessageV3.parseWithIOException(PARSER, input);
			}

			public static WvProto2.LicenseRequest.ContentIdentification parseFrom(
					java.io.InputStream input, ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
				return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
			}

			public static WvProto2.LicenseRequest.ContentIdentification parseDelimitedFrom(
					java.io.InputStream input) throws java.io.IOException {
				return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
			}

			public static WvProto2.LicenseRequest.ContentIdentification parseDelimitedFrom(
					java.io.InputStream input, ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
				return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input, extensionRegistry);
			}

			public static WvProto2.LicenseRequest.ContentIdentification parseFrom(
					CodedInputStream input) throws java.io.IOException {
				return GeneratedMessageV3.parseWithIOException(PARSER, input);
			}

			public static WvProto2.LicenseRequest.ContentIdentification parseFrom(
					CodedInputStream input, ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
				return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
			}

			@java.lang.Override
			public Builder newBuilderForType() {
				return newBuilder();
			}

			public static Builder newBuilder() {
				return DEFAULT_INSTANCE.toBuilder();
			}

			public static Builder newBuilder(
					WvProto2.LicenseRequest.ContentIdentification prototype) {
				return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
			}

			@java.lang.Override
			public Builder toBuilder() {
				return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
			}

			@java.lang.Override
			protected Builder newBuilderForType(GeneratedMessageV3.BuilderParent parent) {
				Builder builder = new Builder(parent);
				return builder;
			}

			/**
			 * Protobuf type {@code LicenseRequest.ContentIdentification}
			 */
			public static final class Builder extends GeneratedMessageV3.Builder<Builder> implements
					// @@protoc_insertion_point(builder_implements:LicenseRequest.ContentIdentification)
					WvProto2.LicenseRequest.ContentIdentificationOrBuilder {
				public static final Descriptors.Descriptor getDescriptor() {
					return WvProto2.internal_static_LicenseRequest_ContentIdentification_descriptor;
				}

				@java.lang.Override
				protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
					return WvProto2.internal_static_LicenseRequest_ContentIdentification_fieldAccessorTable
							.ensureFieldAccessorsInitialized(
									WvProto2.LicenseRequest.ContentIdentification.class,
									WvProto2.LicenseRequest.ContentIdentification.Builder.class);
				}

				// Construct using
				// WvProto2.LicenseRequest.ContentIdentification.newBuilder()
				private Builder() {

				}

				private Builder(GeneratedMessageV3.BuilderParent parent) {
					super(parent);

				}

				@java.lang.Override
				public Builder clear() {
					super.clear();
					bitField0_ = 0;
					if (widevinePsshDataBuilder_ != null) {
						widevinePsshDataBuilder_.clear();
					}
					if (webmKeyIdBuilder_ != null) {
						webmKeyIdBuilder_.clear();
					}
					if (existingLicenseBuilder_ != null) {
						existingLicenseBuilder_.clear();
					}
					if (initDataBuilder_ != null) {
						initDataBuilder_.clear();
					}
					contentIdVariantCase_ = 0;
					contentIdVariant_ = null;
					return this;
				}

				@java.lang.Override
				public Descriptors.Descriptor getDescriptorForType() {
					return WvProto2.internal_static_LicenseRequest_ContentIdentification_descriptor;
				}

				@java.lang.Override
				public WvProto2.LicenseRequest.ContentIdentification getDefaultInstanceForType() {
					return WvProto2.LicenseRequest.ContentIdentification.getDefaultInstance();
				}

				@java.lang.Override
				public WvProto2.LicenseRequest.ContentIdentification build() {
					WvProto2.LicenseRequest.ContentIdentification result = buildPartial();
					if (!result.isInitialized()) {
						throw newUninitializedMessageException(result);
					}
					return result;
				}

				@java.lang.Override
				public WvProto2.LicenseRequest.ContentIdentification buildPartial() {
					WvProto2.LicenseRequest.ContentIdentification result = new WvProto2.LicenseRequest.ContentIdentification(
							this);
					if (bitField0_ != 0) {
						buildPartial0(result);
					}
					buildPartialOneofs(result);
					onBuilt();
					return result;
				}

				private void buildPartial0(
						@SuppressWarnings("unused") WvProto2.LicenseRequest.ContentIdentification result) {
					//
				}

				private void buildPartialOneofs(
						WvProto2.LicenseRequest.ContentIdentification result) {
					result.contentIdVariantCase_ = contentIdVariantCase_;
					result.contentIdVariant_ = this.contentIdVariant_;
					if (contentIdVariantCase_ == 1 && widevinePsshDataBuilder_ != null) {
						result.contentIdVariant_ = widevinePsshDataBuilder_.build();
					}
					if (contentIdVariantCase_ == 2 && webmKeyIdBuilder_ != null) {
						result.contentIdVariant_ = webmKeyIdBuilder_.build();
					}
					if (contentIdVariantCase_ == 3 && existingLicenseBuilder_ != null) {
						result.contentIdVariant_ = existingLicenseBuilder_.build();
					}
					if (contentIdVariantCase_ == 4 && initDataBuilder_ != null) {
						result.contentIdVariant_ = initDataBuilder_.build();
					}
				}

				@java.lang.Override
				public Builder mergeFrom(Message other) {
					if (other instanceof WvProto2.LicenseRequest.ContentIdentification) {
						return mergeFrom((WvProto2.LicenseRequest.ContentIdentification) other);
					}
					super.mergeFrom(other);
					return this;
				}

				public Builder mergeFrom(WvProto2.LicenseRequest.ContentIdentification other) {
					if (other == WvProto2.LicenseRequest.ContentIdentification
							.getDefaultInstance())
						return this;
					switch (other.getContentIdVariantCase()) {
					case WIDEVINE_PSSH_DATA: {
						mergeWidevinePsshData(other.getWidevinePsshData());
						break;
					}
					case WEBM_KEY_ID: {
						mergeWebmKeyId(other.getWebmKeyId());
						break;
					}
					case EXISTING_LICENSE: {
						mergeExistingLicense(other.getExistingLicense());
						break;
					}
					case INIT_DATA: {
						mergeInitData(other.getInitData());
						break;
					}
					case CONTENTIDVARIANT_NOT_SET: {
						break;
					}
					}
					this.mergeUnknownFields(other.getUnknownFields());
					onChanged();
					return this;
				}

				@java.lang.Override
				public final boolean isInitialized() {
					return true;
				}

				@java.lang.Override
				public Builder mergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
						throws java.io.IOException {
					if (extensionRegistry == null) {
						throw new java.lang.NullPointerException();
					}
					try {
						boolean done = false;
						while (!done) {
							int tag = input.readTag();
							switch (tag) {
							case 0:
								done = true;
								break;
							case 10: {
								input.readMessage(getWidevinePsshDataFieldBuilder().getBuilder(), extensionRegistry);
								contentIdVariantCase_ = 1;
								break;
							} // case 10
							case 18: {
								input.readMessage(getWebmKeyIdFieldBuilder().getBuilder(), extensionRegistry);
								contentIdVariantCase_ = 2;
								break;
							} // case 18
							case 26: {
								input.readMessage(getExistingLicenseFieldBuilder().getBuilder(), extensionRegistry);
								contentIdVariantCase_ = 3;
								break;
							} // case 26
							case 34: {
								input.readMessage(getInitDataFieldBuilder().getBuilder(), extensionRegistry);
								contentIdVariantCase_ = 4;
								break;
							} // case 34
							default: {
								if (!super.parseUnknownField(input, extensionRegistry, tag)) {
									done = true; // was an endgroup tag
								}
								break;
							} // default:
							} // switch (tag)
						} // while (!done)
					} catch (InvalidProtocolBufferException e) {
						throw e.unwrapIOException();
					}
					finally {
						onChanged();
					} // finally
					return this;
				}

				private int contentIdVariantCase_ = 0;
				private java.lang.Object contentIdVariant_;

				@Override
				public ContentIdVariantCase getContentIdVariantCase() {
					return ContentIdVariantCase.forNumber(contentIdVariantCase_);
				}

				public Builder clearContentIdVariant() {
					contentIdVariantCase_ = 0;
					contentIdVariant_ = null;
					onChanged();
					return this;
				}

				private int bitField0_;

				private SingleFieldBuilderV3<WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData, WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData.Builder, WvProto2.LicenseRequest.ContentIdentification.WidevinePsshDataOrBuilder> widevinePsshDataBuilder_;

				/**
				 * <pre>
				 * Exactly one of these must be present.
				 * </pre>
				 *
				 * <code>.LicenseRequest.ContentIdentification.WidevinePsshData widevine_pssh_data = 1;</code>
				 * 
				 * @return Whether the widevinePsshData field is set.
				 */
				@java.lang.Override
				public boolean hasWidevinePsshData() {
					return contentIdVariantCase_ == 1;
				}

				/**
				 * <pre>
				 * Exactly one of these must be present.
				 * </pre>
				 *
				 * <code>.LicenseRequest.ContentIdentification.WidevinePsshData widevine_pssh_data = 1;</code>
				 * 
				 * @return The widevinePsshData.
				 */
				@java.lang.Override
				public WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData getWidevinePsshData() {
					if (widevinePsshDataBuilder_ == null) {
						if (contentIdVariantCase_ == 1) {
							return (WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData) contentIdVariant_;
						}
						return WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData
								.getDefaultInstance();
					}
					if (contentIdVariantCase_ == 1) {
						return widevinePsshDataBuilder_.getMessage();
					}
					return WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData
							.getDefaultInstance();
				}

				/**
				 * <pre>
				 * Exactly one of these must be present.
				 * </pre>
				 *
				 * <code>.LicenseRequest.ContentIdentification.WidevinePsshData widevine_pssh_data = 1;</code>
				 */
				public Builder setWidevinePsshData(
						WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData value) {
					if (widevinePsshDataBuilder_ == null) {
						if (value == null) {
							throw new NullPointerException();
						}
						contentIdVariant_ = value;
						onChanged();
					} else {
						widevinePsshDataBuilder_.setMessage(value);
					}
					contentIdVariantCase_ = 1;
					return this;
				}

				/**
				 * <pre>
				 * Exactly one of these must be present.
				 * </pre>
				 *
				 * <code>.LicenseRequest.ContentIdentification.WidevinePsshData widevine_pssh_data = 1;</code>
				 */
				public Builder setWidevinePsshData(
						WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData.Builder builderForValue) {
					if (widevinePsshDataBuilder_ == null) {
						contentIdVariant_ = builderForValue.build();
						onChanged();
					} else {
						widevinePsshDataBuilder_.setMessage(builderForValue.build());
					}
					contentIdVariantCase_ = 1;
					return this;
				}

				/**
				 * <pre>
				 * Exactly one of these must be present.
				 * </pre>
				 *
				 * <code>.LicenseRequest.ContentIdentification.WidevinePsshData widevine_pssh_data = 1;</code>
				 */
				public Builder mergeWidevinePsshData(
						WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData value) {
					if (widevinePsshDataBuilder_ == null) {
						if (contentIdVariantCase_ == 1
								&& contentIdVariant_ != WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData
										.getDefaultInstance()) {
							contentIdVariant_ = WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData
									.newBuilder(
											(WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData) contentIdVariant_)
									.mergeFrom(value).buildPartial();
						} else {
							contentIdVariant_ = value;
						}
						onChanged();
					} else {
						if (contentIdVariantCase_ == 1) {
							widevinePsshDataBuilder_.mergeFrom(value);
						} else {
							widevinePsshDataBuilder_.setMessage(value);
						}
					}
					contentIdVariantCase_ = 1;
					return this;
				}

				/**
				 * <pre>
				 * Exactly one of these must be present.
				 * </pre>
				 *
				 * <code>.LicenseRequest.ContentIdentification.WidevinePsshData widevine_pssh_data = 1;</code>
				 */
				public Builder clearWidevinePsshData() {
					if (widevinePsshDataBuilder_ == null) {
						if (contentIdVariantCase_ == 1) {
							contentIdVariantCase_ = 0;
							contentIdVariant_ = null;
							onChanged();
						}
					} else {
						if (contentIdVariantCase_ == 1) {
							contentIdVariantCase_ = 0;
							contentIdVariant_ = null;
						}
						widevinePsshDataBuilder_.clear();
					}
					return this;
				}

				/**
				 * <pre>
				 * Exactly one of these must be present.
				 * </pre>
				 *
				 * <code>.LicenseRequest.ContentIdentification.WidevinePsshData widevine_pssh_data = 1;</code>
				 */
				public WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData.Builder getWidevinePsshDataBuilder() {
					return getWidevinePsshDataFieldBuilder().getBuilder();
				}

				/**
				 * <pre>
				 * Exactly one of these must be present.
				 * </pre>
				 *
				 * <code>.LicenseRequest.ContentIdentification.WidevinePsshData widevine_pssh_data = 1;</code>
				 */
				@java.lang.Override
				public WvProto2.LicenseRequest.ContentIdentification.WidevinePsshDataOrBuilder getWidevinePsshDataOrBuilder() {
					if ((contentIdVariantCase_ == 1) && (widevinePsshDataBuilder_ != null)) {
						return widevinePsshDataBuilder_.getMessageOrBuilder();
					}
					if (contentIdVariantCase_ == 1) {
						return (WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData) contentIdVariant_;
					}
					return WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData
							.getDefaultInstance();
				}

				/**
				 * <pre>
				 * Exactly one of these must be present.
				 * </pre>
				 *
				 * <code>.LicenseRequest.ContentIdentification.WidevinePsshData widevine_pssh_data = 1;</code>
				 */
				private SingleFieldBuilderV3<WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData, WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData.Builder, WvProto2.LicenseRequest.ContentIdentification.WidevinePsshDataOrBuilder> getWidevinePsshDataFieldBuilder() {
					if (widevinePsshDataBuilder_ == null) {
						if (!(contentIdVariantCase_ == 1)) {
							contentIdVariant_ = WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData
									.getDefaultInstance();
						}
						widevinePsshDataBuilder_ = new SingleFieldBuilderV3<>(
								(WvProto2.LicenseRequest.ContentIdentification.WidevinePsshData) contentIdVariant_,
								getParentForChildren(), isClean());
						contentIdVariant_ = null;
					}
					contentIdVariantCase_ = 1;
					onChanged();
					return widevinePsshDataBuilder_;
				}

				private SingleFieldBuilderV3<WvProto2.LicenseRequest.ContentIdentification.WebmKeyId, WvProto2.LicenseRequest.ContentIdentification.WebmKeyId.Builder, WvProto2.LicenseRequest.ContentIdentification.WebmKeyIdOrBuilder> webmKeyIdBuilder_;

				/**
				 * <code>.LicenseRequest.ContentIdentification.WebmKeyId webm_key_id = 2;</code>
				 * 
				 * @return Whether the webmKeyId field is set.
				 */
				@java.lang.Override
				public boolean hasWebmKeyId() {
					return contentIdVariantCase_ == 2;
				}

				/**
				 * <code>.LicenseRequest.ContentIdentification.WebmKeyId webm_key_id = 2;</code>
				 * 
				 * @return The webmKeyId.
				 */
				@java.lang.Override
				public WvProto2.LicenseRequest.ContentIdentification.WebmKeyId getWebmKeyId() {
					if (webmKeyIdBuilder_ == null) {
						if (contentIdVariantCase_ == 2) {
							return (WvProto2.LicenseRequest.ContentIdentification.WebmKeyId) contentIdVariant_;
						}
						return WvProto2.LicenseRequest.ContentIdentification.WebmKeyId
								.getDefaultInstance();
					}
					if (contentIdVariantCase_ == 2) {
						return webmKeyIdBuilder_.getMessage();
					}
					return WvProto2.LicenseRequest.ContentIdentification.WebmKeyId
							.getDefaultInstance();
				}

				/**
				 * <code>.LicenseRequest.ContentIdentification.WebmKeyId webm_key_id = 2;</code>
				 */
				public Builder setWebmKeyId(
						WvProto2.LicenseRequest.ContentIdentification.WebmKeyId value) {
					if (webmKeyIdBuilder_ == null) {
						if (value == null) {
							throw new NullPointerException();
						}
						contentIdVariant_ = value;
						onChanged();
					} else {
						webmKeyIdBuilder_.setMessage(value);
					}
					contentIdVariantCase_ = 2;
					return this;
				}

				/**
				 * <code>.LicenseRequest.ContentIdentification.WebmKeyId webm_key_id = 2;</code>
				 */
				public Builder setWebmKeyId(
						WvProto2.LicenseRequest.ContentIdentification.WebmKeyId.Builder builderForValue) {
					if (webmKeyIdBuilder_ == null) {
						contentIdVariant_ = builderForValue.build();
						onChanged();
					} else {
						webmKeyIdBuilder_.setMessage(builderForValue.build());
					}
					contentIdVariantCase_ = 2;
					return this;
				}

				/**
				 * <code>.LicenseRequest.ContentIdentification.WebmKeyId webm_key_id = 2;</code>
				 */
				public Builder mergeWebmKeyId(
						WvProto2.LicenseRequest.ContentIdentification.WebmKeyId value) {
					if (webmKeyIdBuilder_ == null) {
						if (contentIdVariantCase_ == 2
								&& contentIdVariant_ != WvProto2.LicenseRequest.ContentIdentification.WebmKeyId
										.getDefaultInstance()) {
							contentIdVariant_ = WvProto2.LicenseRequest.ContentIdentification.WebmKeyId
									.newBuilder(
											(WvProto2.LicenseRequest.ContentIdentification.WebmKeyId) contentIdVariant_)
									.mergeFrom(value).buildPartial();
						} else {
							contentIdVariant_ = value;
						}
						onChanged();
					} else {
						if (contentIdVariantCase_ == 2) {
							webmKeyIdBuilder_.mergeFrom(value);
						} else {
							webmKeyIdBuilder_.setMessage(value);
						}
					}
					contentIdVariantCase_ = 2;
					return this;
				}

				/**
				 * <code>.LicenseRequest.ContentIdentification.WebmKeyId webm_key_id = 2;</code>
				 */
				public Builder clearWebmKeyId() {
					if (webmKeyIdBuilder_ == null) {
						if (contentIdVariantCase_ == 2) {
							contentIdVariantCase_ = 0;
							contentIdVariant_ = null;
							onChanged();
						}
					} else {
						if (contentIdVariantCase_ == 2) {
							contentIdVariantCase_ = 0;
							contentIdVariant_ = null;
						}
						webmKeyIdBuilder_.clear();
					}
					return this;
				}

				/**
				 * <code>.LicenseRequest.ContentIdentification.WebmKeyId webm_key_id = 2;</code>
				 */
				public WvProto2.LicenseRequest.ContentIdentification.WebmKeyId.Builder getWebmKeyIdBuilder() {
					return getWebmKeyIdFieldBuilder().getBuilder();
				}

				/**
				 * <code>.LicenseRequest.ContentIdentification.WebmKeyId webm_key_id = 2;</code>
				 */
				@java.lang.Override
				public WvProto2.LicenseRequest.ContentIdentification.WebmKeyIdOrBuilder getWebmKeyIdOrBuilder() {
					if ((contentIdVariantCase_ == 2) && (webmKeyIdBuilder_ != null)) {
						return webmKeyIdBuilder_.getMessageOrBuilder();
					}
					if (contentIdVariantCase_ == 2) {
						return (WvProto2.LicenseRequest.ContentIdentification.WebmKeyId) contentIdVariant_;
					}
					return WvProto2.LicenseRequest.ContentIdentification.WebmKeyId
							.getDefaultInstance();
				}

				/**
				 * <code>.LicenseRequest.ContentIdentification.WebmKeyId webm_key_id = 2;</code>
				 */
				private SingleFieldBuilderV3<WvProto2.LicenseRequest.ContentIdentification.WebmKeyId, WvProto2.LicenseRequest.ContentIdentification.WebmKeyId.Builder, WvProto2.LicenseRequest.ContentIdentification.WebmKeyIdOrBuilder> getWebmKeyIdFieldBuilder() {
					if (webmKeyIdBuilder_ == null) {
						if (!(contentIdVariantCase_ == 2)) {
							contentIdVariant_ = WvProto2.LicenseRequest.ContentIdentification.WebmKeyId
									.getDefaultInstance();
						}
						webmKeyIdBuilder_ = new SingleFieldBuilderV3<>(
								(WvProto2.LicenseRequest.ContentIdentification.WebmKeyId) contentIdVariant_,
								getParentForChildren(), isClean());
						contentIdVariant_ = null;
					}
					contentIdVariantCase_ = 2;
					onChanged();
					return webmKeyIdBuilder_;
				}

				private SingleFieldBuilderV3<WvProto2.LicenseRequest.ContentIdentification.ExistingLicense, WvProto2.LicenseRequest.ContentIdentification.ExistingLicense.Builder, WvProto2.LicenseRequest.ContentIdentification.ExistingLicenseOrBuilder> existingLicenseBuilder_;

				/**
				 * <code>.LicenseRequest.ContentIdentification.ExistingLicense existing_license = 3;</code>
				 * 
				 * @return Whether the existingLicense field is set.
				 */
				@java.lang.Override
				public boolean hasExistingLicense() {
					return contentIdVariantCase_ == 3;
				}

				/**
				 * <code>.LicenseRequest.ContentIdentification.ExistingLicense existing_license = 3;</code>
				 * 
				 * @return The existingLicense.
				 */
				@java.lang.Override
				public WvProto2.LicenseRequest.ContentIdentification.ExistingLicense getExistingLicense() {
					if (existingLicenseBuilder_ == null) {
						if (contentIdVariantCase_ == 3) {
							return (WvProto2.LicenseRequest.ContentIdentification.ExistingLicense) contentIdVariant_;
						}
						return WvProto2.LicenseRequest.ContentIdentification.ExistingLicense
								.getDefaultInstance();
					}
					if (contentIdVariantCase_ == 3) {
						return existingLicenseBuilder_.getMessage();
					}
					return WvProto2.LicenseRequest.ContentIdentification.ExistingLicense
							.getDefaultInstance();
				}

				/**
				 * <code>.LicenseRequest.ContentIdentification.ExistingLicense existing_license = 3;</code>
				 */
				public Builder setExistingLicense(
						WvProto2.LicenseRequest.ContentIdentification.ExistingLicense value) {
					if (existingLicenseBuilder_ == null) {
						if (value == null) {
							throw new NullPointerException();
						}
						contentIdVariant_ = value;
						onChanged();
					} else {
						existingLicenseBuilder_.setMessage(value);
					}
					contentIdVariantCase_ = 3;
					return this;
				}

				/**
				 * <code>.LicenseRequest.ContentIdentification.ExistingLicense existing_license = 3;</code>
				 */
				public Builder setExistingLicense(
						WvProto2.LicenseRequest.ContentIdentification.ExistingLicense.Builder builderForValue) {
					if (existingLicenseBuilder_ == null) {
						contentIdVariant_ = builderForValue.build();
						onChanged();
					} else {
						existingLicenseBuilder_.setMessage(builderForValue.build());
					}
					contentIdVariantCase_ = 3;
					return this;
				}

				/**
				 * <code>.LicenseRequest.ContentIdentification.ExistingLicense existing_license = 3;</code>
				 */
				public Builder mergeExistingLicense(
						WvProto2.LicenseRequest.ContentIdentification.ExistingLicense value) {
					if (existingLicenseBuilder_ == null) {
						if (contentIdVariantCase_ == 3
								&& contentIdVariant_ != WvProto2.LicenseRequest.ContentIdentification.ExistingLicense
										.getDefaultInstance()) {
							contentIdVariant_ = WvProto2.LicenseRequest.ContentIdentification.ExistingLicense
									.newBuilder(
											(WvProto2.LicenseRequest.ContentIdentification.ExistingLicense) contentIdVariant_)
									.mergeFrom(value).buildPartial();
						} else {
							contentIdVariant_ = value;
						}
						onChanged();
					} else {
						if (contentIdVariantCase_ == 3) {
							existingLicenseBuilder_.mergeFrom(value);
						} else {
							existingLicenseBuilder_.setMessage(value);
						}
					}
					contentIdVariantCase_ = 3;
					return this;
				}

				/**
				 * <code>.LicenseRequest.ContentIdentification.ExistingLicense existing_license = 3;</code>
				 */
				public Builder clearExistingLicense() {
					if (existingLicenseBuilder_ == null) {
						if (contentIdVariantCase_ == 3) {
							contentIdVariantCase_ = 0;
							contentIdVariant_ = null;
							onChanged();
						}
					} else {
						if (contentIdVariantCase_ == 3) {
							contentIdVariantCase_ = 0;
							contentIdVariant_ = null;
						}
						existingLicenseBuilder_.clear();
					}
					return this;
				}

				/**
				 * <code>.LicenseRequest.ContentIdentification.ExistingLicense existing_license = 3;</code>
				 */
				public WvProto2.LicenseRequest.ContentIdentification.ExistingLicense.Builder getExistingLicenseBuilder() {
					return getExistingLicenseFieldBuilder().getBuilder();
				}

				/**
				 * <code>.LicenseRequest.ContentIdentification.ExistingLicense existing_license = 3;</code>
				 */
				@java.lang.Override
				public WvProto2.LicenseRequest.ContentIdentification.ExistingLicenseOrBuilder getExistingLicenseOrBuilder() {
					if ((contentIdVariantCase_ == 3) && (existingLicenseBuilder_ != null)) {
						return existingLicenseBuilder_.getMessageOrBuilder();
					}
					if (contentIdVariantCase_ == 3) {
						return (WvProto2.LicenseRequest.ContentIdentification.ExistingLicense) contentIdVariant_;
					}
					return WvProto2.LicenseRequest.ContentIdentification.ExistingLicense
							.getDefaultInstance();
				}

				/**
				 * <code>.LicenseRequest.ContentIdentification.ExistingLicense existing_license = 3;</code>
				 */
				private SingleFieldBuilderV3<WvProto2.LicenseRequest.ContentIdentification.ExistingLicense, WvProto2.LicenseRequest.ContentIdentification.ExistingLicense.Builder, WvProto2.LicenseRequest.ContentIdentification.ExistingLicenseOrBuilder> getExistingLicenseFieldBuilder() {
					if (existingLicenseBuilder_ == null) {
						if (!(contentIdVariantCase_ == 3)) {
							contentIdVariant_ = WvProto2.LicenseRequest.ContentIdentification.ExistingLicense
									.getDefaultInstance();
						}
						existingLicenseBuilder_ = new SingleFieldBuilderV3<>(
								(WvProto2.LicenseRequest.ContentIdentification.ExistingLicense) contentIdVariant_,
								getParentForChildren(), isClean());
						contentIdVariant_ = null;
					}
					contentIdVariantCase_ = 3;
					onChanged();
					return existingLicenseBuilder_;
				}

				private SingleFieldBuilderV3<WvProto2.LicenseRequest.ContentIdentification.InitData, WvProto2.LicenseRequest.ContentIdentification.InitData.Builder, WvProto2.LicenseRequest.ContentIdentification.InitDataOrBuilder> initDataBuilder_;

				/**
				 * <code>.LicenseRequest.ContentIdentification.InitData init_data = 4;</code>
				 * 
				 * @return Whether the initData field is set.
				 */
				@java.lang.Override
				public boolean hasInitData() {
					return contentIdVariantCase_ == 4;
				}

				/**
				 * <code>.LicenseRequest.ContentIdentification.InitData init_data = 4;</code>
				 * 
				 * @return The initData.
				 */
				@java.lang.Override
				public WvProto2.LicenseRequest.ContentIdentification.InitData getInitData() {
					if (initDataBuilder_ == null) {
						if (contentIdVariantCase_ == 4) {
							return (WvProto2.LicenseRequest.ContentIdentification.InitData) contentIdVariant_;
						}
						return WvProto2.LicenseRequest.ContentIdentification.InitData
								.getDefaultInstance();
					}
					if (contentIdVariantCase_ == 4) {
						return initDataBuilder_.getMessage();
					}
					return WvProto2.LicenseRequest.ContentIdentification.InitData
							.getDefaultInstance();
				}

				/**
				 * <code>.LicenseRequest.ContentIdentification.InitData init_data = 4;</code>
				 */
				public Builder setInitData(
						WvProto2.LicenseRequest.ContentIdentification.InitData value) {
					if (initDataBuilder_ == null) {
						if (value == null) {
							throw new NullPointerException();
						}
						contentIdVariant_ = value;
						onChanged();
					} else {
						initDataBuilder_.setMessage(value);
					}
					contentIdVariantCase_ = 4;
					return this;
				}

				/**
				 * <code>.LicenseRequest.ContentIdentification.InitData init_data = 4;</code>
				 */
				public Builder setInitData(
						WvProto2.LicenseRequest.ContentIdentification.InitData.Builder builderForValue) {
					if (initDataBuilder_ == null) {
						contentIdVariant_ = builderForValue.build();
						onChanged();
					} else {
						initDataBuilder_.setMessage(builderForValue.build());
					}
					contentIdVariantCase_ = 4;
					return this;
				}

				/**
				 * <code>.LicenseRequest.ContentIdentification.InitData init_data = 4;</code>
				 */
				public Builder mergeInitData(
						WvProto2.LicenseRequest.ContentIdentification.InitData value) {
					if (initDataBuilder_ == null) {
						if (contentIdVariantCase_ == 4
								&& contentIdVariant_ != WvProto2.LicenseRequest.ContentIdentification.InitData
										.getDefaultInstance()) {
							contentIdVariant_ = WvProto2.LicenseRequest.ContentIdentification.InitData
									.newBuilder(
											(WvProto2.LicenseRequest.ContentIdentification.InitData) contentIdVariant_)
									.mergeFrom(value).buildPartial();
						} else {
							contentIdVariant_ = value;
						}
						onChanged();
					} else {
						if (contentIdVariantCase_ == 4) {
							initDataBuilder_.mergeFrom(value);
						} else {
							initDataBuilder_.setMessage(value);
						}
					}
					contentIdVariantCase_ = 4;
					return this;
				}

				/**
				 * <code>.LicenseRequest.ContentIdentification.InitData init_data = 4;</code>
				 */
				public Builder clearInitData() {
					if (initDataBuilder_ == null) {
						if (contentIdVariantCase_ == 4) {
							contentIdVariantCase_ = 0;
							contentIdVariant_ = null;
							onChanged();
						}
					} else {
						if (contentIdVariantCase_ == 4) {
							contentIdVariantCase_ = 0;
							contentIdVariant_ = null;
						}
						initDataBuilder_.clear();
					}
					return this;
				}

				/**
				 * <code>.LicenseRequest.ContentIdentification.InitData init_data = 4;</code>
				 */
				public WvProto2.LicenseRequest.ContentIdentification.InitData.Builder getInitDataBuilder() {
					return getInitDataFieldBuilder().getBuilder();
				}

				/**
				 * <code>.LicenseRequest.ContentIdentification.InitData init_data = 4;</code>
				 */
				@java.lang.Override
				public WvProto2.LicenseRequest.ContentIdentification.InitDataOrBuilder getInitDataOrBuilder() {
					if ((contentIdVariantCase_ == 4) && (initDataBuilder_ != null)) {
						return initDataBuilder_.getMessageOrBuilder();
					}
					if (contentIdVariantCase_ == 4) {
						return (WvProto2.LicenseRequest.ContentIdentification.InitData) contentIdVariant_;
					}
					return WvProto2.LicenseRequest.ContentIdentification.InitData
							.getDefaultInstance();
				}

				/**
				 * <code>.LicenseRequest.ContentIdentification.InitData init_data = 4;</code>
				 */
				private SingleFieldBuilderV3<WvProto2.LicenseRequest.ContentIdentification.InitData, WvProto2.LicenseRequest.ContentIdentification.InitData.Builder, WvProto2.LicenseRequest.ContentIdentification.InitDataOrBuilder> getInitDataFieldBuilder() {
					if (initDataBuilder_ == null) {
						if (!(contentIdVariantCase_ == 4)) {
							contentIdVariant_ = WvProto2.LicenseRequest.ContentIdentification.InitData
									.getDefaultInstance();
						}
						initDataBuilder_ = new SingleFieldBuilderV3<>(
								(WvProto2.LicenseRequest.ContentIdentification.InitData) contentIdVariant_,
								getParentForChildren(), isClean());
						contentIdVariant_ = null;
					}
					contentIdVariantCase_ = 4;
					onChanged();
					return initDataBuilder_;
				}

				@java.lang.Override
				public final Builder setUnknownFields(final UnknownFieldSet unknownFields) {
					return super.setUnknownFields(unknownFields);
				}

				@java.lang.Override
				public final Builder mergeUnknownFields(final UnknownFieldSet unknownFields) {
					return super.mergeUnknownFields(unknownFields);
				}

				// @@protoc_insertion_point(builder_scope:LicenseRequest.ContentIdentification)
			}

			// @@protoc_insertion_point(class_scope:LicenseRequest.ContentIdentification)
			private static final WvProto2.LicenseRequest.ContentIdentification DEFAULT_INSTANCE;
			static {
				DEFAULT_INSTANCE = new WvProto2.LicenseRequest.ContentIdentification();
			}

			public static WvProto2.LicenseRequest.ContentIdentification getDefaultInstance() {
				return DEFAULT_INSTANCE;
			}

			@java.lang.Deprecated public static final Parser<ContentIdentification> PARSER = new AbstractParser<>() {
				@java.lang.Override
				public ContentIdentification parsePartialFrom(CodedInputStream input,
						ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
					Builder builder = newBuilder();
					try {
						builder.mergeFrom(input, extensionRegistry);
					} catch (InvalidProtocolBufferException e) {
						throw e.setUnfinishedMessage(builder.buildPartial());
					} catch (UninitializedMessageException e) {
						throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
					} catch (java.io.IOException e) {
						throw new InvalidProtocolBufferException(e).setUnfinishedMessage(builder.buildPartial());
					}
					return builder.buildPartial();
				}
			};

			public static Parser<ContentIdentification> parser() {
				return PARSER;
			}

			@java.lang.Override
			public Parser<ContentIdentification> getParserForType() {
				return PARSER;
			}

			@java.lang.Override
			public WvProto2.LicenseRequest.ContentIdentification getDefaultInstanceForType() {
				return DEFAULT_INSTANCE;
			}

		}

		private int bitField0_;
		public static final int CLIENT_ID_FIELD_NUMBER = 1;
		private WvProto2.ClientIdentification clientId_;

		/**
		 * <pre>
		 * The client_id provides information authenticating the calling device.  It
		 * contains the Widevine keybox token that was installed on the device at the
		 * factory.  This field or encrypted_client_id below is required for a valid
		 * license request, but both should never be present in the same request.
		 * </pre>
		 *
		 * <code>optional .ClientIdentification client_id = 1;</code>
		 * 
		 * @return Whether the clientId field is set.
		 */
		@java.lang.Override
		public boolean hasClientId() {
			return ((bitField0_ & 0x00000001) != 0);
		}

		/**
		 * <pre>
		 * The client_id provides information authenticating the calling device.  It
		 * contains the Widevine keybox token that was installed on the device at the
		 * factory.  This field or encrypted_client_id below is required for a valid
		 * license request, but both should never be present in the same request.
		 * </pre>
		 *
		 * <code>optional .ClientIdentification client_id = 1;</code>
		 * 
		 * @return The clientId.
		 */
		@java.lang.Override
		public WvProto2.ClientIdentification getClientId() {
			return clientId_ == null ? WvProto2.ClientIdentification.getDefaultInstance()
					: clientId_;
		}

		/**
		 * <pre>
		 * The client_id provides information authenticating the calling device.  It
		 * contains the Widevine keybox token that was installed on the device at the
		 * factory.  This field or encrypted_client_id below is required for a valid
		 * license request, but both should never be present in the same request.
		 * </pre>
		 *
		 * <code>optional .ClientIdentification client_id = 1;</code>
		 */
		@java.lang.Override
		public WvProto2.ClientIdentificationOrBuilder getClientIdOrBuilder() {
			return clientId_ == null ? WvProto2.ClientIdentification.getDefaultInstance()
					: clientId_;
		}

		public static final int CONTENT_ID_FIELD_NUMBER = 2;
		private WvProto2.LicenseRequest.ContentIdentification contentId_;

		/**
		 * <code>optional .LicenseRequest.ContentIdentification content_id = 2;</code>
		 * 
		 * @return Whether the contentId field is set.
		 */
		@java.lang.Override
		public boolean hasContentId() {
			return ((bitField0_ & 0x00000002) != 0);
		}

		/**
		 * <code>optional .LicenseRequest.ContentIdentification content_id = 2;</code>
		 * 
		 * @return The contentId.
		 */
		@java.lang.Override
		public WvProto2.LicenseRequest.ContentIdentification getContentId() {
			return contentId_ == null
					? WvProto2.LicenseRequest.ContentIdentification.getDefaultInstance()
					: contentId_;
		}

		/**
		 * <code>optional .LicenseRequest.ContentIdentification content_id = 2;</code>
		 */
		@java.lang.Override
		public WvProto2.LicenseRequest.ContentIdentificationOrBuilder getContentIdOrBuilder() {
			return contentId_ == null
					? WvProto2.LicenseRequest.ContentIdentification.getDefaultInstance()
					: contentId_;
		}

		public static final int TYPE_FIELD_NUMBER = 3;
		private int type_ = 1;

		/**
		 * <code>optional .LicenseRequest.RequestType type = 3;</code>
		 * 
		 * @return Whether the type field is set.
		 */
		@java.lang.Override
		public boolean hasType() {
			return ((bitField0_ & 0x00000004) != 0);
		}

		/**
		 * <code>optional .LicenseRequest.RequestType type = 3;</code>
		 * 
		 * @return The type.
		 */
		@java.lang.Override
		public WvProto2.LicenseRequest.RequestType getType() {
			WvProto2.LicenseRequest.RequestType result = WvProto2.LicenseRequest.RequestType
					.forNumber(type_);
			return result == null ? WvProto2.LicenseRequest.RequestType.NEW : result;
		}

		public static final int REQUEST_TIME_FIELD_NUMBER = 4;
		private long requestTime_ = 0L;

		/**
		 * <pre>
		 * Time of the request in seconds (UTC) as set by the client.
		 * </pre>
		 *
		 * <code>optional int64 request_time = 4;</code>
		 * 
		 * @return Whether the requestTime field is set.
		 */
		@java.lang.Override
		public boolean hasRequestTime() {
			return ((bitField0_ & 0x00000008) != 0);
		}

		/**
		 * <pre>
		 * Time of the request in seconds (UTC) as set by the client.
		 * </pre>
		 *
		 * <code>optional int64 request_time = 4;</code>
		 * 
		 * @return The requestTime.
		 */
		@java.lang.Override
		public long getRequestTime() {
			return requestTime_;
		}

		public static final int KEY_CONTROL_NONCE_DEPRECATED_FIELD_NUMBER = 5;
		private ByteString keyControlNonceDeprecated_ = ByteString.EMPTY;

		/**
		 * <pre>
		 * Old-style decimal-encoded string key control nonce.
		 * </pre>
		 *
		 * <code>optional bytes key_control_nonce_deprecated = 5;</code>
		 * 
		 * @return Whether the keyControlNonceDeprecated field is set.
		 */
		@java.lang.Override
		public boolean hasKeyControlNonceDeprecated() {
			return ((bitField0_ & 0x00000010) != 0);
		}

		/**
		 * <pre>
		 * Old-style decimal-encoded string key control nonce.
		 * </pre>
		 *
		 * <code>optional bytes key_control_nonce_deprecated = 5;</code>
		 * 
		 * @return The keyControlNonceDeprecated.
		 */
		@java.lang.Override
		public ByteString getKeyControlNonceDeprecated() {
			return keyControlNonceDeprecated_;
		}

		public static final int PROTOCOL_VERSION_FIELD_NUMBER = 6;
		private int protocolVersion_ = 20;

		/**
		 * <code>optional .ProtocolVersion protocol_version = 6 [default = VERSION_2_0];</code>
		 * 
		 * @return Whether the protocolVersion field is set.
		 */
		@java.lang.Override
		public boolean hasProtocolVersion() {
			return ((bitField0_ & 0x00000020) != 0);
		}

		/**
		 * <code>optional .ProtocolVersion protocol_version = 6 [default = VERSION_2_0];</code>
		 * 
		 * @return The protocolVersion.
		 */
		@java.lang.Override
		public WvProto2.ProtocolVersion getProtocolVersion() {
			WvProto2.ProtocolVersion result = WvProto2.ProtocolVersion
					.forNumber(protocolVersion_);
			return result == null ? WvProto2.ProtocolVersion.VERSION_2_0 : result;
		}

		public static final int KEY_CONTROL_NONCE_FIELD_NUMBER = 7;
		private int keyControlNonce_ = 0;

		/**
		 * <pre>
		 * New-style uint32 key control nonce, please use instead of
		 * key_control_nonce_deprecated.
		 * </pre>
		 *
		 * <code>optional uint32 key_control_nonce = 7;</code>
		 * 
		 * @return Whether the keyControlNonce field is set.
		 */
		@java.lang.Override
		public boolean hasKeyControlNonce() {
			return ((bitField0_ & 0x00000040) != 0);
		}

		/**
		 * <pre>
		 * New-style uint32 key control nonce, please use instead of
		 * key_control_nonce_deprecated.
		 * </pre>
		 *
		 * <code>optional uint32 key_control_nonce = 7;</code>
		 * 
		 * @return The keyControlNonce.
		 */
		@java.lang.Override
		public int getKeyControlNonce() {
			return keyControlNonce_;
		}

		public static final int ENCRYPTED_CLIENT_ID_FIELD_NUMBER = 8;
		private WvProto2.EncryptedClientIdentification encryptedClientId_;

		/**
		 * <pre>
		 * Encrypted ClientIdentification message, used for privacy purposes.
		 * </pre>
		 *
		 * <code>optional .EncryptedClientIdentification encrypted_client_id = 8;</code>
		 * 
		 * @return Whether the encryptedClientId field is set.
		 */
		@java.lang.Override
		public boolean hasEncryptedClientId() {
			return ((bitField0_ & 0x00000080) != 0);
		}

		/**
		 * <pre>
		 * Encrypted ClientIdentification message, used for privacy purposes.
		 * </pre>
		 *
		 * <code>optional .EncryptedClientIdentification encrypted_client_id = 8;</code>
		 * 
		 * @return The encryptedClientId.
		 */
		@java.lang.Override
		public WvProto2.EncryptedClientIdentification getEncryptedClientId() {
			return encryptedClientId_ == null
					? WvProto2.EncryptedClientIdentification.getDefaultInstance()
					: encryptedClientId_;
		}

		/**
		 * <pre>
		 * Encrypted ClientIdentification message, used for privacy purposes.
		 * </pre>
		 *
		 * <code>optional .EncryptedClientIdentification encrypted_client_id = 8;</code>
		 */
		@java.lang.Override
		public WvProto2.EncryptedClientIdentificationOrBuilder getEncryptedClientIdOrBuilder() {
			return encryptedClientId_ == null
					? WvProto2.EncryptedClientIdentification.getDefaultInstance()
					: encryptedClientId_;
		}

		private byte memoizedIsInitialized = -1;

		@java.lang.Override
		public final boolean isInitialized() {
			byte isInitialized = memoizedIsInitialized;
			if (isInitialized == 1)
				return true;
			if (isInitialized == 0)
				return false;

			memoizedIsInitialized = 1;
			return true;
		}

		@java.lang.Override
		public void writeTo(CodedOutputStream output) throws java.io.IOException {
			if (((bitField0_ & 0x00000001) != 0)) {
				output.writeMessage(1, getClientId());
			}
			if (((bitField0_ & 0x00000002) != 0)) {
				output.writeMessage(2, getContentId());
			}
			if (((bitField0_ & 0x00000004) != 0)) {
				output.writeEnum(3, type_);
			}
			if (((bitField0_ & 0x00000008) != 0)) {
				output.writeInt64(4, requestTime_);
			}
			if (((bitField0_ & 0x00000010) != 0)) {
				output.writeBytes(5, keyControlNonceDeprecated_);
			}
			if (((bitField0_ & 0x00000020) != 0)) {
				output.writeEnum(6, protocolVersion_);
			}
			if (((bitField0_ & 0x00000040) != 0)) {
				output.writeUInt32(7, keyControlNonce_);
			}
			if (((bitField0_ & 0x00000080) != 0)) {
				output.writeMessage(8, getEncryptedClientId());
			}
			getUnknownFields().writeTo(output);
		}

		@java.lang.Override
		public int getSerializedSize() {
			int size = memoizedSize;
			if (size != -1)
				return size;

			size = 0;
			if (((bitField0_ & 0x00000001) != 0)) {
				size += CodedOutputStream.computeMessageSize(1, getClientId());
			}
			if (((bitField0_ & 0x00000002) != 0)) {
				size += CodedOutputStream.computeMessageSize(2, getContentId());
			}
			if (((bitField0_ & 0x00000004) != 0)) {
				size += CodedOutputStream.computeEnumSize(3, type_);
			}
			if (((bitField0_ & 0x00000008) != 0)) {
				size += CodedOutputStream.computeInt64Size(4, requestTime_);
			}
			if (((bitField0_ & 0x00000010) != 0)) {
				size += CodedOutputStream.computeBytesSize(5, keyControlNonceDeprecated_);
			}
			if (((bitField0_ & 0x00000020) != 0)) {
				size += CodedOutputStream.computeEnumSize(6, protocolVersion_);
			}
			if (((bitField0_ & 0x00000040) != 0)) {
				size += CodedOutputStream.computeUInt32Size(7, keyControlNonce_);
			}
			if (((bitField0_ & 0x00000080) != 0)) {
				size += CodedOutputStream.computeMessageSize(8, getEncryptedClientId());
			}
			size += getUnknownFields().getSerializedSize();
			memoizedSize = size;
			return size;
		}

		@java.lang.Override
		public boolean equals(final java.lang.Object obj) {
			if (obj == this) {
				return true;
			}
			if (!(obj instanceof WvProto2.LicenseRequest)) {
				return super.equals(obj);
			}
			WvProto2.LicenseRequest other = (WvProto2.LicenseRequest) obj;

			if (hasClientId() != other.hasClientId())
				return false;
			if (hasClientId()) {
				if (!getClientId().equals(other.getClientId()))
					return false;
			}
			if (hasContentId() != other.hasContentId())
				return false;
			if (hasContentId()) {
				if (!getContentId().equals(other.getContentId()))
					return false;
			}
			if (hasType() != other.hasType())
				return false;
			if (hasType()) {
				if (type_ != other.type_)
					return false;
			}
			if (hasRequestTime() != other.hasRequestTime())
				return false;
			if (hasRequestTime()) {
				if (getRequestTime() != other.getRequestTime())
					return false;
			}
			if (hasKeyControlNonceDeprecated() != other.hasKeyControlNonceDeprecated())
				return false;
			if (hasKeyControlNonceDeprecated()) {
				if (!getKeyControlNonceDeprecated().equals(other.getKeyControlNonceDeprecated()))
					return false;
			}
			if (hasProtocolVersion() != other.hasProtocolVersion())
				return false;
			if (hasProtocolVersion()) {
				if (protocolVersion_ != other.protocolVersion_)
					return false;
			}
			if (hasKeyControlNonce() != other.hasKeyControlNonce())
				return false;
			if (hasKeyControlNonce()) {
				if (getKeyControlNonce() != other.getKeyControlNonce())
					return false;
			}
			if (hasEncryptedClientId() != other.hasEncryptedClientId())
				return false;
			if (hasEncryptedClientId()) {
				if (!getEncryptedClientId().equals(other.getEncryptedClientId()))
					return false;
			}
			if (!getUnknownFields().equals(other.getUnknownFields()))
				return false;
			return true;
		}

		@SuppressWarnings("unchecked")
		@java.lang.Override
		public int hashCode() {
			if (memoizedHashCode != 0) {
				return memoizedHashCode;
			}
			int hash = 41;
			hash = (19 * hash) + getDescriptor().hashCode();
			if (hasClientId()) {
				hash = (37 * hash) + CLIENT_ID_FIELD_NUMBER;
				hash = (53 * hash) + getClientId().hashCode();
			}
			if (hasContentId()) {
				hash = (37 * hash) + CONTENT_ID_FIELD_NUMBER;
				hash = (53 * hash) + getContentId().hashCode();
			}
			if (hasType()) {
				hash = (37 * hash) + TYPE_FIELD_NUMBER;
				hash = (53 * hash) + type_;
			}
			if (hasRequestTime()) {
				hash = (37 * hash) + REQUEST_TIME_FIELD_NUMBER;
				hash = (53 * hash) + Internal.hashLong(getRequestTime());
			}
			if (hasKeyControlNonceDeprecated()) {
				hash = (37 * hash) + KEY_CONTROL_NONCE_DEPRECATED_FIELD_NUMBER;
				hash = (53 * hash) + getKeyControlNonceDeprecated().hashCode();
			}
			if (hasProtocolVersion()) {
				hash = (37 * hash) + PROTOCOL_VERSION_FIELD_NUMBER;
				hash = (53 * hash) + protocolVersion_;
			}
			if (hasKeyControlNonce()) {
				hash = (37 * hash) + KEY_CONTROL_NONCE_FIELD_NUMBER;
				hash = (53 * hash) + getKeyControlNonce();
			}
			if (hasEncryptedClientId()) {
				hash = (37 * hash) + ENCRYPTED_CLIENT_ID_FIELD_NUMBER;
				hash = (53 * hash) + getEncryptedClientId().hashCode();
			}
			hash = (29 * hash) + getUnknownFields().hashCode();
			memoizedHashCode = hash;
			return hash;
		}

		public static WvProto2.LicenseRequest parseFrom(java.nio.ByteBuffer data)
				throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data);
		}

		public static WvProto2.LicenseRequest parseFrom(java.nio.ByteBuffer data,
				ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data, extensionRegistry);
		}

		public static WvProto2.LicenseRequest parseFrom(ByteString data)
				throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data);
		}

		public static WvProto2.LicenseRequest parseFrom(ByteString data,
				ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data, extensionRegistry);
		}

		public static WvProto2.LicenseRequest parseFrom(byte[] data)
				throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data);
		}

		public static WvProto2.LicenseRequest parseFrom(byte[] data,
				ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data, extensionRegistry);
		}

		public static WvProto2.LicenseRequest parseFrom(java.io.InputStream input)
				throws java.io.IOException {
			return GeneratedMessageV3.parseWithIOException(PARSER, input);
		}

		public static WvProto2.LicenseRequest parseFrom(java.io.InputStream input,
				ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
			return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
		}

		public static WvProto2.LicenseRequest parseDelimitedFrom(java.io.InputStream input)
				throws java.io.IOException {
			return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
		}

		public static WvProto2.LicenseRequest parseDelimitedFrom(java.io.InputStream input,
				ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
			return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input, extensionRegistry);
		}

		public static WvProto2.LicenseRequest parseFrom(CodedInputStream input)
				throws java.io.IOException {
			return GeneratedMessageV3.parseWithIOException(PARSER, input);
		}

		public static WvProto2.LicenseRequest parseFrom(CodedInputStream input,
				ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
			return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
		}

		@java.lang.Override
		public Builder newBuilderForType() {
			return newBuilder();
		}

		public static Builder newBuilder() {
			return DEFAULT_INSTANCE.toBuilder();
		}

		public static Builder newBuilder(WvProto2.LicenseRequest prototype) {
			return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
		}

		@java.lang.Override
		public Builder toBuilder() {
			return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
		}

		@java.lang.Override
		protected Builder newBuilderForType(GeneratedMessageV3.BuilderParent parent) {
			Builder builder = new Builder(parent);
			return builder;
		}

		/**
		 * Protobuf type {@code LicenseRequest}
		 */
		public static final class Builder extends GeneratedMessageV3.Builder<Builder> implements
				// @@protoc_insertion_point(builder_implements:LicenseRequest)
				WvProto2.LicenseRequestOrBuilder {
			public static final Descriptors.Descriptor getDescriptor() {
				return WvProto2.internal_static_LicenseRequest_descriptor;
			}

			@java.lang.Override
			protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
				return WvProto2.internal_static_LicenseRequest_fieldAccessorTable
						.ensureFieldAccessorsInitialized(WvProto2.LicenseRequest.class,
								WvProto2.LicenseRequest.Builder.class);
			}

			// Construct using WvProto2.LicenseRequest.newBuilder()
			private Builder() {
				maybeForceBuilderInitialization();
			}

			private Builder(GeneratedMessageV3.BuilderParent parent) {
				super(parent);
				maybeForceBuilderInitialization();
			}

			private void maybeForceBuilderInitialization() {
				if (GeneratedMessageV3.alwaysUseFieldBuilders) {
					getClientIdFieldBuilder();
					getContentIdFieldBuilder();
					getEncryptedClientIdFieldBuilder();
				}
			}

			@java.lang.Override
			public Builder clear() {
				super.clear();
				bitField0_ = 0;
				clientId_ = null;
				if (clientIdBuilder_ != null) {
					clientIdBuilder_.dispose();
					clientIdBuilder_ = null;
				}
				contentId_ = null;
				if (contentIdBuilder_ != null) {
					contentIdBuilder_.dispose();
					contentIdBuilder_ = null;
				}
				type_ = 1;
				requestTime_ = 0L;
				keyControlNonceDeprecated_ = ByteString.EMPTY;
				protocolVersion_ = 20;
				keyControlNonce_ = 0;
				encryptedClientId_ = null;
				if (encryptedClientIdBuilder_ != null) {
					encryptedClientIdBuilder_.dispose();
					encryptedClientIdBuilder_ = null;
				}
				return this;
			}

			@java.lang.Override
			public Descriptors.Descriptor getDescriptorForType() {
				return WvProto2.internal_static_LicenseRequest_descriptor;
			}

			@java.lang.Override
			public WvProto2.LicenseRequest getDefaultInstanceForType() {
				return WvProto2.LicenseRequest.getDefaultInstance();
			}

			@java.lang.Override
			public WvProto2.LicenseRequest build() {
				WvProto2.LicenseRequest result = buildPartial();
				if (!result.isInitialized()) {
					throw newUninitializedMessageException(result);
				}
				return result;
			}

			@java.lang.Override
			public WvProto2.LicenseRequest buildPartial() {
				WvProto2.LicenseRequest result = new WvProto2.LicenseRequest(
						this);
				if (bitField0_ != 0) {
					buildPartial0(result);
				}
				onBuilt();
				return result;
			}

			private void buildPartial0(WvProto2.LicenseRequest result) {
				int from_bitField0_ = bitField0_;
				int to_bitField0_ = 0;
				if (((from_bitField0_ & 0x00000001) != 0)) {
					result.clientId_ = clientIdBuilder_ == null ? clientId_ : clientIdBuilder_.build();
					to_bitField0_ |= 0x00000001;
				}
				if (((from_bitField0_ & 0x00000002) != 0)) {
					result.contentId_ = contentIdBuilder_ == null ? contentId_ : contentIdBuilder_.build();
					to_bitField0_ |= 0x00000002;
				}
				if (((from_bitField0_ & 0x00000004) != 0)) {
					result.type_ = type_;
					to_bitField0_ |= 0x00000004;
				}
				if (((from_bitField0_ & 0x00000008) != 0)) {
					result.requestTime_ = requestTime_;
					to_bitField0_ |= 0x00000008;
				}
				if (((from_bitField0_ & 0x00000010) != 0)) {
					result.keyControlNonceDeprecated_ = keyControlNonceDeprecated_;
					to_bitField0_ |= 0x00000010;
				}
				if (((from_bitField0_ & 0x00000020) != 0)) {
					result.protocolVersion_ = protocolVersion_;
					to_bitField0_ |= 0x00000020;
				}
				if (((from_bitField0_ & 0x00000040) != 0)) {
					result.keyControlNonce_ = keyControlNonce_;
					to_bitField0_ |= 0x00000040;
				}
				if (((from_bitField0_ & 0x00000080) != 0)) {
					result.encryptedClientId_ = encryptedClientIdBuilder_ == null ? encryptedClientId_
							: encryptedClientIdBuilder_.build();
					to_bitField0_ |= 0x00000080;
				}
				result.bitField0_ |= to_bitField0_;
			}

			@java.lang.Override
			public Builder mergeFrom(Message other) {
				if (other instanceof WvProto2.LicenseRequest) {
					return mergeFrom((WvProto2.LicenseRequest) other);
				}
				super.mergeFrom(other);
				return this;
			}

			public Builder mergeFrom(WvProto2.LicenseRequest other) {
				if (other == WvProto2.LicenseRequest.getDefaultInstance())
					return this;
				if (other.hasClientId()) {
					mergeClientId(other.getClientId());
				}
				if (other.hasContentId()) {
					mergeContentId(other.getContentId());
				}
				if (other.hasType()) {
					setType(other.getType());
				}
				if (other.hasRequestTime()) {
					setRequestTime(other.getRequestTime());
				}
				if (other.hasKeyControlNonceDeprecated()) {
					setKeyControlNonceDeprecated(other.getKeyControlNonceDeprecated());
				}
				if (other.hasProtocolVersion()) {
					setProtocolVersion(other.getProtocolVersion());
				}
				if (other.hasKeyControlNonce()) {
					setKeyControlNonce(other.getKeyControlNonce());
				}
				if (other.hasEncryptedClientId()) {
					mergeEncryptedClientId(other.getEncryptedClientId());
				}
				this.mergeUnknownFields(other.getUnknownFields());
				onChanged();
				return this;
			}

			@java.lang.Override
			public final boolean isInitialized() {
				return true;
			}

			@java.lang.Override
			public Builder mergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
					throws java.io.IOException {
				if (extensionRegistry == null) {
					throw new java.lang.NullPointerException();
				}
				try {
					boolean done = false;
					while (!done) {
						int tag = input.readTag();
						switch (tag) {
						case 0:
							done = true;
							break;
						case 10: {
							input.readMessage(getClientIdFieldBuilder().getBuilder(), extensionRegistry);
							bitField0_ |= 0x00000001;
							break;
						} // case 10
						case 18: {
							input.readMessage(getContentIdFieldBuilder().getBuilder(), extensionRegistry);
							bitField0_ |= 0x00000002;
							break;
						} // case 18
						case 24: {
							int tmpRaw = input.readEnum();
							WvProto2.LicenseRequest.RequestType tmpValue = WvProto2.LicenseRequest.RequestType
									.forNumber(tmpRaw);
							if (tmpValue == null) {
								mergeUnknownVarintField(3, tmpRaw);
							} else {
								type_ = tmpRaw;
								bitField0_ |= 0x00000004;
							}
							break;
						} // case 24
						case 32: {
							requestTime_ = input.readInt64();
							bitField0_ |= 0x00000008;
							break;
						} // case 32
						case 42: {
							keyControlNonceDeprecated_ = input.readBytes();
							bitField0_ |= 0x00000010;
							break;
						} // case 42
						case 48: {
							int tmpRaw = input.readEnum();
							WvProto2.ProtocolVersion tmpValue = WvProto2.ProtocolVersion
									.forNumber(tmpRaw);
							if (tmpValue == null) {
								mergeUnknownVarintField(6, tmpRaw);
							} else {
								protocolVersion_ = tmpRaw;
								bitField0_ |= 0x00000020;
							}
							break;
						} // case 48
						case 56: {
							keyControlNonce_ = input.readUInt32();
							bitField0_ |= 0x00000040;
							break;
						} // case 56
						case 66: {
							input.readMessage(getEncryptedClientIdFieldBuilder().getBuilder(), extensionRegistry);
							bitField0_ |= 0x00000080;
							break;
						} // case 66
						default: {
							if (!super.parseUnknownField(input, extensionRegistry, tag)) {
								done = true; // was an endgroup tag
							}
							break;
						} // default:
						} // switch (tag)
					} // while (!done)
				} catch (InvalidProtocolBufferException e) {
					throw e.unwrapIOException();
				}
				finally {
					onChanged();
				} // finally
				return this;
			}

			private int bitField0_;

			private WvProto2.ClientIdentification clientId_;
			private SingleFieldBuilderV3<WvProto2.ClientIdentification, WvProto2.ClientIdentification.Builder, WvProto2.ClientIdentificationOrBuilder> clientIdBuilder_;

			/**
			 * <pre>
			 * The client_id provides information authenticating the calling device.  It
			 * contains the Widevine keybox token that was installed on the device at the
			 * factory.  This field or encrypted_client_id below is required for a valid
			 * license request, but both should never be present in the same request.
			 * </pre>
			 *
			 * <code>optional .ClientIdentification client_id = 1;</code>
			 * 
			 * @return Whether the clientId field is set.
			 */
			@Override
			public boolean hasClientId() {
				return ((bitField0_ & 0x00000001) != 0);
			}

			/**
			 * <pre>
			 * The client_id provides information authenticating the calling device.  It
			 * contains the Widevine keybox token that was installed on the device at the
			 * factory.  This field or encrypted_client_id below is required for a valid
			 * license request, but both should never be present in the same request.
			 * </pre>
			 *
			 * <code>optional .ClientIdentification client_id = 1;</code>
			 * 
			 * @return The clientId.
			 */
			@Override
			public WvProto2.ClientIdentification getClientId() {
				if (clientIdBuilder_ == null) {
					return clientId_ == null
							? WvProto2.ClientIdentification.getDefaultInstance()
							: clientId_;
				}
				return clientIdBuilder_.getMessage();
			}

			/**
			 * <pre>
			 * The client_id provides information authenticating the calling device.  It
			 * contains the Widevine keybox token that was installed on the device at the
			 * factory.  This field or encrypted_client_id below is required for a valid
			 * license request, but both should never be present in the same request.
			 * </pre>
			 *
			 * <code>optional .ClientIdentification client_id = 1;</code>
			 */
			public Builder setClientId(WvProto2.ClientIdentification value) {
				if (clientIdBuilder_ == null) {
					if (value == null) {
						throw new NullPointerException();
					}
					clientId_ = value;
				} else {
					clientIdBuilder_.setMessage(value);
				}
				bitField0_ |= 0x00000001;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * The client_id provides information authenticating the calling device.  It
			 * contains the Widevine keybox token that was installed on the device at the
			 * factory.  This field or encrypted_client_id below is required for a valid
			 * license request, but both should never be present in the same request.
			 * </pre>
			 *
			 * <code>optional .ClientIdentification client_id = 1;</code>
			 */
			public Builder setClientId(WvProto2.ClientIdentification.Builder builderForValue) {
				if (clientIdBuilder_ == null) {
					clientId_ = builderForValue.build();
				} else {
					clientIdBuilder_.setMessage(builderForValue.build());
				}
				bitField0_ |= 0x00000001;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * The client_id provides information authenticating the calling device.  It
			 * contains the Widevine keybox token that was installed on the device at the
			 * factory.  This field or encrypted_client_id below is required for a valid
			 * license request, but both should never be present in the same request.
			 * </pre>
			 *
			 * <code>optional .ClientIdentification client_id = 1;</code>
			 */
			public Builder mergeClientId(WvProto2.ClientIdentification value) {
				if (clientIdBuilder_ == null) {
					if (((bitField0_ & 0x00000001) != 0) && clientId_ != null
							&& clientId_ != WvProto2.ClientIdentification
									.getDefaultInstance()) {
						getClientIdBuilder().mergeFrom(value);
					} else {
						clientId_ = value;
					}
				} else {
					clientIdBuilder_.mergeFrom(value);
				}
				bitField0_ |= 0x00000001;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * The client_id provides information authenticating the calling device.  It
			 * contains the Widevine keybox token that was installed on the device at the
			 * factory.  This field or encrypted_client_id below is required for a valid
			 * license request, but both should never be present in the same request.
			 * </pre>
			 *
			 * <code>optional .ClientIdentification client_id = 1;</code>
			 */
			public Builder clearClientId() {
				bitField0_ = (bitField0_ & ~0x00000001);
				clientId_ = null;
				if (clientIdBuilder_ != null) {
					clientIdBuilder_.dispose();
					clientIdBuilder_ = null;
				}
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * The client_id provides information authenticating the calling device.  It
			 * contains the Widevine keybox token that was installed on the device at the
			 * factory.  This field or encrypted_client_id below is required for a valid
			 * license request, but both should never be present in the same request.
			 * </pre>
			 *
			 * <code>optional .ClientIdentification client_id = 1;</code>
			 */
			public WvProto2.ClientIdentification.Builder getClientIdBuilder() {
				bitField0_ |= 0x00000001;
				onChanged();
				return getClientIdFieldBuilder().getBuilder();
			}

			/**
			 * <pre>
			 * The client_id provides information authenticating the calling device.  It
			 * contains the Widevine keybox token that was installed on the device at the
			 * factory.  This field or encrypted_client_id below is required for a valid
			 * license request, but both should never be present in the same request.
			 * </pre>
			 *
			 * <code>optional .ClientIdentification client_id = 1;</code>
			 */
			@Override
			public WvProto2.ClientIdentificationOrBuilder getClientIdOrBuilder() {
				if (clientIdBuilder_ != null) {
					return clientIdBuilder_.getMessageOrBuilder();
				}
				return clientId_ == null
						? WvProto2.ClientIdentification.getDefaultInstance()
						: clientId_;
			}

			/**
			 * <pre>
			 * The client_id provides information authenticating the calling device.  It
			 * contains the Widevine keybox token that was installed on the device at the
			 * factory.  This field or encrypted_client_id below is required for a valid
			 * license request, but both should never be present in the same request.
			 * </pre>
			 *
			 * <code>optional .ClientIdentification client_id = 1;</code>
			 */
			private SingleFieldBuilderV3<WvProto2.ClientIdentification, WvProto2.ClientIdentification.Builder, WvProto2.ClientIdentificationOrBuilder> getClientIdFieldBuilder() {
				if (clientIdBuilder_ == null) {
					clientIdBuilder_ = new SingleFieldBuilderV3<>(getClientId(), getParentForChildren(), isClean());
					clientId_ = null;
				}
				return clientIdBuilder_;
			}

			private WvProto2.LicenseRequest.ContentIdentification contentId_;
			private SingleFieldBuilderV3<WvProto2.LicenseRequest.ContentIdentification, WvProto2.LicenseRequest.ContentIdentification.Builder, WvProto2.LicenseRequest.ContentIdentificationOrBuilder> contentIdBuilder_;

			/**
			 * <code>optional .LicenseRequest.ContentIdentification content_id = 2;</code>
			 * 
			 * @return Whether the contentId field is set.
			 */
			@Override
			public boolean hasContentId() {
				return ((bitField0_ & 0x00000002) != 0);
			}

			/**
			 * <code>optional .LicenseRequest.ContentIdentification content_id = 2;</code>
			 * 
			 * @return The contentId.
			 */
			@Override
			public WvProto2.LicenseRequest.ContentIdentification getContentId() {
				if (contentIdBuilder_ == null) {
					return contentId_ == null
							? WvProto2.LicenseRequest.ContentIdentification.getDefaultInstance()
							: contentId_;
				}
				return contentIdBuilder_.getMessage();
			}

			/**
			 * <code>optional .LicenseRequest.ContentIdentification content_id = 2;</code>
			 */
			public Builder setContentId(WvProto2.LicenseRequest.ContentIdentification value) {
				if (contentIdBuilder_ == null) {
					if (value == null) {
						throw new NullPointerException();
					}
					contentId_ = value;
				} else {
					contentIdBuilder_.setMessage(value);
				}
				bitField0_ |= 0x00000002;
				onChanged();
				return this;
			}

			/**
			 * <code>optional .LicenseRequest.ContentIdentification content_id = 2;</code>
			 */
			public Builder setContentId(
					WvProto2.LicenseRequest.ContentIdentification.Builder builderForValue) {
				if (contentIdBuilder_ == null) {
					contentId_ = builderForValue.build();
				} else {
					contentIdBuilder_.setMessage(builderForValue.build());
				}
				bitField0_ |= 0x00000002;
				onChanged();
				return this;
			}

			/**
			 * <code>optional .LicenseRequest.ContentIdentification content_id = 2;</code>
			 */
			public Builder mergeContentId(WvProto2.LicenseRequest.ContentIdentification value) {
				if (contentIdBuilder_ == null) {
					if (((bitField0_ & 0x00000002) != 0) && contentId_ != null
							&& contentId_ != WvProto2.LicenseRequest.ContentIdentification
									.getDefaultInstance()) {
						getContentIdBuilder().mergeFrom(value);
					} else {
						contentId_ = value;
					}
				} else {
					contentIdBuilder_.mergeFrom(value);
				}
				bitField0_ |= 0x00000002;
				onChanged();
				return this;
			}

			/**
			 * <code>optional .LicenseRequest.ContentIdentification content_id = 2;</code>
			 */
			public Builder clearContentId() {
				bitField0_ = (bitField0_ & ~0x00000002);
				contentId_ = null;
				if (contentIdBuilder_ != null) {
					contentIdBuilder_.dispose();
					contentIdBuilder_ = null;
				}
				onChanged();
				return this;
			}

			/**
			 * <code>optional .LicenseRequest.ContentIdentification content_id = 2;</code>
			 */
			public WvProto2.LicenseRequest.ContentIdentification.Builder getContentIdBuilder() {
				bitField0_ |= 0x00000002;
				onChanged();
				return getContentIdFieldBuilder().getBuilder();
			}

			/**
			 * <code>optional .LicenseRequest.ContentIdentification content_id = 2;</code>
			 */
			@Override
			public WvProto2.LicenseRequest.ContentIdentificationOrBuilder getContentIdOrBuilder() {
				if (contentIdBuilder_ != null) {
					return contentIdBuilder_.getMessageOrBuilder();
				}
				return contentId_ == null
						? WvProto2.LicenseRequest.ContentIdentification.getDefaultInstance()
						: contentId_;
			}

			/**
			 * <code>optional .LicenseRequest.ContentIdentification content_id = 2;</code>
			 */
			private SingleFieldBuilderV3<WvProto2.LicenseRequest.ContentIdentification, WvProto2.LicenseRequest.ContentIdentification.Builder, WvProto2.LicenseRequest.ContentIdentificationOrBuilder> getContentIdFieldBuilder() {
				if (contentIdBuilder_ == null) {
					contentIdBuilder_ = new SingleFieldBuilderV3<>(getContentId(), getParentForChildren(), isClean());
					contentId_ = null;
				}
				return contentIdBuilder_;
			}

			private int type_ = 1;

			/**
			 * <code>optional .LicenseRequest.RequestType type = 3;</code>
			 * 
			 * @return Whether the type field is set.
			 */
			@java.lang.Override
			public boolean hasType() {
				return ((bitField0_ & 0x00000004) != 0);
			}

			/**
			 * <code>optional .LicenseRequest.RequestType type = 3;</code>
			 * 
			 * @return The type.
			 */
			@java.lang.Override
			public WvProto2.LicenseRequest.RequestType getType() {
				WvProto2.LicenseRequest.RequestType result = WvProto2.LicenseRequest.RequestType
						.forNumber(type_);
				return result == null ? WvProto2.LicenseRequest.RequestType.NEW : result;
			}

			/**
			 * <code>optional .LicenseRequest.RequestType type = 3;</code>
			 * 
			 * @param value The type to set.
			 * @return This builder for chaining.
			 */
			public Builder setType(WvProto2.LicenseRequest.RequestType value) {
				if (value == null) {
					throw new NullPointerException();
				}
				bitField0_ |= 0x00000004;
				type_ = value.getNumber();
				onChanged();
				return this;
			}

			/**
			 * <code>optional .LicenseRequest.RequestType type = 3;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearType() {
				bitField0_ = (bitField0_ & ~0x00000004);
				type_ = 1;
				onChanged();
				return this;
			}

			private long requestTime_;

			/**
			 * <pre>
			 * Time of the request in seconds (UTC) as set by the client.
			 * </pre>
			 *
			 * <code>optional int64 request_time = 4;</code>
			 * 
			 * @return Whether the requestTime field is set.
			 */
			@java.lang.Override
			public boolean hasRequestTime() {
				return ((bitField0_ & 0x00000008) != 0);
			}

			/**
			 * <pre>
			 * Time of the request in seconds (UTC) as set by the client.
			 * </pre>
			 *
			 * <code>optional int64 request_time = 4;</code>
			 * 
			 * @return The requestTime.
			 */
			@java.lang.Override
			public long getRequestTime() {
				return requestTime_;
			}

			/**
			 * <pre>
			 * Time of the request in seconds (UTC) as set by the client.
			 * </pre>
			 *
			 * <code>optional int64 request_time = 4;</code>
			 * 
			 * @param value The requestTime to set.
			 * @return This builder for chaining.
			 */
			public Builder setRequestTime(long value) {

				requestTime_ = value;
				bitField0_ |= 0x00000008;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Time of the request in seconds (UTC) as set by the client.
			 * </pre>
			 *
			 * <code>optional int64 request_time = 4;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearRequestTime() {
				bitField0_ = (bitField0_ & ~0x00000008);
				requestTime_ = 0L;
				onChanged();
				return this;
			}

			private ByteString keyControlNonceDeprecated_ = ByteString.EMPTY;

			/**
			 * <pre>
			 * Old-style decimal-encoded string key control nonce.
			 * </pre>
			 *
			 * <code>optional bytes key_control_nonce_deprecated = 5;</code>
			 * 
			 * @return Whether the keyControlNonceDeprecated field is set.
			 */
			@java.lang.Override
			public boolean hasKeyControlNonceDeprecated() {
				return ((bitField0_ & 0x00000010) != 0);
			}

			/**
			 * <pre>
			 * Old-style decimal-encoded string key control nonce.
			 * </pre>
			 *
			 * <code>optional bytes key_control_nonce_deprecated = 5;</code>
			 * 
			 * @return The keyControlNonceDeprecated.
			 */
			@java.lang.Override
			public ByteString getKeyControlNonceDeprecated() {
				return keyControlNonceDeprecated_;
			}

			/**
			 * <pre>
			 * Old-style decimal-encoded string key control nonce.
			 * </pre>
			 *
			 * <code>optional bytes key_control_nonce_deprecated = 5;</code>
			 * 
			 * @param value The keyControlNonceDeprecated to set.
			 * @return This builder for chaining.
			 */
			public Builder setKeyControlNonceDeprecated(ByteString value) {
				if (value == null) {
					throw new NullPointerException();
				}
				keyControlNonceDeprecated_ = value;
				bitField0_ |= 0x00000010;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Old-style decimal-encoded string key control nonce.
			 * </pre>
			 *
			 * <code>optional bytes key_control_nonce_deprecated = 5;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearKeyControlNonceDeprecated() {
				bitField0_ = (bitField0_ & ~0x00000010);
				keyControlNonceDeprecated_ = getDefaultInstance().getKeyControlNonceDeprecated();
				onChanged();
				return this;
			}

			private int protocolVersion_ = 20;

			/**
			 * <code>optional .ProtocolVersion protocol_version = 6 [default = VERSION_2_0];</code>
			 * 
			 * @return Whether the protocolVersion field is set.
			 */
			@java.lang.Override
			public boolean hasProtocolVersion() {
				return ((bitField0_ & 0x00000020) != 0);
			}

			/**
			 * <code>optional .ProtocolVersion protocol_version = 6 [default = VERSION_2_0];</code>
			 * 
			 * @return The protocolVersion.
			 */
			@java.lang.Override
			public WvProto2.ProtocolVersion getProtocolVersion() {
				WvProto2.ProtocolVersion result = WvProto2.ProtocolVersion
						.forNumber(protocolVersion_);
				return result == null ? WvProto2.ProtocolVersion.VERSION_2_0 : result;
			}

			/**
			 * <code>optional .ProtocolVersion protocol_version = 6 [default = VERSION_2_0];</code>
			 * 
			 * @param value The protocolVersion to set.
			 * @return This builder for chaining.
			 */
			public Builder setProtocolVersion(WvProto2.ProtocolVersion value) {
				if (value == null) {
					throw new NullPointerException();
				}
				bitField0_ |= 0x00000020;
				protocolVersion_ = value.getNumber();
				onChanged();
				return this;
			}

			/**
			 * <code>optional .ProtocolVersion protocol_version = 6 [default = VERSION_2_0];</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearProtocolVersion() {
				bitField0_ = (bitField0_ & ~0x00000020);
				protocolVersion_ = 20;
				onChanged();
				return this;
			}

			private int keyControlNonce_;

			/**
			 * <pre>
			 * New-style uint32 key control nonce, please use instead of
			 * key_control_nonce_deprecated.
			 * </pre>
			 *
			 * <code>optional uint32 key_control_nonce = 7;</code>
			 * 
			 * @return Whether the keyControlNonce field is set.
			 */
			@java.lang.Override
			public boolean hasKeyControlNonce() {
				return ((bitField0_ & 0x00000040) != 0);
			}

			/**
			 * <pre>
			 * New-style uint32 key control nonce, please use instead of
			 * key_control_nonce_deprecated.
			 * </pre>
			 *
			 * <code>optional uint32 key_control_nonce = 7;</code>
			 * 
			 * @return The keyControlNonce.
			 */
			@java.lang.Override
			public int getKeyControlNonce() {
				return keyControlNonce_;
			}

			/**
			 * <pre>
			 * New-style uint32 key control nonce, please use instead of
			 * key_control_nonce_deprecated.
			 * </pre>
			 *
			 * <code>optional uint32 key_control_nonce = 7;</code>
			 * 
			 * @param value The keyControlNonce to set.
			 * @return This builder for chaining.
			 */
			public Builder setKeyControlNonce(int value) {

				keyControlNonce_ = value;
				bitField0_ |= 0x00000040;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * New-style uint32 key control nonce, please use instead of
			 * key_control_nonce_deprecated.
			 * </pre>
			 *
			 * <code>optional uint32 key_control_nonce = 7;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearKeyControlNonce() {
				bitField0_ = (bitField0_ & ~0x00000040);
				keyControlNonce_ = 0;
				onChanged();
				return this;
			}

			private WvProto2.EncryptedClientIdentification encryptedClientId_;
			private SingleFieldBuilderV3<WvProto2.EncryptedClientIdentification, WvProto2.EncryptedClientIdentification.Builder, WvProto2.EncryptedClientIdentificationOrBuilder> encryptedClientIdBuilder_;

			/**
			 * <pre>
			 * Encrypted ClientIdentification message, used for privacy purposes.
			 * </pre>
			 *
			 * <code>optional .EncryptedClientIdentification encrypted_client_id = 8;</code>
			 * 
			 * @return Whether the encryptedClientId field is set.
			 */
			@Override
			public boolean hasEncryptedClientId() {
				return ((bitField0_ & 0x00000080) != 0);
			}

			/**
			 * <pre>
			 * Encrypted ClientIdentification message, used for privacy purposes.
			 * </pre>
			 *
			 * <code>optional .EncryptedClientIdentification encrypted_client_id = 8;</code>
			 * 
			 * @return The encryptedClientId.
			 */
			@Override
			public WvProto2.EncryptedClientIdentification getEncryptedClientId() {
				if (encryptedClientIdBuilder_ == null) {
					return encryptedClientId_ == null
							? WvProto2.EncryptedClientIdentification.getDefaultInstance()
							: encryptedClientId_;
				}
				return encryptedClientIdBuilder_.getMessage();
			}

			/**
			 * <pre>
			 * Encrypted ClientIdentification message, used for privacy purposes.
			 * </pre>
			 *
			 * <code>optional .EncryptedClientIdentification encrypted_client_id = 8;</code>
			 */
			public Builder setEncryptedClientId(WvProto2.EncryptedClientIdentification value) {
				if (encryptedClientIdBuilder_ == null) {
					if (value == null) {
						throw new NullPointerException();
					}
					encryptedClientId_ = value;
				} else {
					encryptedClientIdBuilder_.setMessage(value);
				}
				bitField0_ |= 0x00000080;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Encrypted ClientIdentification message, used for privacy purposes.
			 * </pre>
			 *
			 * <code>optional .EncryptedClientIdentification encrypted_client_id = 8;</code>
			 */
			public Builder setEncryptedClientId(
					WvProto2.EncryptedClientIdentification.Builder builderForValue) {
				if (encryptedClientIdBuilder_ == null) {
					encryptedClientId_ = builderForValue.build();
				} else {
					encryptedClientIdBuilder_.setMessage(builderForValue.build());
				}
				bitField0_ |= 0x00000080;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Encrypted ClientIdentification message, used for privacy purposes.
			 * </pre>
			 *
			 * <code>optional .EncryptedClientIdentification encrypted_client_id = 8;</code>
			 */
			public Builder mergeEncryptedClientId(
					WvProto2.EncryptedClientIdentification value) {
				if (encryptedClientIdBuilder_ == null) {
					if (((bitField0_ & 0x00000080) != 0) && encryptedClientId_ != null
							&& encryptedClientId_ != WvProto2.EncryptedClientIdentification
									.getDefaultInstance()) {
						getEncryptedClientIdBuilder().mergeFrom(value);
					} else {
						encryptedClientId_ = value;
					}
				} else {
					encryptedClientIdBuilder_.mergeFrom(value);
				}
				bitField0_ |= 0x00000080;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Encrypted ClientIdentification message, used for privacy purposes.
			 * </pre>
			 *
			 * <code>optional .EncryptedClientIdentification encrypted_client_id = 8;</code>
			 */
			public Builder clearEncryptedClientId() {
				bitField0_ = (bitField0_ & ~0x00000080);
				encryptedClientId_ = null;
				if (encryptedClientIdBuilder_ != null) {
					encryptedClientIdBuilder_.dispose();
					encryptedClientIdBuilder_ = null;
				}
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Encrypted ClientIdentification message, used for privacy purposes.
			 * </pre>
			 *
			 * <code>optional .EncryptedClientIdentification encrypted_client_id = 8;</code>
			 */
			public WvProto2.EncryptedClientIdentification.Builder getEncryptedClientIdBuilder() {
				bitField0_ |= 0x00000080;
				onChanged();
				return getEncryptedClientIdFieldBuilder().getBuilder();
			}

			/**
			 * <pre>
			 * Encrypted ClientIdentification message, used for privacy purposes.
			 * </pre>
			 *
			 * <code>optional .EncryptedClientIdentification encrypted_client_id = 8;</code>
			 */
			@Override
			public WvProto2.EncryptedClientIdentificationOrBuilder getEncryptedClientIdOrBuilder() {
				if (encryptedClientIdBuilder_ != null) {
					return encryptedClientIdBuilder_.getMessageOrBuilder();
				}
				return encryptedClientId_ == null
						? WvProto2.EncryptedClientIdentification.getDefaultInstance()
						: encryptedClientId_;
			}

			/**
			 * <pre>
			 * Encrypted ClientIdentification message, used for privacy purposes.
			 * </pre>
			 *
			 * <code>optional .EncryptedClientIdentification encrypted_client_id = 8;</code>
			 */
			private SingleFieldBuilderV3<WvProto2.EncryptedClientIdentification, WvProto2.EncryptedClientIdentification.Builder, WvProto2.EncryptedClientIdentificationOrBuilder> getEncryptedClientIdFieldBuilder() {
				if (encryptedClientIdBuilder_ == null) {
					encryptedClientIdBuilder_ = new SingleFieldBuilderV3<>(getEncryptedClientId(),
							getParentForChildren(), isClean());
					encryptedClientId_ = null;
				}
				return encryptedClientIdBuilder_;
			}

			@java.lang.Override
			public final Builder setUnknownFields(final UnknownFieldSet unknownFields) {
				return super.setUnknownFields(unknownFields);
			}

			@java.lang.Override
			public final Builder mergeUnknownFields(final UnknownFieldSet unknownFields) {
				return super.mergeUnknownFields(unknownFields);
			}

			// @@protoc_insertion_point(builder_scope:LicenseRequest)
		}

		// @@protoc_insertion_point(class_scope:LicenseRequest)
		private static final WvProto2.LicenseRequest DEFAULT_INSTANCE;
		static {
			DEFAULT_INSTANCE = new WvProto2.LicenseRequest();
		}

		public static WvProto2.LicenseRequest getDefaultInstance() {
			return DEFAULT_INSTANCE;
		}

		@java.lang.Deprecated public static final Parser<LicenseRequest> PARSER = new AbstractParser<>() {
			@java.lang.Override
			public LicenseRequest parsePartialFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
					throws InvalidProtocolBufferException {
				Builder builder = newBuilder();
				try {
					builder.mergeFrom(input, extensionRegistry);
				} catch (InvalidProtocolBufferException e) {
					throw e.setUnfinishedMessage(builder.buildPartial());
				} catch (UninitializedMessageException e) {
					throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
				} catch (java.io.IOException e) {
					throw new InvalidProtocolBufferException(e).setUnfinishedMessage(builder.buildPartial());
				}
				return builder.buildPartial();
			}
		};

		public static Parser<LicenseRequest> parser() {
			return PARSER;
		}

		@java.lang.Override
		public Parser<LicenseRequest> getParserForType() {
			return PARSER;
		}

		@java.lang.Override
		public WvProto2.LicenseRequest getDefaultInstanceForType() {
			return DEFAULT_INSTANCE;
		}

	}

	public interface MetricDataOrBuilder extends
			// @@protoc_insertion_point(interface_extends:MetricData)
			MessageOrBuilder {

		/**
		 * <pre>
		 * 'stage' that is currently processing the SignedMessage.  Required.
		 * </pre>
		 *
		 * <code>optional string stage_name = 1;</code>
		 * 
		 * @return Whether the stageName field is set.
		 */
		boolean hasStageName();

		/**
		 * <pre>
		 * 'stage' that is currently processing the SignedMessage.  Required.
		 * </pre>
		 *
		 * <code>optional string stage_name = 1;</code>
		 * 
		 * @return The stageName.
		 */
		java.lang.String getStageName();

		/**
		 * <pre>
		 * 'stage' that is currently processing the SignedMessage.  Required.
		 * </pre>
		 *
		 * <code>optional string stage_name = 1;</code>
		 * 
		 * @return The bytes for stageName.
		 */
		ByteString getStageNameBytes();

		/**
		 * <pre>
		 * metric and associated value.
		 * </pre>
		 *
		 * <code>repeated .MetricData.TypeValue metric_data = 2;</code>
		 */
		java.util.List<WvProto2.MetricData.TypeValue> getMetricDataList();

		/**
		 * <pre>
		 * metric and associated value.
		 * </pre>
		 *
		 * <code>repeated .MetricData.TypeValue metric_data = 2;</code>
		 */
		WvProto2.MetricData.TypeValue getMetricData(int index);

		/**
		 * <pre>
		 * metric and associated value.
		 * </pre>
		 *
		 * <code>repeated .MetricData.TypeValue metric_data = 2;</code>
		 */
		int getMetricDataCount();

		/**
		 * <pre>
		 * metric and associated value.
		 * </pre>
		 *
		 * <code>repeated .MetricData.TypeValue metric_data = 2;</code>
		 */
		java.util.List<? extends WvProto2.MetricData.TypeValueOrBuilder> getMetricDataOrBuilderList();

		/**
		 * <pre>
		 * metric and associated value.
		 * </pre>
		 *
		 * <code>repeated .MetricData.TypeValue metric_data = 2;</code>
		 */
		WvProto2.MetricData.TypeValueOrBuilder getMetricDataOrBuilder(int index);
	}

	/**
	 * Protobuf type {@code MetricData}
	 */
	public static final class MetricData extends GeneratedMessageV3 implements
			// @@protoc_insertion_point(message_implements:MetricData)
			MetricDataOrBuilder {
		private static final long serialVersionUID = 0L;

		// Use MetricData.newBuilder() to construct.
		private MetricData(GeneratedMessageV3.Builder<?> builder) {
			super(builder);
		}

		private MetricData() {
			stageName_ = "";
			metricData_ = java.util.Collections.emptyList();
		}

		@java.lang.Override

		protected java.lang.Object newInstance(UnusedPrivateParameter unused) {
			return new MetricData();
		}

		public static final Descriptors.Descriptor getDescriptor() {
			return WvProto2.internal_static_MetricData_descriptor;
		}

		@java.lang.Override
		protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
			return WvProto2.internal_static_MetricData_fieldAccessorTable
					.ensureFieldAccessorsInitialized(WvProto2.MetricData.class,
							WvProto2.MetricData.Builder.class);
		}

		/**
		 * Protobuf enum {@code MetricData.MetricType}
		 */
		public enum MetricType implements ProtocolMessageEnum {
			/**
			 * <pre>
			 * The time spent in the 'stage', specified in microseconds.
			 * </pre>
			 *
			 * <code>LATENCY = 1;</code>
			 */
			LATENCY(1),
			/**
			 * <pre>
			 * The UNIX epoch timestamp at which the 'stage' was first accessed in
			 * microseconds.
			 * </pre>
			 *
			 * <code>TIMESTAMP = 2;</code>
			 */
			TIMESTAMP(2),;

			/**
			 * <pre>
			 * The time spent in the 'stage', specified in microseconds.
			 * </pre>
			 *
			 * <code>LATENCY = 1;</code>
			 */
			public static final int LATENCY_VALUE = 1;
			/**
			 * <pre>
			 * The UNIX epoch timestamp at which the 'stage' was first accessed in
			 * microseconds.
			 * </pre>
			 *
			 * <code>TIMESTAMP = 2;</code>
			 */
			public static final int TIMESTAMP_VALUE = 2;

			@Override
			public final int getNumber() {
				return value;
			}

			/**
			 * @param value The numeric wire value of the corresponding enum entry.
			 * @return The enum associated with the given numeric wire value.
			 * @deprecated Use {@link #forNumber(int)} instead.
			 */
			@java.lang.Deprecated
			public static MetricType valueOf(int value) {
				return forNumber(value);
			}

			/**
			 * @param value The numeric wire value of the corresponding enum entry.
			 * @return The enum associated with the given numeric wire value.
			 */
			public static MetricType forNumber(int value) {
				switch (value) {
				case 1:
					return LATENCY;
				case 2:
					return TIMESTAMP;
				default:
					return null;
				}
			}

			public static Internal.EnumLiteMap<MetricType> internalGetValueMap() {
				return internalValueMap;
			}

			private static final Internal.EnumLiteMap<MetricType> internalValueMap = new Internal.EnumLiteMap<>() {
				@Override
				public MetricType findValueByNumber(int number) {
					return MetricType.forNumber(number);
				}
			};

			@Override
			public final Descriptors.EnumValueDescriptor getValueDescriptor() {
				return getDescriptor().getValues().get(ordinal());
			}

			@Override
			public final Descriptors.EnumDescriptor getDescriptorForType() {
				return getDescriptor();
			}

			public static final Descriptors.EnumDescriptor getDescriptor() {
				return WvProto2.MetricData.getDescriptor().getEnumTypes().get(0);
			}

			private static final MetricType[] VALUES = values();

			public static MetricType valueOf(Descriptors.EnumValueDescriptor desc) {
				if (desc.getType() != getDescriptor()) {
					throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
				}
				return VALUES[desc.getIndex()];
			}

			private final int value;

			private MetricType(int value) {
				this.value = value;
			}

			// @@protoc_insertion_point(enum_scope:MetricData.MetricType)
		}

		public interface TypeValueOrBuilder extends
				// @@protoc_insertion_point(interface_extends:MetricData.TypeValue)
				MessageOrBuilder {

			/**
			 * <code>optional .MetricData.MetricType type = 1;</code>
			 * 
			 * @return Whether the type field is set.
			 */
			boolean hasType();

			/**
			 * <code>optional .MetricData.MetricType type = 1;</code>
			 * 
			 * @return The type.
			 */
			WvProto2.MetricData.MetricType getType();

			/**
			 * <pre>
			 * The value associated with 'type'.  For example if type == LATENCY, the
			 * value would be the time in microseconds spent in this 'stage'.
			 * </pre>
			 *
			 * <code>optional int64 value = 2 [default = 0];</code>
			 * 
			 * @return Whether the value field is set.
			 */
			boolean hasValue();

			/**
			 * <pre>
			 * The value associated with 'type'.  For example if type == LATENCY, the
			 * value would be the time in microseconds spent in this 'stage'.
			 * </pre>
			 *
			 * <code>optional int64 value = 2 [default = 0];</code>
			 * 
			 * @return The value.
			 */
			long getValue();
		}

		/**
		 * Protobuf type {@code MetricData.TypeValue}
		 */
		public static final class TypeValue extends GeneratedMessageV3 implements
				// @@protoc_insertion_point(message_implements:MetricData.TypeValue)
				TypeValueOrBuilder {
			private static final long serialVersionUID = 0L;

			// Use TypeValue.newBuilder() to construct.
			private TypeValue(GeneratedMessageV3.Builder<?> builder) {
				super(builder);
			}

			private TypeValue() {
				type_ = 1;
			}

			@java.lang.Override

			protected java.lang.Object newInstance(UnusedPrivateParameter unused) {
				return new TypeValue();
			}

			public static final Descriptors.Descriptor getDescriptor() {
				return WvProto2.internal_static_MetricData_TypeValue_descriptor;
			}

			@java.lang.Override
			protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
				return WvProto2.internal_static_MetricData_TypeValue_fieldAccessorTable
						.ensureFieldAccessorsInitialized(WvProto2.MetricData.TypeValue.class,
								WvProto2.MetricData.TypeValue.Builder.class);
			}

			private int bitField0_;
			public static final int TYPE_FIELD_NUMBER = 1;
			private int type_ = 1;

			/**
			 * <code>optional .MetricData.MetricType type = 1;</code>
			 * 
			 * @return Whether the type field is set.
			 */
			@java.lang.Override
			public boolean hasType() {
				return ((bitField0_ & 0x00000001) != 0);
			}

			/**
			 * <code>optional .MetricData.MetricType type = 1;</code>
			 * 
			 * @return The type.
			 */
			@java.lang.Override
			public WvProto2.MetricData.MetricType getType() {
				WvProto2.MetricData.MetricType result = WvProto2.MetricData.MetricType
						.forNumber(type_);
				return result == null ? WvProto2.MetricData.MetricType.LATENCY : result;
			}

			public static final int VALUE_FIELD_NUMBER = 2;
			private long value_ = 0L;

			/**
			 * <pre>
			 * The value associated with 'type'.  For example if type == LATENCY, the
			 * value would be the time in microseconds spent in this 'stage'.
			 * </pre>
			 *
			 * <code>optional int64 value = 2 [default = 0];</code>
			 * 
			 * @return Whether the value field is set.
			 */
			@java.lang.Override
			public boolean hasValue() {
				return ((bitField0_ & 0x00000002) != 0);
			}

			/**
			 * <pre>
			 * The value associated with 'type'.  For example if type == LATENCY, the
			 * value would be the time in microseconds spent in this 'stage'.
			 * </pre>
			 *
			 * <code>optional int64 value = 2 [default = 0];</code>
			 * 
			 * @return The value.
			 */
			@java.lang.Override
			public long getValue() {
				return value_;
			}

			private byte memoizedIsInitialized = -1;

			@java.lang.Override
			public final boolean isInitialized() {
				byte isInitialized = memoizedIsInitialized;
				if (isInitialized == 1)
					return true;
				if (isInitialized == 0)
					return false;

				memoizedIsInitialized = 1;
				return true;
			}

			@java.lang.Override
			public void writeTo(CodedOutputStream output) throws java.io.IOException {
				if (((bitField0_ & 0x00000001) != 0)) {
					output.writeEnum(1, type_);
				}
				if (((bitField0_ & 0x00000002) != 0)) {
					output.writeInt64(2, value_);
				}
				getUnknownFields().writeTo(output);
			}

			@java.lang.Override
			public int getSerializedSize() {
				int size = memoizedSize;
				if (size != -1)
					return size;

				size = 0;
				if (((bitField0_ & 0x00000001) != 0)) {
					size += CodedOutputStream.computeEnumSize(1, type_);
				}
				if (((bitField0_ & 0x00000002) != 0)) {
					size += CodedOutputStream.computeInt64Size(2, value_);
				}
				size += getUnknownFields().getSerializedSize();
				memoizedSize = size;
				return size;
			}

			@java.lang.Override
			public boolean equals(final java.lang.Object obj) {
				if (obj == this) {
					return true;
				}
				if (!(obj instanceof WvProto2.MetricData.TypeValue)) {
					return super.equals(obj);
				}
				WvProto2.MetricData.TypeValue other = (WvProto2.MetricData.TypeValue) obj;

				if (hasType() != other.hasType())
					return false;
				if (hasType()) {
					if (type_ != other.type_)
						return false;
				}
				if (hasValue() != other.hasValue())
					return false;
				if (hasValue()) {
					if (getValue() != other.getValue())
						return false;
				}
				if (!getUnknownFields().equals(other.getUnknownFields()))
					return false;
				return true;
			}

			@SuppressWarnings("unchecked")
			@java.lang.Override
			public int hashCode() {
				if (memoizedHashCode != 0) {
					return memoizedHashCode;
				}
				int hash = 41;
				hash = (19 * hash) + getDescriptor().hashCode();
				if (hasType()) {
					hash = (37 * hash) + TYPE_FIELD_NUMBER;
					hash = (53 * hash) + type_;
				}
				if (hasValue()) {
					hash = (37 * hash) + VALUE_FIELD_NUMBER;
					hash = (53 * hash) + Internal.hashLong(getValue());
				}
				hash = (29 * hash) + getUnknownFields().hashCode();
				memoizedHashCode = hash;
				return hash;
			}

			public static WvProto2.MetricData.TypeValue parseFrom(java.nio.ByteBuffer data)
					throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data);
			}

			public static WvProto2.MetricData.TypeValue parseFrom(java.nio.ByteBuffer data,
					ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data, extensionRegistry);
			}

			public static WvProto2.MetricData.TypeValue parseFrom(ByteString data)
					throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data);
			}

			public static WvProto2.MetricData.TypeValue parseFrom(ByteString data,
					ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data, extensionRegistry);
			}

			public static WvProto2.MetricData.TypeValue parseFrom(byte[] data)
					throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data);
			}

			public static WvProto2.MetricData.TypeValue parseFrom(byte[] data,
					ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data, extensionRegistry);
			}

			public static WvProto2.MetricData.TypeValue parseFrom(java.io.InputStream input)
					throws java.io.IOException {
				return GeneratedMessageV3.parseWithIOException(PARSER, input);
			}

			public static WvProto2.MetricData.TypeValue parseFrom(java.io.InputStream input,
					ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
				return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
			}

			public static WvProto2.MetricData.TypeValue parseDelimitedFrom(
					java.io.InputStream input) throws java.io.IOException {
				return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
			}

			public static WvProto2.MetricData.TypeValue parseDelimitedFrom(
					java.io.InputStream input, ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
				return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input, extensionRegistry);
			}

			public static WvProto2.MetricData.TypeValue parseFrom(CodedInputStream input)
					throws java.io.IOException {
				return GeneratedMessageV3.parseWithIOException(PARSER, input);
			}

			public static WvProto2.MetricData.TypeValue parseFrom(CodedInputStream input,
					ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
				return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
			}

			@java.lang.Override
			public Builder newBuilderForType() {
				return newBuilder();
			}

			public static Builder newBuilder() {
				return DEFAULT_INSTANCE.toBuilder();
			}

			public static Builder newBuilder(WvProto2.MetricData.TypeValue prototype) {
				return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
			}

			@java.lang.Override
			public Builder toBuilder() {
				return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
			}

			@java.lang.Override
			protected Builder newBuilderForType(GeneratedMessageV3.BuilderParent parent) {
				Builder builder = new Builder(parent);
				return builder;
			}

			/**
			 * Protobuf type {@code MetricData.TypeValue}
			 */
			public static final class Builder extends GeneratedMessageV3.Builder<Builder> implements
					// @@protoc_insertion_point(builder_implements:MetricData.TypeValue)
					WvProto2.MetricData.TypeValueOrBuilder {
				public static final Descriptors.Descriptor getDescriptor() {
					return WvProto2.internal_static_MetricData_TypeValue_descriptor;
				}

				@java.lang.Override
				protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
					return WvProto2.internal_static_MetricData_TypeValue_fieldAccessorTable
							.ensureFieldAccessorsInitialized(
									WvProto2.MetricData.TypeValue.class,
									WvProto2.MetricData.TypeValue.Builder.class);
				}

				// Construct using
				// WvProto2.MetricData.TypeValue.newBuilder()
				private Builder() {

				}

				private Builder(GeneratedMessageV3.BuilderParent parent) {
					super(parent);

				}

				@java.lang.Override
				public Builder clear() {
					super.clear();
					bitField0_ = 0;
					type_ = 1;
					value_ = 0L;
					return this;
				}

				@java.lang.Override
				public Descriptors.Descriptor getDescriptorForType() {
					return WvProto2.internal_static_MetricData_TypeValue_descriptor;
				}

				@java.lang.Override
				public WvProto2.MetricData.TypeValue getDefaultInstanceForType() {
					return WvProto2.MetricData.TypeValue.getDefaultInstance();
				}

				@java.lang.Override
				public WvProto2.MetricData.TypeValue build() {
					WvProto2.MetricData.TypeValue result = buildPartial();
					if (!result.isInitialized()) {
						throw newUninitializedMessageException(result);
					}
					return result;
				}

				@java.lang.Override
				public WvProto2.MetricData.TypeValue buildPartial() {
					WvProto2.MetricData.TypeValue result = new WvProto2.MetricData.TypeValue(
							this);
					if (bitField0_ != 0) {
						buildPartial0(result);
					}
					onBuilt();
					return result;
				}

				private void buildPartial0(WvProto2.MetricData.TypeValue result) {
					int from_bitField0_ = bitField0_;
					int to_bitField0_ = 0;
					if (((from_bitField0_ & 0x00000001) != 0)) {
						result.type_ = type_;
						to_bitField0_ |= 0x00000001;
					}
					if (((from_bitField0_ & 0x00000002) != 0)) {
						result.value_ = value_;
						to_bitField0_ |= 0x00000002;
					}
					result.bitField0_ |= to_bitField0_;
				}

				@java.lang.Override
				public Builder mergeFrom(Message other) {
					if (other instanceof WvProto2.MetricData.TypeValue) {
						return mergeFrom((WvProto2.MetricData.TypeValue) other);
					}
					super.mergeFrom(other);
					return this;
				}

				public Builder mergeFrom(WvProto2.MetricData.TypeValue other) {
					if (other == WvProto2.MetricData.TypeValue.getDefaultInstance())
						return this;
					if (other.hasType()) {
						setType(other.getType());
					}
					if (other.hasValue()) {
						setValue(other.getValue());
					}
					this.mergeUnknownFields(other.getUnknownFields());
					onChanged();
					return this;
				}

				@java.lang.Override
				public final boolean isInitialized() {
					return true;
				}

				@java.lang.Override
				public Builder mergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
						throws java.io.IOException {
					if (extensionRegistry == null) {
						throw new java.lang.NullPointerException();
					}
					try {
						boolean done = false;
						while (!done) {
							int tag = input.readTag();
							switch (tag) {
							case 0:
								done = true;
								break;
							case 8: {
								int tmpRaw = input.readEnum();
								WvProto2.MetricData.MetricType tmpValue = WvProto2.MetricData.MetricType
										.forNumber(tmpRaw);
								if (tmpValue == null) {
									mergeUnknownVarintField(1, tmpRaw);
								} else {
									type_ = tmpRaw;
									bitField0_ |= 0x00000001;
								}
								break;
							} // case 8
							case 16: {
								value_ = input.readInt64();
								bitField0_ |= 0x00000002;
								break;
							} // case 16
							default: {
								if (!super.parseUnknownField(input, extensionRegistry, tag)) {
									done = true; // was an endgroup tag
								}
								break;
							} // default:
							} // switch (tag)
						} // while (!done)
					} catch (InvalidProtocolBufferException e) {
						throw e.unwrapIOException();
					}
					finally {
						onChanged();
					} // finally
					return this;
				}

				private int bitField0_;

				private int type_ = 1;

				/**
				 * <code>optional .MetricData.MetricType type = 1;</code>
				 * 
				 * @return Whether the type field is set.
				 */
				@java.lang.Override
				public boolean hasType() {
					return ((bitField0_ & 0x00000001) != 0);
				}

				/**
				 * <code>optional .MetricData.MetricType type = 1;</code>
				 * 
				 * @return The type.
				 */
				@java.lang.Override
				public WvProto2.MetricData.MetricType getType() {
					WvProto2.MetricData.MetricType result = WvProto2.MetricData.MetricType
							.forNumber(type_);
					return result == null ? WvProto2.MetricData.MetricType.LATENCY : result;
				}

				/**
				 * <code>optional .MetricData.MetricType type = 1;</code>
				 * 
				 * @param value The type to set.
				 * @return This builder for chaining.
				 */
				public Builder setType(WvProto2.MetricData.MetricType value) {
					if (value == null) {
						throw new NullPointerException();
					}
					bitField0_ |= 0x00000001;
					type_ = value.getNumber();
					onChanged();
					return this;
				}

				/**
				 * <code>optional .MetricData.MetricType type = 1;</code>
				 * 
				 * @return This builder for chaining.
				 */
				public Builder clearType() {
					bitField0_ = (bitField0_ & ~0x00000001);
					type_ = 1;
					onChanged();
					return this;
				}

				private long value_;

				/**
				 * <pre>
				 * The value associated with 'type'.  For example if type == LATENCY, the
				 * value would be the time in microseconds spent in this 'stage'.
				 * </pre>
				 *
				 * <code>optional int64 value = 2 [default = 0];</code>
				 * 
				 * @return Whether the value field is set.
				 */
				@java.lang.Override
				public boolean hasValue() {
					return ((bitField0_ & 0x00000002) != 0);
				}

				/**
				 * <pre>
				 * The value associated with 'type'.  For example if type == LATENCY, the
				 * value would be the time in microseconds spent in this 'stage'.
				 * </pre>
				 *
				 * <code>optional int64 value = 2 [default = 0];</code>
				 * 
				 * @return The value.
				 */
				@java.lang.Override
				public long getValue() {
					return value_;
				}

				/**
				 * <pre>
				 * The value associated with 'type'.  For example if type == LATENCY, the
				 * value would be the time in microseconds spent in this 'stage'.
				 * </pre>
				 *
				 * <code>optional int64 value = 2 [default = 0];</code>
				 * 
				 * @param value The value to set.
				 * @return This builder for chaining.
				 */
				public Builder setValue(long value) {

					value_ = value;
					bitField0_ |= 0x00000002;
					onChanged();
					return this;
				}

				/**
				 * <pre>
				 * The value associated with 'type'.  For example if type == LATENCY, the
				 * value would be the time in microseconds spent in this 'stage'.
				 * </pre>
				 *
				 * <code>optional int64 value = 2 [default = 0];</code>
				 * 
				 * @return This builder for chaining.
				 */
				public Builder clearValue() {
					bitField0_ = (bitField0_ & ~0x00000002);
					value_ = 0L;
					onChanged();
					return this;
				}

				@java.lang.Override
				public final Builder setUnknownFields(final UnknownFieldSet unknownFields) {
					return super.setUnknownFields(unknownFields);
				}

				@java.lang.Override
				public final Builder mergeUnknownFields(final UnknownFieldSet unknownFields) {
					return super.mergeUnknownFields(unknownFields);
				}

				// @@protoc_insertion_point(builder_scope:MetricData.TypeValue)
			}

			// @@protoc_insertion_point(class_scope:MetricData.TypeValue)
			private static final WvProto2.MetricData.TypeValue DEFAULT_INSTANCE;
			static {
				DEFAULT_INSTANCE = new WvProto2.MetricData.TypeValue();
			}

			public static WvProto2.MetricData.TypeValue getDefaultInstance() {
				return DEFAULT_INSTANCE;
			}

			@java.lang.Deprecated public static final Parser<TypeValue> PARSER = new AbstractParser<>() {
				@java.lang.Override
				public TypeValue parsePartialFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
						throws InvalidProtocolBufferException {
					Builder builder = newBuilder();
					try {
						builder.mergeFrom(input, extensionRegistry);
					} catch (InvalidProtocolBufferException e) {
						throw e.setUnfinishedMessage(builder.buildPartial());
					} catch (UninitializedMessageException e) {
						throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
					} catch (java.io.IOException e) {
						throw new InvalidProtocolBufferException(e).setUnfinishedMessage(builder.buildPartial());
					}
					return builder.buildPartial();
				}
			};

			public static Parser<TypeValue> parser() {
				return PARSER;
			}

			@java.lang.Override
			public Parser<TypeValue> getParserForType() {
				return PARSER;
			}

			@java.lang.Override
			public WvProto2.MetricData.TypeValue getDefaultInstanceForType() {
				return DEFAULT_INSTANCE;
			}

		}

		private int bitField0_;
		public static final int STAGE_NAME_FIELD_NUMBER = 1;

		private volatile java.lang.Object stageName_ = "";

		/**
		 * <pre>
		 * 'stage' that is currently processing the SignedMessage.  Required.
		 * </pre>
		 *
		 * <code>optional string stage_name = 1;</code>
		 * 
		 * @return Whether the stageName field is set.
		 */
		@java.lang.Override
		public boolean hasStageName() {
			return ((bitField0_ & 0x00000001) != 0);
		}

		/**
		 * <pre>
		 * 'stage' that is currently processing the SignedMessage.  Required.
		 * </pre>
		 *
		 * <code>optional string stage_name = 1;</code>
		 * 
		 * @return The stageName.
		 */
		@java.lang.Override
		public java.lang.String getStageName() {
			java.lang.Object ref = stageName_;
			if (ref instanceof java.lang.String) {
				return (java.lang.String) ref;
			}
			ByteString bs = (ByteString) ref;
			java.lang.String s = bs.toStringUtf8();
			if (bs.isValidUtf8()) {
				stageName_ = s;
			}
			return s;
		}

		/**
		 * <pre>
		 * 'stage' that is currently processing the SignedMessage.  Required.
		 * </pre>
		 *
		 * <code>optional string stage_name = 1;</code>
		 * 
		 * @return The bytes for stageName.
		 */
		@java.lang.Override
		public ByteString getStageNameBytes() {
			java.lang.Object ref = stageName_;
			if (ref instanceof java.lang.String) {
				ByteString b = ByteString.copyFromUtf8((java.lang.String) ref);
				stageName_ = b;
				return b;
			}
			return (ByteString) ref;
		}

		public static final int METRIC_DATA_FIELD_NUMBER = 2;

		private java.util.List<WvProto2.MetricData.TypeValue> metricData_;

		/**
		 * <pre>
		 * metric and associated value.
		 * </pre>
		 *
		 * <code>repeated .MetricData.TypeValue metric_data = 2;</code>
		 */
		@java.lang.Override
		public java.util.List<WvProto2.MetricData.TypeValue> getMetricDataList() {
			return metricData_;
		}

		/**
		 * <pre>
		 * metric and associated value.
		 * </pre>
		 *
		 * <code>repeated .MetricData.TypeValue metric_data = 2;</code>
		 */
		@java.lang.Override
		public java.util.List<? extends WvProto2.MetricData.TypeValueOrBuilder> getMetricDataOrBuilderList() {
			return metricData_;
		}

		/**
		 * <pre>
		 * metric and associated value.
		 * </pre>
		 *
		 * <code>repeated .MetricData.TypeValue metric_data = 2;</code>
		 */
		@java.lang.Override
		public int getMetricDataCount() {
			return metricData_.size();
		}

		/**
		 * <pre>
		 * metric and associated value.
		 * </pre>
		 *
		 * <code>repeated .MetricData.TypeValue metric_data = 2;</code>
		 */
		@java.lang.Override
		public WvProto2.MetricData.TypeValue getMetricData(int index) {
			return metricData_.get(index);
		}

		/**
		 * <pre>
		 * metric and associated value.
		 * </pre>
		 *
		 * <code>repeated .MetricData.TypeValue metric_data = 2;</code>
		 */
		@java.lang.Override
		public WvProto2.MetricData.TypeValueOrBuilder getMetricDataOrBuilder(int index) {
			return metricData_.get(index);
		}

		private byte memoizedIsInitialized = -1;

		@java.lang.Override
		public final boolean isInitialized() {
			byte isInitialized = memoizedIsInitialized;
			if (isInitialized == 1)
				return true;
			if (isInitialized == 0)
				return false;

			memoizedIsInitialized = 1;
			return true;
		}

		@java.lang.Override
		public void writeTo(CodedOutputStream output) throws java.io.IOException {
			if (((bitField0_ & 0x00000001) != 0)) {
				GeneratedMessageV3.writeString(output, 1, stageName_);
			}
			for (int i = 0; i < metricData_.size(); i++) {
				output.writeMessage(2, metricData_.get(i));
			}
			getUnknownFields().writeTo(output);
		}

		@java.lang.Override
		public int getSerializedSize() {
			int size = memoizedSize;
			if (size != -1)
				return size;

			size = 0;
			if (((bitField0_ & 0x00000001) != 0)) {
				size += GeneratedMessageV3.computeStringSize(1, stageName_);
			}
			for (int i = 0; i < metricData_.size(); i++) {
				size += CodedOutputStream.computeMessageSize(2, metricData_.get(i));
			}
			size += getUnknownFields().getSerializedSize();
			memoizedSize = size;
			return size;
		}

		@java.lang.Override
		public boolean equals(final java.lang.Object obj) {
			if (obj == this) {
				return true;
			}
			if (!(obj instanceof WvProto2.MetricData)) {
				return super.equals(obj);
			}
			WvProto2.MetricData other = (WvProto2.MetricData) obj;

			if (hasStageName() != other.hasStageName())
				return false;
			if (hasStageName()) {
				if (!getStageName().equals(other.getStageName()))
					return false;
			}
			if (!getMetricDataList().equals(other.getMetricDataList()))
				return false;
			if (!getUnknownFields().equals(other.getUnknownFields()))
				return false;
			return true;
		}

		@SuppressWarnings("unchecked")
		@java.lang.Override
		public int hashCode() {
			if (memoizedHashCode != 0) {
				return memoizedHashCode;
			}
			int hash = 41;
			hash = (19 * hash) + getDescriptor().hashCode();
			if (hasStageName()) {
				hash = (37 * hash) + STAGE_NAME_FIELD_NUMBER;
				hash = (53 * hash) + getStageName().hashCode();
			}
			if (getMetricDataCount() > 0) {
				hash = (37 * hash) + METRIC_DATA_FIELD_NUMBER;
				hash = (53 * hash) + getMetricDataList().hashCode();
			}
			hash = (29 * hash) + getUnknownFields().hashCode();
			memoizedHashCode = hash;
			return hash;
		}

		public static WvProto2.MetricData parseFrom(java.nio.ByteBuffer data)
				throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data);
		}

		public static WvProto2.MetricData parseFrom(java.nio.ByteBuffer data,
				ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data, extensionRegistry);
		}

		public static WvProto2.MetricData parseFrom(ByteString data)
				throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data);
		}

		public static WvProto2.MetricData parseFrom(ByteString data,
				ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data, extensionRegistry);
		}

		public static WvProto2.MetricData parseFrom(byte[] data)
				throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data);
		}

		public static WvProto2.MetricData parseFrom(byte[] data,
				ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data, extensionRegistry);
		}

		public static WvProto2.MetricData parseFrom(java.io.InputStream input)
				throws java.io.IOException {
			return GeneratedMessageV3.parseWithIOException(PARSER, input);
		}

		public static WvProto2.MetricData parseFrom(java.io.InputStream input,
				ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
			return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
		}

		public static WvProto2.MetricData parseDelimitedFrom(java.io.InputStream input)
				throws java.io.IOException {
			return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
		}

		public static WvProto2.MetricData parseDelimitedFrom(java.io.InputStream input,
				ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
			return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input, extensionRegistry);
		}

		public static WvProto2.MetricData parseFrom(CodedInputStream input)
				throws java.io.IOException {
			return GeneratedMessageV3.parseWithIOException(PARSER, input);
		}

		public static WvProto2.MetricData parseFrom(CodedInputStream input,
				ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
			return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
		}

		@java.lang.Override
		public Builder newBuilderForType() {
			return newBuilder();
		}

		public static Builder newBuilder() {
			return DEFAULT_INSTANCE.toBuilder();
		}

		public static Builder newBuilder(WvProto2.MetricData prototype) {
			return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
		}

		@java.lang.Override
		public Builder toBuilder() {
			return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
		}

		@java.lang.Override
		protected Builder newBuilderForType(GeneratedMessageV3.BuilderParent parent) {
			Builder builder = new Builder(parent);
			return builder;
		}

		/**
		 * Protobuf type {@code MetricData}
		 */
		public static final class Builder extends GeneratedMessageV3.Builder<Builder> implements
				// @@protoc_insertion_point(builder_implements:MetricData)
				WvProto2.MetricDataOrBuilder {
			public static final Descriptors.Descriptor getDescriptor() {
				return WvProto2.internal_static_MetricData_descriptor;
			}

			@java.lang.Override
			protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
				return WvProto2.internal_static_MetricData_fieldAccessorTable
						.ensureFieldAccessorsInitialized(WvProto2.MetricData.class,
								WvProto2.MetricData.Builder.class);
			}

			// Construct using WvProto2.MetricData.newBuilder()
			private Builder() {

			}

			private Builder(GeneratedMessageV3.BuilderParent parent) {
				super(parent);

			}

			@java.lang.Override
			public Builder clear() {
				super.clear();
				bitField0_ = 0;
				stageName_ = "";
				if (metricDataBuilder_ == null) {
					metricData_ = java.util.Collections.emptyList();
				} else {
					metricData_ = null;
					metricDataBuilder_.clear();
				}
				bitField0_ = (bitField0_ & ~0x00000002);
				return this;
			}

			@java.lang.Override
			public Descriptors.Descriptor getDescriptorForType() {
				return WvProto2.internal_static_MetricData_descriptor;
			}

			@java.lang.Override
			public WvProto2.MetricData getDefaultInstanceForType() {
				return WvProto2.MetricData.getDefaultInstance();
			}

			@java.lang.Override
			public WvProto2.MetricData build() {
				WvProto2.MetricData result = buildPartial();
				if (!result.isInitialized()) {
					throw newUninitializedMessageException(result);
				}
				return result;
			}

			@java.lang.Override
			public WvProto2.MetricData buildPartial() {
				WvProto2.MetricData result = new WvProto2.MetricData(
						this);
				buildPartialRepeatedFields(result);
				if (bitField0_ != 0) {
					buildPartial0(result);
				}
				onBuilt();
				return result;
			}

			private void buildPartialRepeatedFields(WvProto2.MetricData result) {
				if (metricDataBuilder_ == null) {
					if (((bitField0_ & 0x00000002) != 0)) {
						metricData_ = java.util.Collections.unmodifiableList(metricData_);
						bitField0_ = (bitField0_ & ~0x00000002);
					}
					result.metricData_ = metricData_;
				} else {
					result.metricData_ = metricDataBuilder_.build();
				}
			}

			private void buildPartial0(WvProto2.MetricData result) {
				int from_bitField0_ = bitField0_;
				int to_bitField0_ = 0;
				if (((from_bitField0_ & 0x00000001) != 0)) {
					result.stageName_ = stageName_;
					to_bitField0_ |= 0x00000001;
				}
				result.bitField0_ |= to_bitField0_;
			}

			@java.lang.Override
			public Builder mergeFrom(Message other) {
				if (other instanceof WvProto2.MetricData) {
					return mergeFrom((WvProto2.MetricData) other);
				}
				super.mergeFrom(other);
				return this;
			}

			public Builder mergeFrom(WvProto2.MetricData other) {
				if (other == WvProto2.MetricData.getDefaultInstance())
					return this;
				if (other.hasStageName()) {
					stageName_ = other.stageName_;
					bitField0_ |= 0x00000001;
					onChanged();
				}
				if (metricDataBuilder_ == null) {
					if (!other.metricData_.isEmpty()) {
						if (metricData_.isEmpty()) {
							metricData_ = other.metricData_;
							bitField0_ = (bitField0_ & ~0x00000002);
						} else {
							ensureMetricDataIsMutable();
							metricData_.addAll(other.metricData_);
						}
						onChanged();
					}
				} else {
					if (!other.metricData_.isEmpty()) {
						if (metricDataBuilder_.isEmpty()) {
							metricDataBuilder_.dispose();
							metricDataBuilder_ = null;
							metricData_ = other.metricData_;
							bitField0_ = (bitField0_ & ~0x00000002);
							metricDataBuilder_ = GeneratedMessageV3.alwaysUseFieldBuilders ? getMetricDataFieldBuilder()
									: null;
						} else {
							metricDataBuilder_.addAllMessages(other.metricData_);
						}
					}
				}
				this.mergeUnknownFields(other.getUnknownFields());
				onChanged();
				return this;
			}

			@java.lang.Override
			public final boolean isInitialized() {
				return true;
			}

			@java.lang.Override
			public Builder mergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
					throws java.io.IOException {
				if (extensionRegistry == null) {
					throw new java.lang.NullPointerException();
				}
				try {
					boolean done = false;
					while (!done) {
						int tag = input.readTag();
						switch (tag) {
						case 0:
							done = true;
							break;
						case 10: {
							stageName_ = input.readBytes();
							bitField0_ |= 0x00000001;
							break;
						} // case 10
						case 18: {
							WvProto2.MetricData.TypeValue m = input.readMessage(
									WvProto2.MetricData.TypeValue.PARSER, extensionRegistry);
							if (metricDataBuilder_ == null) {
								ensureMetricDataIsMutable();
								metricData_.add(m);
							} else {
								metricDataBuilder_.addMessage(m);
							}
							break;
						} // case 18
						default: {
							if (!super.parseUnknownField(input, extensionRegistry, tag)) {
								done = true; // was an endgroup tag
							}
							break;
						} // default:
						} // switch (tag)
					} // while (!done)
				} catch (InvalidProtocolBufferException e) {
					throw e.unwrapIOException();
				}
				finally {
					onChanged();
				} // finally
				return this;
			}

			private int bitField0_;

			private java.lang.Object stageName_ = "";

			/**
			 * <pre>
			 * 'stage' that is currently processing the SignedMessage.  Required.
			 * </pre>
			 *
			 * <code>optional string stage_name = 1;</code>
			 * 
			 * @return Whether the stageName field is set.
			 */
			@Override
			public boolean hasStageName() {
				return ((bitField0_ & 0x00000001) != 0);
			}

			/**
			 * <pre>
			 * 'stage' that is currently processing the SignedMessage.  Required.
			 * </pre>
			 *
			 * <code>optional string stage_name = 1;</code>
			 * 
			 * @return The stageName.
			 */
			@Override
			public java.lang.String getStageName() {
				java.lang.Object ref = stageName_;
				if (!(ref instanceof java.lang.String)) {
					ByteString bs = (ByteString) ref;
					java.lang.String s = bs.toStringUtf8();
					if (bs.isValidUtf8()) {
						stageName_ = s;
					}
					return s;
				}
				return (java.lang.String) ref;
			}

			/**
			 * <pre>
			 * 'stage' that is currently processing the SignedMessage.  Required.
			 * </pre>
			 *
			 * <code>optional string stage_name = 1;</code>
			 * 
			 * @return The bytes for stageName.
			 */
			@Override
			public ByteString getStageNameBytes() {
				java.lang.Object ref = stageName_;
				if (ref instanceof String) {
					ByteString b = ByteString.copyFromUtf8((java.lang.String) ref);
					stageName_ = b;
					return b;
				}
				return (ByteString) ref;
			}

			/**
			 * <pre>
			 * 'stage' that is currently processing the SignedMessage.  Required.
			 * </pre>
			 *
			 * <code>optional string stage_name = 1;</code>
			 * 
			 * @param value The stageName to set.
			 * @return This builder for chaining.
			 */
			public Builder setStageName(java.lang.String value) {
				if (value == null) {
					throw new NullPointerException();
				}
				stageName_ = value;
				bitField0_ |= 0x00000001;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * 'stage' that is currently processing the SignedMessage.  Required.
			 * </pre>
			 *
			 * <code>optional string stage_name = 1;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearStageName() {
				stageName_ = getDefaultInstance().getStageName();
				bitField0_ = (bitField0_ & ~0x00000001);
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * 'stage' that is currently processing the SignedMessage.  Required.
			 * </pre>
			 *
			 * <code>optional string stage_name = 1;</code>
			 * 
			 * @param value The bytes for stageName to set.
			 * @return This builder for chaining.
			 */
			public Builder setStageNameBytes(ByteString value) {
				if (value == null) {
					throw new NullPointerException();
				}
				stageName_ = value;
				bitField0_ |= 0x00000001;
				onChanged();
				return this;
			}

			private java.util.List<WvProto2.MetricData.TypeValue> metricData_ = java.util.Collections
					.emptyList();

			private void ensureMetricDataIsMutable() {
				if (!((bitField0_ & 0x00000002) != 0)) {
					metricData_ = new java.util.ArrayList<>(metricData_);
					bitField0_ |= 0x00000002;
				}
			}

			private RepeatedFieldBuilderV3<WvProto2.MetricData.TypeValue, WvProto2.MetricData.TypeValue.Builder, WvProto2.MetricData.TypeValueOrBuilder> metricDataBuilder_;

			/**
			 * <pre>
			 * metric and associated value.
			 * </pre>
			 *
			 * <code>repeated .MetricData.TypeValue metric_data = 2;</code>
			 */
			@Override
			public java.util.List<WvProto2.MetricData.TypeValue> getMetricDataList() {
				if (metricDataBuilder_ == null) {
					return java.util.Collections.unmodifiableList(metricData_);
				}
				return metricDataBuilder_.getMessageList();
			}

			/**
			 * <pre>
			 * metric and associated value.
			 * </pre>
			 *
			 * <code>repeated .MetricData.TypeValue metric_data = 2;</code>
			 */
			@Override
			public int getMetricDataCount() {
				if (metricDataBuilder_ == null) {
					return metricData_.size();
				}
				return metricDataBuilder_.getCount();
			}

			/**
			 * <pre>
			 * metric and associated value.
			 * </pre>
			 *
			 * <code>repeated .MetricData.TypeValue metric_data = 2;</code>
			 */
			@Override
			public WvProto2.MetricData.TypeValue getMetricData(int index) {
				if (metricDataBuilder_ == null) {
					return metricData_.get(index);
				}
				return metricDataBuilder_.getMessage(index);
			}

			/**
			 * <pre>
			 * metric and associated value.
			 * </pre>
			 *
			 * <code>repeated .MetricData.TypeValue metric_data = 2;</code>
			 */
			public Builder setMetricData(int index, WvProto2.MetricData.TypeValue value) {
				if (metricDataBuilder_ == null) {
					if (value == null) {
						throw new NullPointerException();
					}
					ensureMetricDataIsMutable();
					metricData_.set(index, value);
					onChanged();
				} else {
					metricDataBuilder_.setMessage(index, value);
				}
				return this;
			}

			/**
			 * <pre>
			 * metric and associated value.
			 * </pre>
			 *
			 * <code>repeated .MetricData.TypeValue metric_data = 2;</code>
			 */
			public Builder setMetricData(int index,
					WvProto2.MetricData.TypeValue.Builder builderForValue) {
				if (metricDataBuilder_ == null) {
					ensureMetricDataIsMutable();
					metricData_.set(index, builderForValue.build());
					onChanged();
				} else {
					metricDataBuilder_.setMessage(index, builderForValue.build());
				}
				return this;
			}

			/**
			 * <pre>
			 * metric and associated value.
			 * </pre>
			 *
			 * <code>repeated .MetricData.TypeValue metric_data = 2;</code>
			 */
			public Builder addMetricData(WvProto2.MetricData.TypeValue value) {
				if (metricDataBuilder_ == null) {
					if (value == null) {
						throw new NullPointerException();
					}
					ensureMetricDataIsMutable();
					metricData_.add(value);
					onChanged();
				} else {
					metricDataBuilder_.addMessage(value);
				}
				return this;
			}

			/**
			 * <pre>
			 * metric and associated value.
			 * </pre>
			 *
			 * <code>repeated .MetricData.TypeValue metric_data = 2;</code>
			 */
			public Builder addMetricData(int index, WvProto2.MetricData.TypeValue value) {
				if (metricDataBuilder_ == null) {
					if (value == null) {
						throw new NullPointerException();
					}
					ensureMetricDataIsMutable();
					metricData_.add(index, value);
					onChanged();
				} else {
					metricDataBuilder_.addMessage(index, value);
				}
				return this;
			}

			/**
			 * <pre>
			 * metric and associated value.
			 * </pre>
			 *
			 * <code>repeated .MetricData.TypeValue metric_data = 2;</code>
			 */
			public Builder addMetricData(
					WvProto2.MetricData.TypeValue.Builder builderForValue) {
				if (metricDataBuilder_ == null) {
					ensureMetricDataIsMutable();
					metricData_.add(builderForValue.build());
					onChanged();
				} else {
					metricDataBuilder_.addMessage(builderForValue.build());
				}
				return this;
			}

			/**
			 * <pre>
			 * metric and associated value.
			 * </pre>
			 *
			 * <code>repeated .MetricData.TypeValue metric_data = 2;</code>
			 */
			public Builder addMetricData(int index,
					WvProto2.MetricData.TypeValue.Builder builderForValue) {
				if (metricDataBuilder_ == null) {
					ensureMetricDataIsMutable();
					metricData_.add(index, builderForValue.build());
					onChanged();
				} else {
					metricDataBuilder_.addMessage(index, builderForValue.build());
				}
				return this;
			}

			/**
			 * <pre>
			 * metric and associated value.
			 * </pre>
			 *
			 * <code>repeated .MetricData.TypeValue metric_data = 2;</code>
			 */
			public Builder addAllMetricData(
					java.lang.Iterable<? extends WvProto2.MetricData.TypeValue> values) {
				if (metricDataBuilder_ == null) {
					ensureMetricDataIsMutable();
					AbstractMessageLite.Builder.addAll(values, metricData_);
					onChanged();
				} else {
					metricDataBuilder_.addAllMessages(values);
				}
				return this;
			}

			/**
			 * <pre>
			 * metric and associated value.
			 * </pre>
			 *
			 * <code>repeated .MetricData.TypeValue metric_data = 2;</code>
			 */
			public Builder clearMetricData() {
				if (metricDataBuilder_ == null) {
					metricData_ = java.util.Collections.emptyList();
					bitField0_ = (bitField0_ & ~0x00000002);
					onChanged();
				} else {
					metricDataBuilder_.clear();
				}
				return this;
			}

			/**
			 * <pre>
			 * metric and associated value.
			 * </pre>
			 *
			 * <code>repeated .MetricData.TypeValue metric_data = 2;</code>
			 */
			public Builder removeMetricData(int index) {
				if (metricDataBuilder_ == null) {
					ensureMetricDataIsMutable();
					metricData_.remove(index);
					onChanged();
				} else {
					metricDataBuilder_.remove(index);
				}
				return this;
			}

			/**
			 * <pre>
			 * metric and associated value.
			 * </pre>
			 *
			 * <code>repeated .MetricData.TypeValue metric_data = 2;</code>
			 */
			public WvProto2.MetricData.TypeValue.Builder getMetricDataBuilder(int index) {
				return getMetricDataFieldBuilder().getBuilder(index);
			}

			/**
			 * <pre>
			 * metric and associated value.
			 * </pre>
			 *
			 * <code>repeated .MetricData.TypeValue metric_data = 2;</code>
			 */
			@Override
			public WvProto2.MetricData.TypeValueOrBuilder getMetricDataOrBuilder(int index) {
				if (metricDataBuilder_ == null) {
					return metricData_.get(index);
				}
				return metricDataBuilder_.getMessageOrBuilder(index);
			}

			/**
			 * <pre>
			 * metric and associated value.
			 * </pre>
			 *
			 * <code>repeated .MetricData.TypeValue metric_data = 2;</code>
			 */
			@Override
			public java.util.List<? extends WvProto2.MetricData.TypeValueOrBuilder> getMetricDataOrBuilderList() {
				if (metricDataBuilder_ != null) {
					return metricDataBuilder_.getMessageOrBuilderList();
				}
				return java.util.Collections.unmodifiableList(metricData_);
			}

			/**
			 * <pre>
			 * metric and associated value.
			 * </pre>
			 *
			 * <code>repeated .MetricData.TypeValue metric_data = 2;</code>
			 */
			public WvProto2.MetricData.TypeValue.Builder addMetricDataBuilder() {
				return getMetricDataFieldBuilder()
						.addBuilder(WvProto2.MetricData.TypeValue.getDefaultInstance());
			}

			/**
			 * <pre>
			 * metric and associated value.
			 * </pre>
			 *
			 * <code>repeated .MetricData.TypeValue metric_data = 2;</code>
			 */
			public WvProto2.MetricData.TypeValue.Builder addMetricDataBuilder(int index) {
				return getMetricDataFieldBuilder().addBuilder(index,
						WvProto2.MetricData.TypeValue.getDefaultInstance());
			}

			/**
			 * <pre>
			 * metric and associated value.
			 * </pre>
			 *
			 * <code>repeated .MetricData.TypeValue metric_data = 2;</code>
			 */
			public java.util.List<WvProto2.MetricData.TypeValue.Builder> getMetricDataBuilderList() {
				return getMetricDataFieldBuilder().getBuilderList();
			}

			private RepeatedFieldBuilderV3<WvProto2.MetricData.TypeValue, WvProto2.MetricData.TypeValue.Builder, WvProto2.MetricData.TypeValueOrBuilder> getMetricDataFieldBuilder() {
				if (metricDataBuilder_ == null) {
					metricDataBuilder_ = new RepeatedFieldBuilderV3<>(metricData_, ((bitField0_ & 0x00000002) != 0),
							getParentForChildren(), isClean());
					metricData_ = null;
				}
				return metricDataBuilder_;
			}

			@java.lang.Override
			public final Builder setUnknownFields(final UnknownFieldSet unknownFields) {
				return super.setUnknownFields(unknownFields);
			}

			@java.lang.Override
			public final Builder mergeUnknownFields(final UnknownFieldSet unknownFields) {
				return super.mergeUnknownFields(unknownFields);
			}

			// @@protoc_insertion_point(builder_scope:MetricData)
		}

		// @@protoc_insertion_point(class_scope:MetricData)
		private static final WvProto2.MetricData DEFAULT_INSTANCE;
		static {
			DEFAULT_INSTANCE = new WvProto2.MetricData();
		}

		public static WvProto2.MetricData getDefaultInstance() {
			return DEFAULT_INSTANCE;
		}

		@java.lang.Deprecated public static final Parser<MetricData> PARSER = new AbstractParser<>() {
			@java.lang.Override
			public MetricData parsePartialFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
					throws InvalidProtocolBufferException {
				Builder builder = newBuilder();
				try {
					builder.mergeFrom(input, extensionRegistry);
				} catch (InvalidProtocolBufferException e) {
					throw e.setUnfinishedMessage(builder.buildPartial());
				} catch (UninitializedMessageException e) {
					throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
				} catch (java.io.IOException e) {
					throw new InvalidProtocolBufferException(e).setUnfinishedMessage(builder.buildPartial());
				}
				return builder.buildPartial();
			}
		};

		public static Parser<MetricData> parser() {
			return PARSER;
		}

		@java.lang.Override
		public Parser<MetricData> getParserForType() {
			return PARSER;
		}

		@java.lang.Override
		public WvProto2.MetricData getDefaultInstanceForType() {
			return DEFAULT_INSTANCE;
		}

	}

	public interface VersionInfoOrBuilder extends
			// @@protoc_insertion_point(interface_extends:VersionInfo)
			MessageOrBuilder {

		/**
		 * <pre>
		 * License SDK version reported by the Widevine License SDK. This field
		 * is populated automatically by the SDK.
		 * </pre>
		 *
		 * <code>optional string license_sdk_version = 1;</code>
		 * 
		 * @return Whether the licenseSdkVersion field is set.
		 */
		boolean hasLicenseSdkVersion();

		/**
		 * <pre>
		 * License SDK version reported by the Widevine License SDK. This field
		 * is populated automatically by the SDK.
		 * </pre>
		 *
		 * <code>optional string license_sdk_version = 1;</code>
		 * 
		 * @return The licenseSdkVersion.
		 */
		java.lang.String getLicenseSdkVersion();

		/**
		 * <pre>
		 * License SDK version reported by the Widevine License SDK. This field
		 * is populated automatically by the SDK.
		 * </pre>
		 *
		 * <code>optional string license_sdk_version = 1;</code>
		 * 
		 * @return The bytes for licenseSdkVersion.
		 */
		ByteString getLicenseSdkVersionBytes();

		/**
		 * <pre>
		 * Version of the service hosting the license SDK. This field is optional.
		 * It may be provided by the hosting service.
		 * </pre>
		 *
		 * <code>optional string license_service_version = 2;</code>
		 * 
		 * @return Whether the licenseServiceVersion field is set.
		 */
		boolean hasLicenseServiceVersion();

		/**
		 * <pre>
		 * Version of the service hosting the license SDK. This field is optional.
		 * It may be provided by the hosting service.
		 * </pre>
		 *
		 * <code>optional string license_service_version = 2;</code>
		 * 
		 * @return The licenseServiceVersion.
		 */
		java.lang.String getLicenseServiceVersion();

		/**
		 * <pre>
		 * Version of the service hosting the license SDK. This field is optional.
		 * It may be provided by the hosting service.
		 * </pre>
		 *
		 * <code>optional string license_service_version = 2;</code>
		 * 
		 * @return The bytes for licenseServiceVersion.
		 */
		ByteString getLicenseServiceVersionBytes();
	}

	/**
	 * Protobuf type {@code VersionInfo}
	 */
	public static final class VersionInfo extends GeneratedMessageV3 implements
			// @@protoc_insertion_point(message_implements:VersionInfo)
			VersionInfoOrBuilder {
		private static final long serialVersionUID = 0L;

		// Use VersionInfo.newBuilder() to construct.
		private VersionInfo(GeneratedMessageV3.Builder<?> builder) {
			super(builder);
		}

		private VersionInfo() {
			licenseSdkVersion_ = "";
			licenseServiceVersion_ = "";
		}

		@java.lang.Override

		protected java.lang.Object newInstance(UnusedPrivateParameter unused) {
			return new VersionInfo();
		}

		public static final Descriptors.Descriptor getDescriptor() {
			return WvProto2.internal_static_VersionInfo_descriptor;
		}

		@java.lang.Override
		protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
			return WvProto2.internal_static_VersionInfo_fieldAccessorTable
					.ensureFieldAccessorsInitialized(WvProto2.VersionInfo.class,
							WvProto2.VersionInfo.Builder.class);
		}

		private int bitField0_;
		public static final int LICENSE_SDK_VERSION_FIELD_NUMBER = 1;

		private volatile java.lang.Object licenseSdkVersion_ = "";

		/**
		 * <pre>
		 * License SDK version reported by the Widevine License SDK. This field
		 * is populated automatically by the SDK.
		 * </pre>
		 *
		 * <code>optional string license_sdk_version = 1;</code>
		 * 
		 * @return Whether the licenseSdkVersion field is set.
		 */
		@java.lang.Override
		public boolean hasLicenseSdkVersion() {
			return ((bitField0_ & 0x00000001) != 0);
		}

		/**
		 * <pre>
		 * License SDK version reported by the Widevine License SDK. This field
		 * is populated automatically by the SDK.
		 * </pre>
		 *
		 * <code>optional string license_sdk_version = 1;</code>
		 * 
		 * @return The licenseSdkVersion.
		 */
		@java.lang.Override
		public java.lang.String getLicenseSdkVersion() {
			java.lang.Object ref = licenseSdkVersion_;
			if (ref instanceof java.lang.String) {
				return (java.lang.String) ref;
			}
			ByteString bs = (ByteString) ref;
			java.lang.String s = bs.toStringUtf8();
			if (bs.isValidUtf8()) {
				licenseSdkVersion_ = s;
			}
			return s;
		}

		/**
		 * <pre>
		 * License SDK version reported by the Widevine License SDK. This field
		 * is populated automatically by the SDK.
		 * </pre>
		 *
		 * <code>optional string license_sdk_version = 1;</code>
		 * 
		 * @return The bytes for licenseSdkVersion.
		 */
		@java.lang.Override
		public ByteString getLicenseSdkVersionBytes() {
			java.lang.Object ref = licenseSdkVersion_;
			if (ref instanceof java.lang.String) {
				ByteString b = ByteString.copyFromUtf8((java.lang.String) ref);
				licenseSdkVersion_ = b;
				return b;
			}
			return (ByteString) ref;
		}

		public static final int LICENSE_SERVICE_VERSION_FIELD_NUMBER = 2;

		private volatile java.lang.Object licenseServiceVersion_ = "";

		/**
		 * <pre>
		 * Version of the service hosting the license SDK. This field is optional.
		 * It may be provided by the hosting service.
		 * </pre>
		 *
		 * <code>optional string license_service_version = 2;</code>
		 * 
		 * @return Whether the licenseServiceVersion field is set.
		 */
		@java.lang.Override
		public boolean hasLicenseServiceVersion() {
			return ((bitField0_ & 0x00000002) != 0);
		}

		/**
		 * <pre>
		 * Version of the service hosting the license SDK. This field is optional.
		 * It may be provided by the hosting service.
		 * </pre>
		 *
		 * <code>optional string license_service_version = 2;</code>
		 * 
		 * @return The licenseServiceVersion.
		 */
		@java.lang.Override
		public java.lang.String getLicenseServiceVersion() {
			java.lang.Object ref = licenseServiceVersion_;
			if (ref instanceof java.lang.String) {
				return (java.lang.String) ref;
			}
			ByteString bs = (ByteString) ref;
			java.lang.String s = bs.toStringUtf8();
			if (bs.isValidUtf8()) {
				licenseServiceVersion_ = s;
			}
			return s;
		}

		/**
		 * <pre>
		 * Version of the service hosting the license SDK. This field is optional.
		 * It may be provided by the hosting service.
		 * </pre>
		 *
		 * <code>optional string license_service_version = 2;</code>
		 * 
		 * @return The bytes for licenseServiceVersion.
		 */
		@java.lang.Override
		public ByteString getLicenseServiceVersionBytes() {
			java.lang.Object ref = licenseServiceVersion_;
			if (ref instanceof java.lang.String) {
				ByteString b = ByteString.copyFromUtf8((java.lang.String) ref);
				licenseServiceVersion_ = b;
				return b;
			}
			return (ByteString) ref;
		}

		private byte memoizedIsInitialized = -1;

		@java.lang.Override
		public final boolean isInitialized() {
			byte isInitialized = memoizedIsInitialized;
			if (isInitialized == 1)
				return true;
			if (isInitialized == 0)
				return false;

			memoizedIsInitialized = 1;
			return true;
		}

		@java.lang.Override
		public void writeTo(CodedOutputStream output) throws java.io.IOException {
			if (((bitField0_ & 0x00000001) != 0)) {
				GeneratedMessageV3.writeString(output, 1, licenseSdkVersion_);
			}
			if (((bitField0_ & 0x00000002) != 0)) {
				GeneratedMessageV3.writeString(output, 2, licenseServiceVersion_);
			}
			getUnknownFields().writeTo(output);
		}

		@java.lang.Override
		public int getSerializedSize() {
			int size = memoizedSize;
			if (size != -1)
				return size;

			size = 0;
			if (((bitField0_ & 0x00000001) != 0)) {
				size += GeneratedMessageV3.computeStringSize(1, licenseSdkVersion_);
			}
			if (((bitField0_ & 0x00000002) != 0)) {
				size += GeneratedMessageV3.computeStringSize(2, licenseServiceVersion_);
			}
			size += getUnknownFields().getSerializedSize();
			memoizedSize = size;
			return size;
		}

		@java.lang.Override
		public boolean equals(final java.lang.Object obj) {
			if (obj == this) {
				return true;
			}
			if (!(obj instanceof WvProto2.VersionInfo)) {
				return super.equals(obj);
			}
			WvProto2.VersionInfo other = (WvProto2.VersionInfo) obj;

			if (hasLicenseSdkVersion() != other.hasLicenseSdkVersion())
				return false;
			if (hasLicenseSdkVersion()) {
				if (!getLicenseSdkVersion().equals(other.getLicenseSdkVersion()))
					return false;
			}
			if (hasLicenseServiceVersion() != other.hasLicenseServiceVersion())
				return false;
			if (hasLicenseServiceVersion()) {
				if (!getLicenseServiceVersion().equals(other.getLicenseServiceVersion()))
					return false;
			}
			if (!getUnknownFields().equals(other.getUnknownFields()))
				return false;
			return true;
		}

		@SuppressWarnings("unchecked")
		@java.lang.Override
		public int hashCode() {
			if (memoizedHashCode != 0) {
				return memoizedHashCode;
			}
			int hash = 41;
			hash = (19 * hash) + getDescriptor().hashCode();
			if (hasLicenseSdkVersion()) {
				hash = (37 * hash) + LICENSE_SDK_VERSION_FIELD_NUMBER;
				hash = (53 * hash) + getLicenseSdkVersion().hashCode();
			}
			if (hasLicenseServiceVersion()) {
				hash = (37 * hash) + LICENSE_SERVICE_VERSION_FIELD_NUMBER;
				hash = (53 * hash) + getLicenseServiceVersion().hashCode();
			}
			hash = (29 * hash) + getUnknownFields().hashCode();
			memoizedHashCode = hash;
			return hash;
		}

		public static WvProto2.VersionInfo parseFrom(java.nio.ByteBuffer data)
				throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data);
		}

		public static WvProto2.VersionInfo parseFrom(java.nio.ByteBuffer data,
				ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data, extensionRegistry);
		}

		public static WvProto2.VersionInfo parseFrom(ByteString data)
				throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data);
		}

		public static WvProto2.VersionInfo parseFrom(ByteString data,
				ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data, extensionRegistry);
		}

		public static WvProto2.VersionInfo parseFrom(byte[] data)
				throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data);
		}

		public static WvProto2.VersionInfo parseFrom(byte[] data,
				ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data, extensionRegistry);
		}

		public static WvProto2.VersionInfo parseFrom(java.io.InputStream input)
				throws java.io.IOException {
			return GeneratedMessageV3.parseWithIOException(PARSER, input);
		}

		public static WvProto2.VersionInfo parseFrom(java.io.InputStream input,
				ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
			return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
		}

		public static WvProto2.VersionInfo parseDelimitedFrom(java.io.InputStream input)
				throws java.io.IOException {
			return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
		}

		public static WvProto2.VersionInfo parseDelimitedFrom(java.io.InputStream input,
				ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
			return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input, extensionRegistry);
		}

		public static WvProto2.VersionInfo parseFrom(CodedInputStream input)
				throws java.io.IOException {
			return GeneratedMessageV3.parseWithIOException(PARSER, input);
		}

		public static WvProto2.VersionInfo parseFrom(CodedInputStream input,
				ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
			return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
		}

		@java.lang.Override
		public Builder newBuilderForType() {
			return newBuilder();
		}

		public static Builder newBuilder() {
			return DEFAULT_INSTANCE.toBuilder();
		}

		public static Builder newBuilder(WvProto2.VersionInfo prototype) {
			return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
		}

		@java.lang.Override
		public Builder toBuilder() {
			return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
		}

		@java.lang.Override
		protected Builder newBuilderForType(GeneratedMessageV3.BuilderParent parent) {
			Builder builder = new Builder(parent);
			return builder;
		}

		/**
		 * Protobuf type {@code VersionInfo}
		 */
		public static final class Builder extends GeneratedMessageV3.Builder<Builder> implements
				// @@protoc_insertion_point(builder_implements:VersionInfo)
				WvProto2.VersionInfoOrBuilder {
			public static final Descriptors.Descriptor getDescriptor() {
				return WvProto2.internal_static_VersionInfo_descriptor;
			}

			@java.lang.Override
			protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
				return WvProto2.internal_static_VersionInfo_fieldAccessorTable
						.ensureFieldAccessorsInitialized(WvProto2.VersionInfo.class,
								WvProto2.VersionInfo.Builder.class);
			}

			// Construct using WvProto2.VersionInfo.newBuilder()
			private Builder() {

			}

			private Builder(GeneratedMessageV3.BuilderParent parent) {
				super(parent);

			}

			@java.lang.Override
			public Builder clear() {
				super.clear();
				bitField0_ = 0;
				licenseSdkVersion_ = "";
				licenseServiceVersion_ = "";
				return this;
			}

			@java.lang.Override
			public Descriptors.Descriptor getDescriptorForType() {
				return WvProto2.internal_static_VersionInfo_descriptor;
			}

			@java.lang.Override
			public WvProto2.VersionInfo getDefaultInstanceForType() {
				return WvProto2.VersionInfo.getDefaultInstance();
			}

			@java.lang.Override
			public WvProto2.VersionInfo build() {
				WvProto2.VersionInfo result = buildPartial();
				if (!result.isInitialized()) {
					throw newUninitializedMessageException(result);
				}
				return result;
			}

			@java.lang.Override
			public WvProto2.VersionInfo buildPartial() {
				WvProto2.VersionInfo result = new WvProto2.VersionInfo(
						this);
				if (bitField0_ != 0) {
					buildPartial0(result);
				}
				onBuilt();
				return result;
			}

			private void buildPartial0(WvProto2.VersionInfo result) {
				int from_bitField0_ = bitField0_;
				int to_bitField0_ = 0;
				if (((from_bitField0_ & 0x00000001) != 0)) {
					result.licenseSdkVersion_ = licenseSdkVersion_;
					to_bitField0_ |= 0x00000001;
				}
				if (((from_bitField0_ & 0x00000002) != 0)) {
					result.licenseServiceVersion_ = licenseServiceVersion_;
					to_bitField0_ |= 0x00000002;
				}
				result.bitField0_ |= to_bitField0_;
			}

			@java.lang.Override
			public Builder mergeFrom(Message other) {
				if (other instanceof WvProto2.VersionInfo) {
					return mergeFrom((WvProto2.VersionInfo) other);
				}
				super.mergeFrom(other);
				return this;
			}

			public Builder mergeFrom(WvProto2.VersionInfo other) {
				if (other == WvProto2.VersionInfo.getDefaultInstance())
					return this;
				if (other.hasLicenseSdkVersion()) {
					licenseSdkVersion_ = other.licenseSdkVersion_;
					bitField0_ |= 0x00000001;
					onChanged();
				}
				if (other.hasLicenseServiceVersion()) {
					licenseServiceVersion_ = other.licenseServiceVersion_;
					bitField0_ |= 0x00000002;
					onChanged();
				}
				this.mergeUnknownFields(other.getUnknownFields());
				onChanged();
				return this;
			}

			@java.lang.Override
			public final boolean isInitialized() {
				return true;
			}

			@java.lang.Override
			public Builder mergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
					throws java.io.IOException {
				if (extensionRegistry == null) {
					throw new java.lang.NullPointerException();
				}
				try {
					boolean done = false;
					while (!done) {
						int tag = input.readTag();
						switch (tag) {
						case 0:
							done = true;
							break;
						case 10: {
							licenseSdkVersion_ = input.readBytes();
							bitField0_ |= 0x00000001;
							break;
						} // case 10
						case 18: {
							licenseServiceVersion_ = input.readBytes();
							bitField0_ |= 0x00000002;
							break;
						} // case 18
						default: {
							if (!super.parseUnknownField(input, extensionRegistry, tag)) {
								done = true; // was an endgroup tag
							}
							break;
						} // default:
						} // switch (tag)
					} // while (!done)
				} catch (InvalidProtocolBufferException e) {
					throw e.unwrapIOException();
				}
				finally {
					onChanged();
				} // finally
				return this;
			}

			private int bitField0_;

			private java.lang.Object licenseSdkVersion_ = "";

			/**
			 * <pre>
			 * License SDK version reported by the Widevine License SDK. This field
			 * is populated automatically by the SDK.
			 * </pre>
			 *
			 * <code>optional string license_sdk_version = 1;</code>
			 * 
			 * @return Whether the licenseSdkVersion field is set.
			 */
			@Override
			public boolean hasLicenseSdkVersion() {
				return ((bitField0_ & 0x00000001) != 0);
			}

			/**
			 * <pre>
			 * License SDK version reported by the Widevine License SDK. This field
			 * is populated automatically by the SDK.
			 * </pre>
			 *
			 * <code>optional string license_sdk_version = 1;</code>
			 * 
			 * @return The licenseSdkVersion.
			 */
			@Override
			public java.lang.String getLicenseSdkVersion() {
				java.lang.Object ref = licenseSdkVersion_;
				if (!(ref instanceof java.lang.String)) {
					ByteString bs = (ByteString) ref;
					java.lang.String s = bs.toStringUtf8();
					if (bs.isValidUtf8()) {
						licenseSdkVersion_ = s;
					}
					return s;
				}
				return (java.lang.String) ref;
			}

			/**
			 * <pre>
			 * License SDK version reported by the Widevine License SDK. This field
			 * is populated automatically by the SDK.
			 * </pre>
			 *
			 * <code>optional string license_sdk_version = 1;</code>
			 * 
			 * @return The bytes for licenseSdkVersion.
			 */
			@Override
			public ByteString getLicenseSdkVersionBytes() {
				java.lang.Object ref = licenseSdkVersion_;
				if (ref instanceof String) {
					ByteString b = ByteString.copyFromUtf8((java.lang.String) ref);
					licenseSdkVersion_ = b;
					return b;
				}
				return (ByteString) ref;
			}

			/**
			 * <pre>
			 * License SDK version reported by the Widevine License SDK. This field
			 * is populated automatically by the SDK.
			 * </pre>
			 *
			 * <code>optional string license_sdk_version = 1;</code>
			 * 
			 * @param value The licenseSdkVersion to set.
			 * @return This builder for chaining.
			 */
			public Builder setLicenseSdkVersion(java.lang.String value) {
				if (value == null) {
					throw new NullPointerException();
				}
				licenseSdkVersion_ = value;
				bitField0_ |= 0x00000001;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * License SDK version reported by the Widevine License SDK. This field
			 * is populated automatically by the SDK.
			 * </pre>
			 *
			 * <code>optional string license_sdk_version = 1;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearLicenseSdkVersion() {
				licenseSdkVersion_ = getDefaultInstance().getLicenseSdkVersion();
				bitField0_ = (bitField0_ & ~0x00000001);
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * License SDK version reported by the Widevine License SDK. This field
			 * is populated automatically by the SDK.
			 * </pre>
			 *
			 * <code>optional string license_sdk_version = 1;</code>
			 * 
			 * @param value The bytes for licenseSdkVersion to set.
			 * @return This builder for chaining.
			 */
			public Builder setLicenseSdkVersionBytes(ByteString value) {
				if (value == null) {
					throw new NullPointerException();
				}
				licenseSdkVersion_ = value;
				bitField0_ |= 0x00000001;
				onChanged();
				return this;
			}

			private java.lang.Object licenseServiceVersion_ = "";

			/**
			 * <pre>
			 * Version of the service hosting the license SDK. This field is optional.
			 * It may be provided by the hosting service.
			 * </pre>
			 *
			 * <code>optional string license_service_version = 2;</code>
			 * 
			 * @return Whether the licenseServiceVersion field is set.
			 */
			@Override
			public boolean hasLicenseServiceVersion() {
				return ((bitField0_ & 0x00000002) != 0);
			}

			/**
			 * <pre>
			 * Version of the service hosting the license SDK. This field is optional.
			 * It may be provided by the hosting service.
			 * </pre>
			 *
			 * <code>optional string license_service_version = 2;</code>
			 * 
			 * @return The licenseServiceVersion.
			 */
			@Override
			public java.lang.String getLicenseServiceVersion() {
				java.lang.Object ref = licenseServiceVersion_;
				if (!(ref instanceof java.lang.String)) {
					ByteString bs = (ByteString) ref;
					java.lang.String s = bs.toStringUtf8();
					if (bs.isValidUtf8()) {
						licenseServiceVersion_ = s;
					}
					return s;
				}
				return (java.lang.String) ref;
			}

			/**
			 * <pre>
			 * Version of the service hosting the license SDK. This field is optional.
			 * It may be provided by the hosting service.
			 * </pre>
			 *
			 * <code>optional string license_service_version = 2;</code>
			 * 
			 * @return The bytes for licenseServiceVersion.
			 */
			@Override
			public ByteString getLicenseServiceVersionBytes() {
				java.lang.Object ref = licenseServiceVersion_;
				if (ref instanceof String) {
					ByteString b = ByteString.copyFromUtf8((java.lang.String) ref);
					licenseServiceVersion_ = b;
					return b;
				}
				return (ByteString) ref;
			}

			/**
			 * <pre>
			 * Version of the service hosting the license SDK. This field is optional.
			 * It may be provided by the hosting service.
			 * </pre>
			 *
			 * <code>optional string license_service_version = 2;</code>
			 * 
			 * @param value The licenseServiceVersion to set.
			 * @return This builder for chaining.
			 */
			public Builder setLicenseServiceVersion(java.lang.String value) {
				if (value == null) {
					throw new NullPointerException();
				}
				licenseServiceVersion_ = value;
				bitField0_ |= 0x00000002;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Version of the service hosting the license SDK. This field is optional.
			 * It may be provided by the hosting service.
			 * </pre>
			 *
			 * <code>optional string license_service_version = 2;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearLicenseServiceVersion() {
				licenseServiceVersion_ = getDefaultInstance().getLicenseServiceVersion();
				bitField0_ = (bitField0_ & ~0x00000002);
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Version of the service hosting the license SDK. This field is optional.
			 * It may be provided by the hosting service.
			 * </pre>
			 *
			 * <code>optional string license_service_version = 2;</code>
			 * 
			 * @param value The bytes for licenseServiceVersion to set.
			 * @return This builder for chaining.
			 */
			public Builder setLicenseServiceVersionBytes(ByteString value) {
				if (value == null) {
					throw new NullPointerException();
				}
				licenseServiceVersion_ = value;
				bitField0_ |= 0x00000002;
				onChanged();
				return this;
			}

			@java.lang.Override
			public final Builder setUnknownFields(final UnknownFieldSet unknownFields) {
				return super.setUnknownFields(unknownFields);
			}

			@java.lang.Override
			public final Builder mergeUnknownFields(final UnknownFieldSet unknownFields) {
				return super.mergeUnknownFields(unknownFields);
			}

			// @@protoc_insertion_point(builder_scope:VersionInfo)
		}

		// @@protoc_insertion_point(class_scope:VersionInfo)
		private static final WvProto2.VersionInfo DEFAULT_INSTANCE;
		static {
			DEFAULT_INSTANCE = new WvProto2.VersionInfo();
		}

		public static WvProto2.VersionInfo getDefaultInstance() {
			return DEFAULT_INSTANCE;
		}

		@java.lang.Deprecated public static final Parser<VersionInfo> PARSER = new AbstractParser<>() {
			@java.lang.Override
			public VersionInfo parsePartialFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
					throws InvalidProtocolBufferException {
				Builder builder = newBuilder();
				try {
					builder.mergeFrom(input, extensionRegistry);
				} catch (InvalidProtocolBufferException e) {
					throw e.setUnfinishedMessage(builder.buildPartial());
				} catch (UninitializedMessageException e) {
					throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
				} catch (java.io.IOException e) {
					throw new InvalidProtocolBufferException(e).setUnfinishedMessage(builder.buildPartial());
				}
				return builder.buildPartial();
			}
		};

		public static Parser<VersionInfo> parser() {
			return PARSER;
		}

		@java.lang.Override
		public Parser<VersionInfo> getParserForType() {
			return PARSER;
		}

		@java.lang.Override
		public WvProto2.VersionInfo getDefaultInstanceForType() {
			return DEFAULT_INSTANCE;
		}

	}

	public interface SignedMessageOrBuilder extends
			// @@protoc_insertion_point(interface_extends:SignedMessage)
			MessageOrBuilder {

		/**
		 * <code>optional .SignedMessage.MessageType type = 1;</code>
		 * 
		 * @return Whether the type field is set.
		 */
		boolean hasType();

		/**
		 * <code>optional .SignedMessage.MessageType type = 1;</code>
		 * 
		 * @return The type.
		 */
		WvProto2.SignedMessage.MessageType getType();

		/**
		 * <code>optional bytes msg = 2;</code>
		 * 
		 * @return Whether the msg field is set.
		 */
		boolean hasMsg();

		/**
		 * <code>optional bytes msg = 2;</code>
		 * 
		 * @return The msg.
		 */
		ByteString getMsg();

		/**
		 * <pre>
		 * Required field that contains the signature of the bytes of msg.
		 * For license requests, the signing algorithm is determined by the
		 * certificate contained in the request.
		 * For license responses, the signing algorithm is HMAC with signing key based
		 * on |session_key|.
		 * </pre>
		 *
		 * <code>optional bytes signature = 3;</code>
		 * 
		 * @return Whether the signature field is set.
		 */
		boolean hasSignature();

		/**
		 * <pre>
		 * Required field that contains the signature of the bytes of msg.
		 * For license requests, the signing algorithm is determined by the
		 * certificate contained in the request.
		 * For license responses, the signing algorithm is HMAC with signing key based
		 * on |session_key|.
		 * </pre>
		 *
		 * <code>optional bytes signature = 3;</code>
		 * 
		 * @return The signature.
		 */
		ByteString getSignature();

		/**
		 * <pre>
		 * If populated, the contents of this field will be signaled by the
		 * |session_key_type| type. If the |session_key_type| is WRAPPED_AES_KEY the
		 * key is the bytes of an encrypted AES key. If the |session_key_type| is
		 * EPHERMERAL_ECC_PUBLIC_KEY the field contains the bytes of an RFC5208 ASN1
		 * serialized ECC public key.
		 * </pre>
		 *
		 * <code>optional bytes session_key = 4;</code>
		 * 
		 * @return Whether the sessionKey field is set.
		 */
		boolean hasSessionKey();

		/**
		 * <pre>
		 * If populated, the contents of this field will be signaled by the
		 * |session_key_type| type. If the |session_key_type| is WRAPPED_AES_KEY the
		 * key is the bytes of an encrypted AES key. If the |session_key_type| is
		 * EPHERMERAL_ECC_PUBLIC_KEY the field contains the bytes of an RFC5208 ASN1
		 * serialized ECC public key.
		 * </pre>
		 *
		 * <code>optional bytes session_key = 4;</code>
		 * 
		 * @return The sessionKey.
		 */
		ByteString getSessionKey();

		/**
		 * <pre>
		 * Remote attestation data which will be present in the initial license
		 * request for ChromeOS client devices operating in verified mode. Remote
		 * attestation challenge data is |msg| field above. Optional.
		 * </pre>
		 *
		 * <code>optional bytes remote_attestation = 5;</code>
		 * 
		 * @return Whether the remoteAttestation field is set.
		 */
		boolean hasRemoteAttestation();

		/**
		 * <pre>
		 * Remote attestation data which will be present in the initial license
		 * request for ChromeOS client devices operating in verified mode. Remote
		 * attestation challenge data is |msg| field above. Optional.
		 * </pre>
		 *
		 * <code>optional bytes remote_attestation = 5;</code>
		 * 
		 * @return The remoteAttestation.
		 */
		ByteString getRemoteAttestation();

		/**
		 * <code>repeated .MetricData metric_data = 6;</code>
		 */
		java.util.List<WvProto2.MetricData> getMetricDataList();

		/**
		 * <code>repeated .MetricData metric_data = 6;</code>
		 */
		WvProto2.MetricData getMetricData(int index);

		/**
		 * <code>repeated .MetricData metric_data = 6;</code>
		 */
		int getMetricDataCount();

		/**
		 * <code>repeated .MetricData metric_data = 6;</code>
		 */
		java.util.List<? extends WvProto2.MetricDataOrBuilder> getMetricDataOrBuilderList();

		/**
		 * <code>repeated .MetricData metric_data = 6;</code>
		 */
		WvProto2.MetricDataOrBuilder getMetricDataOrBuilder(int index);

		/**
		 * <pre>
		 * Version information from the SDK and license service. This information is
		 * provided in the license response.
		 * </pre>
		 *
		 * <code>optional .VersionInfo service_version_info = 7;</code>
		 * 
		 * @return Whether the serviceVersionInfo field is set.
		 */
		boolean hasServiceVersionInfo();

		/**
		 * <pre>
		 * Version information from the SDK and license service. This information is
		 * provided in the license response.
		 * </pre>
		 *
		 * <code>optional .VersionInfo service_version_info = 7;</code>
		 * 
		 * @return The serviceVersionInfo.
		 */
		WvProto2.VersionInfo getServiceVersionInfo();

		/**
		 * <pre>
		 * Version information from the SDK and license service. This information is
		 * provided in the license response.
		 * </pre>
		 *
		 * <code>optional .VersionInfo service_version_info = 7;</code>
		 */
		WvProto2.VersionInfoOrBuilder getServiceVersionInfoOrBuilder();

		/**
		 * <pre>
		 * Optional field that contains the algorithm type used to generate the
		 * session_key and signature in a LICENSE message.
		 * </pre>
		 *
		 * <code>optional .SignedMessage.SessionKeyType session_key_type = 8 [default = WRAPPED_AES_KEY];</code>
		 * 
		 * @return Whether the sessionKeyType field is set.
		 */
		boolean hasSessionKeyType();

		/**
		 * <pre>
		 * Optional field that contains the algorithm type used to generate the
		 * session_key and signature in a LICENSE message.
		 * </pre>
		 *
		 * <code>optional .SignedMessage.SessionKeyType session_key_type = 8 [default = WRAPPED_AES_KEY];</code>
		 * 
		 * @return The sessionKeyType.
		 */
		WvProto2.SignedMessage.SessionKeyType getSessionKeyType();

		/**
		 * <pre>
		 * The core message is the simple serialization of fields used by OEMCrypto.
		 * This field was introduced in OEMCrypto API v16.
		 * </pre>
		 *
		 * <code>optional bytes oemcrypto_core_message = 9;</code>
		 * 
		 * @return Whether the oemcryptoCoreMessage field is set.
		 */
		boolean hasOemcryptoCoreMessage();

		/**
		 * <pre>
		 * The core message is the simple serialization of fields used by OEMCrypto.
		 * This field was introduced in OEMCrypto API v16.
		 * </pre>
		 *
		 * <code>optional bytes oemcrypto_core_message = 9;</code>
		 * 
		 * @return The oemcryptoCoreMessage.
		 */
		ByteString getOemcryptoCoreMessage();
	}

	/**
	 * Protobuf type {@code SignedMessage}
	 */
	public static final class SignedMessage extends GeneratedMessageV3 implements
			// @@protoc_insertion_point(message_implements:SignedMessage)
			SignedMessageOrBuilder {
		private static final long serialVersionUID = 0L;

		// Use SignedMessage.newBuilder() to construct.
		private SignedMessage(GeneratedMessageV3.Builder<?> builder) {
			super(builder);
		}

		private SignedMessage() {
			type_ = 1;
			msg_ = ByteString.EMPTY;
			signature_ = ByteString.EMPTY;
			sessionKey_ = ByteString.EMPTY;
			remoteAttestation_ = ByteString.EMPTY;
			metricData_ = java.util.Collections.emptyList();
			sessionKeyType_ = 1;
			oemcryptoCoreMessage_ = ByteString.EMPTY;
		}

		@java.lang.Override

		protected java.lang.Object newInstance(UnusedPrivateParameter unused) {
			return new SignedMessage();
		}

		public static final Descriptors.Descriptor getDescriptor() {
			return WvProto2.internal_static_SignedMessage_descriptor;
		}

		@java.lang.Override
		protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
			return WvProto2.internal_static_SignedMessage_fieldAccessorTable
					.ensureFieldAccessorsInitialized(WvProto2.SignedMessage.class,
							WvProto2.SignedMessage.Builder.class);
		}

		/**
		 * Protobuf enum {@code SignedMessage.MessageType}
		 */
		public enum MessageType implements ProtocolMessageEnum {
			/**
			 * <code>LICENSE_REQUEST = 1;</code>
			 */
			LICENSE_REQUEST(1),
			/**
			 * <code>LICENSE = 2;</code>
			 */
			LICENSE(2),
			/**
			 * <code>ERROR_RESPONSE = 3;</code>
			 */
			ERROR_RESPONSE(3),
			/**
			 * <code>SERVICE_CERTIFICATE_REQUEST = 4;</code>
			 */
			SERVICE_CERTIFICATE_REQUEST(4),
			/**
			 * <code>SERVICE_CERTIFICATE = 5;</code>
			 */
			SERVICE_CERTIFICATE(5),
			/**
			 * <code>SUB_LICENSE = 6;</code>
			 */
			SUB_LICENSE(6),
			/**
			 * <code>CAS_LICENSE_REQUEST = 7;</code>
			 */
			CAS_LICENSE_REQUEST(7),
			/**
			 * <code>CAS_LICENSE = 8;</code>
			 */
			CAS_LICENSE(8),
			/**
			 * <code>EXTERNAL_LICENSE_REQUEST = 9;</code>
			 */
			EXTERNAL_LICENSE_REQUEST(9),
			/**
			 * <code>EXTERNAL_LICENSE = 10;</code>
			 */
			EXTERNAL_LICENSE(10),;

			/**
			 * <code>LICENSE_REQUEST = 1;</code>
			 */
			public static final int LICENSE_REQUEST_VALUE = 1;
			/**
			 * <code>LICENSE = 2;</code>
			 */
			public static final int LICENSE_VALUE = 2;
			/**
			 * <code>ERROR_RESPONSE = 3;</code>
			 */
			public static final int ERROR_RESPONSE_VALUE = 3;
			/**
			 * <code>SERVICE_CERTIFICATE_REQUEST = 4;</code>
			 */
			public static final int SERVICE_CERTIFICATE_REQUEST_VALUE = 4;
			/**
			 * <code>SERVICE_CERTIFICATE = 5;</code>
			 */
			public static final int SERVICE_CERTIFICATE_VALUE = 5;
			/**
			 * <code>SUB_LICENSE = 6;</code>
			 */
			public static final int SUB_LICENSE_VALUE = 6;
			/**
			 * <code>CAS_LICENSE_REQUEST = 7;</code>
			 */
			public static final int CAS_LICENSE_REQUEST_VALUE = 7;
			/**
			 * <code>CAS_LICENSE = 8;</code>
			 */
			public static final int CAS_LICENSE_VALUE = 8;
			/**
			 * <code>EXTERNAL_LICENSE_REQUEST = 9;</code>
			 */
			public static final int EXTERNAL_LICENSE_REQUEST_VALUE = 9;
			/**
			 * <code>EXTERNAL_LICENSE = 10;</code>
			 */
			public static final int EXTERNAL_LICENSE_VALUE = 10;

			@Override
			public final int getNumber() {
				return value;
			}

			/**
			 * @param value The numeric wire value of the corresponding enum entry.
			 * @return The enum associated with the given numeric wire value.
			 * @deprecated Use {@link #forNumber(int)} instead.
			 */
			@java.lang.Deprecated
			public static MessageType valueOf(int value) {
				return forNumber(value);
			}

			/**
			 * @param value The numeric wire value of the corresponding enum entry.
			 * @return The enum associated with the given numeric wire value.
			 */
			public static MessageType forNumber(int value) {
				switch (value) {
				case 1:
					return LICENSE_REQUEST;
				case 2:
					return LICENSE;
				case 3:
					return ERROR_RESPONSE;
				case 4:
					return SERVICE_CERTIFICATE_REQUEST;
				case 5:
					return SERVICE_CERTIFICATE;
				case 6:
					return SUB_LICENSE;
				case 7:
					return CAS_LICENSE_REQUEST;
				case 8:
					return CAS_LICENSE;
				case 9:
					return EXTERNAL_LICENSE_REQUEST;
				case 10:
					return EXTERNAL_LICENSE;
				default:
					return null;
				}
			}

			public static Internal.EnumLiteMap<MessageType> internalGetValueMap() {
				return internalValueMap;
			}

			private static final Internal.EnumLiteMap<MessageType> internalValueMap = new Internal.EnumLiteMap<>() {
				@Override
				public MessageType findValueByNumber(int number) {
					return MessageType.forNumber(number);
				}
			};

			@Override
			public final Descriptors.EnumValueDescriptor getValueDescriptor() {
				return getDescriptor().getValues().get(ordinal());
			}

			@Override
			public final Descriptors.EnumDescriptor getDescriptorForType() {
				return getDescriptor();
			}

			public static final Descriptors.EnumDescriptor getDescriptor() {
				return WvProto2.SignedMessage.getDescriptor().getEnumTypes().get(0);
			}

			private static final MessageType[] VALUES = values();

			public static MessageType valueOf(Descriptors.EnumValueDescriptor desc) {
				if (desc.getType() != getDescriptor()) {
					throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
				}
				return VALUES[desc.getIndex()];
			}

			private final int value;

			private MessageType(int value) {
				this.value = value;
			}

			// @@protoc_insertion_point(enum_scope:SignedMessage.MessageType)
		}

		/**
		 * Protobuf enum {@code SignedMessage.SessionKeyType}
		 */
		public enum SessionKeyType implements ProtocolMessageEnum {
			/**
			 * <code>UNDEFINED = 0;</code>
			 */
			UNDEFINED(0),
			/**
			 * <code>WRAPPED_AES_KEY = 1;</code>
			 */
			WRAPPED_AES_KEY(1),
			/**
			 * <code>EPHERMERAL_ECC_PUBLIC_KEY = 2;</code>
			 */
			EPHERMERAL_ECC_PUBLIC_KEY(2),;

			/**
			 * <code>UNDEFINED = 0;</code>
			 */
			public static final int UNDEFINED_VALUE = 0;
			/**
			 * <code>WRAPPED_AES_KEY = 1;</code>
			 */
			public static final int WRAPPED_AES_KEY_VALUE = 1;
			/**
			 * <code>EPHERMERAL_ECC_PUBLIC_KEY = 2;</code>
			 */
			public static final int EPHERMERAL_ECC_PUBLIC_KEY_VALUE = 2;

			@Override
			public final int getNumber() {
				return value;
			}

			/**
			 * @param value The numeric wire value of the corresponding enum entry.
			 * @return The enum associated with the given numeric wire value.
			 * @deprecated Use {@link #forNumber(int)} instead.
			 */
			@java.lang.Deprecated
			public static SessionKeyType valueOf(int value) {
				return forNumber(value);
			}

			/**
			 * @param value The numeric wire value of the corresponding enum entry.
			 * @return The enum associated with the given numeric wire value.
			 */
			public static SessionKeyType forNumber(int value) {
				switch (value) {
				case 0:
					return UNDEFINED;
				case 1:
					return WRAPPED_AES_KEY;
				case 2:
					return EPHERMERAL_ECC_PUBLIC_KEY;
				default:
					return null;
				}
			}

			public static Internal.EnumLiteMap<SessionKeyType> internalGetValueMap() {
				return internalValueMap;
			}

			private static final Internal.EnumLiteMap<SessionKeyType> internalValueMap = new Internal.EnumLiteMap<>() {
				@Override
				public SessionKeyType findValueByNumber(int number) {
					return SessionKeyType.forNumber(number);
				}
			};

			@Override
			public final Descriptors.EnumValueDescriptor getValueDescriptor() {
				return getDescriptor().getValues().get(ordinal());
			}

			@Override
			public final Descriptors.EnumDescriptor getDescriptorForType() {
				return getDescriptor();
			}

			public static final Descriptors.EnumDescriptor getDescriptor() {
				return WvProto2.SignedMessage.getDescriptor().getEnumTypes().get(1);
			}

			private static final SessionKeyType[] VALUES = values();

			public static SessionKeyType valueOf(Descriptors.EnumValueDescriptor desc) {
				if (desc.getType() != getDescriptor()) {
					throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
				}
				return VALUES[desc.getIndex()];
			}

			private final int value;

			private SessionKeyType(int value) {
				this.value = value;
			}

			// @@protoc_insertion_point(enum_scope:SignedMessage.SessionKeyType)
		}

		private int bitField0_;
		public static final int TYPE_FIELD_NUMBER = 1;
		private int type_ = 1;

		/**
		 * <code>optional .SignedMessage.MessageType type = 1;</code>
		 * 
		 * @return Whether the type field is set.
		 */
		@java.lang.Override
		public boolean hasType() {
			return ((bitField0_ & 0x00000001) != 0);
		}

		/**
		 * <code>optional .SignedMessage.MessageType type = 1;</code>
		 * 
		 * @return The type.
		 */
		@java.lang.Override
		public WvProto2.SignedMessage.MessageType getType() {
			WvProto2.SignedMessage.MessageType result = WvProto2.SignedMessage.MessageType
					.forNumber(type_);
			return result == null ? WvProto2.SignedMessage.MessageType.LICENSE_REQUEST : result;
		}

		public static final int MSG_FIELD_NUMBER = 2;
		private ByteString msg_ = ByteString.EMPTY;

		/**
		 * <code>optional bytes msg = 2;</code>
		 * 
		 * @return Whether the msg field is set.
		 */
		@java.lang.Override
		public boolean hasMsg() {
			return ((bitField0_ & 0x00000002) != 0);
		}

		/**
		 * <code>optional bytes msg = 2;</code>
		 * 
		 * @return The msg.
		 */
		@java.lang.Override
		public ByteString getMsg() {
			return msg_;
		}

		public static final int SIGNATURE_FIELD_NUMBER = 3;
		private ByteString signature_ = ByteString.EMPTY;

		/**
		 * <pre>
		 * Required field that contains the signature of the bytes of msg.
		 * For license requests, the signing algorithm is determined by the
		 * certificate contained in the request.
		 * For license responses, the signing algorithm is HMAC with signing key based
		 * on |session_key|.
		 * </pre>
		 *
		 * <code>optional bytes signature = 3;</code>
		 * 
		 * @return Whether the signature field is set.
		 */
		@java.lang.Override
		public boolean hasSignature() {
			return ((bitField0_ & 0x00000004) != 0);
		}

		/**
		 * <pre>
		 * Required field that contains the signature of the bytes of msg.
		 * For license requests, the signing algorithm is determined by the
		 * certificate contained in the request.
		 * For license responses, the signing algorithm is HMAC with signing key based
		 * on |session_key|.
		 * </pre>
		 *
		 * <code>optional bytes signature = 3;</code>
		 * 
		 * @return The signature.
		 */
		@java.lang.Override
		public ByteString getSignature() {
			return signature_;
		}

		public static final int SESSION_KEY_FIELD_NUMBER = 4;
		private ByteString sessionKey_ = ByteString.EMPTY;

		/**
		 * <pre>
		 * If populated, the contents of this field will be signaled by the
		 * |session_key_type| type. If the |session_key_type| is WRAPPED_AES_KEY the
		 * key is the bytes of an encrypted AES key. If the |session_key_type| is
		 * EPHERMERAL_ECC_PUBLIC_KEY the field contains the bytes of an RFC5208 ASN1
		 * serialized ECC public key.
		 * </pre>
		 *
		 * <code>optional bytes session_key = 4;</code>
		 * 
		 * @return Whether the sessionKey field is set.
		 */
		@java.lang.Override
		public boolean hasSessionKey() {
			return ((bitField0_ & 0x00000008) != 0);
		}

		/**
		 * <pre>
		 * If populated, the contents of this field will be signaled by the
		 * |session_key_type| type. If the |session_key_type| is WRAPPED_AES_KEY the
		 * key is the bytes of an encrypted AES key. If the |session_key_type| is
		 * EPHERMERAL_ECC_PUBLIC_KEY the field contains the bytes of an RFC5208 ASN1
		 * serialized ECC public key.
		 * </pre>
		 *
		 * <code>optional bytes session_key = 4;</code>
		 * 
		 * @return The sessionKey.
		 */
		@java.lang.Override
		public ByteString getSessionKey() {
			return sessionKey_;
		}

		public static final int REMOTE_ATTESTATION_FIELD_NUMBER = 5;
		private ByteString remoteAttestation_ = ByteString.EMPTY;

		/**
		 * <pre>
		 * Remote attestation data which will be present in the initial license
		 * request for ChromeOS client devices operating in verified mode. Remote
		 * attestation challenge data is |msg| field above. Optional.
		 * </pre>
		 *
		 * <code>optional bytes remote_attestation = 5;</code>
		 * 
		 * @return Whether the remoteAttestation field is set.
		 */
		@java.lang.Override
		public boolean hasRemoteAttestation() {
			return ((bitField0_ & 0x00000010) != 0);
		}

		/**
		 * <pre>
		 * Remote attestation data which will be present in the initial license
		 * request for ChromeOS client devices operating in verified mode. Remote
		 * attestation challenge data is |msg| field above. Optional.
		 * </pre>
		 *
		 * <code>optional bytes remote_attestation = 5;</code>
		 * 
		 * @return The remoteAttestation.
		 */
		@java.lang.Override
		public ByteString getRemoteAttestation() {
			return remoteAttestation_;
		}

		public static final int METRIC_DATA_FIELD_NUMBER = 6;

		private java.util.List<WvProto2.MetricData> metricData_;

		/**
		 * <code>repeated .MetricData metric_data = 6;</code>
		 */
		@java.lang.Override
		public java.util.List<WvProto2.MetricData> getMetricDataList() {
			return metricData_;
		}

		/**
		 * <code>repeated .MetricData metric_data = 6;</code>
		 */
		@java.lang.Override
		public java.util.List<? extends WvProto2.MetricDataOrBuilder> getMetricDataOrBuilderList() {
			return metricData_;
		}

		/**
		 * <code>repeated .MetricData metric_data = 6;</code>
		 */
		@java.lang.Override
		public int getMetricDataCount() {
			return metricData_.size();
		}

		/**
		 * <code>repeated .MetricData metric_data = 6;</code>
		 */
		@java.lang.Override
		public WvProto2.MetricData getMetricData(int index) {
			return metricData_.get(index);
		}

		/**
		 * <code>repeated .MetricData metric_data = 6;</code>
		 */
		@java.lang.Override
		public WvProto2.MetricDataOrBuilder getMetricDataOrBuilder(int index) {
			return metricData_.get(index);
		}

		public static final int SERVICE_VERSION_INFO_FIELD_NUMBER = 7;
		private WvProto2.VersionInfo serviceVersionInfo_;

		/**
		 * <pre>
		 * Version information from the SDK and license service. This information is
		 * provided in the license response.
		 * </pre>
		 *
		 * <code>optional .VersionInfo service_version_info = 7;</code>
		 * 
		 * @return Whether the serviceVersionInfo field is set.
		 */
		@java.lang.Override
		public boolean hasServiceVersionInfo() {
			return ((bitField0_ & 0x00000020) != 0);
		}

		/**
		 * <pre>
		 * Version information from the SDK and license service. This information is
		 * provided in the license response.
		 * </pre>
		 *
		 * <code>optional .VersionInfo service_version_info = 7;</code>
		 * 
		 * @return The serviceVersionInfo.
		 */
		@java.lang.Override
		public WvProto2.VersionInfo getServiceVersionInfo() {
			return serviceVersionInfo_ == null ? WvProto2.VersionInfo.getDefaultInstance()
					: serviceVersionInfo_;
		}

		/**
		 * <pre>
		 * Version information from the SDK and license service. This information is
		 * provided in the license response.
		 * </pre>
		 *
		 * <code>optional .VersionInfo service_version_info = 7;</code>
		 */
		@java.lang.Override
		public WvProto2.VersionInfoOrBuilder getServiceVersionInfoOrBuilder() {
			return serviceVersionInfo_ == null ? WvProto2.VersionInfo.getDefaultInstance()
					: serviceVersionInfo_;
		}

		public static final int SESSION_KEY_TYPE_FIELD_NUMBER = 8;
		private int sessionKeyType_ = 1;

		/**
		 * <pre>
		 * Optional field that contains the algorithm type used to generate the
		 * session_key and signature in a LICENSE message.
		 * </pre>
		 *
		 * <code>optional .SignedMessage.SessionKeyType session_key_type = 8 [default = WRAPPED_AES_KEY];</code>
		 * 
		 * @return Whether the sessionKeyType field is set.
		 */
		@java.lang.Override
		public boolean hasSessionKeyType() {
			return ((bitField0_ & 0x00000040) != 0);
		}

		/**
		 * <pre>
		 * Optional field that contains the algorithm type used to generate the
		 * session_key and signature in a LICENSE message.
		 * </pre>
		 *
		 * <code>optional .SignedMessage.SessionKeyType session_key_type = 8 [default = WRAPPED_AES_KEY];</code>
		 * 
		 * @return The sessionKeyType.
		 */
		@java.lang.Override
		public WvProto2.SignedMessage.SessionKeyType getSessionKeyType() {
			WvProto2.SignedMessage.SessionKeyType result = WvProto2.SignedMessage.SessionKeyType
					.forNumber(sessionKeyType_);
			return result == null ? WvProto2.SignedMessage.SessionKeyType.WRAPPED_AES_KEY
					: result;
		}

		public static final int OEMCRYPTO_CORE_MESSAGE_FIELD_NUMBER = 9;
		private ByteString oemcryptoCoreMessage_ = ByteString.EMPTY;

		/**
		 * <pre>
		 * The core message is the simple serialization of fields used by OEMCrypto.
		 * This field was introduced in OEMCrypto API v16.
		 * </pre>
		 *
		 * <code>optional bytes oemcrypto_core_message = 9;</code>
		 * 
		 * @return Whether the oemcryptoCoreMessage field is set.
		 */
		@java.lang.Override
		public boolean hasOemcryptoCoreMessage() {
			return ((bitField0_ & 0x00000080) != 0);
		}

		/**
		 * <pre>
		 * The core message is the simple serialization of fields used by OEMCrypto.
		 * This field was introduced in OEMCrypto API v16.
		 * </pre>
		 *
		 * <code>optional bytes oemcrypto_core_message = 9;</code>
		 * 
		 * @return The oemcryptoCoreMessage.
		 */
		@java.lang.Override
		public ByteString getOemcryptoCoreMessage() {
			return oemcryptoCoreMessage_;
		}

		private byte memoizedIsInitialized = -1;

		@java.lang.Override
		public final boolean isInitialized() {
			byte isInitialized = memoizedIsInitialized;
			if (isInitialized == 1)
				return true;
			if (isInitialized == 0)
				return false;

			memoizedIsInitialized = 1;
			return true;
		}

		@java.lang.Override
		public void writeTo(CodedOutputStream output) throws java.io.IOException {
			if (((bitField0_ & 0x00000001) != 0)) {
				output.writeEnum(1, type_);
			}
			if (((bitField0_ & 0x00000002) != 0)) {
				output.writeBytes(2, msg_);
			}
			if (((bitField0_ & 0x00000004) != 0)) {
				output.writeBytes(3, signature_);
			}
			if (((bitField0_ & 0x00000008) != 0)) {
				output.writeBytes(4, sessionKey_);
			}
			if (((bitField0_ & 0x00000010) != 0)) {
				output.writeBytes(5, remoteAttestation_);
			}
			for (int i = 0; i < metricData_.size(); i++) {
				output.writeMessage(6, metricData_.get(i));
			}
			if (((bitField0_ & 0x00000020) != 0)) {
				output.writeMessage(7, getServiceVersionInfo());
			}
			if (((bitField0_ & 0x00000040) != 0)) {
				output.writeEnum(8, sessionKeyType_);
			}
			if (((bitField0_ & 0x00000080) != 0)) {
				output.writeBytes(9, oemcryptoCoreMessage_);
			}
			getUnknownFields().writeTo(output);
		}

		@java.lang.Override
		public int getSerializedSize() {
			int size = memoizedSize;
			if (size != -1)
				return size;

			size = 0;
			if (((bitField0_ & 0x00000001) != 0)) {
				size += CodedOutputStream.computeEnumSize(1, type_);
			}
			if (((bitField0_ & 0x00000002) != 0)) {
				size += CodedOutputStream.computeBytesSize(2, msg_);
			}
			if (((bitField0_ & 0x00000004) != 0)) {
				size += CodedOutputStream.computeBytesSize(3, signature_);
			}
			if (((bitField0_ & 0x00000008) != 0)) {
				size += CodedOutputStream.computeBytesSize(4, sessionKey_);
			}
			if (((bitField0_ & 0x00000010) != 0)) {
				size += CodedOutputStream.computeBytesSize(5, remoteAttestation_);
			}
			for (int i = 0; i < metricData_.size(); i++) {
				size += CodedOutputStream.computeMessageSize(6, metricData_.get(i));
			}
			if (((bitField0_ & 0x00000020) != 0)) {
				size += CodedOutputStream.computeMessageSize(7, getServiceVersionInfo());
			}
			if (((bitField0_ & 0x00000040) != 0)) {
				size += CodedOutputStream.computeEnumSize(8, sessionKeyType_);
			}
			if (((bitField0_ & 0x00000080) != 0)) {
				size += CodedOutputStream.computeBytesSize(9, oemcryptoCoreMessage_);
			}
			size += getUnknownFields().getSerializedSize();
			memoizedSize = size;
			return size;
		}

		@java.lang.Override
		public boolean equals(final java.lang.Object obj) {
			if (obj == this) {
				return true;
			}
			if (!(obj instanceof WvProto2.SignedMessage)) {
				return super.equals(obj);
			}
			WvProto2.SignedMessage other = (WvProto2.SignedMessage) obj;

			if (hasType() != other.hasType())
				return false;
			if (hasType()) {
				if (type_ != other.type_)
					return false;
			}
			if (hasMsg() != other.hasMsg())
				return false;
			if (hasMsg()) {
				if (!getMsg().equals(other.getMsg()))
					return false;
			}
			if (hasSignature() != other.hasSignature())
				return false;
			if (hasSignature()) {
				if (!getSignature().equals(other.getSignature()))
					return false;
			}
			if (hasSessionKey() != other.hasSessionKey())
				return false;
			if (hasSessionKey()) {
				if (!getSessionKey().equals(other.getSessionKey()))
					return false;
			}
			if (hasRemoteAttestation() != other.hasRemoteAttestation())
				return false;
			if (hasRemoteAttestation()) {
				if (!getRemoteAttestation().equals(other.getRemoteAttestation()))
					return false;
			}
			if (!getMetricDataList().equals(other.getMetricDataList()))
				return false;
			if (hasServiceVersionInfo() != other.hasServiceVersionInfo())
				return false;
			if (hasServiceVersionInfo()) {
				if (!getServiceVersionInfo().equals(other.getServiceVersionInfo()))
					return false;
			}
			if (hasSessionKeyType() != other.hasSessionKeyType())
				return false;
			if (hasSessionKeyType()) {
				if (sessionKeyType_ != other.sessionKeyType_)
					return false;
			}
			if (hasOemcryptoCoreMessage() != other.hasOemcryptoCoreMessage())
				return false;
			if (hasOemcryptoCoreMessage()) {
				if (!getOemcryptoCoreMessage().equals(other.getOemcryptoCoreMessage()))
					return false;
			}
			if (!getUnknownFields().equals(other.getUnknownFields()))
				return false;
			return true;
		}

		@SuppressWarnings("unchecked")
		@java.lang.Override
		public int hashCode() {
			if (memoizedHashCode != 0) {
				return memoizedHashCode;
			}
			int hash = 41;
			hash = (19 * hash) + getDescriptor().hashCode();
			if (hasType()) {
				hash = (37 * hash) + TYPE_FIELD_NUMBER;
				hash = (53 * hash) + type_;
			}
			if (hasMsg()) {
				hash = (37 * hash) + MSG_FIELD_NUMBER;
				hash = (53 * hash) + getMsg().hashCode();
			}
			if (hasSignature()) {
				hash = (37 * hash) + SIGNATURE_FIELD_NUMBER;
				hash = (53 * hash) + getSignature().hashCode();
			}
			if (hasSessionKey()) {
				hash = (37 * hash) + SESSION_KEY_FIELD_NUMBER;
				hash = (53 * hash) + getSessionKey().hashCode();
			}
			if (hasRemoteAttestation()) {
				hash = (37 * hash) + REMOTE_ATTESTATION_FIELD_NUMBER;
				hash = (53 * hash) + getRemoteAttestation().hashCode();
			}
			if (getMetricDataCount() > 0) {
				hash = (37 * hash) + METRIC_DATA_FIELD_NUMBER;
				hash = (53 * hash) + getMetricDataList().hashCode();
			}
			if (hasServiceVersionInfo()) {
				hash = (37 * hash) + SERVICE_VERSION_INFO_FIELD_NUMBER;
				hash = (53 * hash) + getServiceVersionInfo().hashCode();
			}
			if (hasSessionKeyType()) {
				hash = (37 * hash) + SESSION_KEY_TYPE_FIELD_NUMBER;
				hash = (53 * hash) + sessionKeyType_;
			}
			if (hasOemcryptoCoreMessage()) {
				hash = (37 * hash) + OEMCRYPTO_CORE_MESSAGE_FIELD_NUMBER;
				hash = (53 * hash) + getOemcryptoCoreMessage().hashCode();
			}
			hash = (29 * hash) + getUnknownFields().hashCode();
			memoizedHashCode = hash;
			return hash;
		}

		public static WvProto2.SignedMessage parseFrom(java.nio.ByteBuffer data)
				throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data);
		}

		public static WvProto2.SignedMessage parseFrom(java.nio.ByteBuffer data,
				ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data, extensionRegistry);
		}

		public static WvProto2.SignedMessage parseFrom(ByteString data)
				throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data);
		}

		public static WvProto2.SignedMessage parseFrom(ByteString data,
				ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data, extensionRegistry);
		}

		public static WvProto2.SignedMessage parseFrom(byte[] data)
				throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data);
		}

		public static WvProto2.SignedMessage parseFrom(byte[] data,
				ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data, extensionRegistry);
		}

		public static WvProto2.SignedMessage parseFrom(java.io.InputStream input)
				throws java.io.IOException {
			return GeneratedMessageV3.parseWithIOException(PARSER, input);
		}

		public static WvProto2.SignedMessage parseFrom(java.io.InputStream input,
				ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
			return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
		}

		public static WvProto2.SignedMessage parseDelimitedFrom(java.io.InputStream input)
				throws java.io.IOException {
			return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
		}

		public static WvProto2.SignedMessage parseDelimitedFrom(java.io.InputStream input,
				ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
			return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input, extensionRegistry);
		}

		public static WvProto2.SignedMessage parseFrom(CodedInputStream input)
				throws java.io.IOException {
			return GeneratedMessageV3.parseWithIOException(PARSER, input);
		}

		public static WvProto2.SignedMessage parseFrom(CodedInputStream input,
				ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
			return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
		}

		@java.lang.Override
		public Builder newBuilderForType() {
			return newBuilder();
		}

		public static Builder newBuilder() {
			return DEFAULT_INSTANCE.toBuilder();
		}

		public static Builder newBuilder(WvProto2.SignedMessage prototype) {
			return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
		}

		@java.lang.Override
		public Builder toBuilder() {
			return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
		}

		@java.lang.Override
		protected Builder newBuilderForType(GeneratedMessageV3.BuilderParent parent) {
			Builder builder = new Builder(parent);
			return builder;
		}

		/**
		 * Protobuf type {@code SignedMessage}
		 */
		public static final class Builder extends GeneratedMessageV3.Builder<Builder> implements
				// @@protoc_insertion_point(builder_implements:SignedMessage)
				WvProto2.SignedMessageOrBuilder {
			public static final Descriptors.Descriptor getDescriptor() {
				return WvProto2.internal_static_SignedMessage_descriptor;
			}

			@java.lang.Override
			protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
				return WvProto2.internal_static_SignedMessage_fieldAccessorTable
						.ensureFieldAccessorsInitialized(WvProto2.SignedMessage.class,
								WvProto2.SignedMessage.Builder.class);
			}

			// Construct using WvProto2.SignedMessage.newBuilder()
			private Builder() {
				maybeForceBuilderInitialization();
			}

			private Builder(GeneratedMessageV3.BuilderParent parent) {
				super(parent);
				maybeForceBuilderInitialization();
			}

			private void maybeForceBuilderInitialization() {
				if (GeneratedMessageV3.alwaysUseFieldBuilders) {
					getMetricDataFieldBuilder();
					getServiceVersionInfoFieldBuilder();
				}
			}

			@java.lang.Override
			public Builder clear() {
				super.clear();
				bitField0_ = 0;
				type_ = 1;
				msg_ = ByteString.EMPTY;
				signature_ = ByteString.EMPTY;
				sessionKey_ = ByteString.EMPTY;
				remoteAttestation_ = ByteString.EMPTY;
				if (metricDataBuilder_ == null) {
					metricData_ = java.util.Collections.emptyList();
				} else {
					metricData_ = null;
					metricDataBuilder_.clear();
				}
				bitField0_ = (bitField0_ & ~0x00000020);
				serviceVersionInfo_ = null;
				if (serviceVersionInfoBuilder_ != null) {
					serviceVersionInfoBuilder_.dispose();
					serviceVersionInfoBuilder_ = null;
				}
				sessionKeyType_ = 1;
				oemcryptoCoreMessage_ = ByteString.EMPTY;
				return this;
			}

			@java.lang.Override
			public Descriptors.Descriptor getDescriptorForType() {
				return WvProto2.internal_static_SignedMessage_descriptor;
			}

			@java.lang.Override
			public WvProto2.SignedMessage getDefaultInstanceForType() {
				return WvProto2.SignedMessage.getDefaultInstance();
			}

			@java.lang.Override
			public WvProto2.SignedMessage build() {
				WvProto2.SignedMessage result = buildPartial();
				if (!result.isInitialized()) {
					throw newUninitializedMessageException(result);
				}
				return result;
			}

			@java.lang.Override
			public WvProto2.SignedMessage buildPartial() {
				WvProto2.SignedMessage result = new WvProto2.SignedMessage(
						this);
				buildPartialRepeatedFields(result);
				if (bitField0_ != 0) {
					buildPartial0(result);
				}
				onBuilt();
				return result;
			}

			private void buildPartialRepeatedFields(WvProto2.SignedMessage result) {
				if (metricDataBuilder_ == null) {
					if (((bitField0_ & 0x00000020) != 0)) {
						metricData_ = java.util.Collections.unmodifiableList(metricData_);
						bitField0_ = (bitField0_ & ~0x00000020);
					}
					result.metricData_ = metricData_;
				} else {
					result.metricData_ = metricDataBuilder_.build();
				}
			}

			private void buildPartial0(WvProto2.SignedMessage result) {
				int from_bitField0_ = bitField0_;
				int to_bitField0_ = 0;
				if (((from_bitField0_ & 0x00000001) != 0)) {
					result.type_ = type_;
					to_bitField0_ |= 0x00000001;
				}
				if (((from_bitField0_ & 0x00000002) != 0)) {
					result.msg_ = msg_;
					to_bitField0_ |= 0x00000002;
				}
				if (((from_bitField0_ & 0x00000004) != 0)) {
					result.signature_ = signature_;
					to_bitField0_ |= 0x00000004;
				}
				if (((from_bitField0_ & 0x00000008) != 0)) {
					result.sessionKey_ = sessionKey_;
					to_bitField0_ |= 0x00000008;
				}
				if (((from_bitField0_ & 0x00000010) != 0)) {
					result.remoteAttestation_ = remoteAttestation_;
					to_bitField0_ |= 0x00000010;
				}
				if (((from_bitField0_ & 0x00000040) != 0)) {
					result.serviceVersionInfo_ = serviceVersionInfoBuilder_ == null ? serviceVersionInfo_
							: serviceVersionInfoBuilder_.build();
					to_bitField0_ |= 0x00000020;
				}
				if (((from_bitField0_ & 0x00000080) != 0)) {
					result.sessionKeyType_ = sessionKeyType_;
					to_bitField0_ |= 0x00000040;
				}
				if (((from_bitField0_ & 0x00000100) != 0)) {
					result.oemcryptoCoreMessage_ = oemcryptoCoreMessage_;
					to_bitField0_ |= 0x00000080;
				}
				result.bitField0_ |= to_bitField0_;
			}

			@java.lang.Override
			public Builder mergeFrom(Message other) {
				if (other instanceof WvProto2.SignedMessage) {
					return mergeFrom((WvProto2.SignedMessage) other);
				}
				super.mergeFrom(other);
				return this;
			}

			public Builder mergeFrom(WvProto2.SignedMessage other) {
				if (other == WvProto2.SignedMessage.getDefaultInstance())
					return this;
				if (other.hasType()) {
					setType(other.getType());
				}
				if (other.hasMsg()) {
					setMsg(other.getMsg());
				}
				if (other.hasSignature()) {
					setSignature(other.getSignature());
				}
				if (other.hasSessionKey()) {
					setSessionKey(other.getSessionKey());
				}
				if (other.hasRemoteAttestation()) {
					setRemoteAttestation(other.getRemoteAttestation());
				}
				if (metricDataBuilder_ == null) {
					if (!other.metricData_.isEmpty()) {
						if (metricData_.isEmpty()) {
							metricData_ = other.metricData_;
							bitField0_ = (bitField0_ & ~0x00000020);
						} else {
							ensureMetricDataIsMutable();
							metricData_.addAll(other.metricData_);
						}
						onChanged();
					}
				} else {
					if (!other.metricData_.isEmpty()) {
						if (metricDataBuilder_.isEmpty()) {
							metricDataBuilder_.dispose();
							metricDataBuilder_ = null;
							metricData_ = other.metricData_;
							bitField0_ = (bitField0_ & ~0x00000020);
							metricDataBuilder_ = GeneratedMessageV3.alwaysUseFieldBuilders ? getMetricDataFieldBuilder()
									: null;
						} else {
							metricDataBuilder_.addAllMessages(other.metricData_);
						}
					}
				}
				if (other.hasServiceVersionInfo()) {
					mergeServiceVersionInfo(other.getServiceVersionInfo());
				}
				if (other.hasSessionKeyType()) {
					setSessionKeyType(other.getSessionKeyType());
				}
				if (other.hasOemcryptoCoreMessage()) {
					setOemcryptoCoreMessage(other.getOemcryptoCoreMessage());
				}
				this.mergeUnknownFields(other.getUnknownFields());
				onChanged();
				return this;
			}

			@java.lang.Override
			public final boolean isInitialized() {
				return true;
			}

			@java.lang.Override
			public Builder mergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
					throws java.io.IOException {
				if (extensionRegistry == null) {
					throw new java.lang.NullPointerException();
				}
				try {
					boolean done = false;
					while (!done) {
						int tag = input.readTag();
						switch (tag) {
						case 0:
							done = true;
							break;
						case 8: {
							int tmpRaw = input.readEnum();
							WvProto2.SignedMessage.MessageType tmpValue = WvProto2.SignedMessage.MessageType
									.forNumber(tmpRaw);
							if (tmpValue == null) {
								mergeUnknownVarintField(1, tmpRaw);
							} else {
								type_ = tmpRaw;
								bitField0_ |= 0x00000001;
							}
							break;
						} // case 8
						case 18: {
							msg_ = input.readBytes();
							bitField0_ |= 0x00000002;
							break;
						} // case 18
						case 26: {
							signature_ = input.readBytes();
							bitField0_ |= 0x00000004;
							break;
						} // case 26
						case 34: {
							sessionKey_ = input.readBytes();
							bitField0_ |= 0x00000008;
							break;
						} // case 34
						case 42: {
							remoteAttestation_ = input.readBytes();
							bitField0_ |= 0x00000010;
							break;
						} // case 42
						case 50: {
							WvProto2.MetricData m = input
									.readMessage(WvProto2.MetricData.PARSER, extensionRegistry);
							if (metricDataBuilder_ == null) {
								ensureMetricDataIsMutable();
								metricData_.add(m);
							} else {
								metricDataBuilder_.addMessage(m);
							}
							break;
						} // case 50
						case 58: {
							input.readMessage(getServiceVersionInfoFieldBuilder().getBuilder(), extensionRegistry);
							bitField0_ |= 0x00000040;
							break;
						} // case 58
						case 64: {
							int tmpRaw = input.readEnum();
							WvProto2.SignedMessage.SessionKeyType tmpValue = WvProto2.SignedMessage.SessionKeyType
									.forNumber(tmpRaw);
							if (tmpValue == null) {
								mergeUnknownVarintField(8, tmpRaw);
							} else {
								sessionKeyType_ = tmpRaw;
								bitField0_ |= 0x00000080;
							}
							break;
						} // case 64
						case 74: {
							oemcryptoCoreMessage_ = input.readBytes();
							bitField0_ |= 0x00000100;
							break;
						} // case 74
						default: {
							if (!super.parseUnknownField(input, extensionRegistry, tag)) {
								done = true; // was an endgroup tag
							}
							break;
						} // default:
						} // switch (tag)
					} // while (!done)
				} catch (InvalidProtocolBufferException e) {
					throw e.unwrapIOException();
				}
				finally {
					onChanged();
				} // finally
				return this;
			}

			private int bitField0_;

			private int type_ = 1;

			/**
			 * <code>optional .SignedMessage.MessageType type = 1;</code>
			 * 
			 * @return Whether the type field is set.
			 */
			@java.lang.Override
			public boolean hasType() {
				return ((bitField0_ & 0x00000001) != 0);
			}

			/**
			 * <code>optional .SignedMessage.MessageType type = 1;</code>
			 * 
			 * @return The type.
			 */
			@java.lang.Override
			public WvProto2.SignedMessage.MessageType getType() {
				WvProto2.SignedMessage.MessageType result = WvProto2.SignedMessage.MessageType
						.forNumber(type_);
				return result == null ? WvProto2.SignedMessage.MessageType.LICENSE_REQUEST
						: result;
			}

			/**
			 * <code>optional .SignedMessage.MessageType type = 1;</code>
			 * 
			 * @param value The type to set.
			 * @return This builder for chaining.
			 */
			public Builder setType(WvProto2.SignedMessage.MessageType value) {
				if (value == null) {
					throw new NullPointerException();
				}
				bitField0_ |= 0x00000001;
				type_ = value.getNumber();
				onChanged();
				return this;
			}

			/**
			 * <code>optional .SignedMessage.MessageType type = 1;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearType() {
				bitField0_ = (bitField0_ & ~0x00000001);
				type_ = 1;
				onChanged();
				return this;
			}

			private ByteString msg_ = ByteString.EMPTY;

			/**
			 * <code>optional bytes msg = 2;</code>
			 * 
			 * @return Whether the msg field is set.
			 */
			@java.lang.Override
			public boolean hasMsg() {
				return ((bitField0_ & 0x00000002) != 0);
			}

			/**
			 * <code>optional bytes msg = 2;</code>
			 * 
			 * @return The msg.
			 */
			@java.lang.Override
			public ByteString getMsg() {
				return msg_;
			}

			/**
			 * <code>optional bytes msg = 2;</code>
			 * 
			 * @param value The msg to set.
			 * @return This builder for chaining.
			 */
			public Builder setMsg(ByteString value) {
				if (value == null) {
					throw new NullPointerException();
				}
				msg_ = value;
				bitField0_ |= 0x00000002;
				onChanged();
				return this;
			}

			/**
			 * <code>optional bytes msg = 2;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearMsg() {
				bitField0_ = (bitField0_ & ~0x00000002);
				msg_ = getDefaultInstance().getMsg();
				onChanged();
				return this;
			}

			private ByteString signature_ = ByteString.EMPTY;

			/**
			 * <pre>
			 * Required field that contains the signature of the bytes of msg.
			 * For license requests, the signing algorithm is determined by the
			 * certificate contained in the request.
			 * For license responses, the signing algorithm is HMAC with signing key based
			 * on |session_key|.
			 * </pre>
			 *
			 * <code>optional bytes signature = 3;</code>
			 * 
			 * @return Whether the signature field is set.
			 */
			@java.lang.Override
			public boolean hasSignature() {
				return ((bitField0_ & 0x00000004) != 0);
			}

			/**
			 * <pre>
			 * Required field that contains the signature of the bytes of msg.
			 * For license requests, the signing algorithm is determined by the
			 * certificate contained in the request.
			 * For license responses, the signing algorithm is HMAC with signing key based
			 * on |session_key|.
			 * </pre>
			 *
			 * <code>optional bytes signature = 3;</code>
			 * 
			 * @return The signature.
			 */
			@java.lang.Override
			public ByteString getSignature() {
				return signature_;
			}

			/**
			 * <pre>
			 * Required field that contains the signature of the bytes of msg.
			 * For license requests, the signing algorithm is determined by the
			 * certificate contained in the request.
			 * For license responses, the signing algorithm is HMAC with signing key based
			 * on |session_key|.
			 * </pre>
			 *
			 * <code>optional bytes signature = 3;</code>
			 * 
			 * @param value The signature to set.
			 * @return This builder for chaining.
			 */
			public Builder setSignature(ByteString value) {
				if (value == null) {
					throw new NullPointerException();
				}
				signature_ = value;
				bitField0_ |= 0x00000004;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Required field that contains the signature of the bytes of msg.
			 * For license requests, the signing algorithm is determined by the
			 * certificate contained in the request.
			 * For license responses, the signing algorithm is HMAC with signing key based
			 * on |session_key|.
			 * </pre>
			 *
			 * <code>optional bytes signature = 3;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearSignature() {
				bitField0_ = (bitField0_ & ~0x00000004);
				signature_ = getDefaultInstance().getSignature();
				onChanged();
				return this;
			}

			private ByteString sessionKey_ = ByteString.EMPTY;

			/**
			 * <pre>
			 * If populated, the contents of this field will be signaled by the
			 * |session_key_type| type. If the |session_key_type| is WRAPPED_AES_KEY the
			 * key is the bytes of an encrypted AES key. If the |session_key_type| is
			 * EPHERMERAL_ECC_PUBLIC_KEY the field contains the bytes of an RFC5208 ASN1
			 * serialized ECC public key.
			 * </pre>
			 *
			 * <code>optional bytes session_key = 4;</code>
			 * 
			 * @return Whether the sessionKey field is set.
			 */
			@java.lang.Override
			public boolean hasSessionKey() {
				return ((bitField0_ & 0x00000008) != 0);
			}

			/**
			 * <pre>
			 * If populated, the contents of this field will be signaled by the
			 * |session_key_type| type. If the |session_key_type| is WRAPPED_AES_KEY the
			 * key is the bytes of an encrypted AES key. If the |session_key_type| is
			 * EPHERMERAL_ECC_PUBLIC_KEY the field contains the bytes of an RFC5208 ASN1
			 * serialized ECC public key.
			 * </pre>
			 *
			 * <code>optional bytes session_key = 4;</code>
			 * 
			 * @return The sessionKey.
			 */
			@java.lang.Override
			public ByteString getSessionKey() {
				return sessionKey_;
			}

			/**
			 * <pre>
			 * If populated, the contents of this field will be signaled by the
			 * |session_key_type| type. If the |session_key_type| is WRAPPED_AES_KEY the
			 * key is the bytes of an encrypted AES key. If the |session_key_type| is
			 * EPHERMERAL_ECC_PUBLIC_KEY the field contains the bytes of an RFC5208 ASN1
			 * serialized ECC public key.
			 * </pre>
			 *
			 * <code>optional bytes session_key = 4;</code>
			 * 
			 * @param value The sessionKey to set.
			 * @return This builder for chaining.
			 */
			public Builder setSessionKey(ByteString value) {
				if (value == null) {
					throw new NullPointerException();
				}
				sessionKey_ = value;
				bitField0_ |= 0x00000008;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * If populated, the contents of this field will be signaled by the
			 * |session_key_type| type. If the |session_key_type| is WRAPPED_AES_KEY the
			 * key is the bytes of an encrypted AES key. If the |session_key_type| is
			 * EPHERMERAL_ECC_PUBLIC_KEY the field contains the bytes of an RFC5208 ASN1
			 * serialized ECC public key.
			 * </pre>
			 *
			 * <code>optional bytes session_key = 4;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearSessionKey() {
				bitField0_ = (bitField0_ & ~0x00000008);
				sessionKey_ = getDefaultInstance().getSessionKey();
				onChanged();
				return this;
			}

			private ByteString remoteAttestation_ = ByteString.EMPTY;

			/**
			 * <pre>
			 * Remote attestation data which will be present in the initial license
			 * request for ChromeOS client devices operating in verified mode. Remote
			 * attestation challenge data is |msg| field above. Optional.
			 * </pre>
			 *
			 * <code>optional bytes remote_attestation = 5;</code>
			 * 
			 * @return Whether the remoteAttestation field is set.
			 */
			@java.lang.Override
			public boolean hasRemoteAttestation() {
				return ((bitField0_ & 0x00000010) != 0);
			}

			/**
			 * <pre>
			 * Remote attestation data which will be present in the initial license
			 * request for ChromeOS client devices operating in verified mode. Remote
			 * attestation challenge data is |msg| field above. Optional.
			 * </pre>
			 *
			 * <code>optional bytes remote_attestation = 5;</code>
			 * 
			 * @return The remoteAttestation.
			 */
			@java.lang.Override
			public ByteString getRemoteAttestation() {
				return remoteAttestation_;
			}

			/**
			 * <pre>
			 * Remote attestation data which will be present in the initial license
			 * request for ChromeOS client devices operating in verified mode. Remote
			 * attestation challenge data is |msg| field above. Optional.
			 * </pre>
			 *
			 * <code>optional bytes remote_attestation = 5;</code>
			 * 
			 * @param value The remoteAttestation to set.
			 * @return This builder for chaining.
			 */
			public Builder setRemoteAttestation(ByteString value) {
				if (value == null) {
					throw new NullPointerException();
				}
				remoteAttestation_ = value;
				bitField0_ |= 0x00000010;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Remote attestation data which will be present in the initial license
			 * request for ChromeOS client devices operating in verified mode. Remote
			 * attestation challenge data is |msg| field above. Optional.
			 * </pre>
			 *
			 * <code>optional bytes remote_attestation = 5;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearRemoteAttestation() {
				bitField0_ = (bitField0_ & ~0x00000010);
				remoteAttestation_ = getDefaultInstance().getRemoteAttestation();
				onChanged();
				return this;
			}

			private java.util.List<WvProto2.MetricData> metricData_ = java.util.Collections
					.emptyList();

			private void ensureMetricDataIsMutable() {
				if (!((bitField0_ & 0x00000020) != 0)) {
					metricData_ = new java.util.ArrayList<>(metricData_);
					bitField0_ |= 0x00000020;
				}
			}

			private RepeatedFieldBuilderV3<WvProto2.MetricData, WvProto2.MetricData.Builder, WvProto2.MetricDataOrBuilder> metricDataBuilder_;

			/**
			 * <code>repeated .MetricData metric_data = 6;</code>
			 */
			@Override
			public java.util.List<WvProto2.MetricData> getMetricDataList() {
				if (metricDataBuilder_ == null) {
					return java.util.Collections.unmodifiableList(metricData_);
				}
				return metricDataBuilder_.getMessageList();
			}

			/**
			 * <code>repeated .MetricData metric_data = 6;</code>
			 */
			@Override
			public int getMetricDataCount() {
				if (metricDataBuilder_ == null) {
					return metricData_.size();
				}
				return metricDataBuilder_.getCount();
			}

			/**
			 * <code>repeated .MetricData metric_data = 6;</code>
			 */
			@Override
			public WvProto2.MetricData getMetricData(int index) {
				if (metricDataBuilder_ == null) {
					return metricData_.get(index);
				}
				return metricDataBuilder_.getMessage(index);
			}

			/**
			 * <code>repeated .MetricData metric_data = 6;</code>
			 */
			public Builder setMetricData(int index, WvProto2.MetricData value) {
				if (metricDataBuilder_ == null) {
					if (value == null) {
						throw new NullPointerException();
					}
					ensureMetricDataIsMutable();
					metricData_.set(index, value);
					onChanged();
				} else {
					metricDataBuilder_.setMessage(index, value);
				}
				return this;
			}

			/**
			 * <code>repeated .MetricData metric_data = 6;</code>
			 */
			public Builder setMetricData(int index,
					WvProto2.MetricData.Builder builderForValue) {
				if (metricDataBuilder_ == null) {
					ensureMetricDataIsMutable();
					metricData_.set(index, builderForValue.build());
					onChanged();
				} else {
					metricDataBuilder_.setMessage(index, builderForValue.build());
				}
				return this;
			}

			/**
			 * <code>repeated .MetricData metric_data = 6;</code>
			 */
			public Builder addMetricData(WvProto2.MetricData value) {
				if (metricDataBuilder_ == null) {
					if (value == null) {
						throw new NullPointerException();
					}
					ensureMetricDataIsMutable();
					metricData_.add(value);
					onChanged();
				} else {
					metricDataBuilder_.addMessage(value);
				}
				return this;
			}

			/**
			 * <code>repeated .MetricData metric_data = 6;</code>
			 */
			public Builder addMetricData(int index, WvProto2.MetricData value) {
				if (metricDataBuilder_ == null) {
					if (value == null) {
						throw new NullPointerException();
					}
					ensureMetricDataIsMutable();
					metricData_.add(index, value);
					onChanged();
				} else {
					metricDataBuilder_.addMessage(index, value);
				}
				return this;
			}

			/**
			 * <code>repeated .MetricData metric_data = 6;</code>
			 */
			public Builder addMetricData(WvProto2.MetricData.Builder builderForValue) {
				if (metricDataBuilder_ == null) {
					ensureMetricDataIsMutable();
					metricData_.add(builderForValue.build());
					onChanged();
				} else {
					metricDataBuilder_.addMessage(builderForValue.build());
				}
				return this;
			}

			/**
			 * <code>repeated .MetricData metric_data = 6;</code>
			 */
			public Builder addMetricData(int index,
					WvProto2.MetricData.Builder builderForValue) {
				if (metricDataBuilder_ == null) {
					ensureMetricDataIsMutable();
					metricData_.add(index, builderForValue.build());
					onChanged();
				} else {
					metricDataBuilder_.addMessage(index, builderForValue.build());
				}
				return this;
			}

			/**
			 * <code>repeated .MetricData metric_data = 6;</code>
			 */
			public Builder addAllMetricData(
					java.lang.Iterable<? extends WvProto2.MetricData> values) {
				if (metricDataBuilder_ == null) {
					ensureMetricDataIsMutable();
					AbstractMessageLite.Builder.addAll(values, metricData_);
					onChanged();
				} else {
					metricDataBuilder_.addAllMessages(values);
				}
				return this;
			}

			/**
			 * <code>repeated .MetricData metric_data = 6;</code>
			 */
			public Builder clearMetricData() {
				if (metricDataBuilder_ == null) {
					metricData_ = java.util.Collections.emptyList();
					bitField0_ = (bitField0_ & ~0x00000020);
					onChanged();
				} else {
					metricDataBuilder_.clear();
				}
				return this;
			}

			/**
			 * <code>repeated .MetricData metric_data = 6;</code>
			 */
			public Builder removeMetricData(int index) {
				if (metricDataBuilder_ == null) {
					ensureMetricDataIsMutable();
					metricData_.remove(index);
					onChanged();
				} else {
					metricDataBuilder_.remove(index);
				}
				return this;
			}

			/**
			 * <code>repeated .MetricData metric_data = 6;</code>
			 */
			public WvProto2.MetricData.Builder getMetricDataBuilder(int index) {
				return getMetricDataFieldBuilder().getBuilder(index);
			}

			/**
			 * <code>repeated .MetricData metric_data = 6;</code>
			 */
			@Override
			public WvProto2.MetricDataOrBuilder getMetricDataOrBuilder(int index) {
				if (metricDataBuilder_ == null) {
					return metricData_.get(index);
				}
				return metricDataBuilder_.getMessageOrBuilder(index);
			}

			/**
			 * <code>repeated .MetricData metric_data = 6;</code>
			 */
			@Override
			public java.util.List<? extends WvProto2.MetricDataOrBuilder> getMetricDataOrBuilderList() {
				if (metricDataBuilder_ != null) {
					return metricDataBuilder_.getMessageOrBuilderList();
				}
				return java.util.Collections.unmodifiableList(metricData_);
			}

			/**
			 * <code>repeated .MetricData metric_data = 6;</code>
			 */
			public WvProto2.MetricData.Builder addMetricDataBuilder() {
				return getMetricDataFieldBuilder()
						.addBuilder(WvProto2.MetricData.getDefaultInstance());
			}

			/**
			 * <code>repeated .MetricData metric_data = 6;</code>
			 */
			public WvProto2.MetricData.Builder addMetricDataBuilder(int index) {
				return getMetricDataFieldBuilder().addBuilder(index,
						WvProto2.MetricData.getDefaultInstance());
			}

			/**
			 * <code>repeated .MetricData metric_data = 6;</code>
			 */
			public java.util.List<WvProto2.MetricData.Builder> getMetricDataBuilderList() {
				return getMetricDataFieldBuilder().getBuilderList();
			}

			private RepeatedFieldBuilderV3<WvProto2.MetricData, WvProto2.MetricData.Builder, WvProto2.MetricDataOrBuilder> getMetricDataFieldBuilder() {
				if (metricDataBuilder_ == null) {
					metricDataBuilder_ = new RepeatedFieldBuilderV3<>(metricData_, ((bitField0_ & 0x00000020) != 0),
							getParentForChildren(), isClean());
					metricData_ = null;
				}
				return metricDataBuilder_;
			}

			private WvProto2.VersionInfo serviceVersionInfo_;
			private SingleFieldBuilderV3<WvProto2.VersionInfo, WvProto2.VersionInfo.Builder, WvProto2.VersionInfoOrBuilder> serviceVersionInfoBuilder_;

			/**
			 * <pre>
			 * Version information from the SDK and license service. This information is
			 * provided in the license response.
			 * </pre>
			 *
			 * <code>optional .VersionInfo service_version_info = 7;</code>
			 * 
			 * @return Whether the serviceVersionInfo field is set.
			 */
			@Override
			public boolean hasServiceVersionInfo() {
				return ((bitField0_ & 0x00000040) != 0);
			}

			/**
			 * <pre>
			 * Version information from the SDK and license service. This information is
			 * provided in the license response.
			 * </pre>
			 *
			 * <code>optional .VersionInfo service_version_info = 7;</code>
			 * 
			 * @return The serviceVersionInfo.
			 */
			@Override
			public WvProto2.VersionInfo getServiceVersionInfo() {
				if (serviceVersionInfoBuilder_ == null) {
					return serviceVersionInfo_ == null
							? WvProto2.VersionInfo.getDefaultInstance()
							: serviceVersionInfo_;
				}
				return serviceVersionInfoBuilder_.getMessage();
			}

			/**
			 * <pre>
			 * Version information from the SDK and license service. This information is
			 * provided in the license response.
			 * </pre>
			 *
			 * <code>optional .VersionInfo service_version_info = 7;</code>
			 */
			public Builder setServiceVersionInfo(WvProto2.VersionInfo value) {
				if (serviceVersionInfoBuilder_ == null) {
					if (value == null) {
						throw new NullPointerException();
					}
					serviceVersionInfo_ = value;
				} else {
					serviceVersionInfoBuilder_.setMessage(value);
				}
				bitField0_ |= 0x00000040;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Version information from the SDK and license service. This information is
			 * provided in the license response.
			 * </pre>
			 *
			 * <code>optional .VersionInfo service_version_info = 7;</code>
			 */
			public Builder setServiceVersionInfo(WvProto2.VersionInfo.Builder builderForValue) {
				if (serviceVersionInfoBuilder_ == null) {
					serviceVersionInfo_ = builderForValue.build();
				} else {
					serviceVersionInfoBuilder_.setMessage(builderForValue.build());
				}
				bitField0_ |= 0x00000040;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Version information from the SDK and license service. This information is
			 * provided in the license response.
			 * </pre>
			 *
			 * <code>optional .VersionInfo service_version_info = 7;</code>
			 */
			public Builder mergeServiceVersionInfo(WvProto2.VersionInfo value) {
				if (serviceVersionInfoBuilder_ == null) {
					if (((bitField0_ & 0x00000040) != 0) && serviceVersionInfo_ != null
							&& serviceVersionInfo_ != WvProto2.VersionInfo
									.getDefaultInstance()) {
						getServiceVersionInfoBuilder().mergeFrom(value);
					} else {
						serviceVersionInfo_ = value;
					}
				} else {
					serviceVersionInfoBuilder_.mergeFrom(value);
				}
				bitField0_ |= 0x00000040;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Version information from the SDK and license service. This information is
			 * provided in the license response.
			 * </pre>
			 *
			 * <code>optional .VersionInfo service_version_info = 7;</code>
			 */
			public Builder clearServiceVersionInfo() {
				bitField0_ = (bitField0_ & ~0x00000040);
				serviceVersionInfo_ = null;
				if (serviceVersionInfoBuilder_ != null) {
					serviceVersionInfoBuilder_.dispose();
					serviceVersionInfoBuilder_ = null;
				}
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Version information from the SDK and license service. This information is
			 * provided in the license response.
			 * </pre>
			 *
			 * <code>optional .VersionInfo service_version_info = 7;</code>
			 */
			public WvProto2.VersionInfo.Builder getServiceVersionInfoBuilder() {
				bitField0_ |= 0x00000040;
				onChanged();
				return getServiceVersionInfoFieldBuilder().getBuilder();
			}

			/**
			 * <pre>
			 * Version information from the SDK and license service. This information is
			 * provided in the license response.
			 * </pre>
			 *
			 * <code>optional .VersionInfo service_version_info = 7;</code>
			 */
			@Override
			public WvProto2.VersionInfoOrBuilder getServiceVersionInfoOrBuilder() {
				if (serviceVersionInfoBuilder_ != null) {
					return serviceVersionInfoBuilder_.getMessageOrBuilder();
				}
				return serviceVersionInfo_ == null
						? WvProto2.VersionInfo.getDefaultInstance()
						: serviceVersionInfo_;
			}

			/**
			 * <pre>
			 * Version information from the SDK and license service. This information is
			 * provided in the license response.
			 * </pre>
			 *
			 * <code>optional .VersionInfo service_version_info = 7;</code>
			 */
			private SingleFieldBuilderV3<WvProto2.VersionInfo, WvProto2.VersionInfo.Builder, WvProto2.VersionInfoOrBuilder> getServiceVersionInfoFieldBuilder() {
				if (serviceVersionInfoBuilder_ == null) {
					serviceVersionInfoBuilder_ = new SingleFieldBuilderV3<>(getServiceVersionInfo(),
							getParentForChildren(), isClean());
					serviceVersionInfo_ = null;
				}
				return serviceVersionInfoBuilder_;
			}

			private int sessionKeyType_ = 1;

			/**
			 * <pre>
			 * Optional field that contains the algorithm type used to generate the
			 * session_key and signature in a LICENSE message.
			 * </pre>
			 *
			 * <code>optional .SignedMessage.SessionKeyType session_key_type = 8 [default = WRAPPED_AES_KEY];</code>
			 * 
			 * @return Whether the sessionKeyType field is set.
			 */
			@java.lang.Override
			public boolean hasSessionKeyType() {
				return ((bitField0_ & 0x00000080) != 0);
			}

			/**
			 * <pre>
			 * Optional field that contains the algorithm type used to generate the
			 * session_key and signature in a LICENSE message.
			 * </pre>
			 *
			 * <code>optional .SignedMessage.SessionKeyType session_key_type = 8 [default = WRAPPED_AES_KEY];</code>
			 * 
			 * @return The sessionKeyType.
			 */
			@java.lang.Override
			public WvProto2.SignedMessage.SessionKeyType getSessionKeyType() {
				WvProto2.SignedMessage.SessionKeyType result = WvProto2.SignedMessage.SessionKeyType
						.forNumber(sessionKeyType_);
				return result == null ? WvProto2.SignedMessage.SessionKeyType.WRAPPED_AES_KEY
						: result;
			}

			/**
			 * <pre>
			 * Optional field that contains the algorithm type used to generate the
			 * session_key and signature in a LICENSE message.
			 * </pre>
			 *
			 * <code>optional .SignedMessage.SessionKeyType session_key_type = 8 [default = WRAPPED_AES_KEY];</code>
			 * 
			 * @param value The sessionKeyType to set.
			 * @return This builder for chaining.
			 */
			public Builder setSessionKeyType(WvProto2.SignedMessage.SessionKeyType value) {
				if (value == null) {
					throw new NullPointerException();
				}
				bitField0_ |= 0x00000080;
				sessionKeyType_ = value.getNumber();
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Optional field that contains the algorithm type used to generate the
			 * session_key and signature in a LICENSE message.
			 * </pre>
			 *
			 * <code>optional .SignedMessage.SessionKeyType session_key_type = 8 [default = WRAPPED_AES_KEY];</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearSessionKeyType() {
				bitField0_ = (bitField0_ & ~0x00000080);
				sessionKeyType_ = 1;
				onChanged();
				return this;
			}

			private ByteString oemcryptoCoreMessage_ = ByteString.EMPTY;

			/**
			 * <pre>
			 * The core message is the simple serialization of fields used by OEMCrypto.
			 * This field was introduced in OEMCrypto API v16.
			 * </pre>
			 *
			 * <code>optional bytes oemcrypto_core_message = 9;</code>
			 * 
			 * @return Whether the oemcryptoCoreMessage field is set.
			 */
			@java.lang.Override
			public boolean hasOemcryptoCoreMessage() {
				return ((bitField0_ & 0x00000100) != 0);
			}

			/**
			 * <pre>
			 * The core message is the simple serialization of fields used by OEMCrypto.
			 * This field was introduced in OEMCrypto API v16.
			 * </pre>
			 *
			 * <code>optional bytes oemcrypto_core_message = 9;</code>
			 * 
			 * @return The oemcryptoCoreMessage.
			 */
			@java.lang.Override
			public ByteString getOemcryptoCoreMessage() {
				return oemcryptoCoreMessage_;
			}

			/**
			 * <pre>
			 * The core message is the simple serialization of fields used by OEMCrypto.
			 * This field was introduced in OEMCrypto API v16.
			 * </pre>
			 *
			 * <code>optional bytes oemcrypto_core_message = 9;</code>
			 * 
			 * @param value The oemcryptoCoreMessage to set.
			 * @return This builder for chaining.
			 */
			public Builder setOemcryptoCoreMessage(ByteString value) {
				if (value == null) {
					throw new NullPointerException();
				}
				oemcryptoCoreMessage_ = value;
				bitField0_ |= 0x00000100;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * The core message is the simple serialization of fields used by OEMCrypto.
			 * This field was introduced in OEMCrypto API v16.
			 * </pre>
			 *
			 * <code>optional bytes oemcrypto_core_message = 9;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearOemcryptoCoreMessage() {
				bitField0_ = (bitField0_ & ~0x00000100);
				oemcryptoCoreMessage_ = getDefaultInstance().getOemcryptoCoreMessage();
				onChanged();
				return this;
			}

			@java.lang.Override
			public final Builder setUnknownFields(final UnknownFieldSet unknownFields) {
				return super.setUnknownFields(unknownFields);
			}

			@java.lang.Override
			public final Builder mergeUnknownFields(final UnknownFieldSet unknownFields) {
				return super.mergeUnknownFields(unknownFields);
			}

			// @@protoc_insertion_point(builder_scope:SignedMessage)
		}

		// @@protoc_insertion_point(class_scope:SignedMessage)
		private static final WvProto2.SignedMessage DEFAULT_INSTANCE;
		static {
			DEFAULT_INSTANCE = new WvProto2.SignedMessage();
		}

		public static WvProto2.SignedMessage getDefaultInstance() {
			return DEFAULT_INSTANCE;
		}

		@java.lang.Deprecated public static final Parser<SignedMessage> PARSER = new AbstractParser<>() {
			@java.lang.Override
			public SignedMessage parsePartialFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
					throws InvalidProtocolBufferException {
				Builder builder = newBuilder();
				try {
					builder.mergeFrom(input, extensionRegistry);
				} catch (InvalidProtocolBufferException e) {
					throw e.setUnfinishedMessage(builder.buildPartial());
				} catch (UninitializedMessageException e) {
					throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
				} catch (java.io.IOException e) {
					throw new InvalidProtocolBufferException(e).setUnfinishedMessage(builder.buildPartial());
				}
				return builder.buildPartial();
			}
		};

		public static Parser<SignedMessage> parser() {
			return PARSER;
		}

		@java.lang.Override
		public Parser<SignedMessage> getParserForType() {
			return PARSER;
		}

		@java.lang.Override
		public WvProto2.SignedMessage getDefaultInstanceForType() {
			return DEFAULT_INSTANCE;
		}

	}

	public interface ClientIdentificationOrBuilder extends
			// @@protoc_insertion_point(interface_extends:ClientIdentification)
			MessageOrBuilder {

		/**
		 * <pre>
		 * Type of factory-provisioned device root of trust. Optional.
		 * </pre>
		 *
		 * <code>optional .ClientIdentification.TokenType type = 1 [default = KEYBOX];</code>
		 * 
		 * @return Whether the type field is set.
		 */
		boolean hasType();

		/**
		 * <pre>
		 * Type of factory-provisioned device root of trust. Optional.
		 * </pre>
		 *
		 * <code>optional .ClientIdentification.TokenType type = 1 [default = KEYBOX];</code>
		 * 
		 * @return The type.
		 */
		WvProto2.ClientIdentification.TokenType getType();

		/**
		 * <pre>
		 * Factory-provisioned device root of trust. Required.
		 * </pre>
		 *
		 * <code>optional bytes token = 2;</code>
		 * 
		 * @return Whether the token field is set.
		 */
		boolean hasToken();

		/**
		 * <pre>
		 * Factory-provisioned device root of trust. Required.
		 * </pre>
		 *
		 * <code>optional bytes token = 2;</code>
		 * 
		 * @return The token.
		 */
		ByteString getToken();

		/**
		 * <pre>
		 * Optional client information name/value pairs.
		 * </pre>
		 *
		 * <code>repeated .ClientIdentification.NameValue client_info = 3;</code>
		 */
		java.util.List<WvProto2.ClientIdentification.NameValue> getClientInfoList();

		/**
		 * <pre>
		 * Optional client information name/value pairs.
		 * </pre>
		 *
		 * <code>repeated .ClientIdentification.NameValue client_info = 3;</code>
		 */
		WvProto2.ClientIdentification.NameValue getClientInfo(int index);

		/**
		 * <pre>
		 * Optional client information name/value pairs.
		 * </pre>
		 *
		 * <code>repeated .ClientIdentification.NameValue client_info = 3;</code>
		 */
		int getClientInfoCount();

		/**
		 * <pre>
		 * Optional client information name/value pairs.
		 * </pre>
		 *
		 * <code>repeated .ClientIdentification.NameValue client_info = 3;</code>
		 */
		java.util.List<? extends WvProto2.ClientIdentification.NameValueOrBuilder> getClientInfoOrBuilderList();

		/**
		 * <pre>
		 * Optional client information name/value pairs.
		 * </pre>
		 *
		 * <code>repeated .ClientIdentification.NameValue client_info = 3;</code>
		 */
		WvProto2.ClientIdentification.NameValueOrBuilder getClientInfoOrBuilder(int index);

		/**
		 * <pre>
		 * Client token generated by the content provider. Optional.
		 * </pre>
		 *
		 * <code>optional bytes provider_client_token = 4;</code>
		 * 
		 * @return Whether the providerClientToken field is set.
		 */
		boolean hasProviderClientToken();

		/**
		 * <pre>
		 * Client token generated by the content provider. Optional.
		 * </pre>
		 *
		 * <code>optional bytes provider_client_token = 4;</code>
		 * 
		 * @return The providerClientToken.
		 */
		ByteString getProviderClientToken();

		/**
		 * <pre>
		 * Number of licenses received by the client to which the token above belongs.
		 * Only present if client_token is specified.
		 * </pre>
		 *
		 * <code>optional uint32 license_counter = 5;</code>
		 * 
		 * @return Whether the licenseCounter field is set.
		 */
		boolean hasLicenseCounter();

		/**
		 * <pre>
		 * Number of licenses received by the client to which the token above belongs.
		 * Only present if client_token is specified.
		 * </pre>
		 *
		 * <code>optional uint32 license_counter = 5;</code>
		 * 
		 * @return The licenseCounter.
		 */
		int getLicenseCounter();

		/**
		 * <pre>
		 * List of non-baseline client capabilities.
		 * </pre>
		 *
		 * <code>optional .ClientIdentification.ClientCapabilities client_capabilities = 6;</code>
		 * 
		 * @return Whether the clientCapabilities field is set.
		 */
		boolean hasClientCapabilities();

		/**
		 * <pre>
		 * List of non-baseline client capabilities.
		 * </pre>
		 *
		 * <code>optional .ClientIdentification.ClientCapabilities client_capabilities = 6;</code>
		 * 
		 * @return The clientCapabilities.
		 */
		WvProto2.ClientIdentification.ClientCapabilities getClientCapabilities();

		/**
		 * <pre>
		 * List of non-baseline client capabilities.
		 * </pre>
		 *
		 * <code>optional .ClientIdentification.ClientCapabilities client_capabilities = 6;</code>
		 */
		WvProto2.ClientIdentification.ClientCapabilitiesOrBuilder getClientCapabilitiesOrBuilder();

		/**
		 * <pre>
		 * Serialized VmpData message. Optional.
		 * </pre>
		 *
		 * <code>optional bytes vmp_data = 7;</code>
		 * 
		 * @return Whether the vmpData field is set.
		 */
		boolean hasVmpData();

		/**
		 * <pre>
		 * Serialized VmpData message. Optional.
		 * </pre>
		 *
		 * <code>optional bytes vmp_data = 7;</code>
		 * 
		 * @return The vmpData.
		 */
		ByteString getVmpData();

		/**
		 * <pre>
		 * Optional field that may contain additional provisioning credentials.
		 * </pre>
		 *
		 * <code>repeated .ClientIdentification.ClientCredentials device_credentials = 8;</code>
		 */
		java.util.List<WvProto2.ClientIdentification.ClientCredentials> getDeviceCredentialsList();

		/**
		 * <pre>
		 * Optional field that may contain additional provisioning credentials.
		 * </pre>
		 *
		 * <code>repeated .ClientIdentification.ClientCredentials device_credentials = 8;</code>
		 */
		WvProto2.ClientIdentification.ClientCredentials getDeviceCredentials(int index);

		/**
		 * <pre>
		 * Optional field that may contain additional provisioning credentials.
		 * </pre>
		 *
		 * <code>repeated .ClientIdentification.ClientCredentials device_credentials = 8;</code>
		 */
		int getDeviceCredentialsCount();

		/**
		 * <pre>
		 * Optional field that may contain additional provisioning credentials.
		 * </pre>
		 *
		 * <code>repeated .ClientIdentification.ClientCredentials device_credentials = 8;</code>
		 */
		java.util.List<? extends WvProto2.ClientIdentification.ClientCredentialsOrBuilder> getDeviceCredentialsOrBuilderList();

		/**
		 * <pre>
		 * Optional field that may contain additional provisioning credentials.
		 * </pre>
		 *
		 * <code>repeated .ClientIdentification.ClientCredentials device_credentials = 8;</code>
		 */
		WvProto2.ClientIdentification.ClientCredentialsOrBuilder getDeviceCredentialsOrBuilder(
				int index);
	}

	/**
	 * <pre>
	 * ClientIdentification message used to authenticate the client device.
	 * </pre>
	 *
	 * Protobuf type {@code ClientIdentification}
	 */
	public static final class ClientIdentification extends GeneratedMessageV3 implements
			// @@protoc_insertion_point(message_implements:ClientIdentification)
			ClientIdentificationOrBuilder {
		private static final long serialVersionUID = 0L;

		// Use ClientIdentification.newBuilder() to construct.
		private ClientIdentification(GeneratedMessageV3.Builder<?> builder) {
			super(builder);
		}

		private ClientIdentification() {
			type_ = 0;
			token_ = ByteString.EMPTY;
			clientInfo_ = java.util.Collections.emptyList();
			providerClientToken_ = ByteString.EMPTY;
			vmpData_ = ByteString.EMPTY;
			deviceCredentials_ = java.util.Collections.emptyList();
		}

		@java.lang.Override

		protected java.lang.Object newInstance(UnusedPrivateParameter unused) {
			return new ClientIdentification();
		}

		public static final Descriptors.Descriptor getDescriptor() {
			return WvProto2.internal_static_ClientIdentification_descriptor;
		}

		@java.lang.Override
		protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
			return WvProto2.internal_static_ClientIdentification_fieldAccessorTable
					.ensureFieldAccessorsInitialized(WvProto2.ClientIdentification.class,
							WvProto2.ClientIdentification.Builder.class);
		}

		/**
		 * Protobuf enum {@code ClientIdentification.TokenType}
		 */
		public enum TokenType implements ProtocolMessageEnum {
			/**
			 * <code>KEYBOX = 0;</code>
			 */
			KEYBOX(0),
			/**
			 * <code>DRM_DEVICE_CERTIFICATE = 1;</code>
			 */
			DRM_DEVICE_CERTIFICATE(1),
			/**
			 * <code>REMOTE_ATTESTATION_CERTIFICATE = 2;</code>
			 */
			REMOTE_ATTESTATION_CERTIFICATE(2),
			/**
			 * <code>OEM_DEVICE_CERTIFICATE = 3;</code>
			 */
			OEM_DEVICE_CERTIFICATE(3),;

			/**
			 * <code>KEYBOX = 0;</code>
			 */
			public static final int KEYBOX_VALUE = 0;
			/**
			 * <code>DRM_DEVICE_CERTIFICATE = 1;</code>
			 */
			public static final int DRM_DEVICE_CERTIFICATE_VALUE = 1;
			/**
			 * <code>REMOTE_ATTESTATION_CERTIFICATE = 2;</code>
			 */
			public static final int REMOTE_ATTESTATION_CERTIFICATE_VALUE = 2;
			/**
			 * <code>OEM_DEVICE_CERTIFICATE = 3;</code>
			 */
			public static final int OEM_DEVICE_CERTIFICATE_VALUE = 3;

			@Override
			public final int getNumber() {
				return value;
			}

			/**
			 * @param value The numeric wire value of the corresponding enum entry.
			 * @return The enum associated with the given numeric wire value.
			 * @deprecated Use {@link #forNumber(int)} instead.
			 */
			@java.lang.Deprecated
			public static TokenType valueOf(int value) {
				return forNumber(value);
			}

			/**
			 * @param value The numeric wire value of the corresponding enum entry.
			 * @return The enum associated with the given numeric wire value.
			 */
			public static TokenType forNumber(int value) {
				switch (value) {
				case 0:
					return KEYBOX;
				case 1:
					return DRM_DEVICE_CERTIFICATE;
				case 2:
					return REMOTE_ATTESTATION_CERTIFICATE;
				case 3:
					return OEM_DEVICE_CERTIFICATE;
				default:
					return null;
				}
			}

			public static Internal.EnumLiteMap<TokenType> internalGetValueMap() {
				return internalValueMap;
			}

			private static final Internal.EnumLiteMap<TokenType> internalValueMap = new Internal.EnumLiteMap<>() {
				@Override
				public TokenType findValueByNumber(int number) {
					return TokenType.forNumber(number);
				}
			};

			@Override
			public final Descriptors.EnumValueDescriptor getValueDescriptor() {
				return getDescriptor().getValues().get(ordinal());
			}

			@Override
			public final Descriptors.EnumDescriptor getDescriptorForType() {
				return getDescriptor();
			}

			public static final Descriptors.EnumDescriptor getDescriptor() {
				return WvProto2.ClientIdentification.getDescriptor().getEnumTypes().get(0);
			}

			private static final TokenType[] VALUES = values();

			public static TokenType valueOf(Descriptors.EnumValueDescriptor desc) {
				if (desc.getType() != getDescriptor()) {
					throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
				}
				return VALUES[desc.getIndex()];
			}

			private final int value;

			private TokenType(int value) {
				this.value = value;
			}

			// @@protoc_insertion_point(enum_scope:ClientIdentification.TokenType)
		}

		public interface NameValueOrBuilder extends
				// @@protoc_insertion_point(interface_extends:ClientIdentification.NameValue)
				MessageOrBuilder {

			/**
			 * <code>optional string name = 1;</code>
			 * 
			 * @return Whether the name field is set.
			 */
			boolean hasName();

			/**
			 * <code>optional string name = 1;</code>
			 * 
			 * @return The name.
			 */
			java.lang.String getName();

			/**
			 * <code>optional string name = 1;</code>
			 * 
			 * @return The bytes for name.
			 */
			ByteString getNameBytes();

			/**
			 * <code>optional string value = 2;</code>
			 * 
			 * @return Whether the value field is set.
			 */
			boolean hasValue();

			/**
			 * <code>optional string value = 2;</code>
			 * 
			 * @return The value.
			 */
			java.lang.String getValue();

			/**
			 * <code>optional string value = 2;</code>
			 * 
			 * @return The bytes for value.
			 */
			ByteString getValueBytes();
		}

		/**
		 * Protobuf type {@code ClientIdentification.NameValue}
		 */
		public static final class NameValue extends GeneratedMessageV3 implements
				// @@protoc_insertion_point(message_implements:ClientIdentification.NameValue)
				NameValueOrBuilder {
			private static final long serialVersionUID = 0L;

			// Use NameValue.newBuilder() to construct.
			private NameValue(GeneratedMessageV3.Builder<?> builder) {
				super(builder);
			}

			private NameValue() {
				name_ = "";
				value_ = "";
			}

			@java.lang.Override

			protected java.lang.Object newInstance(UnusedPrivateParameter unused) {
				return new NameValue();
			}

			public static final Descriptors.Descriptor getDescriptor() {
				return WvProto2.internal_static_ClientIdentification_NameValue_descriptor;
			}

			@java.lang.Override
			protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
				return WvProto2.internal_static_ClientIdentification_NameValue_fieldAccessorTable
						.ensureFieldAccessorsInitialized(
								WvProto2.ClientIdentification.NameValue.class,
								WvProto2.ClientIdentification.NameValue.Builder.class);
			}

			private int bitField0_;
			public static final int NAME_FIELD_NUMBER = 1;

			private volatile java.lang.Object name_ = "";

			/**
			 * <code>optional string name = 1;</code>
			 * 
			 * @return Whether the name field is set.
			 */
			@java.lang.Override
			public boolean hasName() {
				return ((bitField0_ & 0x00000001) != 0);
			}

			/**
			 * <code>optional string name = 1;</code>
			 * 
			 * @return The name.
			 */
			@java.lang.Override
			public java.lang.String getName() {
				java.lang.Object ref = name_;
				if (ref instanceof java.lang.String) {
					return (java.lang.String) ref;
				}
				ByteString bs = (ByteString) ref;
				java.lang.String s = bs.toStringUtf8();
				if (bs.isValidUtf8()) {
					name_ = s;
				}
				return s;
			}

			/**
			 * <code>optional string name = 1;</code>
			 * 
			 * @return The bytes for name.
			 */
			@java.lang.Override
			public ByteString getNameBytes() {
				java.lang.Object ref = name_;
				if (ref instanceof java.lang.String) {
					ByteString b = ByteString.copyFromUtf8((java.lang.String) ref);
					name_ = b;
					return b;
				}
				return (ByteString) ref;
			}

			public static final int VALUE_FIELD_NUMBER = 2;

			private volatile java.lang.Object value_ = "";

			/**
			 * <code>optional string value = 2;</code>
			 * 
			 * @return Whether the value field is set.
			 */
			@java.lang.Override
			public boolean hasValue() {
				return ((bitField0_ & 0x00000002) != 0);
			}

			/**
			 * <code>optional string value = 2;</code>
			 * 
			 * @return The value.
			 */
			@java.lang.Override
			public java.lang.String getValue() {
				java.lang.Object ref = value_;
				if (ref instanceof java.lang.String) {
					return (java.lang.String) ref;
				}
				ByteString bs = (ByteString) ref;
				java.lang.String s = bs.toStringUtf8();
				if (bs.isValidUtf8()) {
					value_ = s;
				}
				return s;
			}

			/**
			 * <code>optional string value = 2;</code>
			 * 
			 * @return The bytes for value.
			 */
			@java.lang.Override
			public ByteString getValueBytes() {
				java.lang.Object ref = value_;
				if (ref instanceof java.lang.String) {
					ByteString b = ByteString.copyFromUtf8((java.lang.String) ref);
					value_ = b;
					return b;
				}
				return (ByteString) ref;
			}

			private byte memoizedIsInitialized = -1;

			@java.lang.Override
			public final boolean isInitialized() {
				byte isInitialized = memoizedIsInitialized;
				if (isInitialized == 1)
					return true;
				if (isInitialized == 0)
					return false;

				memoizedIsInitialized = 1;
				return true;
			}

			@java.lang.Override
			public void writeTo(CodedOutputStream output) throws java.io.IOException {
				if (((bitField0_ & 0x00000001) != 0)) {
					GeneratedMessageV3.writeString(output, 1, name_);
				}
				if (((bitField0_ & 0x00000002) != 0)) {
					GeneratedMessageV3.writeString(output, 2, value_);
				}
				getUnknownFields().writeTo(output);
			}

			@java.lang.Override
			public int getSerializedSize() {
				int size = memoizedSize;
				if (size != -1)
					return size;

				size = 0;
				if (((bitField0_ & 0x00000001) != 0)) {
					size += GeneratedMessageV3.computeStringSize(1, name_);
				}
				if (((bitField0_ & 0x00000002) != 0)) {
					size += GeneratedMessageV3.computeStringSize(2, value_);
				}
				size += getUnknownFields().getSerializedSize();
				memoizedSize = size;
				return size;
			}

			@java.lang.Override
			public boolean equals(final java.lang.Object obj) {
				if (obj == this) {
					return true;
				}
				if (!(obj instanceof WvProto2.ClientIdentification.NameValue)) {
					return super.equals(obj);
				}
				WvProto2.ClientIdentification.NameValue other = (WvProto2.ClientIdentification.NameValue) obj;

				if (hasName() != other.hasName())
					return false;
				if (hasName()) {
					if (!getName().equals(other.getName()))
						return false;
				}
				if (hasValue() != other.hasValue())
					return false;
				if (hasValue()) {
					if (!getValue().equals(other.getValue()))
						return false;
				}
				if (!getUnknownFields().equals(other.getUnknownFields()))
					return false;
				return true;
			}

			@SuppressWarnings("unchecked")
			@java.lang.Override
			public int hashCode() {
				if (memoizedHashCode != 0) {
					return memoizedHashCode;
				}
				int hash = 41;
				hash = (19 * hash) + getDescriptor().hashCode();
				if (hasName()) {
					hash = (37 * hash) + NAME_FIELD_NUMBER;
					hash = (53 * hash) + getName().hashCode();
				}
				if (hasValue()) {
					hash = (37 * hash) + VALUE_FIELD_NUMBER;
					hash = (53 * hash) + getValue().hashCode();
				}
				hash = (29 * hash) + getUnknownFields().hashCode();
				memoizedHashCode = hash;
				return hash;
			}

			public static WvProto2.ClientIdentification.NameValue parseFrom(
					java.nio.ByteBuffer data) throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data);
			}

			public static WvProto2.ClientIdentification.NameValue parseFrom(
					java.nio.ByteBuffer data, ExtensionRegistryLite extensionRegistry)
					throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data, extensionRegistry);
			}

			public static WvProto2.ClientIdentification.NameValue parseFrom(ByteString data)
					throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data);
			}

			public static WvProto2.ClientIdentification.NameValue parseFrom(ByteString data,
					ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data, extensionRegistry);
			}

			public static WvProto2.ClientIdentification.NameValue parseFrom(byte[] data)
					throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data);
			}

			public static WvProto2.ClientIdentification.NameValue parseFrom(byte[] data,
					ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data, extensionRegistry);
			}

			public static WvProto2.ClientIdentification.NameValue parseFrom(
					java.io.InputStream input) throws java.io.IOException {
				return GeneratedMessageV3.parseWithIOException(PARSER, input);
			}

			public static WvProto2.ClientIdentification.NameValue parseFrom(
					java.io.InputStream input, ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
				return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
			}

			public static WvProto2.ClientIdentification.NameValue parseDelimitedFrom(
					java.io.InputStream input) throws java.io.IOException {
				return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
			}

			public static WvProto2.ClientIdentification.NameValue parseDelimitedFrom(
					java.io.InputStream input, ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
				return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input, extensionRegistry);
			}

			public static WvProto2.ClientIdentification.NameValue parseFrom(
					CodedInputStream input) throws java.io.IOException {
				return GeneratedMessageV3.parseWithIOException(PARSER, input);
			}

			public static WvProto2.ClientIdentification.NameValue parseFrom(
					CodedInputStream input, ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
				return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
			}

			@java.lang.Override
			public Builder newBuilderForType() {
				return newBuilder();
			}

			public static Builder newBuilder() {
				return DEFAULT_INSTANCE.toBuilder();
			}

			public static Builder newBuilder(
					WvProto2.ClientIdentification.NameValue prototype) {
				return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
			}

			@java.lang.Override
			public Builder toBuilder() {
				return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
			}

			@java.lang.Override
			protected Builder newBuilderForType(GeneratedMessageV3.BuilderParent parent) {
				Builder builder = new Builder(parent);
				return builder;
			}

			/**
			 * Protobuf type {@code ClientIdentification.NameValue}
			 */
			public static final class Builder extends GeneratedMessageV3.Builder<Builder> implements
					// @@protoc_insertion_point(builder_implements:ClientIdentification.NameValue)
					WvProto2.ClientIdentification.NameValueOrBuilder {
				public static final Descriptors.Descriptor getDescriptor() {
					return WvProto2.internal_static_ClientIdentification_NameValue_descriptor;
				}

				@java.lang.Override
				protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
					return WvProto2.internal_static_ClientIdentification_NameValue_fieldAccessorTable
							.ensureFieldAccessorsInitialized(
									WvProto2.ClientIdentification.NameValue.class,
									WvProto2.ClientIdentification.NameValue.Builder.class);
				}

				// Construct using
				// WvProto2.ClientIdentification.NameValue.newBuilder()
				private Builder() {

				}

				private Builder(GeneratedMessageV3.BuilderParent parent) {
					super(parent);

				}

				@java.lang.Override
				public Builder clear() {
					super.clear();
					bitField0_ = 0;
					name_ = "";
					value_ = "";
					return this;
				}

				@java.lang.Override
				public Descriptors.Descriptor getDescriptorForType() {
					return WvProto2.internal_static_ClientIdentification_NameValue_descriptor;
				}

				@java.lang.Override
				public WvProto2.ClientIdentification.NameValue getDefaultInstanceForType() {
					return WvProto2.ClientIdentification.NameValue.getDefaultInstance();
				}

				@java.lang.Override
				public WvProto2.ClientIdentification.NameValue build() {
					WvProto2.ClientIdentification.NameValue result = buildPartial();
					if (!result.isInitialized()) {
						throw newUninitializedMessageException(result);
					}
					return result;
				}

				@java.lang.Override
				public WvProto2.ClientIdentification.NameValue buildPartial() {
					WvProto2.ClientIdentification.NameValue result = new WvProto2.ClientIdentification.NameValue(
							this);
					if (bitField0_ != 0) {
						buildPartial0(result);
					}
					onBuilt();
					return result;
				}

				private void buildPartial0(WvProto2.ClientIdentification.NameValue result) {
					int from_bitField0_ = bitField0_;
					int to_bitField0_ = 0;
					if (((from_bitField0_ & 0x00000001) != 0)) {
						result.name_ = name_;
						to_bitField0_ |= 0x00000001;
					}
					if (((from_bitField0_ & 0x00000002) != 0)) {
						result.value_ = value_;
						to_bitField0_ |= 0x00000002;
					}
					result.bitField0_ |= to_bitField0_;
				}

				@java.lang.Override
				public Builder mergeFrom(Message other) {
					if (other instanceof WvProto2.ClientIdentification.NameValue) {
						return mergeFrom((WvProto2.ClientIdentification.NameValue) other);
					}
					super.mergeFrom(other);
					return this;
				}

				public Builder mergeFrom(WvProto2.ClientIdentification.NameValue other) {
					if (other == WvProto2.ClientIdentification.NameValue.getDefaultInstance())
						return this;
					if (other.hasName()) {
						name_ = other.name_;
						bitField0_ |= 0x00000001;
						onChanged();
					}
					if (other.hasValue()) {
						value_ = other.value_;
						bitField0_ |= 0x00000002;
						onChanged();
					}
					this.mergeUnknownFields(other.getUnknownFields());
					onChanged();
					return this;
				}

				@java.lang.Override
				public final boolean isInitialized() {
					return true;
				}

				@java.lang.Override
				public Builder mergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
						throws java.io.IOException {
					if (extensionRegistry == null) {
						throw new java.lang.NullPointerException();
					}
					try {
						boolean done = false;
						while (!done) {
							int tag = input.readTag();
							switch (tag) {
							case 0:
								done = true;
								break;
							case 10: {
								name_ = input.readBytes();
								bitField0_ |= 0x00000001;
								break;
							} // case 10
							case 18: {
								value_ = input.readBytes();
								bitField0_ |= 0x00000002;
								break;
							} // case 18
							default: {
								if (!super.parseUnknownField(input, extensionRegistry, tag)) {
									done = true; // was an endgroup tag
								}
								break;
							} // default:
							} // switch (tag)
						} // while (!done)
					} catch (InvalidProtocolBufferException e) {
						throw e.unwrapIOException();
					}
					finally {
						onChanged();
					} // finally
					return this;
				}

				private int bitField0_;

				private java.lang.Object name_ = "";

				/**
				 * <code>optional string name = 1;</code>
				 * 
				 * @return Whether the name field is set.
				 */
				@Override
				public boolean hasName() {
					return ((bitField0_ & 0x00000001) != 0);
				}

				/**
				 * <code>optional string name = 1;</code>
				 * 
				 * @return The name.
				 */
				@Override
				public java.lang.String getName() {
					java.lang.Object ref = name_;
					if (!(ref instanceof java.lang.String)) {
						ByteString bs = (ByteString) ref;
						java.lang.String s = bs.toStringUtf8();
						if (bs.isValidUtf8()) {
							name_ = s;
						}
						return s;
					}
					return (java.lang.String) ref;
				}

				/**
				 * <code>optional string name = 1;</code>
				 * 
				 * @return The bytes for name.
				 */
				@Override
				public ByteString getNameBytes() {
					java.lang.Object ref = name_;
					if (ref instanceof String) {
						ByteString b = ByteString.copyFromUtf8((java.lang.String) ref);
						name_ = b;
						return b;
					}
					return (ByteString) ref;
				}

				/**
				 * <code>optional string name = 1;</code>
				 * 
				 * @param value The name to set.
				 * @return This builder for chaining.
				 */
				public Builder setName(java.lang.String value) {
					if (value == null) {
						throw new NullPointerException();
					}
					name_ = value;
					bitField0_ |= 0x00000001;
					onChanged();
					return this;
				}

				/**
				 * <code>optional string name = 1;</code>
				 * 
				 * @return This builder for chaining.
				 */
				public Builder clearName() {
					name_ = getDefaultInstance().getName();
					bitField0_ = (bitField0_ & ~0x00000001);
					onChanged();
					return this;
				}

				/**
				 * <code>optional string name = 1;</code>
				 * 
				 * @param value The bytes for name to set.
				 * @return This builder for chaining.
				 */
				public Builder setNameBytes(ByteString value) {
					if (value == null) {
						throw new NullPointerException();
					}
					name_ = value;
					bitField0_ |= 0x00000001;
					onChanged();
					return this;
				}

				private java.lang.Object value_ = "";

				/**
				 * <code>optional string value = 2;</code>
				 * 
				 * @return Whether the value field is set.
				 */
				@Override
				public boolean hasValue() {
					return ((bitField0_ & 0x00000002) != 0);
				}

				/**
				 * <code>optional string value = 2;</code>
				 * 
				 * @return The value.
				 */
				@Override
				public java.lang.String getValue() {
					java.lang.Object ref = value_;
					if (!(ref instanceof java.lang.String)) {
						ByteString bs = (ByteString) ref;
						java.lang.String s = bs.toStringUtf8();
						if (bs.isValidUtf8()) {
							value_ = s;
						}
						return s;
					}
					return (java.lang.String) ref;
				}

				/**
				 * <code>optional string value = 2;</code>
				 * 
				 * @return The bytes for value.
				 */
				@Override
				public ByteString getValueBytes() {
					java.lang.Object ref = value_;
					if (ref instanceof String) {
						ByteString b = ByteString.copyFromUtf8((java.lang.String) ref);
						value_ = b;
						return b;
					}
					return (ByteString) ref;
				}

				/**
				 * <code>optional string value = 2;</code>
				 * 
				 * @param value The value to set.
				 * @return This builder for chaining.
				 */
				public Builder setValue(java.lang.String value) {
					if (value == null) {
						throw new NullPointerException();
					}
					value_ = value;
					bitField0_ |= 0x00000002;
					onChanged();
					return this;
				}

				/**
				 * <code>optional string value = 2;</code>
				 * 
				 * @return This builder for chaining.
				 */
				public Builder clearValue() {
					value_ = getDefaultInstance().getValue();
					bitField0_ = (bitField0_ & ~0x00000002);
					onChanged();
					return this;
				}

				/**
				 * <code>optional string value = 2;</code>
				 * 
				 * @param value The bytes for value to set.
				 * @return This builder for chaining.
				 */
				public Builder setValueBytes(ByteString value) {
					if (value == null) {
						throw new NullPointerException();
					}
					value_ = value;
					bitField0_ |= 0x00000002;
					onChanged();
					return this;
				}

				@java.lang.Override
				public final Builder setUnknownFields(final UnknownFieldSet unknownFields) {
					return super.setUnknownFields(unknownFields);
				}

				@java.lang.Override
				public final Builder mergeUnknownFields(final UnknownFieldSet unknownFields) {
					return super.mergeUnknownFields(unknownFields);
				}

				// @@protoc_insertion_point(builder_scope:ClientIdentification.NameValue)
			}

			// @@protoc_insertion_point(class_scope:ClientIdentification.NameValue)
			private static final WvProto2.ClientIdentification.NameValue DEFAULT_INSTANCE;
			static {
				DEFAULT_INSTANCE = new WvProto2.ClientIdentification.NameValue();
			}

			public static WvProto2.ClientIdentification.NameValue getDefaultInstance() {
				return DEFAULT_INSTANCE;
			}

			@java.lang.Deprecated public static final Parser<NameValue> PARSER = new AbstractParser<>() {
				@java.lang.Override
				public NameValue parsePartialFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
						throws InvalidProtocolBufferException {
					Builder builder = newBuilder();
					try {
						builder.mergeFrom(input, extensionRegistry);
					} catch (InvalidProtocolBufferException e) {
						throw e.setUnfinishedMessage(builder.buildPartial());
					} catch (UninitializedMessageException e) {
						throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
					} catch (java.io.IOException e) {
						throw new InvalidProtocolBufferException(e).setUnfinishedMessage(builder.buildPartial());
					}
					return builder.buildPartial();
				}
			};

			public static Parser<NameValue> parser() {
				return PARSER;
			}

			@java.lang.Override
			public Parser<NameValue> getParserForType() {
				return PARSER;
			}

			@java.lang.Override
			public WvProto2.ClientIdentification.NameValue getDefaultInstanceForType() {
				return DEFAULT_INSTANCE;
			}

		}

		public interface ClientCapabilitiesOrBuilder extends
				// @@protoc_insertion_point(interface_extends:ClientIdentification.ClientCapabilities)
				MessageOrBuilder {

			/**
			 * <code>optional bool client_token = 1 [default = false];</code>
			 * 
			 * @return Whether the clientToken field is set.
			 */
			boolean hasClientToken();

			/**
			 * <code>optional bool client_token = 1 [default = false];</code>
			 * 
			 * @return The clientToken.
			 */
			boolean getClientToken();

			/**
			 * <code>optional bool session_token = 2 [default = false];</code>
			 * 
			 * @return Whether the sessionToken field is set.
			 */
			boolean hasSessionToken();

			/**
			 * <code>optional bool session_token = 2 [default = false];</code>
			 * 
			 * @return The sessionToken.
			 */
			boolean getSessionToken();

			/**
			 * <code>optional bool video_resolution_constraints = 3 [default = false];</code>
			 * 
			 * @return Whether the videoResolutionConstraints field is set.
			 */
			boolean hasVideoResolutionConstraints();

			/**
			 * <code>optional bool video_resolution_constraints = 3 [default = false];</code>
			 * 
			 * @return The videoResolutionConstraints.
			 */
			boolean getVideoResolutionConstraints();

			/**
			 * <code>optional .ClientIdentification.ClientCapabilities.HdcpVersion max_hdcp_version = 4 [default = HDCP_NONE];</code>
			 * 
			 * @return Whether the maxHdcpVersion field is set.
			 */
			boolean hasMaxHdcpVersion();

			/**
			 * <code>optional .ClientIdentification.ClientCapabilities.HdcpVersion max_hdcp_version = 4 [default = HDCP_NONE];</code>
			 * 
			 * @return The maxHdcpVersion.
			 */
			WvProto2.ClientIdentification.ClientCapabilities.HdcpVersion getMaxHdcpVersion();

			/**
			 * <code>optional uint32 oem_crypto_api_version = 5;</code>
			 * 
			 * @return Whether the oemCryptoApiVersion field is set.
			 */
			boolean hasOemCryptoApiVersion();

			/**
			 * <code>optional uint32 oem_crypto_api_version = 5;</code>
			 * 
			 * @return The oemCryptoApiVersion.
			 */
			int getOemCryptoApiVersion();

			/**
			 * <pre>
			 * Client has hardware support for protecting the usage table, such as
			 * storing the generation number in secure memory.  For Details, see:
			 * Widevine Modular DRM Security Integration Guide for CENC
			 * </pre>
			 *
			 * <code>optional bool anti_rollback_usage_table = 6 [default = false];</code>
			 * 
			 * @return Whether the antiRollbackUsageTable field is set.
			 */
			boolean hasAntiRollbackUsageTable();

			/**
			 * <pre>
			 * Client has hardware support for protecting the usage table, such as
			 * storing the generation number in secure memory.  For Details, see:
			 * Widevine Modular DRM Security Integration Guide for CENC
			 * </pre>
			 *
			 * <code>optional bool anti_rollback_usage_table = 6 [default = false];</code>
			 * 
			 * @return The antiRollbackUsageTable.
			 */
			boolean getAntiRollbackUsageTable();

			/**
			 * <pre>
			 * The client shall report |srm_version| if available.
			 * </pre>
			 *
			 * <code>optional uint32 srm_version = 7;</code>
			 * 
			 * @return Whether the srmVersion field is set.
			 */
			boolean hasSrmVersion();

			/**
			 * <pre>
			 * The client shall report |srm_version| if available.
			 * </pre>
			 *
			 * <code>optional uint32 srm_version = 7;</code>
			 * 
			 * @return The srmVersion.
			 */
			int getSrmVersion();

			/**
			 * <pre>
			 * A device may have SRM data, and report a version, but may not be capable
			 * of updating SRM data.
			 * </pre>
			 *
			 * <code>optional bool can_update_srm = 8 [default = false];</code>
			 * 
			 * @return Whether the canUpdateSrm field is set.
			 */
			boolean hasCanUpdateSrm();

			/**
			 * <pre>
			 * A device may have SRM data, and report a version, but may not be capable
			 * of updating SRM data.
			 * </pre>
			 *
			 * <code>optional bool can_update_srm = 8 [default = false];</code>
			 * 
			 * @return The canUpdateSrm.
			 */
			boolean getCanUpdateSrm();

			/**
			 * <code>repeated .ClientIdentification.ClientCapabilities.CertificateKeyType supported_certificate_key_type = 9;</code>
			 * 
			 * @return A list containing the supportedCertificateKeyType.
			 */
			java.util.List<WvProto2.ClientIdentification.ClientCapabilities.CertificateKeyType> getSupportedCertificateKeyTypeList();

			/**
			 * <code>repeated .ClientIdentification.ClientCapabilities.CertificateKeyType supported_certificate_key_type = 9;</code>
			 * 
			 * @return The count of supportedCertificateKeyType.
			 */
			int getSupportedCertificateKeyTypeCount();

			/**
			 * <code>repeated .ClientIdentification.ClientCapabilities.CertificateKeyType supported_certificate_key_type = 9;</code>
			 * 
			 * @param index The index of the element to return.
			 * @return The supportedCertificateKeyType at the given index.
			 */
			WvProto2.ClientIdentification.ClientCapabilities.CertificateKeyType getSupportedCertificateKeyType(
					int index);

			/**
			 * <code>optional .ClientIdentification.ClientCapabilities.AnalogOutputCapabilities analog_output_capabilities = 10 [default = ANALOG_OUTPUT_UNKNOWN];</code>
			 * 
			 * @return Whether the analogOutputCapabilities field is set.
			 */
			boolean hasAnalogOutputCapabilities();

			/**
			 * <code>optional .ClientIdentification.ClientCapabilities.AnalogOutputCapabilities analog_output_capabilities = 10 [default = ANALOG_OUTPUT_UNKNOWN];</code>
			 * 
			 * @return The analogOutputCapabilities.
			 */
			WvProto2.ClientIdentification.ClientCapabilities.AnalogOutputCapabilities getAnalogOutputCapabilities();

			/**
			 * <code>optional bool can_disable_analog_output = 11 [default = false];</code>
			 * 
			 * @return Whether the canDisableAnalogOutput field is set.
			 */
			boolean hasCanDisableAnalogOutput();

			/**
			 * <code>optional bool can_disable_analog_output = 11 [default = false];</code>
			 * 
			 * @return The canDisableAnalogOutput.
			 */
			boolean getCanDisableAnalogOutput();

			/**
			 * <pre>
			 * Clients can indicate a performance level supported by OEMCrypto.
			 * This will allow applications and providers to choose an appropriate
			 * quality of content to serve. Currently defined tiers are
			 * 1 (low), 2 (medium) and 3 (high). Any other value indicates that
			 * the resource rating is unavailable or reporting erroneous values
			 * for that device. For details see,
			 * Widevine Modular DRM Security Integration Guide for CENC
			 * </pre>
			 *
			 * <code>optional uint32 resource_rating_tier = 12 [default = 0];</code>
			 * 
			 * @return Whether the resourceRatingTier field is set.
			 */
			boolean hasResourceRatingTier();

			/**
			 * <pre>
			 * Clients can indicate a performance level supported by OEMCrypto.
			 * This will allow applications and providers to choose an appropriate
			 * quality of content to serve. Currently defined tiers are
			 * 1 (low), 2 (medium) and 3 (high). Any other value indicates that
			 * the resource rating is unavailable or reporting erroneous values
			 * for that device. For details see,
			 * Widevine Modular DRM Security Integration Guide for CENC
			 * </pre>
			 *
			 * <code>optional uint32 resource_rating_tier = 12 [default = 0];</code>
			 * 
			 * @return The resourceRatingTier.
			 */
			int getResourceRatingTier();
		}

		/**
		 * <pre>
		 * Capabilities which not all clients may support. Used for the license
		 * exchange protocol only.
		 * </pre>
		 *
		 * Protobuf type {@code ClientIdentification.ClientCapabilities}
		 */
		public static final class ClientCapabilities extends GeneratedMessageV3 implements
				// @@protoc_insertion_point(message_implements:ClientIdentification.ClientCapabilities)
				ClientCapabilitiesOrBuilder {
			private static final long serialVersionUID = 0L;

			// Use ClientCapabilities.newBuilder() to construct.
			private ClientCapabilities(GeneratedMessageV3.Builder<?> builder) {
				super(builder);
			}

			private ClientCapabilities() {
				maxHdcpVersion_ = 0;
				supportedCertificateKeyType_ = java.util.Collections.emptyList();
				analogOutputCapabilities_ = 0;
			}

			@java.lang.Override

			protected java.lang.Object newInstance(UnusedPrivateParameter unused) {
				return new ClientCapabilities();
			}

			public static final Descriptors.Descriptor getDescriptor() {
				return WvProto2.internal_static_ClientIdentification_ClientCapabilities_descriptor;
			}

			@java.lang.Override
			protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
				return WvProto2.internal_static_ClientIdentification_ClientCapabilities_fieldAccessorTable
						.ensureFieldAccessorsInitialized(
								WvProto2.ClientIdentification.ClientCapabilities.class,
								WvProto2.ClientIdentification.ClientCapabilities.Builder.class);
			}

			/**
			 * Protobuf enum {@code ClientIdentification.ClientCapabilities.HdcpVersion}
			 */
			public enum HdcpVersion implements ProtocolMessageEnum {
				/**
				 * <code>HDCP_NONE = 0;</code>
				 */
				HDCP_NONE(0),
				/**
				 * <code>HDCP_V1 = 1;</code>
				 */
				HDCP_V1(1),
				/**
				 * <code>HDCP_V2 = 2;</code>
				 */
				HDCP_V2(2),
				/**
				 * <code>HDCP_V2_1 = 3;</code>
				 */
				HDCP_V2_1(3),
				/**
				 * <code>HDCP_V2_2 = 4;</code>
				 */
				HDCP_V2_2(4),
				/**
				 * <code>HDCP_V2_3 = 5;</code>
				 */
				HDCP_V2_3(5),
				/**
				 * <code>HDCP_NO_DIGITAL_OUTPUT = 255;</code>
				 */
				HDCP_NO_DIGITAL_OUTPUT(255),;

				/**
				 * <code>HDCP_NONE = 0;</code>
				 */
				public static final int HDCP_NONE_VALUE = 0;
				/**
				 * <code>HDCP_V1 = 1;</code>
				 */
				public static final int HDCP_V1_VALUE = 1;
				/**
				 * <code>HDCP_V2 = 2;</code>
				 */
				public static final int HDCP_V2_VALUE = 2;
				/**
				 * <code>HDCP_V2_1 = 3;</code>
				 */
				public static final int HDCP_V2_1_VALUE = 3;
				/**
				 * <code>HDCP_V2_2 = 4;</code>
				 */
				public static final int HDCP_V2_2_VALUE = 4;
				/**
				 * <code>HDCP_V2_3 = 5;</code>
				 */
				public static final int HDCP_V2_3_VALUE = 5;
				/**
				 * <code>HDCP_NO_DIGITAL_OUTPUT = 255;</code>
				 */
				public static final int HDCP_NO_DIGITAL_OUTPUT_VALUE = 255;

				@Override
				public final int getNumber() {
					return value;
				}

				/**
				 * @param value The numeric wire value of the corresponding enum entry.
				 * @return The enum associated with the given numeric wire value.
				 * @deprecated Use {@link #forNumber(int)} instead.
				 */
				@java.lang.Deprecated
				public static HdcpVersion valueOf(int value) {
					return forNumber(value);
				}

				/**
				 * @param value The numeric wire value of the corresponding enum entry.
				 * @return The enum associated with the given numeric wire value.
				 */
				public static HdcpVersion forNumber(int value) {
					switch (value) {
					case 0:
						return HDCP_NONE;
					case 1:
						return HDCP_V1;
					case 2:
						return HDCP_V2;
					case 3:
						return HDCP_V2_1;
					case 4:
						return HDCP_V2_2;
					case 5:
						return HDCP_V2_3;
					case 255:
						return HDCP_NO_DIGITAL_OUTPUT;
					default:
						return null;
					}
				}

				public static Internal.EnumLiteMap<HdcpVersion> internalGetValueMap() {
					return internalValueMap;
				}

				private static final Internal.EnumLiteMap<HdcpVersion> internalValueMap = new Internal.EnumLiteMap<>() {
					@Override
					public HdcpVersion findValueByNumber(int number) {
						return HdcpVersion.forNumber(number);
					}
				};

				@Override
				public final Descriptors.EnumValueDescriptor getValueDescriptor() {
					return getDescriptor().getValues().get(ordinal());
				}

				@Override
				public final Descriptors.EnumDescriptor getDescriptorForType() {
					return getDescriptor();
				}

				public static final Descriptors.EnumDescriptor getDescriptor() {
					return WvProto2.ClientIdentification.ClientCapabilities.getDescriptor()
							.getEnumTypes().get(0);
				}

				private static final HdcpVersion[] VALUES = values();

				public static HdcpVersion valueOf(Descriptors.EnumValueDescriptor desc) {
					if (desc.getType() != getDescriptor()) {
						throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
					}
					return VALUES[desc.getIndex()];
				}

				private final int value;

				private HdcpVersion(int value) {
					this.value = value;
				}

				// @@protoc_insertion_point(enum_scope:ClientIdentification.ClientCapabilities.HdcpVersion)
			}

			/**
			 * Protobuf enum
			 * {@code ClientIdentification.ClientCapabilities.CertificateKeyType}
			 */
			public enum CertificateKeyType implements ProtocolMessageEnum {
				/**
				 * <code>RSA_2048 = 0;</code>
				 */
				RSA_2048(0),
				/**
				 * <code>RSA_3072 = 1;</code>
				 */
				RSA_3072(1),
				/**
				 * <code>ECC_SECP256R1 = 2;</code>
				 */
				ECC_SECP256R1(2),
				/**
				 * <code>ECC_SECP384R1 = 3;</code>
				 */
				ECC_SECP384R1(3),
				/**
				 * <code>ECC_SECP521R1 = 4;</code>
				 */
				ECC_SECP521R1(4),;

				/**
				 * <code>RSA_2048 = 0;</code>
				 */
				public static final int RSA_2048_VALUE = 0;
				/**
				 * <code>RSA_3072 = 1;</code>
				 */
				public static final int RSA_3072_VALUE = 1;
				/**
				 * <code>ECC_SECP256R1 = 2;</code>
				 */
				public static final int ECC_SECP256R1_VALUE = 2;
				/**
				 * <code>ECC_SECP384R1 = 3;</code>
				 */
				public static final int ECC_SECP384R1_VALUE = 3;
				/**
				 * <code>ECC_SECP521R1 = 4;</code>
				 */
				public static final int ECC_SECP521R1_VALUE = 4;

				@Override
				public final int getNumber() {
					return value;
				}

				/**
				 * @param value The numeric wire value of the corresponding enum entry.
				 * @return The enum associated with the given numeric wire value.
				 * @deprecated Use {@link #forNumber(int)} instead.
				 */
				@java.lang.Deprecated
				public static CertificateKeyType valueOf(int value) {
					return forNumber(value);
				}

				/**
				 * @param value The numeric wire value of the corresponding enum entry.
				 * @return The enum associated with the given numeric wire value.
				 */
				public static CertificateKeyType forNumber(int value) {
					switch (value) {
					case 0:
						return RSA_2048;
					case 1:
						return RSA_3072;
					case 2:
						return ECC_SECP256R1;
					case 3:
						return ECC_SECP384R1;
					case 4:
						return ECC_SECP521R1;
					default:
						return null;
					}
				}

				public static Internal.EnumLiteMap<CertificateKeyType> internalGetValueMap() {
					return internalValueMap;
				}

				private static final Internal.EnumLiteMap<CertificateKeyType> internalValueMap = new Internal.EnumLiteMap<>() {
					@Override
					public CertificateKeyType findValueByNumber(int number) {
						return CertificateKeyType.forNumber(number);
					}
				};

				@Override
				public final Descriptors.EnumValueDescriptor getValueDescriptor() {
					return getDescriptor().getValues().get(ordinal());
				}

				@Override
				public final Descriptors.EnumDescriptor getDescriptorForType() {
					return getDescriptor();
				}

				public static final Descriptors.EnumDescriptor getDescriptor() {
					return WvProto2.ClientIdentification.ClientCapabilities.getDescriptor()
							.getEnumTypes().get(1);
				}

				private static final CertificateKeyType[] VALUES = values();

				public static CertificateKeyType valueOf(Descriptors.EnumValueDescriptor desc) {
					if (desc.getType() != getDescriptor()) {
						throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
					}
					return VALUES[desc.getIndex()];
				}

				private final int value;

				private CertificateKeyType(int value) {
					this.value = value;
				}

				// @@protoc_insertion_point(enum_scope:ClientIdentification.ClientCapabilities.CertificateKeyType)
			}

			/**
			 * Protobuf enum
			 * {@code ClientIdentification.ClientCapabilities.AnalogOutputCapabilities}
			 */
			public enum AnalogOutputCapabilities implements ProtocolMessageEnum {
				/**
				 * <code>ANALOG_OUTPUT_UNKNOWN = 0;</code>
				 */
				ANALOG_OUTPUT_UNKNOWN(0),
				/**
				 * <code>ANALOG_OUTPUT_NONE = 1;</code>
				 */
				ANALOG_OUTPUT_NONE(1),
				/**
				 * <code>ANALOG_OUTPUT_SUPPORTED = 2;</code>
				 */
				ANALOG_OUTPUT_SUPPORTED(2),
				/**
				 * <code>ANALOG_OUTPUT_SUPPORTS_CGMS_A = 3;</code>
				 */
				ANALOG_OUTPUT_SUPPORTS_CGMS_A(3),;

				/**
				 * <code>ANALOG_OUTPUT_UNKNOWN = 0;</code>
				 */
				public static final int ANALOG_OUTPUT_UNKNOWN_VALUE = 0;
				/**
				 * <code>ANALOG_OUTPUT_NONE = 1;</code>
				 */
				public static final int ANALOG_OUTPUT_NONE_VALUE = 1;
				/**
				 * <code>ANALOG_OUTPUT_SUPPORTED = 2;</code>
				 */
				public static final int ANALOG_OUTPUT_SUPPORTED_VALUE = 2;
				/**
				 * <code>ANALOG_OUTPUT_SUPPORTS_CGMS_A = 3;</code>
				 */
				public static final int ANALOG_OUTPUT_SUPPORTS_CGMS_A_VALUE = 3;

				@Override
				public final int getNumber() {
					return value;
				}

				/**
				 * @param value The numeric wire value of the corresponding enum entry.
				 * @return The enum associated with the given numeric wire value.
				 * @deprecated Use {@link #forNumber(int)} instead.
				 */
				@java.lang.Deprecated
				public static AnalogOutputCapabilities valueOf(int value) {
					return forNumber(value);
				}

				/**
				 * @param value The numeric wire value of the corresponding enum entry.
				 * @return The enum associated with the given numeric wire value.
				 */
				public static AnalogOutputCapabilities forNumber(int value) {
					switch (value) {
					case 0:
						return ANALOG_OUTPUT_UNKNOWN;
					case 1:
						return ANALOG_OUTPUT_NONE;
					case 2:
						return ANALOG_OUTPUT_SUPPORTED;
					case 3:
						return ANALOG_OUTPUT_SUPPORTS_CGMS_A;
					default:
						return null;
					}
				}

				public static Internal.EnumLiteMap<AnalogOutputCapabilities> internalGetValueMap() {
					return internalValueMap;
				}

				private static final Internal.EnumLiteMap<AnalogOutputCapabilities> internalValueMap = new Internal.EnumLiteMap<>() {
					@Override
					public AnalogOutputCapabilities findValueByNumber(int number) {
						return AnalogOutputCapabilities.forNumber(number);
					}
				};

				@Override
				public final Descriptors.EnumValueDescriptor getValueDescriptor() {
					return getDescriptor().getValues().get(ordinal());
				}

				@Override
				public final Descriptors.EnumDescriptor getDescriptorForType() {
					return getDescriptor();
				}

				public static final Descriptors.EnumDescriptor getDescriptor() {
					return WvProto2.ClientIdentification.ClientCapabilities.getDescriptor()
							.getEnumTypes().get(2);
				}

				private static final AnalogOutputCapabilities[] VALUES = values();

				public static AnalogOutputCapabilities valueOf(Descriptors.EnumValueDescriptor desc) {
					if (desc.getType() != getDescriptor()) {
						throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
					}
					return VALUES[desc.getIndex()];
				}

				private final int value;

				private AnalogOutputCapabilities(int value) {
					this.value = value;
				}

				// @@protoc_insertion_point(enum_scope:ClientIdentification.ClientCapabilities.AnalogOutputCapabilities)
			}

			private int bitField0_;
			public static final int CLIENT_TOKEN_FIELD_NUMBER = 1;
			private boolean clientToken_ = false;

			/**
			 * <code>optional bool client_token = 1 [default = false];</code>
			 * 
			 * @return Whether the clientToken field is set.
			 */
			@java.lang.Override
			public boolean hasClientToken() {
				return ((bitField0_ & 0x00000001) != 0);
			}

			/**
			 * <code>optional bool client_token = 1 [default = false];</code>
			 * 
			 * @return The clientToken.
			 */
			@java.lang.Override
			public boolean getClientToken() {
				return clientToken_;
			}

			public static final int SESSION_TOKEN_FIELD_NUMBER = 2;
			private boolean sessionToken_ = false;

			/**
			 * <code>optional bool session_token = 2 [default = false];</code>
			 * 
			 * @return Whether the sessionToken field is set.
			 */
			@java.lang.Override
			public boolean hasSessionToken() {
				return ((bitField0_ & 0x00000002) != 0);
			}

			/**
			 * <code>optional bool session_token = 2 [default = false];</code>
			 * 
			 * @return The sessionToken.
			 */
			@java.lang.Override
			public boolean getSessionToken() {
				return sessionToken_;
			}

			public static final int VIDEO_RESOLUTION_CONSTRAINTS_FIELD_NUMBER = 3;
			private boolean videoResolutionConstraints_ = false;

			/**
			 * <code>optional bool video_resolution_constraints = 3 [default = false];</code>
			 * 
			 * @return Whether the videoResolutionConstraints field is set.
			 */
			@java.lang.Override
			public boolean hasVideoResolutionConstraints() {
				return ((bitField0_ & 0x00000004) != 0);
			}

			/**
			 * <code>optional bool video_resolution_constraints = 3 [default = false];</code>
			 * 
			 * @return The videoResolutionConstraints.
			 */
			@java.lang.Override
			public boolean getVideoResolutionConstraints() {
				return videoResolutionConstraints_;
			}

			public static final int MAX_HDCP_VERSION_FIELD_NUMBER = 4;
			private int maxHdcpVersion_ = 0;

			/**
			 * <code>optional .ClientIdentification.ClientCapabilities.HdcpVersion max_hdcp_version = 4 [default = HDCP_NONE];</code>
			 * 
			 * @return Whether the maxHdcpVersion field is set.
			 */
			@java.lang.Override
			public boolean hasMaxHdcpVersion() {
				return ((bitField0_ & 0x00000008) != 0);
			}

			/**
			 * <code>optional .ClientIdentification.ClientCapabilities.HdcpVersion max_hdcp_version = 4 [default = HDCP_NONE];</code>
			 * 
			 * @return The maxHdcpVersion.
			 */
			@java.lang.Override
			public WvProto2.ClientIdentification.ClientCapabilities.HdcpVersion getMaxHdcpVersion() {
				WvProto2.ClientIdentification.ClientCapabilities.HdcpVersion result = WvProto2.ClientIdentification.ClientCapabilities.HdcpVersion
						.forNumber(maxHdcpVersion_);
				return result == null
						? WvProto2.ClientIdentification.ClientCapabilities.HdcpVersion.HDCP_NONE
						: result;
			}

			public static final int OEM_CRYPTO_API_VERSION_FIELD_NUMBER = 5;
			private int oemCryptoApiVersion_ = 0;

			/**
			 * <code>optional uint32 oem_crypto_api_version = 5;</code>
			 * 
			 * @return Whether the oemCryptoApiVersion field is set.
			 */
			@java.lang.Override
			public boolean hasOemCryptoApiVersion() {
				return ((bitField0_ & 0x00000010) != 0);
			}

			/**
			 * <code>optional uint32 oem_crypto_api_version = 5;</code>
			 * 
			 * @return The oemCryptoApiVersion.
			 */
			@java.lang.Override
			public int getOemCryptoApiVersion() {
				return oemCryptoApiVersion_;
			}

			public static final int ANTI_ROLLBACK_USAGE_TABLE_FIELD_NUMBER = 6;
			private boolean antiRollbackUsageTable_ = false;

			/**
			 * <pre>
			 * Client has hardware support for protecting the usage table, such as
			 * storing the generation number in secure memory.  For Details, see:
			 * Widevine Modular DRM Security Integration Guide for CENC
			 * </pre>
			 *
			 * <code>optional bool anti_rollback_usage_table = 6 [default = false];</code>
			 * 
			 * @return Whether the antiRollbackUsageTable field is set.
			 */
			@java.lang.Override
			public boolean hasAntiRollbackUsageTable() {
				return ((bitField0_ & 0x00000020) != 0);
			}

			/**
			 * <pre>
			 * Client has hardware support for protecting the usage table, such as
			 * storing the generation number in secure memory.  For Details, see:
			 * Widevine Modular DRM Security Integration Guide for CENC
			 * </pre>
			 *
			 * <code>optional bool anti_rollback_usage_table = 6 [default = false];</code>
			 * 
			 * @return The antiRollbackUsageTable.
			 */
			@java.lang.Override
			public boolean getAntiRollbackUsageTable() {
				return antiRollbackUsageTable_;
			}

			public static final int SRM_VERSION_FIELD_NUMBER = 7;
			private int srmVersion_ = 0;

			/**
			 * <pre>
			 * The client shall report |srm_version| if available.
			 * </pre>
			 *
			 * <code>optional uint32 srm_version = 7;</code>
			 * 
			 * @return Whether the srmVersion field is set.
			 */
			@java.lang.Override
			public boolean hasSrmVersion() {
				return ((bitField0_ & 0x00000040) != 0);
			}

			/**
			 * <pre>
			 * The client shall report |srm_version| if available.
			 * </pre>
			 *
			 * <code>optional uint32 srm_version = 7;</code>
			 * 
			 * @return The srmVersion.
			 */
			@java.lang.Override
			public int getSrmVersion() {
				return srmVersion_;
			}

			public static final int CAN_UPDATE_SRM_FIELD_NUMBER = 8;
			private boolean canUpdateSrm_ = false;

			/**
			 * <pre>
			 * A device may have SRM data, and report a version, but may not be capable
			 * of updating SRM data.
			 * </pre>
			 *
			 * <code>optional bool can_update_srm = 8 [default = false];</code>
			 * 
			 * @return Whether the canUpdateSrm field is set.
			 */
			@java.lang.Override
			public boolean hasCanUpdateSrm() {
				return ((bitField0_ & 0x00000080) != 0);
			}

			/**
			 * <pre>
			 * A device may have SRM data, and report a version, but may not be capable
			 * of updating SRM data.
			 * </pre>
			 *
			 * <code>optional bool can_update_srm = 8 [default = false];</code>
			 * 
			 * @return The canUpdateSrm.
			 */
			@java.lang.Override
			public boolean getCanUpdateSrm() {
				return canUpdateSrm_;
			}

			public static final int SUPPORTED_CERTIFICATE_KEY_TYPE_FIELD_NUMBER = 9;

			private java.util.List<java.lang.Integer> supportedCertificateKeyType_;
			private static final Internal.ListAdapter.Converter<java.lang.Integer, WvProto2.ClientIdentification.ClientCapabilities.CertificateKeyType> supportedCertificateKeyType_converter_ = new Internal.ListAdapter.Converter<>() {
				@Override
				public WvProto2.ClientIdentification.ClientCapabilities.CertificateKeyType convert(
						java.lang.Integer from) {
					WvProto2.ClientIdentification.ClientCapabilities.CertificateKeyType result = WvProto2.ClientIdentification.ClientCapabilities.CertificateKeyType
							.forNumber(from);
					return result == null
							? WvProto2.ClientIdentification.ClientCapabilities.CertificateKeyType.RSA_2048
							: result;
				}
			};

			/**
			 * <code>repeated .ClientIdentification.ClientCapabilities.CertificateKeyType supported_certificate_key_type = 9;</code>
			 * 
			 * @return A list containing the supportedCertificateKeyType.
			 */
			@java.lang.Override
			public java.util.List<WvProto2.ClientIdentification.ClientCapabilities.CertificateKeyType> getSupportedCertificateKeyTypeList() {
				return new Internal.ListAdapter<>(supportedCertificateKeyType_, supportedCertificateKeyType_converter_);
			}

			/**
			 * <code>repeated .ClientIdentification.ClientCapabilities.CertificateKeyType supported_certificate_key_type = 9;</code>
			 * 
			 * @return The count of supportedCertificateKeyType.
			 */
			@java.lang.Override
			public int getSupportedCertificateKeyTypeCount() {
				return supportedCertificateKeyType_.size();
			}

			/**
			 * <code>repeated .ClientIdentification.ClientCapabilities.CertificateKeyType supported_certificate_key_type = 9;</code>
			 * 
			 * @param index The index of the element to return.
			 * @return The supportedCertificateKeyType at the given index.
			 */
			@java.lang.Override
			public WvProto2.ClientIdentification.ClientCapabilities.CertificateKeyType getSupportedCertificateKeyType(
					int index) {
				return supportedCertificateKeyType_converter_.convert(supportedCertificateKeyType_.get(index));
			}

			public static final int ANALOG_OUTPUT_CAPABILITIES_FIELD_NUMBER = 10;
			private int analogOutputCapabilities_ = 0;

			/**
			 * <code>optional .ClientIdentification.ClientCapabilities.AnalogOutputCapabilities analog_output_capabilities = 10 [default = ANALOG_OUTPUT_UNKNOWN];</code>
			 * 
			 * @return Whether the analogOutputCapabilities field is set.
			 */
			@java.lang.Override
			public boolean hasAnalogOutputCapabilities() {
				return ((bitField0_ & 0x00000100) != 0);
			}

			/**
			 * <code>optional .ClientIdentification.ClientCapabilities.AnalogOutputCapabilities analog_output_capabilities = 10 [default = ANALOG_OUTPUT_UNKNOWN];</code>
			 * 
			 * @return The analogOutputCapabilities.
			 */
			@java.lang.Override
			public WvProto2.ClientIdentification.ClientCapabilities.AnalogOutputCapabilities getAnalogOutputCapabilities() {
				WvProto2.ClientIdentification.ClientCapabilities.AnalogOutputCapabilities result = WvProto2.ClientIdentification.ClientCapabilities.AnalogOutputCapabilities
						.forNumber(analogOutputCapabilities_);
				return result == null
						? WvProto2.ClientIdentification.ClientCapabilities.AnalogOutputCapabilities.ANALOG_OUTPUT_UNKNOWN
						: result;
			}

			public static final int CAN_DISABLE_ANALOG_OUTPUT_FIELD_NUMBER = 11;
			private boolean canDisableAnalogOutput_ = false;

			/**
			 * <code>optional bool can_disable_analog_output = 11 [default = false];</code>
			 * 
			 * @return Whether the canDisableAnalogOutput field is set.
			 */
			@java.lang.Override
			public boolean hasCanDisableAnalogOutput() {
				return ((bitField0_ & 0x00000200) != 0);
			}

			/**
			 * <code>optional bool can_disable_analog_output = 11 [default = false];</code>
			 * 
			 * @return The canDisableAnalogOutput.
			 */
			@java.lang.Override
			public boolean getCanDisableAnalogOutput() {
				return canDisableAnalogOutput_;
			}

			public static final int RESOURCE_RATING_TIER_FIELD_NUMBER = 12;
			private int resourceRatingTier_ = 0;

			/**
			 * <pre>
			 * Clients can indicate a performance level supported by OEMCrypto.
			 * This will allow applications and providers to choose an appropriate
			 * quality of content to serve. Currently defined tiers are
			 * 1 (low), 2 (medium) and 3 (high). Any other value indicates that
			 * the resource rating is unavailable or reporting erroneous values
			 * for that device. For details see,
			 * Widevine Modular DRM Security Integration Guide for CENC
			 * </pre>
			 *
			 * <code>optional uint32 resource_rating_tier = 12 [default = 0];</code>
			 * 
			 * @return Whether the resourceRatingTier field is set.
			 */
			@java.lang.Override
			public boolean hasResourceRatingTier() {
				return ((bitField0_ & 0x00000400) != 0);
			}

			/**
			 * <pre>
			 * Clients can indicate a performance level supported by OEMCrypto.
			 * This will allow applications and providers to choose an appropriate
			 * quality of content to serve. Currently defined tiers are
			 * 1 (low), 2 (medium) and 3 (high). Any other value indicates that
			 * the resource rating is unavailable or reporting erroneous values
			 * for that device. For details see,
			 * Widevine Modular DRM Security Integration Guide for CENC
			 * </pre>
			 *
			 * <code>optional uint32 resource_rating_tier = 12 [default = 0];</code>
			 * 
			 * @return The resourceRatingTier.
			 */
			@java.lang.Override
			public int getResourceRatingTier() {
				return resourceRatingTier_;
			}

			private byte memoizedIsInitialized = -1;

			@java.lang.Override
			public final boolean isInitialized() {
				byte isInitialized = memoizedIsInitialized;
				if (isInitialized == 1)
					return true;
				if (isInitialized == 0)
					return false;

				memoizedIsInitialized = 1;
				return true;
			}

			@java.lang.Override
			public void writeTo(CodedOutputStream output) throws java.io.IOException {
				if (((bitField0_ & 0x00000001) != 0)) {
					output.writeBool(1, clientToken_);
				}
				if (((bitField0_ & 0x00000002) != 0)) {
					output.writeBool(2, sessionToken_);
				}
				if (((bitField0_ & 0x00000004) != 0)) {
					output.writeBool(3, videoResolutionConstraints_);
				}
				if (((bitField0_ & 0x00000008) != 0)) {
					output.writeEnum(4, maxHdcpVersion_);
				}
				if (((bitField0_ & 0x00000010) != 0)) {
					output.writeUInt32(5, oemCryptoApiVersion_);
				}
				if (((bitField0_ & 0x00000020) != 0)) {
					output.writeBool(6, antiRollbackUsageTable_);
				}
				if (((bitField0_ & 0x00000040) != 0)) {
					output.writeUInt32(7, srmVersion_);
				}
				if (((bitField0_ & 0x00000080) != 0)) {
					output.writeBool(8, canUpdateSrm_);
				}
				for (int i = 0; i < supportedCertificateKeyType_.size(); i++) {
					output.writeEnum(9, supportedCertificateKeyType_.get(i));
				}
				if (((bitField0_ & 0x00000100) != 0)) {
					output.writeEnum(10, analogOutputCapabilities_);
				}
				if (((bitField0_ & 0x00000200) != 0)) {
					output.writeBool(11, canDisableAnalogOutput_);
				}
				if (((bitField0_ & 0x00000400) != 0)) {
					output.writeUInt32(12, resourceRatingTier_);
				}
				getUnknownFields().writeTo(output);
			}

			@java.lang.Override
			public int getSerializedSize() {
				int size = memoizedSize;
				if (size != -1)
					return size;

				size = 0;
				if (((bitField0_ & 0x00000001) != 0)) {
					size += CodedOutputStream.computeBoolSize(1, clientToken_);
				}
				if (((bitField0_ & 0x00000002) != 0)) {
					size += CodedOutputStream.computeBoolSize(2, sessionToken_);
				}
				if (((bitField0_ & 0x00000004) != 0)) {
					size += CodedOutputStream.computeBoolSize(3, videoResolutionConstraints_);
				}
				if (((bitField0_ & 0x00000008) != 0)) {
					size += CodedOutputStream.computeEnumSize(4, maxHdcpVersion_);
				}
				if (((bitField0_ & 0x00000010) != 0)) {
					size += CodedOutputStream.computeUInt32Size(5, oemCryptoApiVersion_);
				}
				if (((bitField0_ & 0x00000020) != 0)) {
					size += CodedOutputStream.computeBoolSize(6, antiRollbackUsageTable_);
				}
				if (((bitField0_ & 0x00000040) != 0)) {
					size += CodedOutputStream.computeUInt32Size(7, srmVersion_);
				}
				if (((bitField0_ & 0x00000080) != 0)) {
					size += CodedOutputStream.computeBoolSize(8, canUpdateSrm_);
				}
				{
					int dataSize = 0;
					for (int i = 0; i < supportedCertificateKeyType_.size(); i++) {
						dataSize += CodedOutputStream.computeEnumSizeNoTag(supportedCertificateKeyType_.get(i));
					}
					size += dataSize;
					size += 1 * supportedCertificateKeyType_.size();
				}
				if (((bitField0_ & 0x00000100) != 0)) {
					size += CodedOutputStream.computeEnumSize(10, analogOutputCapabilities_);
				}
				if (((bitField0_ & 0x00000200) != 0)) {
					size += CodedOutputStream.computeBoolSize(11, canDisableAnalogOutput_);
				}
				if (((bitField0_ & 0x00000400) != 0)) {
					size += CodedOutputStream.computeUInt32Size(12, resourceRatingTier_);
				}
				size += getUnknownFields().getSerializedSize();
				memoizedSize = size;
				return size;
			}

			@java.lang.Override
			public boolean equals(final java.lang.Object obj) {
				if (obj == this) {
					return true;
				}
				if (!(obj instanceof WvProto2.ClientIdentification.ClientCapabilities)) {
					return super.equals(obj);
				}
				WvProto2.ClientIdentification.ClientCapabilities other = (WvProto2.ClientIdentification.ClientCapabilities) obj;

				if (hasClientToken() != other.hasClientToken())
					return false;
				if (hasClientToken()) {
					if (getClientToken() != other.getClientToken())
						return false;
				}
				if (hasSessionToken() != other.hasSessionToken())
					return false;
				if (hasSessionToken()) {
					if (getSessionToken() != other.getSessionToken())
						return false;
				}
				if (hasVideoResolutionConstraints() != other.hasVideoResolutionConstraints())
					return false;
				if (hasVideoResolutionConstraints()) {
					if (getVideoResolutionConstraints() != other.getVideoResolutionConstraints())
						return false;
				}
				if (hasMaxHdcpVersion() != other.hasMaxHdcpVersion())
					return false;
				if (hasMaxHdcpVersion()) {
					if (maxHdcpVersion_ != other.maxHdcpVersion_)
						return false;
				}
				if (hasOemCryptoApiVersion() != other.hasOemCryptoApiVersion())
					return false;
				if (hasOemCryptoApiVersion()) {
					if (getOemCryptoApiVersion() != other.getOemCryptoApiVersion())
						return false;
				}
				if (hasAntiRollbackUsageTable() != other.hasAntiRollbackUsageTable())
					return false;
				if (hasAntiRollbackUsageTable()) {
					if (getAntiRollbackUsageTable() != other.getAntiRollbackUsageTable())
						return false;
				}
				if (hasSrmVersion() != other.hasSrmVersion())
					return false;
				if (hasSrmVersion()) {
					if (getSrmVersion() != other.getSrmVersion())
						return false;
				}
				if (hasCanUpdateSrm() != other.hasCanUpdateSrm())
					return false;
				if (hasCanUpdateSrm()) {
					if (getCanUpdateSrm() != other.getCanUpdateSrm())
						return false;
				}
				if (!supportedCertificateKeyType_.equals(other.supportedCertificateKeyType_))
					return false;
				if (hasAnalogOutputCapabilities() != other.hasAnalogOutputCapabilities())
					return false;
				if (hasAnalogOutputCapabilities()) {
					if (analogOutputCapabilities_ != other.analogOutputCapabilities_)
						return false;
				}
				if (hasCanDisableAnalogOutput() != other.hasCanDisableAnalogOutput())
					return false;
				if (hasCanDisableAnalogOutput()) {
					if (getCanDisableAnalogOutput() != other.getCanDisableAnalogOutput())
						return false;
				}
				if (hasResourceRatingTier() != other.hasResourceRatingTier())
					return false;
				if (hasResourceRatingTier()) {
					if (getResourceRatingTier() != other.getResourceRatingTier())
						return false;
				}
				if (!getUnknownFields().equals(other.getUnknownFields()))
					return false;
				return true;
			}

			@SuppressWarnings("unchecked")
			@java.lang.Override
			public int hashCode() {
				if (memoizedHashCode != 0) {
					return memoizedHashCode;
				}
				int hash = 41;
				hash = (19 * hash) + getDescriptor().hashCode();
				if (hasClientToken()) {
					hash = (37 * hash) + CLIENT_TOKEN_FIELD_NUMBER;
					hash = (53 * hash) + Internal.hashBoolean(getClientToken());
				}
				if (hasSessionToken()) {
					hash = (37 * hash) + SESSION_TOKEN_FIELD_NUMBER;
					hash = (53 * hash) + Internal.hashBoolean(getSessionToken());
				}
				if (hasVideoResolutionConstraints()) {
					hash = (37 * hash) + VIDEO_RESOLUTION_CONSTRAINTS_FIELD_NUMBER;
					hash = (53 * hash) + Internal.hashBoolean(getVideoResolutionConstraints());
				}
				if (hasMaxHdcpVersion()) {
					hash = (37 * hash) + MAX_HDCP_VERSION_FIELD_NUMBER;
					hash = (53 * hash) + maxHdcpVersion_;
				}
				if (hasOemCryptoApiVersion()) {
					hash = (37 * hash) + OEM_CRYPTO_API_VERSION_FIELD_NUMBER;
					hash = (53 * hash) + getOemCryptoApiVersion();
				}
				if (hasAntiRollbackUsageTable()) {
					hash = (37 * hash) + ANTI_ROLLBACK_USAGE_TABLE_FIELD_NUMBER;
					hash = (53 * hash) + Internal.hashBoolean(getAntiRollbackUsageTable());
				}
				if (hasSrmVersion()) {
					hash = (37 * hash) + SRM_VERSION_FIELD_NUMBER;
					hash = (53 * hash) + getSrmVersion();
				}
				if (hasCanUpdateSrm()) {
					hash = (37 * hash) + CAN_UPDATE_SRM_FIELD_NUMBER;
					hash = (53 * hash) + Internal.hashBoolean(getCanUpdateSrm());
				}
				if (getSupportedCertificateKeyTypeCount() > 0) {
					hash = (37 * hash) + SUPPORTED_CERTIFICATE_KEY_TYPE_FIELD_NUMBER;
					hash = (53 * hash) + supportedCertificateKeyType_.hashCode();
				}
				if (hasAnalogOutputCapabilities()) {
					hash = (37 * hash) + ANALOG_OUTPUT_CAPABILITIES_FIELD_NUMBER;
					hash = (53 * hash) + analogOutputCapabilities_;
				}
				if (hasCanDisableAnalogOutput()) {
					hash = (37 * hash) + CAN_DISABLE_ANALOG_OUTPUT_FIELD_NUMBER;
					hash = (53 * hash) + Internal.hashBoolean(getCanDisableAnalogOutput());
				}
				if (hasResourceRatingTier()) {
					hash = (37 * hash) + RESOURCE_RATING_TIER_FIELD_NUMBER;
					hash = (53 * hash) + getResourceRatingTier();
				}
				hash = (29 * hash) + getUnknownFields().hashCode();
				memoizedHashCode = hash;
				return hash;
			}

			public static WvProto2.ClientIdentification.ClientCapabilities parseFrom(
					java.nio.ByteBuffer data) throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data);
			}

			public static WvProto2.ClientIdentification.ClientCapabilities parseFrom(
					java.nio.ByteBuffer data, ExtensionRegistryLite extensionRegistry)
					throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data, extensionRegistry);
			}

			public static WvProto2.ClientIdentification.ClientCapabilities parseFrom(
					ByteString data) throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data);
			}

			public static WvProto2.ClientIdentification.ClientCapabilities parseFrom(
					ByteString data, ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data, extensionRegistry);
			}

			public static WvProto2.ClientIdentification.ClientCapabilities parseFrom(
					byte[] data) throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data);
			}

			public static WvProto2.ClientIdentification.ClientCapabilities parseFrom(
					byte[] data, ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data, extensionRegistry);
			}

			public static WvProto2.ClientIdentification.ClientCapabilities parseFrom(
					java.io.InputStream input) throws java.io.IOException {
				return GeneratedMessageV3.parseWithIOException(PARSER, input);
			}

			public static WvProto2.ClientIdentification.ClientCapabilities parseFrom(
					java.io.InputStream input, ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
				return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
			}

			public static WvProto2.ClientIdentification.ClientCapabilities parseDelimitedFrom(
					java.io.InputStream input) throws java.io.IOException {
				return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
			}

			public static WvProto2.ClientIdentification.ClientCapabilities parseDelimitedFrom(
					java.io.InputStream input, ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
				return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input, extensionRegistry);
			}

			public static WvProto2.ClientIdentification.ClientCapabilities parseFrom(
					CodedInputStream input) throws java.io.IOException {
				return GeneratedMessageV3.parseWithIOException(PARSER, input);
			}

			public static WvProto2.ClientIdentification.ClientCapabilities parseFrom(
					CodedInputStream input, ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
				return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
			}

			@java.lang.Override
			public Builder newBuilderForType() {
				return newBuilder();
			}

			public static Builder newBuilder() {
				return DEFAULT_INSTANCE.toBuilder();
			}

			public static Builder newBuilder(
					WvProto2.ClientIdentification.ClientCapabilities prototype) {
				return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
			}

			@java.lang.Override
			public Builder toBuilder() {
				return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
			}

			@java.lang.Override
			protected Builder newBuilderForType(GeneratedMessageV3.BuilderParent parent) {
				Builder builder = new Builder(parent);
				return builder;
			}

			/**
			 * <pre>
			 * Capabilities which not all clients may support. Used for the license
			 * exchange protocol only.
			 * </pre>
			 *
			 * Protobuf type {@code ClientIdentification.ClientCapabilities}
			 */
			public static final class Builder extends GeneratedMessageV3.Builder<Builder> implements
					// @@protoc_insertion_point(builder_implements:ClientIdentification.ClientCapabilities)
					WvProto2.ClientIdentification.ClientCapabilitiesOrBuilder {
				public static final Descriptors.Descriptor getDescriptor() {
					return WvProto2.internal_static_ClientIdentification_ClientCapabilities_descriptor;
				}

				@java.lang.Override
				protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
					return WvProto2.internal_static_ClientIdentification_ClientCapabilities_fieldAccessorTable
							.ensureFieldAccessorsInitialized(
									WvProto2.ClientIdentification.ClientCapabilities.class,
									WvProto2.ClientIdentification.ClientCapabilities.Builder.class);
				}

				// Construct using
				// WvProto2.ClientIdentification.ClientCapabilities.newBuilder()
				private Builder() {

				}

				private Builder(GeneratedMessageV3.BuilderParent parent) {
					super(parent);

				}

				@java.lang.Override
				public Builder clear() {
					super.clear();
					bitField0_ = 0;
					clientToken_ = false;
					sessionToken_ = false;
					videoResolutionConstraints_ = false;
					maxHdcpVersion_ = 0;
					oemCryptoApiVersion_ = 0;
					antiRollbackUsageTable_ = false;
					srmVersion_ = 0;
					canUpdateSrm_ = false;
					supportedCertificateKeyType_ = java.util.Collections.emptyList();
					bitField0_ = (bitField0_ & ~0x00000100);
					analogOutputCapabilities_ = 0;
					canDisableAnalogOutput_ = false;
					resourceRatingTier_ = 0;
					return this;
				}

				@java.lang.Override
				public Descriptors.Descriptor getDescriptorForType() {
					return WvProto2.internal_static_ClientIdentification_ClientCapabilities_descriptor;
				}

				@java.lang.Override
				public WvProto2.ClientIdentification.ClientCapabilities getDefaultInstanceForType() {
					return WvProto2.ClientIdentification.ClientCapabilities
							.getDefaultInstance();
				}

				@java.lang.Override
				public WvProto2.ClientIdentification.ClientCapabilities build() {
					WvProto2.ClientIdentification.ClientCapabilities result = buildPartial();
					if (!result.isInitialized()) {
						throw newUninitializedMessageException(result);
					}
					return result;
				}

				@java.lang.Override
				public WvProto2.ClientIdentification.ClientCapabilities buildPartial() {
					WvProto2.ClientIdentification.ClientCapabilities result = new WvProto2.ClientIdentification.ClientCapabilities(
							this);
					buildPartialRepeatedFields(result);
					if (bitField0_ != 0) {
						buildPartial0(result);
					}
					onBuilt();
					return result;
				}

				private void buildPartialRepeatedFields(
						WvProto2.ClientIdentification.ClientCapabilities result) {
					if (((bitField0_ & 0x00000100) != 0)) {
						supportedCertificateKeyType_ = java.util.Collections
								.unmodifiableList(supportedCertificateKeyType_);
						bitField0_ = (bitField0_ & ~0x00000100);
					}
					result.supportedCertificateKeyType_ = supportedCertificateKeyType_;
				}

				private void buildPartial0(
						WvProto2.ClientIdentification.ClientCapabilities result) {
					int from_bitField0_ = bitField0_;
					int to_bitField0_ = 0;
					if (((from_bitField0_ & 0x00000001) != 0)) {
						result.clientToken_ = clientToken_;
						to_bitField0_ |= 0x00000001;
					}
					if (((from_bitField0_ & 0x00000002) != 0)) {
						result.sessionToken_ = sessionToken_;
						to_bitField0_ |= 0x00000002;
					}
					if (((from_bitField0_ & 0x00000004) != 0)) {
						result.videoResolutionConstraints_ = videoResolutionConstraints_;
						to_bitField0_ |= 0x00000004;
					}
					if (((from_bitField0_ & 0x00000008) != 0)) {
						result.maxHdcpVersion_ = maxHdcpVersion_;
						to_bitField0_ |= 0x00000008;
					}
					if (((from_bitField0_ & 0x00000010) != 0)) {
						result.oemCryptoApiVersion_ = oemCryptoApiVersion_;
						to_bitField0_ |= 0x00000010;
					}
					if (((from_bitField0_ & 0x00000020) != 0)) {
						result.antiRollbackUsageTable_ = antiRollbackUsageTable_;
						to_bitField0_ |= 0x00000020;
					}
					if (((from_bitField0_ & 0x00000040) != 0)) {
						result.srmVersion_ = srmVersion_;
						to_bitField0_ |= 0x00000040;
					}
					if (((from_bitField0_ & 0x00000080) != 0)) {
						result.canUpdateSrm_ = canUpdateSrm_;
						to_bitField0_ |= 0x00000080;
					}
					if (((from_bitField0_ & 0x00000200) != 0)) {
						result.analogOutputCapabilities_ = analogOutputCapabilities_;
						to_bitField0_ |= 0x00000100;
					}
					if (((from_bitField0_ & 0x00000400) != 0)) {
						result.canDisableAnalogOutput_ = canDisableAnalogOutput_;
						to_bitField0_ |= 0x00000200;
					}
					if (((from_bitField0_ & 0x00000800) != 0)) {
						result.resourceRatingTier_ = resourceRatingTier_;
						to_bitField0_ |= 0x00000400;
					}
					result.bitField0_ |= to_bitField0_;
				}

				@java.lang.Override
				public Builder mergeFrom(Message other) {
					if (other instanceof WvProto2.ClientIdentification.ClientCapabilities) {
						return mergeFrom(
								(WvProto2.ClientIdentification.ClientCapabilities) other);
					}
					super.mergeFrom(other);
					return this;
				}

				public Builder mergeFrom(
						WvProto2.ClientIdentification.ClientCapabilities other) {
					if (other == WvProto2.ClientIdentification.ClientCapabilities
							.getDefaultInstance())
						return this;
					if (other.hasClientToken()) {
						setClientToken(other.getClientToken());
					}
					if (other.hasSessionToken()) {
						setSessionToken(other.getSessionToken());
					}
					if (other.hasVideoResolutionConstraints()) {
						setVideoResolutionConstraints(other.getVideoResolutionConstraints());
					}
					if (other.hasMaxHdcpVersion()) {
						setMaxHdcpVersion(other.getMaxHdcpVersion());
					}
					if (other.hasOemCryptoApiVersion()) {
						setOemCryptoApiVersion(other.getOemCryptoApiVersion());
					}
					if (other.hasAntiRollbackUsageTable()) {
						setAntiRollbackUsageTable(other.getAntiRollbackUsageTable());
					}
					if (other.hasSrmVersion()) {
						setSrmVersion(other.getSrmVersion());
					}
					if (other.hasCanUpdateSrm()) {
						setCanUpdateSrm(other.getCanUpdateSrm());
					}
					if (!other.supportedCertificateKeyType_.isEmpty()) {
						if (supportedCertificateKeyType_.isEmpty()) {
							supportedCertificateKeyType_ = other.supportedCertificateKeyType_;
							bitField0_ = (bitField0_ & ~0x00000100);
						} else {
							ensureSupportedCertificateKeyTypeIsMutable();
							supportedCertificateKeyType_.addAll(other.supportedCertificateKeyType_);
						}
						onChanged();
					}
					if (other.hasAnalogOutputCapabilities()) {
						setAnalogOutputCapabilities(other.getAnalogOutputCapabilities());
					}
					if (other.hasCanDisableAnalogOutput()) {
						setCanDisableAnalogOutput(other.getCanDisableAnalogOutput());
					}
					if (other.hasResourceRatingTier()) {
						setResourceRatingTier(other.getResourceRatingTier());
					}
					this.mergeUnknownFields(other.getUnknownFields());
					onChanged();
					return this;
				}

				@java.lang.Override
				public final boolean isInitialized() {
					return true;
				}

				@java.lang.Override
				public Builder mergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
						throws java.io.IOException {
					if (extensionRegistry == null) {
						throw new java.lang.NullPointerException();
					}
					try {
						boolean done = false;
						while (!done) {
							int tag = input.readTag();
							switch (tag) {
							case 0:
								done = true;
								break;
							case 8: {
								clientToken_ = input.readBool();
								bitField0_ |= 0x00000001;
								break;
							} // case 8
							case 16: {
								sessionToken_ = input.readBool();
								bitField0_ |= 0x00000002;
								break;
							} // case 16
							case 24: {
								videoResolutionConstraints_ = input.readBool();
								bitField0_ |= 0x00000004;
								break;
							} // case 24
							case 32: {
								int tmpRaw = input.readEnum();
								WvProto2.ClientIdentification.ClientCapabilities.HdcpVersion tmpValue = WvProto2.ClientIdentification.ClientCapabilities.HdcpVersion
										.forNumber(tmpRaw);
								if (tmpValue == null) {
									mergeUnknownVarintField(4, tmpRaw);
								} else {
									maxHdcpVersion_ = tmpRaw;
									bitField0_ |= 0x00000008;
								}
								break;
							} // case 32
							case 40: {
								oemCryptoApiVersion_ = input.readUInt32();
								bitField0_ |= 0x00000010;
								break;
							} // case 40
							case 48: {
								antiRollbackUsageTable_ = input.readBool();
								bitField0_ |= 0x00000020;
								break;
							} // case 48
							case 56: {
								srmVersion_ = input.readUInt32();
								bitField0_ |= 0x00000040;
								break;
							} // case 56
							case 64: {
								canUpdateSrm_ = input.readBool();
								bitField0_ |= 0x00000080;
								break;
							} // case 64
							case 72: {
								int tmpRaw = input.readEnum();
								WvProto2.ClientIdentification.ClientCapabilities.CertificateKeyType tmpValue = WvProto2.ClientIdentification.ClientCapabilities.CertificateKeyType
										.forNumber(tmpRaw);
								if (tmpValue == null) {
									mergeUnknownVarintField(9, tmpRaw);
								} else {
									ensureSupportedCertificateKeyTypeIsMutable();
									supportedCertificateKeyType_.add(tmpRaw);
								}
								break;
							} // case 72
							case 74: {
								int length = input.readRawVarint32();
								int oldLimit = input.pushLimit(length);
								while (input.getBytesUntilLimit() > 0) {
									int tmpRaw = input.readEnum();
									WvProto2.ClientIdentification.ClientCapabilities.CertificateKeyType tmpValue = WvProto2.ClientIdentification.ClientCapabilities.CertificateKeyType
											.forNumber(tmpRaw);
									if (tmpValue == null) {
										mergeUnknownVarintField(9, tmpRaw);
									} else {
										ensureSupportedCertificateKeyTypeIsMutable();
										supportedCertificateKeyType_.add(tmpRaw);
									}
								}
								input.popLimit(oldLimit);
								break;
							} // case 74
							case 80: {
								int tmpRaw = input.readEnum();
								WvProto2.ClientIdentification.ClientCapabilities.AnalogOutputCapabilities tmpValue = WvProto2.ClientIdentification.ClientCapabilities.AnalogOutputCapabilities
										.forNumber(tmpRaw);
								if (tmpValue == null) {
									mergeUnknownVarintField(10, tmpRaw);
								} else {
									analogOutputCapabilities_ = tmpRaw;
									bitField0_ |= 0x00000200;
								}
								break;
							} // case 80
							case 88: {
								canDisableAnalogOutput_ = input.readBool();
								bitField0_ |= 0x00000400;
								break;
							} // case 88
							case 96: {
								resourceRatingTier_ = input.readUInt32();
								bitField0_ |= 0x00000800;
								break;
							} // case 96
							default: {
								if (!super.parseUnknownField(input, extensionRegistry, tag)) {
									done = true; // was an endgroup tag
								}
								break;
							} // default:
							} // switch (tag)
						} // while (!done)
					} catch (InvalidProtocolBufferException e) {
						throw e.unwrapIOException();
					}
					finally {
						onChanged();
					} // finally
					return this;
				}

				private int bitField0_;

				private boolean clientToken_;

				/**
				 * <code>optional bool client_token = 1 [default = false];</code>
				 * 
				 * @return Whether the clientToken field is set.
				 */
				@java.lang.Override
				public boolean hasClientToken() {
					return ((bitField0_ & 0x00000001) != 0);
				}

				/**
				 * <code>optional bool client_token = 1 [default = false];</code>
				 * 
				 * @return The clientToken.
				 */
				@java.lang.Override
				public boolean getClientToken() {
					return clientToken_;
				}

				/**
				 * <code>optional bool client_token = 1 [default = false];</code>
				 * 
				 * @param value The clientToken to set.
				 * @return This builder for chaining.
				 */
				public Builder setClientToken(boolean value) {

					clientToken_ = value;
					bitField0_ |= 0x00000001;
					onChanged();
					return this;
				}

				/**
				 * <code>optional bool client_token = 1 [default = false];</code>
				 * 
				 * @return This builder for chaining.
				 */
				public Builder clearClientToken() {
					bitField0_ = (bitField0_ & ~0x00000001);
					clientToken_ = false;
					onChanged();
					return this;
				}

				private boolean sessionToken_;

				/**
				 * <code>optional bool session_token = 2 [default = false];</code>
				 * 
				 * @return Whether the sessionToken field is set.
				 */
				@java.lang.Override
				public boolean hasSessionToken() {
					return ((bitField0_ & 0x00000002) != 0);
				}

				/**
				 * <code>optional bool session_token = 2 [default = false];</code>
				 * 
				 * @return The sessionToken.
				 */
				@java.lang.Override
				public boolean getSessionToken() {
					return sessionToken_;
				}

				/**
				 * <code>optional bool session_token = 2 [default = false];</code>
				 * 
				 * @param value The sessionToken to set.
				 * @return This builder for chaining.
				 */
				public Builder setSessionToken(boolean value) {

					sessionToken_ = value;
					bitField0_ |= 0x00000002;
					onChanged();
					return this;
				}

				/**
				 * <code>optional bool session_token = 2 [default = false];</code>
				 * 
				 * @return This builder for chaining.
				 */
				public Builder clearSessionToken() {
					bitField0_ = (bitField0_ & ~0x00000002);
					sessionToken_ = false;
					onChanged();
					return this;
				}

				private boolean videoResolutionConstraints_;

				/**
				 * <code>optional bool video_resolution_constraints = 3 [default = false];</code>
				 * 
				 * @return Whether the videoResolutionConstraints field is set.
				 */
				@java.lang.Override
				public boolean hasVideoResolutionConstraints() {
					return ((bitField0_ & 0x00000004) != 0);
				}

				/**
				 * <code>optional bool video_resolution_constraints = 3 [default = false];</code>
				 * 
				 * @return The videoResolutionConstraints.
				 */
				@java.lang.Override
				public boolean getVideoResolutionConstraints() {
					return videoResolutionConstraints_;
				}

				/**
				 * <code>optional bool video_resolution_constraints = 3 [default = false];</code>
				 * 
				 * @param value The videoResolutionConstraints to set.
				 * @return This builder for chaining.
				 */
				public Builder setVideoResolutionConstraints(boolean value) {

					videoResolutionConstraints_ = value;
					bitField0_ |= 0x00000004;
					onChanged();
					return this;
				}

				/**
				 * <code>optional bool video_resolution_constraints = 3 [default = false];</code>
				 * 
				 * @return This builder for chaining.
				 */
				public Builder clearVideoResolutionConstraints() {
					bitField0_ = (bitField0_ & ~0x00000004);
					videoResolutionConstraints_ = false;
					onChanged();
					return this;
				}

				private int maxHdcpVersion_ = 0;

				/**
				 * <code>optional .ClientIdentification.ClientCapabilities.HdcpVersion max_hdcp_version = 4 [default = HDCP_NONE];</code>
				 * 
				 * @return Whether the maxHdcpVersion field is set.
				 */
				@java.lang.Override
				public boolean hasMaxHdcpVersion() {
					return ((bitField0_ & 0x00000008) != 0);
				}

				/**
				 * <code>optional .ClientIdentification.ClientCapabilities.HdcpVersion max_hdcp_version = 4 [default = HDCP_NONE];</code>
				 * 
				 * @return The maxHdcpVersion.
				 */
				@java.lang.Override
				public WvProto2.ClientIdentification.ClientCapabilities.HdcpVersion getMaxHdcpVersion() {
					WvProto2.ClientIdentification.ClientCapabilities.HdcpVersion result = WvProto2.ClientIdentification.ClientCapabilities.HdcpVersion
							.forNumber(maxHdcpVersion_);
					return result == null
							? WvProto2.ClientIdentification.ClientCapabilities.HdcpVersion.HDCP_NONE
							: result;
				}

				/**
				 * <code>optional .ClientIdentification.ClientCapabilities.HdcpVersion max_hdcp_version = 4 [default = HDCP_NONE];</code>
				 * 
				 * @param value The maxHdcpVersion to set.
				 * @return This builder for chaining.
				 */
				public Builder setMaxHdcpVersion(
						WvProto2.ClientIdentification.ClientCapabilities.HdcpVersion value) {
					if (value == null) {
						throw new NullPointerException();
					}
					bitField0_ |= 0x00000008;
					maxHdcpVersion_ = value.getNumber();
					onChanged();
					return this;
				}

				/**
				 * <code>optional .ClientIdentification.ClientCapabilities.HdcpVersion max_hdcp_version = 4 [default = HDCP_NONE];</code>
				 * 
				 * @return This builder for chaining.
				 */
				public Builder clearMaxHdcpVersion() {
					bitField0_ = (bitField0_ & ~0x00000008);
					maxHdcpVersion_ = 0;
					onChanged();
					return this;
				}

				private int oemCryptoApiVersion_;

				/**
				 * <code>optional uint32 oem_crypto_api_version = 5;</code>
				 * 
				 * @return Whether the oemCryptoApiVersion field is set.
				 */
				@java.lang.Override
				public boolean hasOemCryptoApiVersion() {
					return ((bitField0_ & 0x00000010) != 0);
				}

				/**
				 * <code>optional uint32 oem_crypto_api_version = 5;</code>
				 * 
				 * @return The oemCryptoApiVersion.
				 */
				@java.lang.Override
				public int getOemCryptoApiVersion() {
					return oemCryptoApiVersion_;
				}

				/**
				 * <code>optional uint32 oem_crypto_api_version = 5;</code>
				 * 
				 * @param value The oemCryptoApiVersion to set.
				 * @return This builder for chaining.
				 */
				public Builder setOemCryptoApiVersion(int value) {

					oemCryptoApiVersion_ = value;
					bitField0_ |= 0x00000010;
					onChanged();
					return this;
				}

				/**
				 * <code>optional uint32 oem_crypto_api_version = 5;</code>
				 * 
				 * @return This builder for chaining.
				 */
				public Builder clearOemCryptoApiVersion() {
					bitField0_ = (bitField0_ & ~0x00000010);
					oemCryptoApiVersion_ = 0;
					onChanged();
					return this;
				}

				private boolean antiRollbackUsageTable_;

				/**
				 * <pre>
				 * Client has hardware support for protecting the usage table, such as
				 * storing the generation number in secure memory.  For Details, see:
				 * Widevine Modular DRM Security Integration Guide for CENC
				 * </pre>
				 *
				 * <code>optional bool anti_rollback_usage_table = 6 [default = false];</code>
				 * 
				 * @return Whether the antiRollbackUsageTable field is set.
				 */
				@java.lang.Override
				public boolean hasAntiRollbackUsageTable() {
					return ((bitField0_ & 0x00000020) != 0);
				}

				/**
				 * <pre>
				 * Client has hardware support for protecting the usage table, such as
				 * storing the generation number in secure memory.  For Details, see:
				 * Widevine Modular DRM Security Integration Guide for CENC
				 * </pre>
				 *
				 * <code>optional bool anti_rollback_usage_table = 6 [default = false];</code>
				 * 
				 * @return The antiRollbackUsageTable.
				 */
				@java.lang.Override
				public boolean getAntiRollbackUsageTable() {
					return antiRollbackUsageTable_;
				}

				/**
				 * <pre>
				 * Client has hardware support for protecting the usage table, such as
				 * storing the generation number in secure memory.  For Details, see:
				 * Widevine Modular DRM Security Integration Guide for CENC
				 * </pre>
				 *
				 * <code>optional bool anti_rollback_usage_table = 6 [default = false];</code>
				 * 
				 * @param value The antiRollbackUsageTable to set.
				 * @return This builder for chaining.
				 */
				public Builder setAntiRollbackUsageTable(boolean value) {

					antiRollbackUsageTable_ = value;
					bitField0_ |= 0x00000020;
					onChanged();
					return this;
				}

				/**
				 * <pre>
				 * Client has hardware support for protecting the usage table, such as
				 * storing the generation number in secure memory.  For Details, see:
				 * Widevine Modular DRM Security Integration Guide for CENC
				 * </pre>
				 *
				 * <code>optional bool anti_rollback_usage_table = 6 [default = false];</code>
				 * 
				 * @return This builder for chaining.
				 */
				public Builder clearAntiRollbackUsageTable() {
					bitField0_ = (bitField0_ & ~0x00000020);
					antiRollbackUsageTable_ = false;
					onChanged();
					return this;
				}

				private int srmVersion_;

				/**
				 * <pre>
				 * The client shall report |srm_version| if available.
				 * </pre>
				 *
				 * <code>optional uint32 srm_version = 7;</code>
				 * 
				 * @return Whether the srmVersion field is set.
				 */
				@java.lang.Override
				public boolean hasSrmVersion() {
					return ((bitField0_ & 0x00000040) != 0);
				}

				/**
				 * <pre>
				 * The client shall report |srm_version| if available.
				 * </pre>
				 *
				 * <code>optional uint32 srm_version = 7;</code>
				 * 
				 * @return The srmVersion.
				 */
				@java.lang.Override
				public int getSrmVersion() {
					return srmVersion_;
				}

				/**
				 * <pre>
				 * The client shall report |srm_version| if available.
				 * </pre>
				 *
				 * <code>optional uint32 srm_version = 7;</code>
				 * 
				 * @param value The srmVersion to set.
				 * @return This builder for chaining.
				 */
				public Builder setSrmVersion(int value) {

					srmVersion_ = value;
					bitField0_ |= 0x00000040;
					onChanged();
					return this;
				}

				/**
				 * <pre>
				 * The client shall report |srm_version| if available.
				 * </pre>
				 *
				 * <code>optional uint32 srm_version = 7;</code>
				 * 
				 * @return This builder for chaining.
				 */
				public Builder clearSrmVersion() {
					bitField0_ = (bitField0_ & ~0x00000040);
					srmVersion_ = 0;
					onChanged();
					return this;
				}

				private boolean canUpdateSrm_;

				/**
				 * <pre>
				 * A device may have SRM data, and report a version, but may not be capable
				 * of updating SRM data.
				 * </pre>
				 *
				 * <code>optional bool can_update_srm = 8 [default = false];</code>
				 * 
				 * @return Whether the canUpdateSrm field is set.
				 */
				@java.lang.Override
				public boolean hasCanUpdateSrm() {
					return ((bitField0_ & 0x00000080) != 0);
				}

				/**
				 * <pre>
				 * A device may have SRM data, and report a version, but may not be capable
				 * of updating SRM data.
				 * </pre>
				 *
				 * <code>optional bool can_update_srm = 8 [default = false];</code>
				 * 
				 * @return The canUpdateSrm.
				 */
				@java.lang.Override
				public boolean getCanUpdateSrm() {
					return canUpdateSrm_;
				}

				/**
				 * <pre>
				 * A device may have SRM data, and report a version, but may not be capable
				 * of updating SRM data.
				 * </pre>
				 *
				 * <code>optional bool can_update_srm = 8 [default = false];</code>
				 * 
				 * @param value The canUpdateSrm to set.
				 * @return This builder for chaining.
				 */
				public Builder setCanUpdateSrm(boolean value) {

					canUpdateSrm_ = value;
					bitField0_ |= 0x00000080;
					onChanged();
					return this;
				}

				/**
				 * <pre>
				 * A device may have SRM data, and report a version, but may not be capable
				 * of updating SRM data.
				 * </pre>
				 *
				 * <code>optional bool can_update_srm = 8 [default = false];</code>
				 * 
				 * @return This builder for chaining.
				 */
				public Builder clearCanUpdateSrm() {
					bitField0_ = (bitField0_ & ~0x00000080);
					canUpdateSrm_ = false;
					onChanged();
					return this;
				}

				private java.util.List<java.lang.Integer> supportedCertificateKeyType_ = java.util.Collections
						.emptyList();

				private void ensureSupportedCertificateKeyTypeIsMutable() {
					if (!((bitField0_ & 0x00000100) != 0)) {
						supportedCertificateKeyType_ = new java.util.ArrayList<>(supportedCertificateKeyType_);
						bitField0_ |= 0x00000100;
					}
				}

				/**
				 * <code>repeated .ClientIdentification.ClientCapabilities.CertificateKeyType supported_certificate_key_type = 9;</code>
				 * 
				 * @return A list containing the supportedCertificateKeyType.
				 */
				@Override
				public java.util.List<WvProto2.ClientIdentification.ClientCapabilities.CertificateKeyType> getSupportedCertificateKeyTypeList() {
					return new Internal.ListAdapter<>(supportedCertificateKeyType_,
							supportedCertificateKeyType_converter_);
				}

				/**
				 * <code>repeated .ClientIdentification.ClientCapabilities.CertificateKeyType supported_certificate_key_type = 9;</code>
				 * 
				 * @return The count of supportedCertificateKeyType.
				 */
				@Override
				public int getSupportedCertificateKeyTypeCount() {
					return supportedCertificateKeyType_.size();
				}

				/**
				 * <code>repeated .ClientIdentification.ClientCapabilities.CertificateKeyType supported_certificate_key_type = 9;</code>
				 * 
				 * @param index The index of the element to return.
				 * @return The supportedCertificateKeyType at the given index.
				 */
				@Override
				public WvProto2.ClientIdentification.ClientCapabilities.CertificateKeyType getSupportedCertificateKeyType(
						int index) {
					return supportedCertificateKeyType_converter_.convert(supportedCertificateKeyType_.get(index));
				}

				/**
				 * <code>repeated .ClientIdentification.ClientCapabilities.CertificateKeyType supported_certificate_key_type = 9;</code>
				 * 
				 * @param index The index to set the value at.
				 * @param value The supportedCertificateKeyType to set.
				 * @return This builder for chaining.
				 */
				public Builder setSupportedCertificateKeyType(int index,
						WvProto2.ClientIdentification.ClientCapabilities.CertificateKeyType value) {
					if (value == null) {
						throw new NullPointerException();
					}
					ensureSupportedCertificateKeyTypeIsMutable();
					supportedCertificateKeyType_.set(index, value.getNumber());
					onChanged();
					return this;
				}

				/**
				 * <code>repeated .ClientIdentification.ClientCapabilities.CertificateKeyType supported_certificate_key_type = 9;</code>
				 * 
				 * @param value The supportedCertificateKeyType to add.
				 * @return This builder for chaining.
				 */
				public Builder addSupportedCertificateKeyType(
						WvProto2.ClientIdentification.ClientCapabilities.CertificateKeyType value) {
					if (value == null) {
						throw new NullPointerException();
					}
					ensureSupportedCertificateKeyTypeIsMutable();
					supportedCertificateKeyType_.add(value.getNumber());
					onChanged();
					return this;
				}

				/**
				 * <code>repeated .ClientIdentification.ClientCapabilities.CertificateKeyType supported_certificate_key_type = 9;</code>
				 * 
				 * @param values The supportedCertificateKeyType to add.
				 * @return This builder for chaining.
				 */
				public Builder addAllSupportedCertificateKeyType(
						java.lang.Iterable<? extends WvProto2.ClientIdentification.ClientCapabilities.CertificateKeyType> values) {
					ensureSupportedCertificateKeyTypeIsMutable();
					for (WvProto2.ClientIdentification.ClientCapabilities.CertificateKeyType value : values) {
						supportedCertificateKeyType_.add(value.getNumber());
					}
					onChanged();
					return this;
				}

				/**
				 * <code>repeated .ClientIdentification.ClientCapabilities.CertificateKeyType supported_certificate_key_type = 9;</code>
				 * 
				 * @return This builder for chaining.
				 */
				public Builder clearSupportedCertificateKeyType() {
					supportedCertificateKeyType_ = java.util.Collections.emptyList();
					bitField0_ = (bitField0_ & ~0x00000100);
					onChanged();
					return this;
				}

				private int analogOutputCapabilities_ = 0;

				/**
				 * <code>optional .ClientIdentification.ClientCapabilities.AnalogOutputCapabilities analog_output_capabilities = 10 [default = ANALOG_OUTPUT_UNKNOWN];</code>
				 * 
				 * @return Whether the analogOutputCapabilities field is set.
				 */
				@java.lang.Override
				public boolean hasAnalogOutputCapabilities() {
					return ((bitField0_ & 0x00000200) != 0);
				}

				/**
				 * <code>optional .ClientIdentification.ClientCapabilities.AnalogOutputCapabilities analog_output_capabilities = 10 [default = ANALOG_OUTPUT_UNKNOWN];</code>
				 * 
				 * @return The analogOutputCapabilities.
				 */
				@java.lang.Override
				public WvProto2.ClientIdentification.ClientCapabilities.AnalogOutputCapabilities getAnalogOutputCapabilities() {
					WvProto2.ClientIdentification.ClientCapabilities.AnalogOutputCapabilities result = WvProto2.ClientIdentification.ClientCapabilities.AnalogOutputCapabilities
							.forNumber(analogOutputCapabilities_);
					return result == null
							? WvProto2.ClientIdentification.ClientCapabilities.AnalogOutputCapabilities.ANALOG_OUTPUT_UNKNOWN
							: result;
				}

				/**
				 * <code>optional .ClientIdentification.ClientCapabilities.AnalogOutputCapabilities analog_output_capabilities = 10 [default = ANALOG_OUTPUT_UNKNOWN];</code>
				 * 
				 * @param value The analogOutputCapabilities to set.
				 * @return This builder for chaining.
				 */
				public Builder setAnalogOutputCapabilities(
						WvProto2.ClientIdentification.ClientCapabilities.AnalogOutputCapabilities value) {
					if (value == null) {
						throw new NullPointerException();
					}
					bitField0_ |= 0x00000200;
					analogOutputCapabilities_ = value.getNumber();
					onChanged();
					return this;
				}

				/**
				 * <code>optional .ClientIdentification.ClientCapabilities.AnalogOutputCapabilities analog_output_capabilities = 10 [default = ANALOG_OUTPUT_UNKNOWN];</code>
				 * 
				 * @return This builder for chaining.
				 */
				public Builder clearAnalogOutputCapabilities() {
					bitField0_ = (bitField0_ & ~0x00000200);
					analogOutputCapabilities_ = 0;
					onChanged();
					return this;
				}

				private boolean canDisableAnalogOutput_;

				/**
				 * <code>optional bool can_disable_analog_output = 11 [default = false];</code>
				 * 
				 * @return Whether the canDisableAnalogOutput field is set.
				 */
				@java.lang.Override
				public boolean hasCanDisableAnalogOutput() {
					return ((bitField0_ & 0x00000400) != 0);
				}

				/**
				 * <code>optional bool can_disable_analog_output = 11 [default = false];</code>
				 * 
				 * @return The canDisableAnalogOutput.
				 */
				@java.lang.Override
				public boolean getCanDisableAnalogOutput() {
					return canDisableAnalogOutput_;
				}

				/**
				 * <code>optional bool can_disable_analog_output = 11 [default = false];</code>
				 * 
				 * @param value The canDisableAnalogOutput to set.
				 * @return This builder for chaining.
				 */
				public Builder setCanDisableAnalogOutput(boolean value) {

					canDisableAnalogOutput_ = value;
					bitField0_ |= 0x00000400;
					onChanged();
					return this;
				}

				/**
				 * <code>optional bool can_disable_analog_output = 11 [default = false];</code>
				 * 
				 * @return This builder for chaining.
				 */
				public Builder clearCanDisableAnalogOutput() {
					bitField0_ = (bitField0_ & ~0x00000400);
					canDisableAnalogOutput_ = false;
					onChanged();
					return this;
				}

				private int resourceRatingTier_;

				/**
				 * <pre>
				 * Clients can indicate a performance level supported by OEMCrypto.
				 * This will allow applications and providers to choose an appropriate
				 * quality of content to serve. Currently defined tiers are
				 * 1 (low), 2 (medium) and 3 (high). Any other value indicates that
				 * the resource rating is unavailable or reporting erroneous values
				 * for that device. For details see,
				 * Widevine Modular DRM Security Integration Guide for CENC
				 * </pre>
				 *
				 * <code>optional uint32 resource_rating_tier = 12 [default = 0];</code>
				 * 
				 * @return Whether the resourceRatingTier field is set.
				 */
				@java.lang.Override
				public boolean hasResourceRatingTier() {
					return ((bitField0_ & 0x00000800) != 0);
				}

				/**
				 * <pre>
				 * Clients can indicate a performance level supported by OEMCrypto.
				 * This will allow applications and providers to choose an appropriate
				 * quality of content to serve. Currently defined tiers are
				 * 1 (low), 2 (medium) and 3 (high). Any other value indicates that
				 * the resource rating is unavailable or reporting erroneous values
				 * for that device. For details see,
				 * Widevine Modular DRM Security Integration Guide for CENC
				 * </pre>
				 *
				 * <code>optional uint32 resource_rating_tier = 12 [default = 0];</code>
				 * 
				 * @return The resourceRatingTier.
				 */
				@java.lang.Override
				public int getResourceRatingTier() {
					return resourceRatingTier_;
				}

				/**
				 * <pre>
				 * Clients can indicate a performance level supported by OEMCrypto.
				 * This will allow applications and providers to choose an appropriate
				 * quality of content to serve. Currently defined tiers are
				 * 1 (low), 2 (medium) and 3 (high). Any other value indicates that
				 * the resource rating is unavailable or reporting erroneous values
				 * for that device. For details see,
				 * Widevine Modular DRM Security Integration Guide for CENC
				 * </pre>
				 *
				 * <code>optional uint32 resource_rating_tier = 12 [default = 0];</code>
				 * 
				 * @param value The resourceRatingTier to set.
				 * @return This builder for chaining.
				 */
				public Builder setResourceRatingTier(int value) {

					resourceRatingTier_ = value;
					bitField0_ |= 0x00000800;
					onChanged();
					return this;
				}

				/**
				 * <pre>
				 * Clients can indicate a performance level supported by OEMCrypto.
				 * This will allow applications and providers to choose an appropriate
				 * quality of content to serve. Currently defined tiers are
				 * 1 (low), 2 (medium) and 3 (high). Any other value indicates that
				 * the resource rating is unavailable or reporting erroneous values
				 * for that device. For details see,
				 * Widevine Modular DRM Security Integration Guide for CENC
				 * </pre>
				 *
				 * <code>optional uint32 resource_rating_tier = 12 [default = 0];</code>
				 * 
				 * @return This builder for chaining.
				 */
				public Builder clearResourceRatingTier() {
					bitField0_ = (bitField0_ & ~0x00000800);
					resourceRatingTier_ = 0;
					onChanged();
					return this;
				}

				@java.lang.Override
				public final Builder setUnknownFields(final UnknownFieldSet unknownFields) {
					return super.setUnknownFields(unknownFields);
				}

				@java.lang.Override
				public final Builder mergeUnknownFields(final UnknownFieldSet unknownFields) {
					return super.mergeUnknownFields(unknownFields);
				}

				// @@protoc_insertion_point(builder_scope:ClientIdentification.ClientCapabilities)
			}

			// @@protoc_insertion_point(class_scope:ClientIdentification.ClientCapabilities)
			private static final WvProto2.ClientIdentification.ClientCapabilities DEFAULT_INSTANCE;
			static {
				DEFAULT_INSTANCE = new WvProto2.ClientIdentification.ClientCapabilities();
			}

			public static WvProto2.ClientIdentification.ClientCapabilities getDefaultInstance() {
				return DEFAULT_INSTANCE;
			}

			@java.lang.Deprecated public static final Parser<ClientCapabilities> PARSER = new AbstractParser<>() {
				@java.lang.Override
				public ClientCapabilities parsePartialFrom(CodedInputStream input,
						ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
					Builder builder = newBuilder();
					try {
						builder.mergeFrom(input, extensionRegistry);
					} catch (InvalidProtocolBufferException e) {
						throw e.setUnfinishedMessage(builder.buildPartial());
					} catch (UninitializedMessageException e) {
						throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
					} catch (java.io.IOException e) {
						throw new InvalidProtocolBufferException(e).setUnfinishedMessage(builder.buildPartial());
					}
					return builder.buildPartial();
				}
			};

			public static Parser<ClientCapabilities> parser() {
				return PARSER;
			}

			@java.lang.Override
			public Parser<ClientCapabilities> getParserForType() {
				return PARSER;
			}

			@java.lang.Override
			public WvProto2.ClientIdentification.ClientCapabilities getDefaultInstanceForType() {
				return DEFAULT_INSTANCE;
			}

		}

		public interface ClientCredentialsOrBuilder extends
				// @@protoc_insertion_point(interface_extends:ClientIdentification.ClientCredentials)
				MessageOrBuilder {

			/**
			 * <code>optional .ClientIdentification.TokenType type = 1 [default = KEYBOX];</code>
			 * 
			 * @return Whether the type field is set.
			 */
			boolean hasType();

			/**
			 * <code>optional .ClientIdentification.TokenType type = 1 [default = KEYBOX];</code>
			 * 
			 * @return The type.
			 */
			WvProto2.ClientIdentification.TokenType getType();

			/**
			 * <code>optional bytes token = 2;</code>
			 * 
			 * @return Whether the token field is set.
			 */
			boolean hasToken();

			/**
			 * <code>optional bytes token = 2;</code>
			 * 
			 * @return The token.
			 */
			ByteString getToken();
		}

		/**
		 * Protobuf type {@code ClientIdentification.ClientCredentials}
		 */
		public static final class ClientCredentials extends GeneratedMessageV3 implements
				// @@protoc_insertion_point(message_implements:ClientIdentification.ClientCredentials)
				ClientCredentialsOrBuilder {
			private static final long serialVersionUID = 0L;

			// Use ClientCredentials.newBuilder() to construct.
			private ClientCredentials(GeneratedMessageV3.Builder<?> builder) {
				super(builder);
			}

			private ClientCredentials() {
				type_ = 0;
				token_ = ByteString.EMPTY;
			}

			@java.lang.Override

			protected java.lang.Object newInstance(UnusedPrivateParameter unused) {
				return new ClientCredentials();
			}

			public static final Descriptors.Descriptor getDescriptor() {
				return WvProto2.internal_static_ClientIdentification_ClientCredentials_descriptor;
			}

			@java.lang.Override
			protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
				return WvProto2.internal_static_ClientIdentification_ClientCredentials_fieldAccessorTable
						.ensureFieldAccessorsInitialized(
								WvProto2.ClientIdentification.ClientCredentials.class,
								WvProto2.ClientIdentification.ClientCredentials.Builder.class);
			}

			private int bitField0_;
			public static final int TYPE_FIELD_NUMBER = 1;
			private int type_ = 0;

			/**
			 * <code>optional .ClientIdentification.TokenType type = 1 [default = KEYBOX];</code>
			 * 
			 * @return Whether the type field is set.
			 */
			@java.lang.Override
			public boolean hasType() {
				return ((bitField0_ & 0x00000001) != 0);
			}

			/**
			 * <code>optional .ClientIdentification.TokenType type = 1 [default = KEYBOX];</code>
			 * 
			 * @return The type.
			 */
			@java.lang.Override
			public WvProto2.ClientIdentification.TokenType getType() {
				WvProto2.ClientIdentification.TokenType result = WvProto2.ClientIdentification.TokenType
						.forNumber(type_);
				return result == null ? WvProto2.ClientIdentification.TokenType.KEYBOX : result;
			}

			public static final int TOKEN_FIELD_NUMBER = 2;
			private ByteString token_ = ByteString.EMPTY;

			/**
			 * <code>optional bytes token = 2;</code>
			 * 
			 * @return Whether the token field is set.
			 */
			@java.lang.Override
			public boolean hasToken() {
				return ((bitField0_ & 0x00000002) != 0);
			}

			/**
			 * <code>optional bytes token = 2;</code>
			 * 
			 * @return The token.
			 */
			@java.lang.Override
			public ByteString getToken() {
				return token_;
			}

			private byte memoizedIsInitialized = -1;

			@java.lang.Override
			public final boolean isInitialized() {
				byte isInitialized = memoizedIsInitialized;
				if (isInitialized == 1)
					return true;
				if (isInitialized == 0)
					return false;

				memoizedIsInitialized = 1;
				return true;
			}

			@java.lang.Override
			public void writeTo(CodedOutputStream output) throws java.io.IOException {
				if (((bitField0_ & 0x00000001) != 0)) {
					output.writeEnum(1, type_);
				}
				if (((bitField0_ & 0x00000002) != 0)) {
					output.writeBytes(2, token_);
				}
				getUnknownFields().writeTo(output);
			}

			@java.lang.Override
			public int getSerializedSize() {
				int size = memoizedSize;
				if (size != -1)
					return size;

				size = 0;
				if (((bitField0_ & 0x00000001) != 0)) {
					size += CodedOutputStream.computeEnumSize(1, type_);
				}
				if (((bitField0_ & 0x00000002) != 0)) {
					size += CodedOutputStream.computeBytesSize(2, token_);
				}
				size += getUnknownFields().getSerializedSize();
				memoizedSize = size;
				return size;
			}

			@java.lang.Override
			public boolean equals(final java.lang.Object obj) {
				if (obj == this) {
					return true;
				}
				if (!(obj instanceof WvProto2.ClientIdentification.ClientCredentials)) {
					return super.equals(obj);
				}
				WvProto2.ClientIdentification.ClientCredentials other = (WvProto2.ClientIdentification.ClientCredentials) obj;

				if (hasType() != other.hasType())
					return false;
				if (hasType()) {
					if (type_ != other.type_)
						return false;
				}
				if (hasToken() != other.hasToken())
					return false;
				if (hasToken()) {
					if (!getToken().equals(other.getToken()))
						return false;
				}
				if (!getUnknownFields().equals(other.getUnknownFields()))
					return false;
				return true;
			}

			@SuppressWarnings("unchecked")
			@java.lang.Override
			public int hashCode() {
				if (memoizedHashCode != 0) {
					return memoizedHashCode;
				}
				int hash = 41;
				hash = (19 * hash) + getDescriptor().hashCode();
				if (hasType()) {
					hash = (37 * hash) + TYPE_FIELD_NUMBER;
					hash = (53 * hash) + type_;
				}
				if (hasToken()) {
					hash = (37 * hash) + TOKEN_FIELD_NUMBER;
					hash = (53 * hash) + getToken().hashCode();
				}
				hash = (29 * hash) + getUnknownFields().hashCode();
				memoizedHashCode = hash;
				return hash;
			}

			public static WvProto2.ClientIdentification.ClientCredentials parseFrom(
					java.nio.ByteBuffer data) throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data);
			}

			public static WvProto2.ClientIdentification.ClientCredentials parseFrom(
					java.nio.ByteBuffer data, ExtensionRegistryLite extensionRegistry)
					throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data, extensionRegistry);
			}

			public static WvProto2.ClientIdentification.ClientCredentials parseFrom(
					ByteString data) throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data);
			}

			public static WvProto2.ClientIdentification.ClientCredentials parseFrom(
					ByteString data, ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data, extensionRegistry);
			}

			public static WvProto2.ClientIdentification.ClientCredentials parseFrom(byte[] data)
					throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data);
			}

			public static WvProto2.ClientIdentification.ClientCredentials parseFrom(byte[] data,
					ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data, extensionRegistry);
			}

			public static WvProto2.ClientIdentification.ClientCredentials parseFrom(
					java.io.InputStream input) throws java.io.IOException {
				return GeneratedMessageV3.parseWithIOException(PARSER, input);
			}

			public static WvProto2.ClientIdentification.ClientCredentials parseFrom(
					java.io.InputStream input, ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
				return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
			}

			public static WvProto2.ClientIdentification.ClientCredentials parseDelimitedFrom(
					java.io.InputStream input) throws java.io.IOException {
				return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
			}

			public static WvProto2.ClientIdentification.ClientCredentials parseDelimitedFrom(
					java.io.InputStream input, ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
				return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input, extensionRegistry);
			}

			public static WvProto2.ClientIdentification.ClientCredentials parseFrom(
					CodedInputStream input) throws java.io.IOException {
				return GeneratedMessageV3.parseWithIOException(PARSER, input);
			}

			public static WvProto2.ClientIdentification.ClientCredentials parseFrom(
					CodedInputStream input, ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
				return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
			}

			@java.lang.Override
			public Builder newBuilderForType() {
				return newBuilder();
			}

			public static Builder newBuilder() {
				return DEFAULT_INSTANCE.toBuilder();
			}

			public static Builder newBuilder(
					WvProto2.ClientIdentification.ClientCredentials prototype) {
				return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
			}

			@java.lang.Override
			public Builder toBuilder() {
				return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
			}

			@java.lang.Override
			protected Builder newBuilderForType(GeneratedMessageV3.BuilderParent parent) {
				Builder builder = new Builder(parent);
				return builder;
			}

			/**
			 * Protobuf type {@code ClientIdentification.ClientCredentials}
			 */
			public static final class Builder extends GeneratedMessageV3.Builder<Builder> implements
					// @@protoc_insertion_point(builder_implements:ClientIdentification.ClientCredentials)
					WvProto2.ClientIdentification.ClientCredentialsOrBuilder {
				public static final Descriptors.Descriptor getDescriptor() {
					return WvProto2.internal_static_ClientIdentification_ClientCredentials_descriptor;
				}

				@java.lang.Override
				protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
					return WvProto2.internal_static_ClientIdentification_ClientCredentials_fieldAccessorTable
							.ensureFieldAccessorsInitialized(
									WvProto2.ClientIdentification.ClientCredentials.class,
									WvProto2.ClientIdentification.ClientCredentials.Builder.class);
				}

				// Construct using
				// WvProto2.ClientIdentification.ClientCredentials.newBuilder()
				private Builder() {

				}

				private Builder(GeneratedMessageV3.BuilderParent parent) {
					super(parent);

				}

				@java.lang.Override
				public Builder clear() {
					super.clear();
					bitField0_ = 0;
					type_ = 0;
					token_ = ByteString.EMPTY;
					return this;
				}

				@java.lang.Override
				public Descriptors.Descriptor getDescriptorForType() {
					return WvProto2.internal_static_ClientIdentification_ClientCredentials_descriptor;
				}

				@java.lang.Override
				public WvProto2.ClientIdentification.ClientCredentials getDefaultInstanceForType() {
					return WvProto2.ClientIdentification.ClientCredentials.getDefaultInstance();
				}

				@java.lang.Override
				public WvProto2.ClientIdentification.ClientCredentials build() {
					WvProto2.ClientIdentification.ClientCredentials result = buildPartial();
					if (!result.isInitialized()) {
						throw newUninitializedMessageException(result);
					}
					return result;
				}

				@java.lang.Override
				public WvProto2.ClientIdentification.ClientCredentials buildPartial() {
					WvProto2.ClientIdentification.ClientCredentials result = new WvProto2.ClientIdentification.ClientCredentials(
							this);
					if (bitField0_ != 0) {
						buildPartial0(result);
					}
					onBuilt();
					return result;
				}

				private void buildPartial0(
						WvProto2.ClientIdentification.ClientCredentials result) {
					int from_bitField0_ = bitField0_;
					int to_bitField0_ = 0;
					if (((from_bitField0_ & 0x00000001) != 0)) {
						result.type_ = type_;
						to_bitField0_ |= 0x00000001;
					}
					if (((from_bitField0_ & 0x00000002) != 0)) {
						result.token_ = token_;
						to_bitField0_ |= 0x00000002;
					}
					result.bitField0_ |= to_bitField0_;
				}

				@java.lang.Override
				public Builder mergeFrom(Message other) {
					if (other instanceof WvProto2.ClientIdentification.ClientCredentials) {
						return mergeFrom(
								(WvProto2.ClientIdentification.ClientCredentials) other);
					}
					super.mergeFrom(other);
					return this;
				}

				public Builder mergeFrom(
						WvProto2.ClientIdentification.ClientCredentials other) {
					if (other == WvProto2.ClientIdentification.ClientCredentials
							.getDefaultInstance())
						return this;
					if (other.hasType()) {
						setType(other.getType());
					}
					if (other.hasToken()) {
						setToken(other.getToken());
					}
					this.mergeUnknownFields(other.getUnknownFields());
					onChanged();
					return this;
				}

				@java.lang.Override
				public final boolean isInitialized() {
					return true;
				}

				@java.lang.Override
				public Builder mergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
						throws java.io.IOException {
					if (extensionRegistry == null) {
						throw new java.lang.NullPointerException();
					}
					try {
						boolean done = false;
						while (!done) {
							int tag = input.readTag();
							switch (tag) {
							case 0:
								done = true;
								break;
							case 8: {
								int tmpRaw = input.readEnum();
								WvProto2.ClientIdentification.TokenType tmpValue = WvProto2.ClientIdentification.TokenType
										.forNumber(tmpRaw);
								if (tmpValue == null) {
									mergeUnknownVarintField(1, tmpRaw);
								} else {
									type_ = tmpRaw;
									bitField0_ |= 0x00000001;
								}
								break;
							} // case 8
							case 18: {
								token_ = input.readBytes();
								bitField0_ |= 0x00000002;
								break;
							} // case 18
							default: {
								if (!super.parseUnknownField(input, extensionRegistry, tag)) {
									done = true; // was an endgroup tag
								}
								break;
							} // default:
							} // switch (tag)
						} // while (!done)
					} catch (InvalidProtocolBufferException e) {
						throw e.unwrapIOException();
					}
					finally {
						onChanged();
					} // finally
					return this;
				}

				private int bitField0_;

				private int type_ = 0;

				/**
				 * <code>optional .ClientIdentification.TokenType type = 1 [default = KEYBOX];</code>
				 * 
				 * @return Whether the type field is set.
				 */
				@java.lang.Override
				public boolean hasType() {
					return ((bitField0_ & 0x00000001) != 0);
				}

				/**
				 * <code>optional .ClientIdentification.TokenType type = 1 [default = KEYBOX];</code>
				 * 
				 * @return The type.
				 */
				@java.lang.Override
				public WvProto2.ClientIdentification.TokenType getType() {
					WvProto2.ClientIdentification.TokenType result = WvProto2.ClientIdentification.TokenType
							.forNumber(type_);
					return result == null ? WvProto2.ClientIdentification.TokenType.KEYBOX
							: result;
				}

				/**
				 * <code>optional .ClientIdentification.TokenType type = 1 [default = KEYBOX];</code>
				 * 
				 * @param value The type to set.
				 * @return This builder for chaining.
				 */
				public Builder setType(WvProto2.ClientIdentification.TokenType value) {
					if (value == null) {
						throw new NullPointerException();
					}
					bitField0_ |= 0x00000001;
					type_ = value.getNumber();
					onChanged();
					return this;
				}

				/**
				 * <code>optional .ClientIdentification.TokenType type = 1 [default = KEYBOX];</code>
				 * 
				 * @return This builder for chaining.
				 */
				public Builder clearType() {
					bitField0_ = (bitField0_ & ~0x00000001);
					type_ = 0;
					onChanged();
					return this;
				}

				private ByteString token_ = ByteString.EMPTY;

				/**
				 * <code>optional bytes token = 2;</code>
				 * 
				 * @return Whether the token field is set.
				 */
				@java.lang.Override
				public boolean hasToken() {
					return ((bitField0_ & 0x00000002) != 0);
				}

				/**
				 * <code>optional bytes token = 2;</code>
				 * 
				 * @return The token.
				 */
				@java.lang.Override
				public ByteString getToken() {
					return token_;
				}

				/**
				 * <code>optional bytes token = 2;</code>
				 * 
				 * @param value The token to set.
				 * @return This builder for chaining.
				 */
				public Builder setToken(ByteString value) {
					if (value == null) {
						throw new NullPointerException();
					}
					token_ = value;
					bitField0_ |= 0x00000002;
					onChanged();
					return this;
				}

				/**
				 * <code>optional bytes token = 2;</code>
				 * 
				 * @return This builder for chaining.
				 */
				public Builder clearToken() {
					bitField0_ = (bitField0_ & ~0x00000002);
					token_ = getDefaultInstance().getToken();
					onChanged();
					return this;
				}

				@java.lang.Override
				public final Builder setUnknownFields(final UnknownFieldSet unknownFields) {
					return super.setUnknownFields(unknownFields);
				}

				@java.lang.Override
				public final Builder mergeUnknownFields(final UnknownFieldSet unknownFields) {
					return super.mergeUnknownFields(unknownFields);
				}

				// @@protoc_insertion_point(builder_scope:ClientIdentification.ClientCredentials)
			}

			// @@protoc_insertion_point(class_scope:ClientIdentification.ClientCredentials)
			private static final WvProto2.ClientIdentification.ClientCredentials DEFAULT_INSTANCE;
			static {
				DEFAULT_INSTANCE = new WvProto2.ClientIdentification.ClientCredentials();
			}

			public static WvProto2.ClientIdentification.ClientCredentials getDefaultInstance() {
				return DEFAULT_INSTANCE;
			}

			@java.lang.Deprecated public static final Parser<ClientCredentials> PARSER = new AbstractParser<>() {
				@java.lang.Override
				public ClientCredentials parsePartialFrom(CodedInputStream input,
						ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
					Builder builder = newBuilder();
					try {
						builder.mergeFrom(input, extensionRegistry);
					} catch (InvalidProtocolBufferException e) {
						throw e.setUnfinishedMessage(builder.buildPartial());
					} catch (UninitializedMessageException e) {
						throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
					} catch (java.io.IOException e) {
						throw new InvalidProtocolBufferException(e).setUnfinishedMessage(builder.buildPartial());
					}
					return builder.buildPartial();
				}
			};

			public static Parser<ClientCredentials> parser() {
				return PARSER;
			}

			@java.lang.Override
			public Parser<ClientCredentials> getParserForType() {
				return PARSER;
			}

			@java.lang.Override
			public WvProto2.ClientIdentification.ClientCredentials getDefaultInstanceForType() {
				return DEFAULT_INSTANCE;
			}

		}

		private int bitField0_;
		public static final int TYPE_FIELD_NUMBER = 1;
		private int type_ = 0;

		/**
		 * <pre>
		 * Type of factory-provisioned device root of trust. Optional.
		 * </pre>
		 *
		 * <code>optional .ClientIdentification.TokenType type = 1 [default = KEYBOX];</code>
		 * 
		 * @return Whether the type field is set.
		 */
		@java.lang.Override
		public boolean hasType() {
			return ((bitField0_ & 0x00000001) != 0);
		}

		/**
		 * <pre>
		 * Type of factory-provisioned device root of trust. Optional.
		 * </pre>
		 *
		 * <code>optional .ClientIdentification.TokenType type = 1 [default = KEYBOX];</code>
		 * 
		 * @return The type.
		 */
		@java.lang.Override
		public WvProto2.ClientIdentification.TokenType getType() {
			WvProto2.ClientIdentification.TokenType result = WvProto2.ClientIdentification.TokenType
					.forNumber(type_);
			return result == null ? WvProto2.ClientIdentification.TokenType.KEYBOX : result;
		}

		public static final int TOKEN_FIELD_NUMBER = 2;
		private ByteString token_ = ByteString.EMPTY;

		/**
		 * <pre>
		 * Factory-provisioned device root of trust. Required.
		 * </pre>
		 *
		 * <code>optional bytes token = 2;</code>
		 * 
		 * @return Whether the token field is set.
		 */
		@java.lang.Override
		public boolean hasToken() {
			return ((bitField0_ & 0x00000002) != 0);
		}

		/**
		 * <pre>
		 * Factory-provisioned device root of trust. Required.
		 * </pre>
		 *
		 * <code>optional bytes token = 2;</code>
		 * 
		 * @return The token.
		 */
		@java.lang.Override
		public ByteString getToken() {
			return token_;
		}

		public static final int CLIENT_INFO_FIELD_NUMBER = 3;

		private java.util.List<WvProto2.ClientIdentification.NameValue> clientInfo_;

		/**
		 * <pre>
		 * Optional client information name/value pairs.
		 * </pre>
		 *
		 * <code>repeated .ClientIdentification.NameValue client_info = 3;</code>
		 */
		@java.lang.Override
		public java.util.List<WvProto2.ClientIdentification.NameValue> getClientInfoList() {
			return clientInfo_;
		}

		/**
		 * <pre>
		 * Optional client information name/value pairs.
		 * </pre>
		 *
		 * <code>repeated .ClientIdentification.NameValue client_info = 3;</code>
		 */
		@java.lang.Override
		public java.util.List<? extends WvProto2.ClientIdentification.NameValueOrBuilder> getClientInfoOrBuilderList() {
			return clientInfo_;
		}

		/**
		 * <pre>
		 * Optional client information name/value pairs.
		 * </pre>
		 *
		 * <code>repeated .ClientIdentification.NameValue client_info = 3;</code>
		 */
		@java.lang.Override
		public int getClientInfoCount() {
			return clientInfo_.size();
		}

		/**
		 * <pre>
		 * Optional client information name/value pairs.
		 * </pre>
		 *
		 * <code>repeated .ClientIdentification.NameValue client_info = 3;</code>
		 */
		@java.lang.Override
		public WvProto2.ClientIdentification.NameValue getClientInfo(int index) {
			return clientInfo_.get(index);
		}

		/**
		 * <pre>
		 * Optional client information name/value pairs.
		 * </pre>
		 *
		 * <code>repeated .ClientIdentification.NameValue client_info = 3;</code>
		 */
		@java.lang.Override
		public WvProto2.ClientIdentification.NameValueOrBuilder getClientInfoOrBuilder(
				int index) {
			return clientInfo_.get(index);
		}

		public static final int PROVIDER_CLIENT_TOKEN_FIELD_NUMBER = 4;
		private ByteString providerClientToken_ = ByteString.EMPTY;

		/**
		 * <pre>
		 * Client token generated by the content provider. Optional.
		 * </pre>
		 *
		 * <code>optional bytes provider_client_token = 4;</code>
		 * 
		 * @return Whether the providerClientToken field is set.
		 */
		@java.lang.Override
		public boolean hasProviderClientToken() {
			return ((bitField0_ & 0x00000004) != 0);
		}

		/**
		 * <pre>
		 * Client token generated by the content provider. Optional.
		 * </pre>
		 *
		 * <code>optional bytes provider_client_token = 4;</code>
		 * 
		 * @return The providerClientToken.
		 */
		@java.lang.Override
		public ByteString getProviderClientToken() {
			return providerClientToken_;
		}

		public static final int LICENSE_COUNTER_FIELD_NUMBER = 5;
		private int licenseCounter_ = 0;

		/**
		 * <pre>
		 * Number of licenses received by the client to which the token above belongs.
		 * Only present if client_token is specified.
		 * </pre>
		 *
		 * <code>optional uint32 license_counter = 5;</code>
		 * 
		 * @return Whether the licenseCounter field is set.
		 */
		@java.lang.Override
		public boolean hasLicenseCounter() {
			return ((bitField0_ & 0x00000008) != 0);
		}

		/**
		 * <pre>
		 * Number of licenses received by the client to which the token above belongs.
		 * Only present if client_token is specified.
		 * </pre>
		 *
		 * <code>optional uint32 license_counter = 5;</code>
		 * 
		 * @return The licenseCounter.
		 */
		@java.lang.Override
		public int getLicenseCounter() {
			return licenseCounter_;
		}

		public static final int CLIENT_CAPABILITIES_FIELD_NUMBER = 6;
		private WvProto2.ClientIdentification.ClientCapabilities clientCapabilities_;

		/**
		 * <pre>
		 * List of non-baseline client capabilities.
		 * </pre>
		 *
		 * <code>optional .ClientIdentification.ClientCapabilities client_capabilities = 6;</code>
		 * 
		 * @return Whether the clientCapabilities field is set.
		 */
		@java.lang.Override
		public boolean hasClientCapabilities() {
			return ((bitField0_ & 0x00000010) != 0);
		}

		/**
		 * <pre>
		 * List of non-baseline client capabilities.
		 * </pre>
		 *
		 * <code>optional .ClientIdentification.ClientCapabilities client_capabilities = 6;</code>
		 * 
		 * @return The clientCapabilities.
		 */
		@java.lang.Override
		public WvProto2.ClientIdentification.ClientCapabilities getClientCapabilities() {
			return clientCapabilities_ == null
					? WvProto2.ClientIdentification.ClientCapabilities.getDefaultInstance()
					: clientCapabilities_;
		}

		/**
		 * <pre>
		 * List of non-baseline client capabilities.
		 * </pre>
		 *
		 * <code>optional .ClientIdentification.ClientCapabilities client_capabilities = 6;</code>
		 */
		@java.lang.Override
		public WvProto2.ClientIdentification.ClientCapabilitiesOrBuilder getClientCapabilitiesOrBuilder() {
			return clientCapabilities_ == null
					? WvProto2.ClientIdentification.ClientCapabilities.getDefaultInstance()
					: clientCapabilities_;
		}

		public static final int VMP_DATA_FIELD_NUMBER = 7;
		private ByteString vmpData_ = ByteString.EMPTY;

		/**
		 * <pre>
		 * Serialized VmpData message. Optional.
		 * </pre>
		 *
		 * <code>optional bytes vmp_data = 7;</code>
		 * 
		 * @return Whether the vmpData field is set.
		 */
		@java.lang.Override
		public boolean hasVmpData() {
			return ((bitField0_ & 0x00000020) != 0);
		}

		/**
		 * <pre>
		 * Serialized VmpData message. Optional.
		 * </pre>
		 *
		 * <code>optional bytes vmp_data = 7;</code>
		 * 
		 * @return The vmpData.
		 */
		@java.lang.Override
		public ByteString getVmpData() {
			return vmpData_;
		}

		public static final int DEVICE_CREDENTIALS_FIELD_NUMBER = 8;

		private java.util.List<WvProto2.ClientIdentification.ClientCredentials> deviceCredentials_;

		/**
		 * <pre>
		 * Optional field that may contain additional provisioning credentials.
		 * </pre>
		 *
		 * <code>repeated .ClientIdentification.ClientCredentials device_credentials = 8;</code>
		 */
		@java.lang.Override
		public java.util.List<WvProto2.ClientIdentification.ClientCredentials> getDeviceCredentialsList() {
			return deviceCredentials_;
		}

		/**
		 * <pre>
		 * Optional field that may contain additional provisioning credentials.
		 * </pre>
		 *
		 * <code>repeated .ClientIdentification.ClientCredentials device_credentials = 8;</code>
		 */
		@java.lang.Override
		public java.util.List<? extends WvProto2.ClientIdentification.ClientCredentialsOrBuilder> getDeviceCredentialsOrBuilderList() {
			return deviceCredentials_;
		}

		/**
		 * <pre>
		 * Optional field that may contain additional provisioning credentials.
		 * </pre>
		 *
		 * <code>repeated .ClientIdentification.ClientCredentials device_credentials = 8;</code>
		 */
		@java.lang.Override
		public int getDeviceCredentialsCount() {
			return deviceCredentials_.size();
		}

		/**
		 * <pre>
		 * Optional field that may contain additional provisioning credentials.
		 * </pre>
		 *
		 * <code>repeated .ClientIdentification.ClientCredentials device_credentials = 8;</code>
		 */
		@java.lang.Override
		public WvProto2.ClientIdentification.ClientCredentials getDeviceCredentials(int index) {
			return deviceCredentials_.get(index);
		}

		/**
		 * <pre>
		 * Optional field that may contain additional provisioning credentials.
		 * </pre>
		 *
		 * <code>repeated .ClientIdentification.ClientCredentials device_credentials = 8;</code>
		 */
		@java.lang.Override
		public WvProto2.ClientIdentification.ClientCredentialsOrBuilder getDeviceCredentialsOrBuilder(
				int index) {
			return deviceCredentials_.get(index);
		}

		private byte memoizedIsInitialized = -1;

		@java.lang.Override
		public final boolean isInitialized() {
			byte isInitialized = memoizedIsInitialized;
			if (isInitialized == 1)
				return true;
			if (isInitialized == 0)
				return false;

			memoizedIsInitialized = 1;
			return true;
		}

		@java.lang.Override
		public void writeTo(CodedOutputStream output) throws java.io.IOException {
			if (((bitField0_ & 0x00000001) != 0)) {
				output.writeEnum(1, type_);
			}
			if (((bitField0_ & 0x00000002) != 0)) {
				output.writeBytes(2, token_);
			}
			for (int i = 0; i < clientInfo_.size(); i++) {
				output.writeMessage(3, clientInfo_.get(i));
			}
			if (((bitField0_ & 0x00000004) != 0)) {
				output.writeBytes(4, providerClientToken_);
			}
			if (((bitField0_ & 0x00000008) != 0)) {
				output.writeUInt32(5, licenseCounter_);
			}
			if (((bitField0_ & 0x00000010) != 0)) {
				output.writeMessage(6, getClientCapabilities());
			}
			if (((bitField0_ & 0x00000020) != 0)) {
				output.writeBytes(7, vmpData_);
			}
			for (int i = 0; i < deviceCredentials_.size(); i++) {
				output.writeMessage(8, deviceCredentials_.get(i));
			}
			getUnknownFields().writeTo(output);
		}

		@java.lang.Override
		public int getSerializedSize() {
			int size = memoizedSize;
			if (size != -1)
				return size;

			size = 0;
			if (((bitField0_ & 0x00000001) != 0)) {
				size += CodedOutputStream.computeEnumSize(1, type_);
			}
			if (((bitField0_ & 0x00000002) != 0)) {
				size += CodedOutputStream.computeBytesSize(2, token_);
			}
			for (int i = 0; i < clientInfo_.size(); i++) {
				size += CodedOutputStream.computeMessageSize(3, clientInfo_.get(i));
			}
			if (((bitField0_ & 0x00000004) != 0)) {
				size += CodedOutputStream.computeBytesSize(4, providerClientToken_);
			}
			if (((bitField0_ & 0x00000008) != 0)) {
				size += CodedOutputStream.computeUInt32Size(5, licenseCounter_);
			}
			if (((bitField0_ & 0x00000010) != 0)) {
				size += CodedOutputStream.computeMessageSize(6, getClientCapabilities());
			}
			if (((bitField0_ & 0x00000020) != 0)) {
				size += CodedOutputStream.computeBytesSize(7, vmpData_);
			}
			for (int i = 0; i < deviceCredentials_.size(); i++) {
				size += CodedOutputStream.computeMessageSize(8, deviceCredentials_.get(i));
			}
			size += getUnknownFields().getSerializedSize();
			memoizedSize = size;
			return size;
		}

		@java.lang.Override
		public boolean equals(final java.lang.Object obj) {
			if (obj == this) {
				return true;
			}
			if (!(obj instanceof WvProto2.ClientIdentification)) {
				return super.equals(obj);
			}
			WvProto2.ClientIdentification other = (WvProto2.ClientIdentification) obj;

			if (hasType() != other.hasType())
				return false;
			if (hasType()) {
				if (type_ != other.type_)
					return false;
			}
			if (hasToken() != other.hasToken())
				return false;
			if (hasToken()) {
				if (!getToken().equals(other.getToken()))
					return false;
			}
			if (!getClientInfoList().equals(other.getClientInfoList()))
				return false;
			if (hasProviderClientToken() != other.hasProviderClientToken())
				return false;
			if (hasProviderClientToken()) {
				if (!getProviderClientToken().equals(other.getProviderClientToken()))
					return false;
			}
			if (hasLicenseCounter() != other.hasLicenseCounter())
				return false;
			if (hasLicenseCounter()) {
				if (getLicenseCounter() != other.getLicenseCounter())
					return false;
			}
			if (hasClientCapabilities() != other.hasClientCapabilities())
				return false;
			if (hasClientCapabilities()) {
				if (!getClientCapabilities().equals(other.getClientCapabilities()))
					return false;
			}
			if (hasVmpData() != other.hasVmpData())
				return false;
			if (hasVmpData()) {
				if (!getVmpData().equals(other.getVmpData()))
					return false;
			}
			if (!getDeviceCredentialsList().equals(other.getDeviceCredentialsList()))
				return false;
			if (!getUnknownFields().equals(other.getUnknownFields()))
				return false;
			return true;
		}

		@SuppressWarnings("unchecked")
		@java.lang.Override
		public int hashCode() {
			if (memoizedHashCode != 0) {
				return memoizedHashCode;
			}
			int hash = 41;
			hash = (19 * hash) + getDescriptor().hashCode();
			if (hasType()) {
				hash = (37 * hash) + TYPE_FIELD_NUMBER;
				hash = (53 * hash) + type_;
			}
			if (hasToken()) {
				hash = (37 * hash) + TOKEN_FIELD_NUMBER;
				hash = (53 * hash) + getToken().hashCode();
			}
			if (getClientInfoCount() > 0) {
				hash = (37 * hash) + CLIENT_INFO_FIELD_NUMBER;
				hash = (53 * hash) + getClientInfoList().hashCode();
			}
			if (hasProviderClientToken()) {
				hash = (37 * hash) + PROVIDER_CLIENT_TOKEN_FIELD_NUMBER;
				hash = (53 * hash) + getProviderClientToken().hashCode();
			}
			if (hasLicenseCounter()) {
				hash = (37 * hash) + LICENSE_COUNTER_FIELD_NUMBER;
				hash = (53 * hash) + getLicenseCounter();
			}
			if (hasClientCapabilities()) {
				hash = (37 * hash) + CLIENT_CAPABILITIES_FIELD_NUMBER;
				hash = (53 * hash) + getClientCapabilities().hashCode();
			}
			if (hasVmpData()) {
				hash = (37 * hash) + VMP_DATA_FIELD_NUMBER;
				hash = (53 * hash) + getVmpData().hashCode();
			}
			if (getDeviceCredentialsCount() > 0) {
				hash = (37 * hash) + DEVICE_CREDENTIALS_FIELD_NUMBER;
				hash = (53 * hash) + getDeviceCredentialsList().hashCode();
			}
			hash = (29 * hash) + getUnknownFields().hashCode();
			memoizedHashCode = hash;
			return hash;
		}

		public static WvProto2.ClientIdentification parseFrom(java.nio.ByteBuffer data)
				throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data);
		}

		public static WvProto2.ClientIdentification parseFrom(java.nio.ByteBuffer data,
				ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data, extensionRegistry);
		}

		public static WvProto2.ClientIdentification parseFrom(ByteString data)
				throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data);
		}

		public static WvProto2.ClientIdentification parseFrom(ByteString data,
				ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data, extensionRegistry);
		}

		public static WvProto2.ClientIdentification parseFrom(byte[] data)
				throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data);
		}

		public static WvProto2.ClientIdentification parseFrom(byte[] data,
				ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data, extensionRegistry);
		}

		public static WvProto2.ClientIdentification parseFrom(java.io.InputStream input)
				throws java.io.IOException {
			return GeneratedMessageV3.parseWithIOException(PARSER, input);
		}

		public static WvProto2.ClientIdentification parseFrom(java.io.InputStream input,
				ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
			return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
		}

		public static WvProto2.ClientIdentification parseDelimitedFrom(
				java.io.InputStream input) throws java.io.IOException {
			return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
		}

		public static WvProto2.ClientIdentification parseDelimitedFrom(
				java.io.InputStream input, ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
			return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input, extensionRegistry);
		}

		public static WvProto2.ClientIdentification parseFrom(CodedInputStream input)
				throws java.io.IOException {
			return GeneratedMessageV3.parseWithIOException(PARSER, input);
		}

		public static WvProto2.ClientIdentification parseFrom(CodedInputStream input,
				ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
			return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
		}

		@java.lang.Override
		public Builder newBuilderForType() {
			return newBuilder();
		}

		public static Builder newBuilder() {
			return DEFAULT_INSTANCE.toBuilder();
		}

		public static Builder newBuilder(WvProto2.ClientIdentification prototype) {
			return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
		}

		@java.lang.Override
		public Builder toBuilder() {
			return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
		}

		@java.lang.Override
		protected Builder newBuilderForType(GeneratedMessageV3.BuilderParent parent) {
			Builder builder = new Builder(parent);
			return builder;
		}

		/**
		 * <pre>
		 * ClientIdentification message used to authenticate the client device.
		 * </pre>
		 *
		 * Protobuf type {@code ClientIdentification}
		 */
		public static final class Builder extends GeneratedMessageV3.Builder<Builder> implements
				// @@protoc_insertion_point(builder_implements:ClientIdentification)
				WvProto2.ClientIdentificationOrBuilder {
			public static final Descriptors.Descriptor getDescriptor() {
				return WvProto2.internal_static_ClientIdentification_descriptor;
			}

			@java.lang.Override
			protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
				return WvProto2.internal_static_ClientIdentification_fieldAccessorTable
						.ensureFieldAccessorsInitialized(WvProto2.ClientIdentification.class,
								WvProto2.ClientIdentification.Builder.class);
			}

			// Construct using
			// WvProto2.ClientIdentification.newBuilder()
			private Builder() {
				maybeForceBuilderInitialization();
			}

			private Builder(GeneratedMessageV3.BuilderParent parent) {
				super(parent);
				maybeForceBuilderInitialization();
			}

			private void maybeForceBuilderInitialization() {
				if (GeneratedMessageV3.alwaysUseFieldBuilders) {
					getClientInfoFieldBuilder();
					getClientCapabilitiesFieldBuilder();
					getDeviceCredentialsFieldBuilder();
				}
			}

			@java.lang.Override
			public Builder clear() {
				super.clear();
				bitField0_ = 0;
				type_ = 0;
				token_ = ByteString.EMPTY;
				if (clientInfoBuilder_ == null) {
					clientInfo_ = java.util.Collections.emptyList();
				} else {
					clientInfo_ = null;
					clientInfoBuilder_.clear();
				}
				bitField0_ = (bitField0_ & ~0x00000004);
				providerClientToken_ = ByteString.EMPTY;
				licenseCounter_ = 0;
				clientCapabilities_ = null;
				if (clientCapabilitiesBuilder_ != null) {
					clientCapabilitiesBuilder_.dispose();
					clientCapabilitiesBuilder_ = null;
				}
				vmpData_ = ByteString.EMPTY;
				if (deviceCredentialsBuilder_ == null) {
					deviceCredentials_ = java.util.Collections.emptyList();
				} else {
					deviceCredentials_ = null;
					deviceCredentialsBuilder_.clear();
				}
				bitField0_ = (bitField0_ & ~0x00000080);
				return this;
			}

			@java.lang.Override
			public Descriptors.Descriptor getDescriptorForType() {
				return WvProto2.internal_static_ClientIdentification_descriptor;
			}

			@java.lang.Override
			public WvProto2.ClientIdentification getDefaultInstanceForType() {
				return WvProto2.ClientIdentification.getDefaultInstance();
			}

			@java.lang.Override
			public WvProto2.ClientIdentification build() {
				WvProto2.ClientIdentification result = buildPartial();
				if (!result.isInitialized()) {
					throw newUninitializedMessageException(result);
				}
				return result;
			}

			@java.lang.Override
			public WvProto2.ClientIdentification buildPartial() {
				WvProto2.ClientIdentification result = new WvProto2.ClientIdentification(
						this);
				buildPartialRepeatedFields(result);
				if (bitField0_ != 0) {
					buildPartial0(result);
				}
				onBuilt();
				return result;
			}

			private void buildPartialRepeatedFields(WvProto2.ClientIdentification result) {
				if (clientInfoBuilder_ == null) {
					if (((bitField0_ & 0x00000004) != 0)) {
						clientInfo_ = java.util.Collections.unmodifiableList(clientInfo_);
						bitField0_ = (bitField0_ & ~0x00000004);
					}
					result.clientInfo_ = clientInfo_;
				} else {
					result.clientInfo_ = clientInfoBuilder_.build();
				}
				if (deviceCredentialsBuilder_ == null) {
					if (((bitField0_ & 0x00000080) != 0)) {
						deviceCredentials_ = java.util.Collections.unmodifiableList(deviceCredentials_);
						bitField0_ = (bitField0_ & ~0x00000080);
					}
					result.deviceCredentials_ = deviceCredentials_;
				} else {
					result.deviceCredentials_ = deviceCredentialsBuilder_.build();
				}
			}

			private void buildPartial0(WvProto2.ClientIdentification result) {
				int from_bitField0_ = bitField0_;
				int to_bitField0_ = 0;
				if (((from_bitField0_ & 0x00000001) != 0)) {
					result.type_ = type_;
					to_bitField0_ |= 0x00000001;
				}
				if (((from_bitField0_ & 0x00000002) != 0)) {
					result.token_ = token_;
					to_bitField0_ |= 0x00000002;
				}
				if (((from_bitField0_ & 0x00000008) != 0)) {
					result.providerClientToken_ = providerClientToken_;
					to_bitField0_ |= 0x00000004;
				}
				if (((from_bitField0_ & 0x00000010) != 0)) {
					result.licenseCounter_ = licenseCounter_;
					to_bitField0_ |= 0x00000008;
				}
				if (((from_bitField0_ & 0x00000020) != 0)) {
					result.clientCapabilities_ = clientCapabilitiesBuilder_ == null ? clientCapabilities_
							: clientCapabilitiesBuilder_.build();
					to_bitField0_ |= 0x00000010;
				}
				if (((from_bitField0_ & 0x00000040) != 0)) {
					result.vmpData_ = vmpData_;
					to_bitField0_ |= 0x00000020;
				}
				result.bitField0_ |= to_bitField0_;
			}

			@java.lang.Override
			public Builder mergeFrom(Message other) {
				if (other instanceof WvProto2.ClientIdentification) {
					return mergeFrom((WvProto2.ClientIdentification) other);
				}
				super.mergeFrom(other);
				return this;
			}

			public Builder mergeFrom(WvProto2.ClientIdentification other) {
				if (other == WvProto2.ClientIdentification.getDefaultInstance())
					return this;
				if (other.hasType()) {
					setType(other.getType());
				}
				if (other.hasToken()) {
					setToken(other.getToken());
				}
				if (clientInfoBuilder_ == null) {
					if (!other.clientInfo_.isEmpty()) {
						if (clientInfo_.isEmpty()) {
							clientInfo_ = other.clientInfo_;
							bitField0_ = (bitField0_ & ~0x00000004);
						} else {
							ensureClientInfoIsMutable();
							clientInfo_.addAll(other.clientInfo_);
						}
						onChanged();
					}
				} else {
					if (!other.clientInfo_.isEmpty()) {
						if (clientInfoBuilder_.isEmpty()) {
							clientInfoBuilder_.dispose();
							clientInfoBuilder_ = null;
							clientInfo_ = other.clientInfo_;
							bitField0_ = (bitField0_ & ~0x00000004);
							clientInfoBuilder_ = GeneratedMessageV3.alwaysUseFieldBuilders ? getClientInfoFieldBuilder()
									: null;
						} else {
							clientInfoBuilder_.addAllMessages(other.clientInfo_);
						}
					}
				}
				if (other.hasProviderClientToken()) {
					setProviderClientToken(other.getProviderClientToken());
				}
				if (other.hasLicenseCounter()) {
					setLicenseCounter(other.getLicenseCounter());
				}
				if (other.hasClientCapabilities()) {
					mergeClientCapabilities(other.getClientCapabilities());
				}
				if (other.hasVmpData()) {
					setVmpData(other.getVmpData());
				}
				if (deviceCredentialsBuilder_ == null) {
					if (!other.deviceCredentials_.isEmpty()) {
						if (deviceCredentials_.isEmpty()) {
							deviceCredentials_ = other.deviceCredentials_;
							bitField0_ = (bitField0_ & ~0x00000080);
						} else {
							ensureDeviceCredentialsIsMutable();
							deviceCredentials_.addAll(other.deviceCredentials_);
						}
						onChanged();
					}
				} else {
					if (!other.deviceCredentials_.isEmpty()) {
						if (deviceCredentialsBuilder_.isEmpty()) {
							deviceCredentialsBuilder_.dispose();
							deviceCredentialsBuilder_ = null;
							deviceCredentials_ = other.deviceCredentials_;
							bitField0_ = (bitField0_ & ~0x00000080);
							deviceCredentialsBuilder_ = GeneratedMessageV3.alwaysUseFieldBuilders
									? getDeviceCredentialsFieldBuilder()
									: null;
						} else {
							deviceCredentialsBuilder_.addAllMessages(other.deviceCredentials_);
						}
					}
				}
				this.mergeUnknownFields(other.getUnknownFields());
				onChanged();
				return this;
			}

			@java.lang.Override
			public final boolean isInitialized() {
				return true;
			}

			@java.lang.Override
			public Builder mergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
					throws java.io.IOException {
				if (extensionRegistry == null) {
					throw new java.lang.NullPointerException();
				}
				try {
					boolean done = false;
					while (!done) {
						int tag = input.readTag();
						switch (tag) {
						case 0:
							done = true;
							break;
						case 8: {
							int tmpRaw = input.readEnum();
							WvProto2.ClientIdentification.TokenType tmpValue = WvProto2.ClientIdentification.TokenType
									.forNumber(tmpRaw);
							if (tmpValue == null) {
								mergeUnknownVarintField(1, tmpRaw);
							} else {
								type_ = tmpRaw;
								bitField0_ |= 0x00000001;
							}
							break;
						} // case 8
						case 18: {
							token_ = input.readBytes();
							bitField0_ |= 0x00000002;
							break;
						} // case 18
						case 26: {
							WvProto2.ClientIdentification.NameValue m = input.readMessage(
									WvProto2.ClientIdentification.NameValue.PARSER,
									extensionRegistry);
							if (clientInfoBuilder_ == null) {
								ensureClientInfoIsMutable();
								clientInfo_.add(m);
							} else {
								clientInfoBuilder_.addMessage(m);
							}
							break;
						} // case 26
						case 34: {
							providerClientToken_ = input.readBytes();
							bitField0_ |= 0x00000008;
							break;
						} // case 34
						case 40: {
							licenseCounter_ = input.readUInt32();
							bitField0_ |= 0x00000010;
							break;
						} // case 40
						case 50: {
							input.readMessage(getClientCapabilitiesFieldBuilder().getBuilder(), extensionRegistry);
							bitField0_ |= 0x00000020;
							break;
						} // case 50
						case 58: {
							vmpData_ = input.readBytes();
							bitField0_ |= 0x00000040;
							break;
						} // case 58
						case 66: {
							WvProto2.ClientIdentification.ClientCredentials m = input
									.readMessage(
											WvProto2.ClientIdentification.ClientCredentials.PARSER,
											extensionRegistry);
							if (deviceCredentialsBuilder_ == null) {
								ensureDeviceCredentialsIsMutable();
								deviceCredentials_.add(m);
							} else {
								deviceCredentialsBuilder_.addMessage(m);
							}
							break;
						} // case 66
						default: {
							if (!super.parseUnknownField(input, extensionRegistry, tag)) {
								done = true; // was an endgroup tag
							}
							break;
						} // default:
						} // switch (tag)
					} // while (!done)
				} catch (InvalidProtocolBufferException e) {
					throw e.unwrapIOException();
				}
				finally {
					onChanged();
				} // finally
				return this;
			}

			private int bitField0_;

			private int type_ = 0;

			/**
			 * <pre>
			 * Type of factory-provisioned device root of trust. Optional.
			 * </pre>
			 *
			 * <code>optional .ClientIdentification.TokenType type = 1 [default = KEYBOX];</code>
			 * 
			 * @return Whether the type field is set.
			 */
			@java.lang.Override
			public boolean hasType() {
				return ((bitField0_ & 0x00000001) != 0);
			}

			/**
			 * <pre>
			 * Type of factory-provisioned device root of trust. Optional.
			 * </pre>
			 *
			 * <code>optional .ClientIdentification.TokenType type = 1 [default = KEYBOX];</code>
			 * 
			 * @return The type.
			 */
			@java.lang.Override
			public WvProto2.ClientIdentification.TokenType getType() {
				WvProto2.ClientIdentification.TokenType result = WvProto2.ClientIdentification.TokenType
						.forNumber(type_);
				return result == null ? WvProto2.ClientIdentification.TokenType.KEYBOX : result;
			}

			/**
			 * <pre>
			 * Type of factory-provisioned device root of trust. Optional.
			 * </pre>
			 *
			 * <code>optional .ClientIdentification.TokenType type = 1 [default = KEYBOX];</code>
			 * 
			 * @param value The type to set.
			 * @return This builder for chaining.
			 */
			public Builder setType(WvProto2.ClientIdentification.TokenType value) {
				if (value == null) {
					throw new NullPointerException();
				}
				bitField0_ |= 0x00000001;
				type_ = value.getNumber();
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Type of factory-provisioned device root of trust. Optional.
			 * </pre>
			 *
			 * <code>optional .ClientIdentification.TokenType type = 1 [default = KEYBOX];</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearType() {
				bitField0_ = (bitField0_ & ~0x00000001);
				type_ = 0;
				onChanged();
				return this;
			}

			private ByteString token_ = ByteString.EMPTY;

			/**
			 * <pre>
			 * Factory-provisioned device root of trust. Required.
			 * </pre>
			 *
			 * <code>optional bytes token = 2;</code>
			 * 
			 * @return Whether the token field is set.
			 */
			@java.lang.Override
			public boolean hasToken() {
				return ((bitField0_ & 0x00000002) != 0);
			}

			/**
			 * <pre>
			 * Factory-provisioned device root of trust. Required.
			 * </pre>
			 *
			 * <code>optional bytes token = 2;</code>
			 * 
			 * @return The token.
			 */
			@java.lang.Override
			public ByteString getToken() {
				return token_;
			}

			/**
			 * <pre>
			 * Factory-provisioned device root of trust. Required.
			 * </pre>
			 *
			 * <code>optional bytes token = 2;</code>
			 * 
			 * @param value The token to set.
			 * @return This builder for chaining.
			 */
			public Builder setToken(ByteString value) {
				if (value == null) {
					throw new NullPointerException();
				}
				token_ = value;
				bitField0_ |= 0x00000002;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Factory-provisioned device root of trust. Required.
			 * </pre>
			 *
			 * <code>optional bytes token = 2;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearToken() {
				bitField0_ = (bitField0_ & ~0x00000002);
				token_ = getDefaultInstance().getToken();
				onChanged();
				return this;
			}

			private java.util.List<WvProto2.ClientIdentification.NameValue> clientInfo_ = java.util.Collections
					.emptyList();

			private void ensureClientInfoIsMutable() {
				if (!((bitField0_ & 0x00000004) != 0)) {
					clientInfo_ = new java.util.ArrayList<>(clientInfo_);
					bitField0_ |= 0x00000004;
				}
			}

			private RepeatedFieldBuilderV3<WvProto2.ClientIdentification.NameValue, WvProto2.ClientIdentification.NameValue.Builder, WvProto2.ClientIdentification.NameValueOrBuilder> clientInfoBuilder_;

			/**
			 * <pre>
			 * Optional client information name/value pairs.
			 * </pre>
			 *
			 * <code>repeated .ClientIdentification.NameValue client_info = 3;</code>
			 */
			@Override
			public java.util.List<WvProto2.ClientIdentification.NameValue> getClientInfoList() {
				if (clientInfoBuilder_ == null) {
					return java.util.Collections.unmodifiableList(clientInfo_);
				}
				return clientInfoBuilder_.getMessageList();
			}

			/**
			 * <pre>
			 * Optional client information name/value pairs.
			 * </pre>
			 *
			 * <code>repeated .ClientIdentification.NameValue client_info = 3;</code>
			 */
			@Override
			public int getClientInfoCount() {
				if (clientInfoBuilder_ == null) {
					return clientInfo_.size();
				}
				return clientInfoBuilder_.getCount();
			}

			/**
			 * <pre>
			 * Optional client information name/value pairs.
			 * </pre>
			 *
			 * <code>repeated .ClientIdentification.NameValue client_info = 3;</code>
			 */
			@Override
			public WvProto2.ClientIdentification.NameValue getClientInfo(int index) {
				if (clientInfoBuilder_ == null) {
					return clientInfo_.get(index);
				}
				return clientInfoBuilder_.getMessage(index);
			}

			/**
			 * <pre>
			 * Optional client information name/value pairs.
			 * </pre>
			 *
			 * <code>repeated .ClientIdentification.NameValue client_info = 3;</code>
			 */
			public Builder setClientInfo(int index,
					WvProto2.ClientIdentification.NameValue value) {
				if (clientInfoBuilder_ == null) {
					if (value == null) {
						throw new NullPointerException();
					}
					ensureClientInfoIsMutable();
					clientInfo_.set(index, value);
					onChanged();
				} else {
					clientInfoBuilder_.setMessage(index, value);
				}
				return this;
			}

			/**
			 * <pre>
			 * Optional client information name/value pairs.
			 * </pre>
			 *
			 * <code>repeated .ClientIdentification.NameValue client_info = 3;</code>
			 */
			public Builder setClientInfo(int index,
					WvProto2.ClientIdentification.NameValue.Builder builderForValue) {
				if (clientInfoBuilder_ == null) {
					ensureClientInfoIsMutable();
					clientInfo_.set(index, builderForValue.build());
					onChanged();
				} else {
					clientInfoBuilder_.setMessage(index, builderForValue.build());
				}
				return this;
			}

			/**
			 * <pre>
			 * Optional client information name/value pairs.
			 * </pre>
			 *
			 * <code>repeated .ClientIdentification.NameValue client_info = 3;</code>
			 */
			public Builder addClientInfo(WvProto2.ClientIdentification.NameValue value) {
				if (clientInfoBuilder_ == null) {
					if (value == null) {
						throw new NullPointerException();
					}
					ensureClientInfoIsMutable();
					clientInfo_.add(value);
					onChanged();
				} else {
					clientInfoBuilder_.addMessage(value);
				}
				return this;
			}

			/**
			 * <pre>
			 * Optional client information name/value pairs.
			 * </pre>
			 *
			 * <code>repeated .ClientIdentification.NameValue client_info = 3;</code>
			 */
			public Builder addClientInfo(int index,
					WvProto2.ClientIdentification.NameValue value) {
				if (clientInfoBuilder_ == null) {
					if (value == null) {
						throw new NullPointerException();
					}
					ensureClientInfoIsMutable();
					clientInfo_.add(index, value);
					onChanged();
				} else {
					clientInfoBuilder_.addMessage(index, value);
				}
				return this;
			}

			/**
			 * <pre>
			 * Optional client information name/value pairs.
			 * </pre>
			 *
			 * <code>repeated .ClientIdentification.NameValue client_info = 3;</code>
			 */
			public Builder addClientInfo(
					WvProto2.ClientIdentification.NameValue.Builder builderForValue) {
				if (clientInfoBuilder_ == null) {
					ensureClientInfoIsMutable();
					clientInfo_.add(builderForValue.build());
					onChanged();
				} else {
					clientInfoBuilder_.addMessage(builderForValue.build());
				}
				return this;
			}

			/**
			 * <pre>
			 * Optional client information name/value pairs.
			 * </pre>
			 *
			 * <code>repeated .ClientIdentification.NameValue client_info = 3;</code>
			 */
			public Builder addClientInfo(int index,
					WvProto2.ClientIdentification.NameValue.Builder builderForValue) {
				if (clientInfoBuilder_ == null) {
					ensureClientInfoIsMutable();
					clientInfo_.add(index, builderForValue.build());
					onChanged();
				} else {
					clientInfoBuilder_.addMessage(index, builderForValue.build());
				}
				return this;
			}

			/**
			 * <pre>
			 * Optional client information name/value pairs.
			 * </pre>
			 *
			 * <code>repeated .ClientIdentification.NameValue client_info = 3;</code>
			 */
			public Builder addAllClientInfo(
					java.lang.Iterable<? extends WvProto2.ClientIdentification.NameValue> values) {
				if (clientInfoBuilder_ == null) {
					ensureClientInfoIsMutable();
					AbstractMessageLite.Builder.addAll(values, clientInfo_);
					onChanged();
				} else {
					clientInfoBuilder_.addAllMessages(values);
				}
				return this;
			}

			/**
			 * <pre>
			 * Optional client information name/value pairs.
			 * </pre>
			 *
			 * <code>repeated .ClientIdentification.NameValue client_info = 3;</code>
			 */
			public Builder clearClientInfo() {
				if (clientInfoBuilder_ == null) {
					clientInfo_ = java.util.Collections.emptyList();
					bitField0_ = (bitField0_ & ~0x00000004);
					onChanged();
				} else {
					clientInfoBuilder_.clear();
				}
				return this;
			}

			/**
			 * <pre>
			 * Optional client information name/value pairs.
			 * </pre>
			 *
			 * <code>repeated .ClientIdentification.NameValue client_info = 3;</code>
			 */
			public Builder removeClientInfo(int index) {
				if (clientInfoBuilder_ == null) {
					ensureClientInfoIsMutable();
					clientInfo_.remove(index);
					onChanged();
				} else {
					clientInfoBuilder_.remove(index);
				}
				return this;
			}

			/**
			 * <pre>
			 * Optional client information name/value pairs.
			 * </pre>
			 *
			 * <code>repeated .ClientIdentification.NameValue client_info = 3;</code>
			 */
			public WvProto2.ClientIdentification.NameValue.Builder getClientInfoBuilder(
					int index) {
				return getClientInfoFieldBuilder().getBuilder(index);
			}

			/**
			 * <pre>
			 * Optional client information name/value pairs.
			 * </pre>
			 *
			 * <code>repeated .ClientIdentification.NameValue client_info = 3;</code>
			 */
			@Override
			public WvProto2.ClientIdentification.NameValueOrBuilder getClientInfoOrBuilder(
					int index) {
				if (clientInfoBuilder_ == null) {
					return clientInfo_.get(index);
				}
				return clientInfoBuilder_.getMessageOrBuilder(index);
			}

			/**
			 * <pre>
			 * Optional client information name/value pairs.
			 * </pre>
			 *
			 * <code>repeated .ClientIdentification.NameValue client_info = 3;</code>
			 */
			@Override
			public java.util.List<? extends WvProto2.ClientIdentification.NameValueOrBuilder> getClientInfoOrBuilderList() {
				if (clientInfoBuilder_ != null) {
					return clientInfoBuilder_.getMessageOrBuilderList();
				}
				return java.util.Collections.unmodifiableList(clientInfo_);
			}

			/**
			 * <pre>
			 * Optional client information name/value pairs.
			 * </pre>
			 *
			 * <code>repeated .ClientIdentification.NameValue client_info = 3;</code>
			 */
			public WvProto2.ClientIdentification.NameValue.Builder addClientInfoBuilder() {
				return getClientInfoFieldBuilder().addBuilder(
						WvProto2.ClientIdentification.NameValue.getDefaultInstance());
			}

			/**
			 * <pre>
			 * Optional client information name/value pairs.
			 * </pre>
			 *
			 * <code>repeated .ClientIdentification.NameValue client_info = 3;</code>
			 */
			public WvProto2.ClientIdentification.NameValue.Builder addClientInfoBuilder(
					int index) {
				return getClientInfoFieldBuilder().addBuilder(index,
						WvProto2.ClientIdentification.NameValue.getDefaultInstance());
			}

			/**
			 * <pre>
			 * Optional client information name/value pairs.
			 * </pre>
			 *
			 * <code>repeated .ClientIdentification.NameValue client_info = 3;</code>
			 */
			public java.util.List<WvProto2.ClientIdentification.NameValue.Builder> getClientInfoBuilderList() {
				return getClientInfoFieldBuilder().getBuilderList();
			}

			private RepeatedFieldBuilderV3<WvProto2.ClientIdentification.NameValue, WvProto2.ClientIdentification.NameValue.Builder, WvProto2.ClientIdentification.NameValueOrBuilder> getClientInfoFieldBuilder() {
				if (clientInfoBuilder_ == null) {
					clientInfoBuilder_ = new RepeatedFieldBuilderV3<>(clientInfo_, ((bitField0_ & 0x00000004) != 0),
							getParentForChildren(), isClean());
					clientInfo_ = null;
				}
				return clientInfoBuilder_;
			}

			private ByteString providerClientToken_ = ByteString.EMPTY;

			/**
			 * <pre>
			 * Client token generated by the content provider. Optional.
			 * </pre>
			 *
			 * <code>optional bytes provider_client_token = 4;</code>
			 * 
			 * @return Whether the providerClientToken field is set.
			 */
			@java.lang.Override
			public boolean hasProviderClientToken() {
				return ((bitField0_ & 0x00000008) != 0);
			}

			/**
			 * <pre>
			 * Client token generated by the content provider. Optional.
			 * </pre>
			 *
			 * <code>optional bytes provider_client_token = 4;</code>
			 * 
			 * @return The providerClientToken.
			 */
			@java.lang.Override
			public ByteString getProviderClientToken() {
				return providerClientToken_;
			}

			/**
			 * <pre>
			 * Client token generated by the content provider. Optional.
			 * </pre>
			 *
			 * <code>optional bytes provider_client_token = 4;</code>
			 * 
			 * @param value The providerClientToken to set.
			 * @return This builder for chaining.
			 */
			public Builder setProviderClientToken(ByteString value) {
				if (value == null) {
					throw new NullPointerException();
				}
				providerClientToken_ = value;
				bitField0_ |= 0x00000008;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Client token generated by the content provider. Optional.
			 * </pre>
			 *
			 * <code>optional bytes provider_client_token = 4;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearProviderClientToken() {
				bitField0_ = (bitField0_ & ~0x00000008);
				providerClientToken_ = getDefaultInstance().getProviderClientToken();
				onChanged();
				return this;
			}

			private int licenseCounter_;

			/**
			 * <pre>
			 * Number of licenses received by the client to which the token above belongs.
			 * Only present if client_token is specified.
			 * </pre>
			 *
			 * <code>optional uint32 license_counter = 5;</code>
			 * 
			 * @return Whether the licenseCounter field is set.
			 */
			@java.lang.Override
			public boolean hasLicenseCounter() {
				return ((bitField0_ & 0x00000010) != 0);
			}

			/**
			 * <pre>
			 * Number of licenses received by the client to which the token above belongs.
			 * Only present if client_token is specified.
			 * </pre>
			 *
			 * <code>optional uint32 license_counter = 5;</code>
			 * 
			 * @return The licenseCounter.
			 */
			@java.lang.Override
			public int getLicenseCounter() {
				return licenseCounter_;
			}

			/**
			 * <pre>
			 * Number of licenses received by the client to which the token above belongs.
			 * Only present if client_token is specified.
			 * </pre>
			 *
			 * <code>optional uint32 license_counter = 5;</code>
			 * 
			 * @param value The licenseCounter to set.
			 * @return This builder for chaining.
			 */
			public Builder setLicenseCounter(int value) {

				licenseCounter_ = value;
				bitField0_ |= 0x00000010;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Number of licenses received by the client to which the token above belongs.
			 * Only present if client_token is specified.
			 * </pre>
			 *
			 * <code>optional uint32 license_counter = 5;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearLicenseCounter() {
				bitField0_ = (bitField0_ & ~0x00000010);
				licenseCounter_ = 0;
				onChanged();
				return this;
			}

			private WvProto2.ClientIdentification.ClientCapabilities clientCapabilities_;
			private SingleFieldBuilderV3<WvProto2.ClientIdentification.ClientCapabilities, WvProto2.ClientIdentification.ClientCapabilities.Builder, WvProto2.ClientIdentification.ClientCapabilitiesOrBuilder> clientCapabilitiesBuilder_;

			/**
			 * <pre>
			 * List of non-baseline client capabilities.
			 * </pre>
			 *
			 * <code>optional .ClientIdentification.ClientCapabilities client_capabilities = 6;</code>
			 * 
			 * @return Whether the clientCapabilities field is set.
			 */
			@Override
			public boolean hasClientCapabilities() {
				return ((bitField0_ & 0x00000020) != 0);
			}

			/**
			 * <pre>
			 * List of non-baseline client capabilities.
			 * </pre>
			 *
			 * <code>optional .ClientIdentification.ClientCapabilities client_capabilities = 6;</code>
			 * 
			 * @return The clientCapabilities.
			 */
			@Override
			public WvProto2.ClientIdentification.ClientCapabilities getClientCapabilities() {
				if (clientCapabilitiesBuilder_ == null) {
					return clientCapabilities_ == null
							? WvProto2.ClientIdentification.ClientCapabilities
									.getDefaultInstance()
							: clientCapabilities_;
				}
				return clientCapabilitiesBuilder_.getMessage();
			}

			/**
			 * <pre>
			 * List of non-baseline client capabilities.
			 * </pre>
			 *
			 * <code>optional .ClientIdentification.ClientCapabilities client_capabilities = 6;</code>
			 */
			public Builder setClientCapabilities(
					WvProto2.ClientIdentification.ClientCapabilities value) {
				if (clientCapabilitiesBuilder_ == null) {
					if (value == null) {
						throw new NullPointerException();
					}
					clientCapabilities_ = value;
				} else {
					clientCapabilitiesBuilder_.setMessage(value);
				}
				bitField0_ |= 0x00000020;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * List of non-baseline client capabilities.
			 * </pre>
			 *
			 * <code>optional .ClientIdentification.ClientCapabilities client_capabilities = 6;</code>
			 */
			public Builder setClientCapabilities(
					WvProto2.ClientIdentification.ClientCapabilities.Builder builderForValue) {
				if (clientCapabilitiesBuilder_ == null) {
					clientCapabilities_ = builderForValue.build();
				} else {
					clientCapabilitiesBuilder_.setMessage(builderForValue.build());
				}
				bitField0_ |= 0x00000020;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * List of non-baseline client capabilities.
			 * </pre>
			 *
			 * <code>optional .ClientIdentification.ClientCapabilities client_capabilities = 6;</code>
			 */
			public Builder mergeClientCapabilities(
					WvProto2.ClientIdentification.ClientCapabilities value) {
				if (clientCapabilitiesBuilder_ == null) {
					if (((bitField0_ & 0x00000020) != 0) && clientCapabilities_ != null
							&& clientCapabilities_ != WvProto2.ClientIdentification.ClientCapabilities
									.getDefaultInstance()) {
						getClientCapabilitiesBuilder().mergeFrom(value);
					} else {
						clientCapabilities_ = value;
					}
				} else {
					clientCapabilitiesBuilder_.mergeFrom(value);
				}
				bitField0_ |= 0x00000020;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * List of non-baseline client capabilities.
			 * </pre>
			 *
			 * <code>optional .ClientIdentification.ClientCapabilities client_capabilities = 6;</code>
			 */
			public Builder clearClientCapabilities() {
				bitField0_ = (bitField0_ & ~0x00000020);
				clientCapabilities_ = null;
				if (clientCapabilitiesBuilder_ != null) {
					clientCapabilitiesBuilder_.dispose();
					clientCapabilitiesBuilder_ = null;
				}
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * List of non-baseline client capabilities.
			 * </pre>
			 *
			 * <code>optional .ClientIdentification.ClientCapabilities client_capabilities = 6;</code>
			 */
			public WvProto2.ClientIdentification.ClientCapabilities.Builder getClientCapabilitiesBuilder() {
				bitField0_ |= 0x00000020;
				onChanged();
				return getClientCapabilitiesFieldBuilder().getBuilder();
			}

			/**
			 * <pre>
			 * List of non-baseline client capabilities.
			 * </pre>
			 *
			 * <code>optional .ClientIdentification.ClientCapabilities client_capabilities = 6;</code>
			 */
			@Override
			public WvProto2.ClientIdentification.ClientCapabilitiesOrBuilder getClientCapabilitiesOrBuilder() {
				if (clientCapabilitiesBuilder_ != null) {
					return clientCapabilitiesBuilder_.getMessageOrBuilder();
				}
				return clientCapabilities_ == null
						? WvProto2.ClientIdentification.ClientCapabilities
								.getDefaultInstance()
						: clientCapabilities_;
			}

			/**
			 * <pre>
			 * List of non-baseline client capabilities.
			 * </pre>
			 *
			 * <code>optional .ClientIdentification.ClientCapabilities client_capabilities = 6;</code>
			 */
			private SingleFieldBuilderV3<WvProto2.ClientIdentification.ClientCapabilities, WvProto2.ClientIdentification.ClientCapabilities.Builder, WvProto2.ClientIdentification.ClientCapabilitiesOrBuilder> getClientCapabilitiesFieldBuilder() {
				if (clientCapabilitiesBuilder_ == null) {
					clientCapabilitiesBuilder_ = new SingleFieldBuilderV3<>(getClientCapabilities(),
							getParentForChildren(), isClean());
					clientCapabilities_ = null;
				}
				return clientCapabilitiesBuilder_;
			}

			private ByteString vmpData_ = ByteString.EMPTY;

			/**
			 * <pre>
			 * Serialized VmpData message. Optional.
			 * </pre>
			 *
			 * <code>optional bytes vmp_data = 7;</code>
			 * 
			 * @return Whether the vmpData field is set.
			 */
			@java.lang.Override
			public boolean hasVmpData() {
				return ((bitField0_ & 0x00000040) != 0);
			}

			/**
			 * <pre>
			 * Serialized VmpData message. Optional.
			 * </pre>
			 *
			 * <code>optional bytes vmp_data = 7;</code>
			 * 
			 * @return The vmpData.
			 */
			@java.lang.Override
			public ByteString getVmpData() {
				return vmpData_;
			}

			/**
			 * <pre>
			 * Serialized VmpData message. Optional.
			 * </pre>
			 *
			 * <code>optional bytes vmp_data = 7;</code>
			 * 
			 * @param value The vmpData to set.
			 * @return This builder for chaining.
			 */
			public Builder setVmpData(ByteString value) {
				if (value == null) {
					throw new NullPointerException();
				}
				vmpData_ = value;
				bitField0_ |= 0x00000040;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Serialized VmpData message. Optional.
			 * </pre>
			 *
			 * <code>optional bytes vmp_data = 7;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearVmpData() {
				bitField0_ = (bitField0_ & ~0x00000040);
				vmpData_ = getDefaultInstance().getVmpData();
				onChanged();
				return this;
			}

			private java.util.List<WvProto2.ClientIdentification.ClientCredentials> deviceCredentials_ = java.util.Collections
					.emptyList();

			private void ensureDeviceCredentialsIsMutable() {
				if (!((bitField0_ & 0x00000080) != 0)) {
					deviceCredentials_ = new java.util.ArrayList<>(deviceCredentials_);
					bitField0_ |= 0x00000080;
				}
			}

			private RepeatedFieldBuilderV3<WvProto2.ClientIdentification.ClientCredentials, WvProto2.ClientIdentification.ClientCredentials.Builder, WvProto2.ClientIdentification.ClientCredentialsOrBuilder> deviceCredentialsBuilder_;

			/**
			 * <pre>
			 * Optional field that may contain additional provisioning credentials.
			 * </pre>
			 *
			 * <code>repeated .ClientIdentification.ClientCredentials device_credentials = 8;</code>
			 */
			@Override
			public java.util.List<WvProto2.ClientIdentification.ClientCredentials> getDeviceCredentialsList() {
				if (deviceCredentialsBuilder_ == null) {
					return java.util.Collections.unmodifiableList(deviceCredentials_);
				}
				return deviceCredentialsBuilder_.getMessageList();
			}

			/**
			 * <pre>
			 * Optional field that may contain additional provisioning credentials.
			 * </pre>
			 *
			 * <code>repeated .ClientIdentification.ClientCredentials device_credentials = 8;</code>
			 */
			@Override
			public int getDeviceCredentialsCount() {
				if (deviceCredentialsBuilder_ == null) {
					return deviceCredentials_.size();
				}
				return deviceCredentialsBuilder_.getCount();
			}

			/**
			 * <pre>
			 * Optional field that may contain additional provisioning credentials.
			 * </pre>
			 *
			 * <code>repeated .ClientIdentification.ClientCredentials device_credentials = 8;</code>
			 */
			@Override
			public WvProto2.ClientIdentification.ClientCredentials getDeviceCredentials(
					int index) {
				if (deviceCredentialsBuilder_ == null) {
					return deviceCredentials_.get(index);
				}
				return deviceCredentialsBuilder_.getMessage(index);
			}

			/**
			 * <pre>
			 * Optional field that may contain additional provisioning credentials.
			 * </pre>
			 *
			 * <code>repeated .ClientIdentification.ClientCredentials device_credentials = 8;</code>
			 */
			public Builder setDeviceCredentials(int index,
					WvProto2.ClientIdentification.ClientCredentials value) {
				if (deviceCredentialsBuilder_ == null) {
					if (value == null) {
						throw new NullPointerException();
					}
					ensureDeviceCredentialsIsMutable();
					deviceCredentials_.set(index, value);
					onChanged();
				} else {
					deviceCredentialsBuilder_.setMessage(index, value);
				}
				return this;
			}

			/**
			 * <pre>
			 * Optional field that may contain additional provisioning credentials.
			 * </pre>
			 *
			 * <code>repeated .ClientIdentification.ClientCredentials device_credentials = 8;</code>
			 */
			public Builder setDeviceCredentials(int index,
					WvProto2.ClientIdentification.ClientCredentials.Builder builderForValue) {
				if (deviceCredentialsBuilder_ == null) {
					ensureDeviceCredentialsIsMutable();
					deviceCredentials_.set(index, builderForValue.build());
					onChanged();
				} else {
					deviceCredentialsBuilder_.setMessage(index, builderForValue.build());
				}
				return this;
			}

			/**
			 * <pre>
			 * Optional field that may contain additional provisioning credentials.
			 * </pre>
			 *
			 * <code>repeated .ClientIdentification.ClientCredentials device_credentials = 8;</code>
			 */
			public Builder addDeviceCredentials(
					WvProto2.ClientIdentification.ClientCredentials value) {
				if (deviceCredentialsBuilder_ == null) {
					if (value == null) {
						throw new NullPointerException();
					}
					ensureDeviceCredentialsIsMutable();
					deviceCredentials_.add(value);
					onChanged();
				} else {
					deviceCredentialsBuilder_.addMessage(value);
				}
				return this;
			}

			/**
			 * <pre>
			 * Optional field that may contain additional provisioning credentials.
			 * </pre>
			 *
			 * <code>repeated .ClientIdentification.ClientCredentials device_credentials = 8;</code>
			 */
			public Builder addDeviceCredentials(int index,
					WvProto2.ClientIdentification.ClientCredentials value) {
				if (deviceCredentialsBuilder_ == null) {
					if (value == null) {
						throw new NullPointerException();
					}
					ensureDeviceCredentialsIsMutable();
					deviceCredentials_.add(index, value);
					onChanged();
				} else {
					deviceCredentialsBuilder_.addMessage(index, value);
				}
				return this;
			}

			/**
			 * <pre>
			 * Optional field that may contain additional provisioning credentials.
			 * </pre>
			 *
			 * <code>repeated .ClientIdentification.ClientCredentials device_credentials = 8;</code>
			 */
			public Builder addDeviceCredentials(
					WvProto2.ClientIdentification.ClientCredentials.Builder builderForValue) {
				if (deviceCredentialsBuilder_ == null) {
					ensureDeviceCredentialsIsMutable();
					deviceCredentials_.add(builderForValue.build());
					onChanged();
				} else {
					deviceCredentialsBuilder_.addMessage(builderForValue.build());
				}
				return this;
			}

			/**
			 * <pre>
			 * Optional field that may contain additional provisioning credentials.
			 * </pre>
			 *
			 * <code>repeated .ClientIdentification.ClientCredentials device_credentials = 8;</code>
			 */
			public Builder addDeviceCredentials(int index,
					WvProto2.ClientIdentification.ClientCredentials.Builder builderForValue) {
				if (deviceCredentialsBuilder_ == null) {
					ensureDeviceCredentialsIsMutable();
					deviceCredentials_.add(index, builderForValue.build());
					onChanged();
				} else {
					deviceCredentialsBuilder_.addMessage(index, builderForValue.build());
				}
				return this;
			}

			/**
			 * <pre>
			 * Optional field that may contain additional provisioning credentials.
			 * </pre>
			 *
			 * <code>repeated .ClientIdentification.ClientCredentials device_credentials = 8;</code>
			 */
			public Builder addAllDeviceCredentials(
					java.lang.Iterable<? extends WvProto2.ClientIdentification.ClientCredentials> values) {
				if (deviceCredentialsBuilder_ == null) {
					ensureDeviceCredentialsIsMutable();
					AbstractMessageLite.Builder.addAll(values, deviceCredentials_);
					onChanged();
				} else {
					deviceCredentialsBuilder_.addAllMessages(values);
				}
				return this;
			}

			/**
			 * <pre>
			 * Optional field that may contain additional provisioning credentials.
			 * </pre>
			 *
			 * <code>repeated .ClientIdentification.ClientCredentials device_credentials = 8;</code>
			 */
			public Builder clearDeviceCredentials() {
				if (deviceCredentialsBuilder_ == null) {
					deviceCredentials_ = java.util.Collections.emptyList();
					bitField0_ = (bitField0_ & ~0x00000080);
					onChanged();
				} else {
					deviceCredentialsBuilder_.clear();
				}
				return this;
			}

			/**
			 * <pre>
			 * Optional field that may contain additional provisioning credentials.
			 * </pre>
			 *
			 * <code>repeated .ClientIdentification.ClientCredentials device_credentials = 8;</code>
			 */
			public Builder removeDeviceCredentials(int index) {
				if (deviceCredentialsBuilder_ == null) {
					ensureDeviceCredentialsIsMutable();
					deviceCredentials_.remove(index);
					onChanged();
				} else {
					deviceCredentialsBuilder_.remove(index);
				}
				return this;
			}

			/**
			 * <pre>
			 * Optional field that may contain additional provisioning credentials.
			 * </pre>
			 *
			 * <code>repeated .ClientIdentification.ClientCredentials device_credentials = 8;</code>
			 */
			public WvProto2.ClientIdentification.ClientCredentials.Builder getDeviceCredentialsBuilder(
					int index) {
				return getDeviceCredentialsFieldBuilder().getBuilder(index);
			}

			/**
			 * <pre>
			 * Optional field that may contain additional provisioning credentials.
			 * </pre>
			 *
			 * <code>repeated .ClientIdentification.ClientCredentials device_credentials = 8;</code>
			 */
			@Override
			public WvProto2.ClientIdentification.ClientCredentialsOrBuilder getDeviceCredentialsOrBuilder(
					int index) {
				if (deviceCredentialsBuilder_ == null) {
					return deviceCredentials_.get(index);
				}
				return deviceCredentialsBuilder_.getMessageOrBuilder(index);
			}

			/**
			 * <pre>
			 * Optional field that may contain additional provisioning credentials.
			 * </pre>
			 *
			 * <code>repeated .ClientIdentification.ClientCredentials device_credentials = 8;</code>
			 */
			@Override
			public java.util.List<? extends WvProto2.ClientIdentification.ClientCredentialsOrBuilder> getDeviceCredentialsOrBuilderList() {
				if (deviceCredentialsBuilder_ != null) {
					return deviceCredentialsBuilder_.getMessageOrBuilderList();
				}
				return java.util.Collections.unmodifiableList(deviceCredentials_);
			}

			/**
			 * <pre>
			 * Optional field that may contain additional provisioning credentials.
			 * </pre>
			 *
			 * <code>repeated .ClientIdentification.ClientCredentials device_credentials = 8;</code>
			 */
			public WvProto2.ClientIdentification.ClientCredentials.Builder addDeviceCredentialsBuilder() {
				return getDeviceCredentialsFieldBuilder().addBuilder(
						WvProto2.ClientIdentification.ClientCredentials.getDefaultInstance());
			}

			/**
			 * <pre>
			 * Optional field that may contain additional provisioning credentials.
			 * </pre>
			 *
			 * <code>repeated .ClientIdentification.ClientCredentials device_credentials = 8;</code>
			 */
			public WvProto2.ClientIdentification.ClientCredentials.Builder addDeviceCredentialsBuilder(
					int index) {
				return getDeviceCredentialsFieldBuilder().addBuilder(index,
						WvProto2.ClientIdentification.ClientCredentials.getDefaultInstance());
			}

			/**
			 * <pre>
			 * Optional field that may contain additional provisioning credentials.
			 * </pre>
			 *
			 * <code>repeated .ClientIdentification.ClientCredentials device_credentials = 8;</code>
			 */
			public java.util.List<WvProto2.ClientIdentification.ClientCredentials.Builder> getDeviceCredentialsBuilderList() {
				return getDeviceCredentialsFieldBuilder().getBuilderList();
			}

			private RepeatedFieldBuilderV3<WvProto2.ClientIdentification.ClientCredentials, WvProto2.ClientIdentification.ClientCredentials.Builder, WvProto2.ClientIdentification.ClientCredentialsOrBuilder> getDeviceCredentialsFieldBuilder() {
				if (deviceCredentialsBuilder_ == null) {
					deviceCredentialsBuilder_ = new RepeatedFieldBuilderV3<>(deviceCredentials_,
							((bitField0_ & 0x00000080) != 0), getParentForChildren(), isClean());
					deviceCredentials_ = null;
				}
				return deviceCredentialsBuilder_;
			}

			@java.lang.Override
			public final Builder setUnknownFields(final UnknownFieldSet unknownFields) {
				return super.setUnknownFields(unknownFields);
			}

			@java.lang.Override
			public final Builder mergeUnknownFields(final UnknownFieldSet unknownFields) {
				return super.mergeUnknownFields(unknownFields);
			}

			// @@protoc_insertion_point(builder_scope:ClientIdentification)
		}

		// @@protoc_insertion_point(class_scope:ClientIdentification)
		private static final WvProto2.ClientIdentification DEFAULT_INSTANCE;
		static {
			DEFAULT_INSTANCE = new WvProto2.ClientIdentification();
		}

		public static WvProto2.ClientIdentification getDefaultInstance() {
			return DEFAULT_INSTANCE;
		}

		@java.lang.Deprecated public static final Parser<ClientIdentification> PARSER = new AbstractParser<>() {
			@java.lang.Override
			public ClientIdentification parsePartialFrom(CodedInputStream input,
					ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
				Builder builder = newBuilder();
				try {
					builder.mergeFrom(input, extensionRegistry);
				} catch (InvalidProtocolBufferException e) {
					throw e.setUnfinishedMessage(builder.buildPartial());
				} catch (UninitializedMessageException e) {
					throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
				} catch (java.io.IOException e) {
					throw new InvalidProtocolBufferException(e).setUnfinishedMessage(builder.buildPartial());
				}
				return builder.buildPartial();
			}
		};

		public static Parser<ClientIdentification> parser() {
			return PARSER;
		}

		@java.lang.Override
		public Parser<ClientIdentification> getParserForType() {
			return PARSER;
		}

		@java.lang.Override
		public WvProto2.ClientIdentification getDefaultInstanceForType() {
			return DEFAULT_INSTANCE;
		}

	}

	public interface EncryptedClientIdentificationOrBuilder extends
			// @@protoc_insertion_point(interface_extends:EncryptedClientIdentification)
			MessageOrBuilder {

		/**
		 * <pre>
		 * Provider ID for which the ClientIdentifcation is encrypted (owner of
		 * service certificate).
		 * </pre>
		 *
		 * <code>optional string provider_id = 1;</code>
		 * 
		 * @return Whether the providerId field is set.
		 */
		boolean hasProviderId();

		/**
		 * <pre>
		 * Provider ID for which the ClientIdentifcation is encrypted (owner of
		 * service certificate).
		 * </pre>
		 *
		 * <code>optional string provider_id = 1;</code>
		 * 
		 * @return The providerId.
		 */
		java.lang.String getProviderId();

		/**
		 * <pre>
		 * Provider ID for which the ClientIdentifcation is encrypted (owner of
		 * service certificate).
		 * </pre>
		 *
		 * <code>optional string provider_id = 1;</code>
		 * 
		 * @return The bytes for providerId.
		 */
		ByteString getProviderIdBytes();

		/**
		 * <pre>
		 * Serial number for the service certificate for which ClientIdentification is
		 * encrypted.
		 * </pre>
		 *
		 * <code>optional bytes service_certificate_serial_number = 2;</code>
		 * 
		 * @return Whether the serviceCertificateSerialNumber field is set.
		 */
		boolean hasServiceCertificateSerialNumber();

		/**
		 * <pre>
		 * Serial number for the service certificate for which ClientIdentification is
		 * encrypted.
		 * </pre>
		 *
		 * <code>optional bytes service_certificate_serial_number = 2;</code>
		 * 
		 * @return The serviceCertificateSerialNumber.
		 */
		ByteString getServiceCertificateSerialNumber();

		/**
		 * <pre>
		 * Serialized ClientIdentification message, encrypted with the privacy key
		 * using AES-128-CBC with PKCS#5 padding.
		 * </pre>
		 *
		 * <code>optional bytes encrypted_client_id = 3;</code>
		 * 
		 * @return Whether the encryptedClientId field is set.
		 */
		boolean hasEncryptedClientId();

		/**
		 * <pre>
		 * Serialized ClientIdentification message, encrypted with the privacy key
		 * using AES-128-CBC with PKCS#5 padding.
		 * </pre>
		 *
		 * <code>optional bytes encrypted_client_id = 3;</code>
		 * 
		 * @return The encryptedClientId.
		 */
		ByteString getEncryptedClientId();

		/**
		 * <pre>
		 * Initialization vector needed to decrypt encrypted_client_id.
		 * </pre>
		 *
		 * <code>optional bytes encrypted_client_id_iv = 4;</code>
		 * 
		 * @return Whether the encryptedClientIdIv field is set.
		 */
		boolean hasEncryptedClientIdIv();

		/**
		 * <pre>
		 * Initialization vector needed to decrypt encrypted_client_id.
		 * </pre>
		 *
		 * <code>optional bytes encrypted_client_id_iv = 4;</code>
		 * 
		 * @return The encryptedClientIdIv.
		 */
		ByteString getEncryptedClientIdIv();

		/**
		 * <pre>
		 * AES-128 privacy key, encrypted with the service public key using RSA-OAEP.
		 * </pre>
		 *
		 * <code>optional bytes encrypted_privacy_key = 5;</code>
		 * 
		 * @return Whether the encryptedPrivacyKey field is set.
		 */
		boolean hasEncryptedPrivacyKey();

		/**
		 * <pre>
		 * AES-128 privacy key, encrypted with the service public key using RSA-OAEP.
		 * </pre>
		 *
		 * <code>optional bytes encrypted_privacy_key = 5;</code>
		 * 
		 * @return The encryptedPrivacyKey.
		 */
		ByteString getEncryptedPrivacyKey();
	}

	/**
	 * <pre>
	 * EncryptedClientIdentification message used to hold ClientIdentification
	 * messages encrypted for privacy purposes.
	 * </pre>
	 *
	 * Protobuf type {@code EncryptedClientIdentification}
	 */
	public static final class EncryptedClientIdentification extends GeneratedMessageV3 implements
			// @@protoc_insertion_point(message_implements:EncryptedClientIdentification)
			EncryptedClientIdentificationOrBuilder {
		private static final long serialVersionUID = 0L;

		// Use EncryptedClientIdentification.newBuilder() to construct.
		private EncryptedClientIdentification(GeneratedMessageV3.Builder<?> builder) {
			super(builder);
		}

		private EncryptedClientIdentification() {
			providerId_ = "";
			serviceCertificateSerialNumber_ = ByteString.EMPTY;
			encryptedClientId_ = ByteString.EMPTY;
			encryptedClientIdIv_ = ByteString.EMPTY;
			encryptedPrivacyKey_ = ByteString.EMPTY;
		}

		@java.lang.Override

		protected java.lang.Object newInstance(UnusedPrivateParameter unused) {
			return new EncryptedClientIdentification();
		}

		public static final Descriptors.Descriptor getDescriptor() {
			return WvProto2.internal_static_EncryptedClientIdentification_descriptor;
		}

		@java.lang.Override
		protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
			return WvProto2.internal_static_EncryptedClientIdentification_fieldAccessorTable
					.ensureFieldAccessorsInitialized(
							WvProto2.EncryptedClientIdentification.class,
							WvProto2.EncryptedClientIdentification.Builder.class);
		}

		private int bitField0_;
		public static final int PROVIDER_ID_FIELD_NUMBER = 1;

		private volatile java.lang.Object providerId_ = "";

		/**
		 * <pre>
		 * Provider ID for which the ClientIdentifcation is encrypted (owner of
		 * service certificate).
		 * </pre>
		 *
		 * <code>optional string provider_id = 1;</code>
		 * 
		 * @return Whether the providerId field is set.
		 */
		@java.lang.Override
		public boolean hasProviderId() {
			return ((bitField0_ & 0x00000001) != 0);
		}

		/**
		 * <pre>
		 * Provider ID for which the ClientIdentifcation is encrypted (owner of
		 * service certificate).
		 * </pre>
		 *
		 * <code>optional string provider_id = 1;</code>
		 * 
		 * @return The providerId.
		 */
		@java.lang.Override
		public java.lang.String getProviderId() {
			java.lang.Object ref = providerId_;
			if (ref instanceof java.lang.String) {
				return (java.lang.String) ref;
			}
			ByteString bs = (ByteString) ref;
			java.lang.String s = bs.toStringUtf8();
			if (bs.isValidUtf8()) {
				providerId_ = s;
			}
			return s;
		}

		/**
		 * <pre>
		 * Provider ID for which the ClientIdentifcation is encrypted (owner of
		 * service certificate).
		 * </pre>
		 *
		 * <code>optional string provider_id = 1;</code>
		 * 
		 * @return The bytes for providerId.
		 */
		@java.lang.Override
		public ByteString getProviderIdBytes() {
			java.lang.Object ref = providerId_;
			if (ref instanceof java.lang.String) {
				ByteString b = ByteString.copyFromUtf8((java.lang.String) ref);
				providerId_ = b;
				return b;
			}
			return (ByteString) ref;
		}

		public static final int SERVICE_CERTIFICATE_SERIAL_NUMBER_FIELD_NUMBER = 2;
		private ByteString serviceCertificateSerialNumber_ = ByteString.EMPTY;

		/**
		 * <pre>
		 * Serial number for the service certificate for which ClientIdentification is
		 * encrypted.
		 * </pre>
		 *
		 * <code>optional bytes service_certificate_serial_number = 2;</code>
		 * 
		 * @return Whether the serviceCertificateSerialNumber field is set.
		 */
		@java.lang.Override
		public boolean hasServiceCertificateSerialNumber() {
			return ((bitField0_ & 0x00000002) != 0);
		}

		/**
		 * <pre>
		 * Serial number for the service certificate for which ClientIdentification is
		 * encrypted.
		 * </pre>
		 *
		 * <code>optional bytes service_certificate_serial_number = 2;</code>
		 * 
		 * @return The serviceCertificateSerialNumber.
		 */
		@java.lang.Override
		public ByteString getServiceCertificateSerialNumber() {
			return serviceCertificateSerialNumber_;
		}

		public static final int ENCRYPTED_CLIENT_ID_FIELD_NUMBER = 3;
		private ByteString encryptedClientId_ = ByteString.EMPTY;

		/**
		 * <pre>
		 * Serialized ClientIdentification message, encrypted with the privacy key
		 * using AES-128-CBC with PKCS#5 padding.
		 * </pre>
		 *
		 * <code>optional bytes encrypted_client_id = 3;</code>
		 * 
		 * @return Whether the encryptedClientId field is set.
		 */
		@java.lang.Override
		public boolean hasEncryptedClientId() {
			return ((bitField0_ & 0x00000004) != 0);
		}

		/**
		 * <pre>
		 * Serialized ClientIdentification message, encrypted with the privacy key
		 * using AES-128-CBC with PKCS#5 padding.
		 * </pre>
		 *
		 * <code>optional bytes encrypted_client_id = 3;</code>
		 * 
		 * @return The encryptedClientId.
		 */
		@java.lang.Override
		public ByteString getEncryptedClientId() {
			return encryptedClientId_;
		}

		public static final int ENCRYPTED_CLIENT_ID_IV_FIELD_NUMBER = 4;
		private ByteString encryptedClientIdIv_ = ByteString.EMPTY;

		/**
		 * <pre>
		 * Initialization vector needed to decrypt encrypted_client_id.
		 * </pre>
		 *
		 * <code>optional bytes encrypted_client_id_iv = 4;</code>
		 * 
		 * @return Whether the encryptedClientIdIv field is set.
		 */
		@java.lang.Override
		public boolean hasEncryptedClientIdIv() {
			return ((bitField0_ & 0x00000008) != 0);
		}

		/**
		 * <pre>
		 * Initialization vector needed to decrypt encrypted_client_id.
		 * </pre>
		 *
		 * <code>optional bytes encrypted_client_id_iv = 4;</code>
		 * 
		 * @return The encryptedClientIdIv.
		 */
		@java.lang.Override
		public ByteString getEncryptedClientIdIv() {
			return encryptedClientIdIv_;
		}

		public static final int ENCRYPTED_PRIVACY_KEY_FIELD_NUMBER = 5;
		private ByteString encryptedPrivacyKey_ = ByteString.EMPTY;

		/**
		 * <pre>
		 * AES-128 privacy key, encrypted with the service public key using RSA-OAEP.
		 * </pre>
		 *
		 * <code>optional bytes encrypted_privacy_key = 5;</code>
		 * 
		 * @return Whether the encryptedPrivacyKey field is set.
		 */
		@java.lang.Override
		public boolean hasEncryptedPrivacyKey() {
			return ((bitField0_ & 0x00000010) != 0);
		}

		/**
		 * <pre>
		 * AES-128 privacy key, encrypted with the service public key using RSA-OAEP.
		 * </pre>
		 *
		 * <code>optional bytes encrypted_privacy_key = 5;</code>
		 * 
		 * @return The encryptedPrivacyKey.
		 */
		@java.lang.Override
		public ByteString getEncryptedPrivacyKey() {
			return encryptedPrivacyKey_;
		}

		private byte memoizedIsInitialized = -1;

		@java.lang.Override
		public final boolean isInitialized() {
			byte isInitialized = memoizedIsInitialized;
			if (isInitialized == 1)
				return true;
			if (isInitialized == 0)
				return false;

			memoizedIsInitialized = 1;
			return true;
		}

		@java.lang.Override
		public void writeTo(CodedOutputStream output) throws java.io.IOException {
			if (((bitField0_ & 0x00000001) != 0)) {
				GeneratedMessageV3.writeString(output, 1, providerId_);
			}
			if (((bitField0_ & 0x00000002) != 0)) {
				output.writeBytes(2, serviceCertificateSerialNumber_);
			}
			if (((bitField0_ & 0x00000004) != 0)) {
				output.writeBytes(3, encryptedClientId_);
			}
			if (((bitField0_ & 0x00000008) != 0)) {
				output.writeBytes(4, encryptedClientIdIv_);
			}
			if (((bitField0_ & 0x00000010) != 0)) {
				output.writeBytes(5, encryptedPrivacyKey_);
			}
			getUnknownFields().writeTo(output);
		}

		@java.lang.Override
		public int getSerializedSize() {
			int size = memoizedSize;
			if (size != -1)
				return size;

			size = 0;
			if (((bitField0_ & 0x00000001) != 0)) {
				size += GeneratedMessageV3.computeStringSize(1, providerId_);
			}
			if (((bitField0_ & 0x00000002) != 0)) {
				size += CodedOutputStream.computeBytesSize(2, serviceCertificateSerialNumber_);
			}
			if (((bitField0_ & 0x00000004) != 0)) {
				size += CodedOutputStream.computeBytesSize(3, encryptedClientId_);
			}
			if (((bitField0_ & 0x00000008) != 0)) {
				size += CodedOutputStream.computeBytesSize(4, encryptedClientIdIv_);
			}
			if (((bitField0_ & 0x00000010) != 0)) {
				size += CodedOutputStream.computeBytesSize(5, encryptedPrivacyKey_);
			}
			size += getUnknownFields().getSerializedSize();
			memoizedSize = size;
			return size;
		}

		@java.lang.Override
		public boolean equals(final java.lang.Object obj) {
			if (obj == this) {
				return true;
			}
			if (!(obj instanceof WvProto2.EncryptedClientIdentification)) {
				return super.equals(obj);
			}
			WvProto2.EncryptedClientIdentification other = (WvProto2.EncryptedClientIdentification) obj;

			if (hasProviderId() != other.hasProviderId())
				return false;
			if (hasProviderId()) {
				if (!getProviderId().equals(other.getProviderId()))
					return false;
			}
			if (hasServiceCertificateSerialNumber() != other.hasServiceCertificateSerialNumber())
				return false;
			if (hasServiceCertificateSerialNumber()) {
				if (!getServiceCertificateSerialNumber().equals(other.getServiceCertificateSerialNumber()))
					return false;
			}
			if (hasEncryptedClientId() != other.hasEncryptedClientId())
				return false;
			if (hasEncryptedClientId()) {
				if (!getEncryptedClientId().equals(other.getEncryptedClientId()))
					return false;
			}
			if (hasEncryptedClientIdIv() != other.hasEncryptedClientIdIv())
				return false;
			if (hasEncryptedClientIdIv()) {
				if (!getEncryptedClientIdIv().equals(other.getEncryptedClientIdIv()))
					return false;
			}
			if (hasEncryptedPrivacyKey() != other.hasEncryptedPrivacyKey())
				return false;
			if (hasEncryptedPrivacyKey()) {
				if (!getEncryptedPrivacyKey().equals(other.getEncryptedPrivacyKey()))
					return false;
			}
			if (!getUnknownFields().equals(other.getUnknownFields()))
				return false;
			return true;
		}

		@SuppressWarnings("unchecked")
		@java.lang.Override
		public int hashCode() {
			if (memoizedHashCode != 0) {
				return memoizedHashCode;
			}
			int hash = 41;
			hash = (19 * hash) + getDescriptor().hashCode();
			if (hasProviderId()) {
				hash = (37 * hash) + PROVIDER_ID_FIELD_NUMBER;
				hash = (53 * hash) + getProviderId().hashCode();
			}
			if (hasServiceCertificateSerialNumber()) {
				hash = (37 * hash) + SERVICE_CERTIFICATE_SERIAL_NUMBER_FIELD_NUMBER;
				hash = (53 * hash) + getServiceCertificateSerialNumber().hashCode();
			}
			if (hasEncryptedClientId()) {
				hash = (37 * hash) + ENCRYPTED_CLIENT_ID_FIELD_NUMBER;
				hash = (53 * hash) + getEncryptedClientId().hashCode();
			}
			if (hasEncryptedClientIdIv()) {
				hash = (37 * hash) + ENCRYPTED_CLIENT_ID_IV_FIELD_NUMBER;
				hash = (53 * hash) + getEncryptedClientIdIv().hashCode();
			}
			if (hasEncryptedPrivacyKey()) {
				hash = (37 * hash) + ENCRYPTED_PRIVACY_KEY_FIELD_NUMBER;
				hash = (53 * hash) + getEncryptedPrivacyKey().hashCode();
			}
			hash = (29 * hash) + getUnknownFields().hashCode();
			memoizedHashCode = hash;
			return hash;
		}

		public static WvProto2.EncryptedClientIdentification parseFrom(java.nio.ByteBuffer data)
				throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data);
		}

		public static WvProto2.EncryptedClientIdentification parseFrom(java.nio.ByteBuffer data,
				ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data, extensionRegistry);
		}

		public static WvProto2.EncryptedClientIdentification parseFrom(ByteString data)
				throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data);
		}

		public static WvProto2.EncryptedClientIdentification parseFrom(ByteString data,
				ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data, extensionRegistry);
		}

		public static WvProto2.EncryptedClientIdentification parseFrom(byte[] data)
				throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data);
		}

		public static WvProto2.EncryptedClientIdentification parseFrom(byte[] data,
				ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data, extensionRegistry);
		}

		public static WvProto2.EncryptedClientIdentification parseFrom(
				java.io.InputStream input) throws java.io.IOException {
			return GeneratedMessageV3.parseWithIOException(PARSER, input);
		}

		public static WvProto2.EncryptedClientIdentification parseFrom(
				java.io.InputStream input, ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
			return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
		}

		public static WvProto2.EncryptedClientIdentification parseDelimitedFrom(
				java.io.InputStream input) throws java.io.IOException {
			return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
		}

		public static WvProto2.EncryptedClientIdentification parseDelimitedFrom(
				java.io.InputStream input, ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
			return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input, extensionRegistry);
		}

		public static WvProto2.EncryptedClientIdentification parseFrom(CodedInputStream input)
				throws java.io.IOException {
			return GeneratedMessageV3.parseWithIOException(PARSER, input);
		}

		public static WvProto2.EncryptedClientIdentification parseFrom(CodedInputStream input,
				ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
			return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
		}

		@java.lang.Override
		public Builder newBuilderForType() {
			return newBuilder();
		}

		public static Builder newBuilder() {
			return DEFAULT_INSTANCE.toBuilder();
		}

		public static Builder newBuilder(WvProto2.EncryptedClientIdentification prototype) {
			return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
		}

		@java.lang.Override
		public Builder toBuilder() {
			return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
		}

		@java.lang.Override
		protected Builder newBuilderForType(GeneratedMessageV3.BuilderParent parent) {
			Builder builder = new Builder(parent);
			return builder;
		}

		/**
		 * <pre>
		 * EncryptedClientIdentification message used to hold ClientIdentification
		 * messages encrypted for privacy purposes.
		 * </pre>
		 *
		 * Protobuf type {@code EncryptedClientIdentification}
		 */
		public static final class Builder extends GeneratedMessageV3.Builder<Builder> implements
				// @@protoc_insertion_point(builder_implements:EncryptedClientIdentification)
				WvProto2.EncryptedClientIdentificationOrBuilder {
			public static final Descriptors.Descriptor getDescriptor() {
				return WvProto2.internal_static_EncryptedClientIdentification_descriptor;
			}

			@java.lang.Override
			protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
				return WvProto2.internal_static_EncryptedClientIdentification_fieldAccessorTable
						.ensureFieldAccessorsInitialized(
								WvProto2.EncryptedClientIdentification.class,
								WvProto2.EncryptedClientIdentification.Builder.class);
			}

			// Construct using
			// WvProto2.EncryptedClientIdentification.newBuilder()
			private Builder() {

			}

			private Builder(GeneratedMessageV3.BuilderParent parent) {
				super(parent);

			}

			@java.lang.Override
			public Builder clear() {
				super.clear();
				bitField0_ = 0;
				providerId_ = "";
				serviceCertificateSerialNumber_ = ByteString.EMPTY;
				encryptedClientId_ = ByteString.EMPTY;
				encryptedClientIdIv_ = ByteString.EMPTY;
				encryptedPrivacyKey_ = ByteString.EMPTY;
				return this;
			}

			@java.lang.Override
			public Descriptors.Descriptor getDescriptorForType() {
				return WvProto2.internal_static_EncryptedClientIdentification_descriptor;
			}

			@java.lang.Override
			public WvProto2.EncryptedClientIdentification getDefaultInstanceForType() {
				return WvProto2.EncryptedClientIdentification.getDefaultInstance();
			}

			@java.lang.Override
			public WvProto2.EncryptedClientIdentification build() {
				WvProto2.EncryptedClientIdentification result = buildPartial();
				if (!result.isInitialized()) {
					throw newUninitializedMessageException(result);
				}
				return result;
			}

			@java.lang.Override
			public WvProto2.EncryptedClientIdentification buildPartial() {
				WvProto2.EncryptedClientIdentification result = new WvProto2.EncryptedClientIdentification(
						this);
				if (bitField0_ != 0) {
					buildPartial0(result);
				}
				onBuilt();
				return result;
			}

			private void buildPartial0(WvProto2.EncryptedClientIdentification result) {
				int from_bitField0_ = bitField0_;
				int to_bitField0_ = 0;
				if (((from_bitField0_ & 0x00000001) != 0)) {
					result.providerId_ = providerId_;
					to_bitField0_ |= 0x00000001;
				}
				if (((from_bitField0_ & 0x00000002) != 0)) {
					result.serviceCertificateSerialNumber_ = serviceCertificateSerialNumber_;
					to_bitField0_ |= 0x00000002;
				}
				if (((from_bitField0_ & 0x00000004) != 0)) {
					result.encryptedClientId_ = encryptedClientId_;
					to_bitField0_ |= 0x00000004;
				}
				if (((from_bitField0_ & 0x00000008) != 0)) {
					result.encryptedClientIdIv_ = encryptedClientIdIv_;
					to_bitField0_ |= 0x00000008;
				}
				if (((from_bitField0_ & 0x00000010) != 0)) {
					result.encryptedPrivacyKey_ = encryptedPrivacyKey_;
					to_bitField0_ |= 0x00000010;
				}
				result.bitField0_ |= to_bitField0_;
			}

			@java.lang.Override
			public Builder mergeFrom(Message other) {
				if (other instanceof WvProto2.EncryptedClientIdentification) {
					return mergeFrom((WvProto2.EncryptedClientIdentification) other);
				}
				super.mergeFrom(other);
				return this;
			}

			public Builder mergeFrom(WvProto2.EncryptedClientIdentification other) {
				if (other == WvProto2.EncryptedClientIdentification.getDefaultInstance())
					return this;
				if (other.hasProviderId()) {
					providerId_ = other.providerId_;
					bitField0_ |= 0x00000001;
					onChanged();
				}
				if (other.hasServiceCertificateSerialNumber()) {
					setServiceCertificateSerialNumber(other.getServiceCertificateSerialNumber());
				}
				if (other.hasEncryptedClientId()) {
					setEncryptedClientId(other.getEncryptedClientId());
				}
				if (other.hasEncryptedClientIdIv()) {
					setEncryptedClientIdIv(other.getEncryptedClientIdIv());
				}
				if (other.hasEncryptedPrivacyKey()) {
					setEncryptedPrivacyKey(other.getEncryptedPrivacyKey());
				}
				this.mergeUnknownFields(other.getUnknownFields());
				onChanged();
				return this;
			}

			@java.lang.Override
			public final boolean isInitialized() {
				return true;
			}

			@java.lang.Override
			public Builder mergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
					throws java.io.IOException {
				if (extensionRegistry == null) {
					throw new java.lang.NullPointerException();
				}
				try {
					boolean done = false;
					while (!done) {
						int tag = input.readTag();
						switch (tag) {
						case 0:
							done = true;
							break;
						case 10: {
							providerId_ = input.readBytes();
							bitField0_ |= 0x00000001;
							break;
						} // case 10
						case 18: {
							serviceCertificateSerialNumber_ = input.readBytes();
							bitField0_ |= 0x00000002;
							break;
						} // case 18
						case 26: {
							encryptedClientId_ = input.readBytes();
							bitField0_ |= 0x00000004;
							break;
						} // case 26
						case 34: {
							encryptedClientIdIv_ = input.readBytes();
							bitField0_ |= 0x00000008;
							break;
						} // case 34
						case 42: {
							encryptedPrivacyKey_ = input.readBytes();
							bitField0_ |= 0x00000010;
							break;
						} // case 42
						default: {
							if (!super.parseUnknownField(input, extensionRegistry, tag)) {
								done = true; // was an endgroup tag
							}
							break;
						} // default:
						} // switch (tag)
					} // while (!done)
				} catch (InvalidProtocolBufferException e) {
					throw e.unwrapIOException();
				}
				finally {
					onChanged();
				} // finally
				return this;
			}

			private int bitField0_;

			private java.lang.Object providerId_ = "";

			/**
			 * <pre>
			 * Provider ID for which the ClientIdentifcation is encrypted (owner of
			 * service certificate).
			 * </pre>
			 *
			 * <code>optional string provider_id = 1;</code>
			 * 
			 * @return Whether the providerId field is set.
			 */
			@Override
			public boolean hasProviderId() {
				return ((bitField0_ & 0x00000001) != 0);
			}

			/**
			 * <pre>
			 * Provider ID for which the ClientIdentifcation is encrypted (owner of
			 * service certificate).
			 * </pre>
			 *
			 * <code>optional string provider_id = 1;</code>
			 * 
			 * @return The providerId.
			 */
			@Override
			public java.lang.String getProviderId() {
				java.lang.Object ref = providerId_;
				if (!(ref instanceof java.lang.String)) {
					ByteString bs = (ByteString) ref;
					java.lang.String s = bs.toStringUtf8();
					if (bs.isValidUtf8()) {
						providerId_ = s;
					}
					return s;
				}
				return (java.lang.String) ref;
			}

			/**
			 * <pre>
			 * Provider ID for which the ClientIdentifcation is encrypted (owner of
			 * service certificate).
			 * </pre>
			 *
			 * <code>optional string provider_id = 1;</code>
			 * 
			 * @return The bytes for providerId.
			 */
			@Override
			public ByteString getProviderIdBytes() {
				java.lang.Object ref = providerId_;
				if (ref instanceof String) {
					ByteString b = ByteString.copyFromUtf8((java.lang.String) ref);
					providerId_ = b;
					return b;
				}
				return (ByteString) ref;
			}

			/**
			 * <pre>
			 * Provider ID for which the ClientIdentifcation is encrypted (owner of
			 * service certificate).
			 * </pre>
			 *
			 * <code>optional string provider_id = 1;</code>
			 * 
			 * @param value The providerId to set.
			 * @return This builder for chaining.
			 */
			public Builder setProviderId(java.lang.String value) {
				if (value == null) {
					throw new NullPointerException();
				}
				providerId_ = value;
				bitField0_ |= 0x00000001;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Provider ID for which the ClientIdentifcation is encrypted (owner of
			 * service certificate).
			 * </pre>
			 *
			 * <code>optional string provider_id = 1;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearProviderId() {
				providerId_ = getDefaultInstance().getProviderId();
				bitField0_ = (bitField0_ & ~0x00000001);
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Provider ID for which the ClientIdentifcation is encrypted (owner of
			 * service certificate).
			 * </pre>
			 *
			 * <code>optional string provider_id = 1;</code>
			 * 
			 * @param value The bytes for providerId to set.
			 * @return This builder for chaining.
			 */
			public Builder setProviderIdBytes(ByteString value) {
				if (value == null) {
					throw new NullPointerException();
				}
				providerId_ = value;
				bitField0_ |= 0x00000001;
				onChanged();
				return this;
			}

			private ByteString serviceCertificateSerialNumber_ = ByteString.EMPTY;

			/**
			 * <pre>
			 * Serial number for the service certificate for which ClientIdentification is
			 * encrypted.
			 * </pre>
			 *
			 * <code>optional bytes service_certificate_serial_number = 2;</code>
			 * 
			 * @return Whether the serviceCertificateSerialNumber field is set.
			 */
			@java.lang.Override
			public boolean hasServiceCertificateSerialNumber() {
				return ((bitField0_ & 0x00000002) != 0);
			}

			/**
			 * <pre>
			 * Serial number for the service certificate for which ClientIdentification is
			 * encrypted.
			 * </pre>
			 *
			 * <code>optional bytes service_certificate_serial_number = 2;</code>
			 * 
			 * @return The serviceCertificateSerialNumber.
			 */
			@java.lang.Override
			public ByteString getServiceCertificateSerialNumber() {
				return serviceCertificateSerialNumber_;
			}

			/**
			 * <pre>
			 * Serial number for the service certificate for which ClientIdentification is
			 * encrypted.
			 * </pre>
			 *
			 * <code>optional bytes service_certificate_serial_number = 2;</code>
			 * 
			 * @param value The serviceCertificateSerialNumber to set.
			 * @return This builder for chaining.
			 */
			public Builder setServiceCertificateSerialNumber(ByteString value) {
				if (value == null) {
					throw new NullPointerException();
				}
				serviceCertificateSerialNumber_ = value;
				bitField0_ |= 0x00000002;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Serial number for the service certificate for which ClientIdentification is
			 * encrypted.
			 * </pre>
			 *
			 * <code>optional bytes service_certificate_serial_number = 2;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearServiceCertificateSerialNumber() {
				bitField0_ = (bitField0_ & ~0x00000002);
				serviceCertificateSerialNumber_ = getDefaultInstance().getServiceCertificateSerialNumber();
				onChanged();
				return this;
			}

			private ByteString encryptedClientId_ = ByteString.EMPTY;

			/**
			 * <pre>
			 * Serialized ClientIdentification message, encrypted with the privacy key
			 * using AES-128-CBC with PKCS#5 padding.
			 * </pre>
			 *
			 * <code>optional bytes encrypted_client_id = 3;</code>
			 * 
			 * @return Whether the encryptedClientId field is set.
			 */
			@java.lang.Override
			public boolean hasEncryptedClientId() {
				return ((bitField0_ & 0x00000004) != 0);
			}

			/**
			 * <pre>
			 * Serialized ClientIdentification message, encrypted with the privacy key
			 * using AES-128-CBC with PKCS#5 padding.
			 * </pre>
			 *
			 * <code>optional bytes encrypted_client_id = 3;</code>
			 * 
			 * @return The encryptedClientId.
			 */
			@java.lang.Override
			public ByteString getEncryptedClientId() {
				return encryptedClientId_;
			}

			/**
			 * <pre>
			 * Serialized ClientIdentification message, encrypted with the privacy key
			 * using AES-128-CBC with PKCS#5 padding.
			 * </pre>
			 *
			 * <code>optional bytes encrypted_client_id = 3;</code>
			 * 
			 * @param value The encryptedClientId to set.
			 * @return This builder for chaining.
			 */
			public Builder setEncryptedClientId(ByteString value) {
				if (value == null) {
					throw new NullPointerException();
				}
				encryptedClientId_ = value;
				bitField0_ |= 0x00000004;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Serialized ClientIdentification message, encrypted with the privacy key
			 * using AES-128-CBC with PKCS#5 padding.
			 * </pre>
			 *
			 * <code>optional bytes encrypted_client_id = 3;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearEncryptedClientId() {
				bitField0_ = (bitField0_ & ~0x00000004);
				encryptedClientId_ = getDefaultInstance().getEncryptedClientId();
				onChanged();
				return this;
			}

			private ByteString encryptedClientIdIv_ = ByteString.EMPTY;

			/**
			 * <pre>
			 * Initialization vector needed to decrypt encrypted_client_id.
			 * </pre>
			 *
			 * <code>optional bytes encrypted_client_id_iv = 4;</code>
			 * 
			 * @return Whether the encryptedClientIdIv field is set.
			 */
			@java.lang.Override
			public boolean hasEncryptedClientIdIv() {
				return ((bitField0_ & 0x00000008) != 0);
			}

			/**
			 * <pre>
			 * Initialization vector needed to decrypt encrypted_client_id.
			 * </pre>
			 *
			 * <code>optional bytes encrypted_client_id_iv = 4;</code>
			 * 
			 * @return The encryptedClientIdIv.
			 */
			@java.lang.Override
			public ByteString getEncryptedClientIdIv() {
				return encryptedClientIdIv_;
			}

			/**
			 * <pre>
			 * Initialization vector needed to decrypt encrypted_client_id.
			 * </pre>
			 *
			 * <code>optional bytes encrypted_client_id_iv = 4;</code>
			 * 
			 * @param value The encryptedClientIdIv to set.
			 * @return This builder for chaining.
			 */
			public Builder setEncryptedClientIdIv(ByteString value) {
				if (value == null) {
					throw new NullPointerException();
				}
				encryptedClientIdIv_ = value;
				bitField0_ |= 0x00000008;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Initialization vector needed to decrypt encrypted_client_id.
			 * </pre>
			 *
			 * <code>optional bytes encrypted_client_id_iv = 4;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearEncryptedClientIdIv() {
				bitField0_ = (bitField0_ & ~0x00000008);
				encryptedClientIdIv_ = getDefaultInstance().getEncryptedClientIdIv();
				onChanged();
				return this;
			}

			private ByteString encryptedPrivacyKey_ = ByteString.EMPTY;

			/**
			 * <pre>
			 * AES-128 privacy key, encrypted with the service public key using RSA-OAEP.
			 * </pre>
			 *
			 * <code>optional bytes encrypted_privacy_key = 5;</code>
			 * 
			 * @return Whether the encryptedPrivacyKey field is set.
			 */
			@java.lang.Override
			public boolean hasEncryptedPrivacyKey() {
				return ((bitField0_ & 0x00000010) != 0);
			}

			/**
			 * <pre>
			 * AES-128 privacy key, encrypted with the service public key using RSA-OAEP.
			 * </pre>
			 *
			 * <code>optional bytes encrypted_privacy_key = 5;</code>
			 * 
			 * @return The encryptedPrivacyKey.
			 */
			@java.lang.Override
			public ByteString getEncryptedPrivacyKey() {
				return encryptedPrivacyKey_;
			}

			/**
			 * <pre>
			 * AES-128 privacy key, encrypted with the service public key using RSA-OAEP.
			 * </pre>
			 *
			 * <code>optional bytes encrypted_privacy_key = 5;</code>
			 * 
			 * @param value The encryptedPrivacyKey to set.
			 * @return This builder for chaining.
			 */
			public Builder setEncryptedPrivacyKey(ByteString value) {
				if (value == null) {
					throw new NullPointerException();
				}
				encryptedPrivacyKey_ = value;
				bitField0_ |= 0x00000010;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * AES-128 privacy key, encrypted with the service public key using RSA-OAEP.
			 * </pre>
			 *
			 * <code>optional bytes encrypted_privacy_key = 5;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearEncryptedPrivacyKey() {
				bitField0_ = (bitField0_ & ~0x00000010);
				encryptedPrivacyKey_ = getDefaultInstance().getEncryptedPrivacyKey();
				onChanged();
				return this;
			}

			@java.lang.Override
			public final Builder setUnknownFields(final UnknownFieldSet unknownFields) {
				return super.setUnknownFields(unknownFields);
			}

			@java.lang.Override
			public final Builder mergeUnknownFields(final UnknownFieldSet unknownFields) {
				return super.mergeUnknownFields(unknownFields);
			}

			// @@protoc_insertion_point(builder_scope:EncryptedClientIdentification)
		}

		// @@protoc_insertion_point(class_scope:EncryptedClientIdentification)
		private static final WvProto2.EncryptedClientIdentification DEFAULT_INSTANCE;
		static {
			DEFAULT_INSTANCE = new WvProto2.EncryptedClientIdentification();
		}

		public static WvProto2.EncryptedClientIdentification getDefaultInstance() {
			return DEFAULT_INSTANCE;
		}

		@java.lang.Deprecated public static final Parser<EncryptedClientIdentification> PARSER = new AbstractParser<>() {
			@java.lang.Override
			public EncryptedClientIdentification parsePartialFrom(CodedInputStream input,
					ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
				Builder builder = newBuilder();
				try {
					builder.mergeFrom(input, extensionRegistry);
				} catch (InvalidProtocolBufferException e) {
					throw e.setUnfinishedMessage(builder.buildPartial());
				} catch (UninitializedMessageException e) {
					throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
				} catch (java.io.IOException e) {
					throw new InvalidProtocolBufferException(e).setUnfinishedMessage(builder.buildPartial());
				}
				return builder.buildPartial();
			}
		};

		public static Parser<EncryptedClientIdentification> parser() {
			return PARSER;
		}

		@java.lang.Override
		public Parser<EncryptedClientIdentification> getParserForType() {
			return PARSER;
		}

		@java.lang.Override
		public WvProto2.EncryptedClientIdentification getDefaultInstanceForType() {
			return DEFAULT_INSTANCE;
		}

	}

	public interface DrmCertificateOrBuilder extends
			// @@protoc_insertion_point(interface_extends:DrmCertificate)
			MessageOrBuilder {

		/**
		 * <pre>
		 * Type of certificate. Required.
		 * </pre>
		 *
		 * <code>optional .DrmCertificate.Type type = 1;</code>
		 * 
		 * @return Whether the type field is set.
		 */
		boolean hasType();

		/**
		 * <pre>
		 * Type of certificate. Required.
		 * </pre>
		 *
		 * <code>optional .DrmCertificate.Type type = 1;</code>
		 * 
		 * @return The type.
		 */
		WvProto2.DrmCertificate.Type getType();

		/**
		 * <pre>
		 * 128-bit globally unique serial number of certificate.
		 * Value is 0 for root certificate. Required.
		 * </pre>
		 *
		 * <code>optional bytes serial_number = 2;</code>
		 * 
		 * @return Whether the serialNumber field is set.
		 */
		boolean hasSerialNumber();

		/**
		 * <pre>
		 * 128-bit globally unique serial number of certificate.
		 * Value is 0 for root certificate. Required.
		 * </pre>
		 *
		 * <code>optional bytes serial_number = 2;</code>
		 * 
		 * @return The serialNumber.
		 */
		ByteString getSerialNumber();

		/**
		 * <pre>
		 * POSIX time, in seconds, when the certificate was created. Required.
		 * </pre>
		 *
		 * <code>optional uint32 creation_time_seconds = 3;</code>
		 * 
		 * @return Whether the creationTimeSeconds field is set.
		 */
		boolean hasCreationTimeSeconds();

		/**
		 * <pre>
		 * POSIX time, in seconds, when the certificate was created. Required.
		 * </pre>
		 *
		 * <code>optional uint32 creation_time_seconds = 3;</code>
		 * 
		 * @return The creationTimeSeconds.
		 */
		int getCreationTimeSeconds();

		/**
		 * <pre>
		 * POSIX time, in seconds, when the certificate should expire. Value of zero
		 * denotes indefinite expiry time. For more information on limited lifespan
		 * DRM certificates see (go/limited-lifespan-drm-certificates).
		 * </pre>
		 *
		 * <code>optional uint32 expiration_time_seconds = 12;</code>
		 * 
		 * @return Whether the expirationTimeSeconds field is set.
		 */
		boolean hasExpirationTimeSeconds();

		/**
		 * <pre>
		 * POSIX time, in seconds, when the certificate should expire. Value of zero
		 * denotes indefinite expiry time. For more information on limited lifespan
		 * DRM certificates see (go/limited-lifespan-drm-certificates).
		 * </pre>
		 *
		 * <code>optional uint32 expiration_time_seconds = 12;</code>
		 * 
		 * @return The expirationTimeSeconds.
		 */
		int getExpirationTimeSeconds();

		/**
		 * <pre>
		 * Device public key. PKCS#1 ASN.1 DER-encoded. Required.
		 * </pre>
		 *
		 * <code>optional bytes public_key = 4;</code>
		 * 
		 * @return Whether the publicKey field is set.
		 */
		boolean hasPublicKey();

		/**
		 * <pre>
		 * Device public key. PKCS#1 ASN.1 DER-encoded. Required.
		 * </pre>
		 *
		 * <code>optional bytes public_key = 4;</code>
		 * 
		 * @return The publicKey.
		 */
		ByteString getPublicKey();

		/**
		 * <pre>
		 * Widevine system ID for the device. Required for intermediate and
		 * user device certificates.
		 * </pre>
		 *
		 * <code>optional uint32 system_id = 5;</code>
		 * 
		 * @return Whether the systemId field is set.
		 */
		boolean hasSystemId();

		/**
		 * <pre>
		 * Widevine system ID for the device. Required for intermediate and
		 * user device certificates.
		 * </pre>
		 *
		 * <code>optional uint32 system_id = 5;</code>
		 * 
		 * @return The systemId.
		 */
		int getSystemId();

		/**
		 * <pre>
		 * Deprecated field, which used to indicate whether the device was a test
		 * (non-production) device. The test_device field in ProvisionedDeviceInfo
		 * below should be observed instead.
		 * </pre>
		 *
		 * <code>optional bool test_device_deprecated = 6 [deprecated = true];</code>
		 * 
		 * @deprecated DrmCertificate.test_device_deprecated is deprecated. See
		 *             wv_proto2.proto;l=598
		 * @return Whether the testDeviceDeprecated field is set.
		 */
		@java.lang.Deprecated
		boolean hasTestDeviceDeprecated();

		/**
		 * <pre>
		 * Deprecated field, which used to indicate whether the device was a test
		 * (non-production) device. The test_device field in ProvisionedDeviceInfo
		 * below should be observed instead.
		 * </pre>
		 *
		 * <code>optional bool test_device_deprecated = 6 [deprecated = true];</code>
		 * 
		 * @deprecated DrmCertificate.test_device_deprecated is deprecated. See
		 *             wv_proto2.proto;l=598
		 * @return The testDeviceDeprecated.
		 */
		@java.lang.Deprecated
		boolean getTestDeviceDeprecated();

		/**
		 * <pre>
		 * Service identifier (web origin) for the provider which owns the
		 * certificate. Required for service and provisioner certificates.
		 * </pre>
		 *
		 * <code>optional string provider_id = 7;</code>
		 * 
		 * @return Whether the providerId field is set.
		 */
		boolean hasProviderId();

		/**
		 * <pre>
		 * Service identifier (web origin) for the provider which owns the
		 * certificate. Required for service and provisioner certificates.
		 * </pre>
		 *
		 * <code>optional string provider_id = 7;</code>
		 * 
		 * @return The providerId.
		 */
		java.lang.String getProviderId();

		/**
		 * <pre>
		 * Service identifier (web origin) for the provider which owns the
		 * certificate. Required for service and provisioner certificates.
		 * </pre>
		 *
		 * <code>optional string provider_id = 7;</code>
		 * 
		 * @return The bytes for providerId.
		 */
		ByteString getProviderIdBytes();

		/**
		 * <pre>
		 * This field is used only when type = SERVICE to specify which SDK uses
		 * service certificate. This repeated field is treated as a set. A certificate
		 * may be used for the specified service SDK if the appropriate ServiceType
		 * is specified in this field.
		 * </pre>
		 *
		 * <code>repeated .DrmCertificate.ServiceType service_types = 8;</code>
		 * 
		 * @return A list containing the serviceTypes.
		 */
		java.util.List<WvProto2.DrmCertificate.ServiceType> getServiceTypesList();

		/**
		 * <pre>
		 * This field is used only when type = SERVICE to specify which SDK uses
		 * service certificate. This repeated field is treated as a set. A certificate
		 * may be used for the specified service SDK if the appropriate ServiceType
		 * is specified in this field.
		 * </pre>
		 *
		 * <code>repeated .DrmCertificate.ServiceType service_types = 8;</code>
		 * 
		 * @return The count of serviceTypes.
		 */
		int getServiceTypesCount();

		/**
		 * <pre>
		 * This field is used only when type = SERVICE to specify which SDK uses
		 * service certificate. This repeated field is treated as a set. A certificate
		 * may be used for the specified service SDK if the appropriate ServiceType
		 * is specified in this field.
		 * </pre>
		 *
		 * <code>repeated .DrmCertificate.ServiceType service_types = 8;</code>
		 * 
		 * @param index The index of the element to return.
		 * @return The serviceTypes at the given index.
		 */
		WvProto2.DrmCertificate.ServiceType getServiceTypes(int index);

		/**
		 * <pre>
		 * Required. The algorithm field contains the curve used to create the
		 * |public_key| if algorithm is one of the ECC types.
		 * The |algorithm| is used for both to determine the if the certificate is ECC
		 * or RSA. The |algorithm| also specifies the parameters that were used to
		 * create |public_key| and are used to create an ephemeral session key.
		 * </pre>
		 *
		 * <code>optional .DrmCertificate.Algorithm algorithm = 9 [default = RSA];</code>
		 * 
		 * @return Whether the algorithm field is set.
		 */
		boolean hasAlgorithm();

		/**
		 * <pre>
		 * Required. The algorithm field contains the curve used to create the
		 * |public_key| if algorithm is one of the ECC types.
		 * The |algorithm| is used for both to determine the if the certificate is ECC
		 * or RSA. The |algorithm| also specifies the parameters that were used to
		 * create |public_key| and are used to create an ephemeral session key.
		 * </pre>
		 *
		 * <code>optional .DrmCertificate.Algorithm algorithm = 9 [default = RSA];</code>
		 * 
		 * @return The algorithm.
		 */
		WvProto2.DrmCertificate.Algorithm getAlgorithm();

		/**
		 * <pre>
		 * Optional. May be present in DEVICE certificate types. This is the root
		 * of trust identifier that holds an encrypted value that identifies the
		 * keybox or other root of trust that was used to provision a DEVICE drm
		 * certificate.
		 * </pre>
		 *
		 * <code>optional bytes rot_id = 10;</code>
		 * 
		 * @return Whether the rotId field is set.
		 */
		boolean hasRotId();

		/**
		 * <pre>
		 * Optional. May be present in DEVICE certificate types. This is the root
		 * of trust identifier that holds an encrypted value that identifies the
		 * keybox or other root of trust that was used to provision a DEVICE drm
		 * certificate.
		 * </pre>
		 *
		 * <code>optional bytes rot_id = 10;</code>
		 * 
		 * @return The rotId.
		 */
		ByteString getRotId();

		/**
		 * <pre>
		 * Optional. May be present in devices that explicitly support dual keys. When
		 * present the |public_key| is used for verification of received license
		 * request messages.
		 * </pre>
		 *
		 * <code>optional .DrmCertificate.EncryptionKey encryption_key = 11;</code>
		 * 
		 * @return Whether the encryptionKey field is set.
		 */
		boolean hasEncryptionKey();

		/**
		 * <pre>
		 * Optional. May be present in devices that explicitly support dual keys. When
		 * present the |public_key| is used for verification of received license
		 * request messages.
		 * </pre>
		 *
		 * <code>optional .DrmCertificate.EncryptionKey encryption_key = 11;</code>
		 * 
		 * @return The encryptionKey.
		 */
		WvProto2.DrmCertificate.EncryptionKey getEncryptionKey();

		/**
		 * <pre>
		 * Optional. May be present in devices that explicitly support dual keys. When
		 * present the |public_key| is used for verification of received license
		 * request messages.
		 * </pre>
		 *
		 * <code>optional .DrmCertificate.EncryptionKey encryption_key = 11;</code>
		 */
		WvProto2.DrmCertificate.EncryptionKeyOrBuilder getEncryptionKeyOrBuilder();
	}

	/**
	 * <pre>
	 * DRM certificate definition for user devices, intermediate, service, and root
	 * certificates.
	 * </pre>
	 *
	 * Protobuf type {@code DrmCertificate}
	 */
	public static final class DrmCertificate extends GeneratedMessageV3 implements
			// @@protoc_insertion_point(message_implements:DrmCertificate)
			DrmCertificateOrBuilder {
		private static final long serialVersionUID = 0L;

		// Use DrmCertificate.newBuilder() to construct.
		private DrmCertificate(GeneratedMessageV3.Builder<?> builder) {
			super(builder);
		}

		private DrmCertificate() {
			type_ = 0;
			serialNumber_ = ByteString.EMPTY;
			publicKey_ = ByteString.EMPTY;
			providerId_ = "";
			serviceTypes_ = java.util.Collections.emptyList();
			algorithm_ = 1;
			rotId_ = ByteString.EMPTY;
		}

		@java.lang.Override

		protected java.lang.Object newInstance(UnusedPrivateParameter unused) {
			return new DrmCertificate();
		}

		public static final Descriptors.Descriptor getDescriptor() {
			return WvProto2.internal_static_DrmCertificate_descriptor;
		}

		@java.lang.Override
		protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
			return WvProto2.internal_static_DrmCertificate_fieldAccessorTable
					.ensureFieldAccessorsInitialized(WvProto2.DrmCertificate.class,
							WvProto2.DrmCertificate.Builder.class);
		}

		/**
		 * Protobuf enum {@code DrmCertificate.Type}
		 */
		public enum Type implements ProtocolMessageEnum {
			/**
			 * <pre>
			 * ProtoBestPractices: ignore.
			 * </pre>
			 *
			 * <code>ROOT = 0;</code>
			 */
			ROOT(0),
			/**
			 * <code>DEVICE_MODEL = 1;</code>
			 */
			DEVICE_MODEL(1),
			/**
			 * <code>DEVICE = 2;</code>
			 */
			DEVICE(2),
			/**
			 * <code>SERVICE = 3;</code>
			 */
			SERVICE(3),
			/**
			 * <code>PROVISIONER = 4;</code>
			 */
			PROVISIONER(4),;

			/**
			 * <pre>
			 * ProtoBestPractices: ignore.
			 * </pre>
			 *
			 * <code>ROOT = 0;</code>
			 */
			public static final int ROOT_VALUE = 0;
			/**
			 * <code>DEVICE_MODEL = 1;</code>
			 */
			public static final int DEVICE_MODEL_VALUE = 1;
			/**
			 * <code>DEVICE = 2;</code>
			 */
			public static final int DEVICE_VALUE = 2;
			/**
			 * <code>SERVICE = 3;</code>
			 */
			public static final int SERVICE_VALUE = 3;
			/**
			 * <code>PROVISIONER = 4;</code>
			 */
			public static final int PROVISIONER_VALUE = 4;

			@Override
			public final int getNumber() {
				return value;
			}

			/**
			 * @param value The numeric wire value of the corresponding enum entry.
			 * @return The enum associated with the given numeric wire value.
			 * @deprecated Use {@link #forNumber(int)} instead.
			 */
			@java.lang.Deprecated
			public static Type valueOf(int value) {
				return forNumber(value);
			}

			/**
			 * @param value The numeric wire value of the corresponding enum entry.
			 * @return The enum associated with the given numeric wire value.
			 */
			public static Type forNumber(int value) {
				switch (value) {
				case 0:
					return ROOT;
				case 1:
					return DEVICE_MODEL;
				case 2:
					return DEVICE;
				case 3:
					return SERVICE;
				case 4:
					return PROVISIONER;
				default:
					return null;
				}
			}

			public static Internal.EnumLiteMap<Type> internalGetValueMap() {
				return internalValueMap;
			}

			private static final Internal.EnumLiteMap<Type> internalValueMap = new Internal.EnumLiteMap<>() {
				@Override
				public Type findValueByNumber(int number) {
					return Type.forNumber(number);
				}
			};

			@Override
			public final Descriptors.EnumValueDescriptor getValueDescriptor() {
				return getDescriptor().getValues().get(ordinal());
			}

			@Override
			public final Descriptors.EnumDescriptor getDescriptorForType() {
				return getDescriptor();
			}

			public static final Descriptors.EnumDescriptor getDescriptor() {
				return WvProto2.DrmCertificate.getDescriptor().getEnumTypes().get(0);
			}

			private static final Type[] VALUES = values();

			public static Type valueOf(Descriptors.EnumValueDescriptor desc) {
				if (desc.getType() != getDescriptor()) {
					throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
				}
				return VALUES[desc.getIndex()];
			}

			private final int value;

			private Type(int value) {
				this.value = value;
			}

			// @@protoc_insertion_point(enum_scope:DrmCertificate.Type)
		}

		/**
		 * Protobuf enum {@code DrmCertificate.ServiceType}
		 */
		public enum ServiceType implements ProtocolMessageEnum {
			/**
			 * <code>UNKNOWN_SERVICE_TYPE = 0;</code>
			 */
			UNKNOWN_SERVICE_TYPE(0),
			/**
			 * <code>LICENSE_SERVER_SDK = 1;</code>
			 */
			LICENSE_SERVER_SDK(1),
			/**
			 * <code>LICENSE_SERVER_PROXY_SDK = 2;</code>
			 */
			LICENSE_SERVER_PROXY_SDK(2),
			/**
			 * <code>PROVISIONING_SDK = 3;</code>
			 */
			PROVISIONING_SDK(3),
			/**
			 * <code>CAS_PROXY_SDK = 4;</code>
			 */
			CAS_PROXY_SDK(4),;

			/**
			 * <code>UNKNOWN_SERVICE_TYPE = 0;</code>
			 */
			public static final int UNKNOWN_SERVICE_TYPE_VALUE = 0;
			/**
			 * <code>LICENSE_SERVER_SDK = 1;</code>
			 */
			public static final int LICENSE_SERVER_SDK_VALUE = 1;
			/**
			 * <code>LICENSE_SERVER_PROXY_SDK = 2;</code>
			 */
			public static final int LICENSE_SERVER_PROXY_SDK_VALUE = 2;
			/**
			 * <code>PROVISIONING_SDK = 3;</code>
			 */
			public static final int PROVISIONING_SDK_VALUE = 3;
			/**
			 * <code>CAS_PROXY_SDK = 4;</code>
			 */
			public static final int CAS_PROXY_SDK_VALUE = 4;

			@Override
			public final int getNumber() {
				return value;
			}

			/**
			 * @param value The numeric wire value of the corresponding enum entry.
			 * @return The enum associated with the given numeric wire value.
			 * @deprecated Use {@link #forNumber(int)} instead.
			 */
			@java.lang.Deprecated
			public static ServiceType valueOf(int value) {
				return forNumber(value);
			}

			/**
			 * @param value The numeric wire value of the corresponding enum entry.
			 * @return The enum associated with the given numeric wire value.
			 */
			public static ServiceType forNumber(int value) {
				switch (value) {
				case 0:
					return UNKNOWN_SERVICE_TYPE;
				case 1:
					return LICENSE_SERVER_SDK;
				case 2:
					return LICENSE_SERVER_PROXY_SDK;
				case 3:
					return PROVISIONING_SDK;
				case 4:
					return CAS_PROXY_SDK;
				default:
					return null;
				}
			}

			public static Internal.EnumLiteMap<ServiceType> internalGetValueMap() {
				return internalValueMap;
			}

			private static final Internal.EnumLiteMap<ServiceType> internalValueMap = new Internal.EnumLiteMap<>() {
				@Override
				public ServiceType findValueByNumber(int number) {
					return ServiceType.forNumber(number);
				}
			};

			@Override
			public final Descriptors.EnumValueDescriptor getValueDescriptor() {
				return getDescriptor().getValues().get(ordinal());
			}

			@Override
			public final Descriptors.EnumDescriptor getDescriptorForType() {
				return getDescriptor();
			}

			public static final Descriptors.EnumDescriptor getDescriptor() {
				return WvProto2.DrmCertificate.getDescriptor().getEnumTypes().get(1);
			}

			private static final ServiceType[] VALUES = values();

			public static ServiceType valueOf(Descriptors.EnumValueDescriptor desc) {
				if (desc.getType() != getDescriptor()) {
					throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
				}
				return VALUES[desc.getIndex()];
			}

			private final int value;

			private ServiceType(int value) {
				this.value = value;
			}

			// @@protoc_insertion_point(enum_scope:DrmCertificate.ServiceType)
		}

		/**
		 * Protobuf enum {@code DrmCertificate.Algorithm}
		 */
		public enum Algorithm implements ProtocolMessageEnum {
			/**
			 * <code>UNKNOWN_ALGORITHM = 0;</code>
			 */
			UNKNOWN_ALGORITHM(0),
			/**
			 * <code>RSA = 1;</code>
			 */
			RSA(1),
			/**
			 * <code>ECC_SECP256R1 = 2;</code>
			 */
			ECC_SECP256R1(2),
			/**
			 * <code>ECC_SECP384R1 = 3;</code>
			 */
			ECC_SECP384R1(3),
			/**
			 * <code>ECC_SECP521R1 = 4;</code>
			 */
			ECC_SECP521R1(4),;

			/**
			 * <code>UNKNOWN_ALGORITHM = 0;</code>
			 */
			public static final int UNKNOWN_ALGORITHM_VALUE = 0;
			/**
			 * <code>RSA = 1;</code>
			 */
			public static final int RSA_VALUE = 1;
			/**
			 * <code>ECC_SECP256R1 = 2;</code>
			 */
			public static final int ECC_SECP256R1_VALUE = 2;
			/**
			 * <code>ECC_SECP384R1 = 3;</code>
			 */
			public static final int ECC_SECP384R1_VALUE = 3;
			/**
			 * <code>ECC_SECP521R1 = 4;</code>
			 */
			public static final int ECC_SECP521R1_VALUE = 4;

			@Override
			public final int getNumber() {
				return value;
			}

			/**
			 * @param value The numeric wire value of the corresponding enum entry.
			 * @return The enum associated with the given numeric wire value.
			 * @deprecated Use {@link #forNumber(int)} instead.
			 */
			@java.lang.Deprecated
			public static Algorithm valueOf(int value) {
				return forNumber(value);
			}

			/**
			 * @param value The numeric wire value of the corresponding enum entry.
			 * @return The enum associated with the given numeric wire value.
			 */
			public static Algorithm forNumber(int value) {
				switch (value) {
				case 0:
					return UNKNOWN_ALGORITHM;
				case 1:
					return RSA;
				case 2:
					return ECC_SECP256R1;
				case 3:
					return ECC_SECP384R1;
				case 4:
					return ECC_SECP521R1;
				default:
					return null;
				}
			}

			public static Internal.EnumLiteMap<Algorithm> internalGetValueMap() {
				return internalValueMap;
			}

			private static final Internal.EnumLiteMap<Algorithm> internalValueMap = new Internal.EnumLiteMap<>() {
				@Override
				public Algorithm findValueByNumber(int number) {
					return Algorithm.forNumber(number);
				}
			};

			@Override
			public final Descriptors.EnumValueDescriptor getValueDescriptor() {
				return getDescriptor().getValues().get(ordinal());
			}

			@Override
			public final Descriptors.EnumDescriptor getDescriptorForType() {
				return getDescriptor();
			}

			public static final Descriptors.EnumDescriptor getDescriptor() {
				return WvProto2.DrmCertificate.getDescriptor().getEnumTypes().get(2);
			}

			private static final Algorithm[] VALUES = values();

			public static Algorithm valueOf(Descriptors.EnumValueDescriptor desc) {
				if (desc.getType() != getDescriptor()) {
					throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
				}
				return VALUES[desc.getIndex()];
			}

			private final int value;

			private Algorithm(int value) {
				this.value = value;
			}

			// @@protoc_insertion_point(enum_scope:DrmCertificate.Algorithm)
		}

		public interface EncryptionKeyOrBuilder extends
				// @@protoc_insertion_point(interface_extends:DrmCertificate.EncryptionKey)
				MessageOrBuilder {

			/**
			 * <pre>
			 * Device public key. PKCS#1 ASN.1 DER-encoded. Required.
			 * </pre>
			 *
			 * <code>optional bytes public_key = 1;</code>
			 * 
			 * @return Whether the publicKey field is set.
			 */
			boolean hasPublicKey();

			/**
			 * <pre>
			 * Device public key. PKCS#1 ASN.1 DER-encoded. Required.
			 * </pre>
			 *
			 * <code>optional bytes public_key = 1;</code>
			 * 
			 * @return The publicKey.
			 */
			ByteString getPublicKey();

			/**
			 * <pre>
			 * Required. The algorithm field contains the curve used to create the
			 * |public_key| if algorithm is one of the ECC types.
			 * The |algorithm| is used for both to determine the if the certificate is
			 * ECC or RSA. The |algorithm| also specifies the parameters that were used
			 * to create |public_key| and are used to create an ephemeral session key.
			 * </pre>
			 *
			 * <code>optional .DrmCertificate.Algorithm algorithm = 2 [default = RSA];</code>
			 * 
			 * @return Whether the algorithm field is set.
			 */
			boolean hasAlgorithm();

			/**
			 * <pre>
			 * Required. The algorithm field contains the curve used to create the
			 * |public_key| if algorithm is one of the ECC types.
			 * The |algorithm| is used for both to determine the if the certificate is
			 * ECC or RSA. The |algorithm| also specifies the parameters that were used
			 * to create |public_key| and are used to create an ephemeral session key.
			 * </pre>
			 *
			 * <code>optional .DrmCertificate.Algorithm algorithm = 2 [default = RSA];</code>
			 * 
			 * @return The algorithm.
			 */
			WvProto2.DrmCertificate.Algorithm getAlgorithm();
		}

		/**
		 * Protobuf type {@code DrmCertificate.EncryptionKey}
		 */
		public static final class EncryptionKey extends GeneratedMessageV3 implements
				// @@protoc_insertion_point(message_implements:DrmCertificate.EncryptionKey)
				EncryptionKeyOrBuilder {
			private static final long serialVersionUID = 0L;

			// Use EncryptionKey.newBuilder() to construct.
			private EncryptionKey(GeneratedMessageV3.Builder<?> builder) {
				super(builder);
			}

			private EncryptionKey() {
				publicKey_ = ByteString.EMPTY;
				algorithm_ = 1;
			}

			@java.lang.Override

			protected java.lang.Object newInstance(UnusedPrivateParameter unused) {
				return new EncryptionKey();
			}

			public static final Descriptors.Descriptor getDescriptor() {
				return WvProto2.internal_static_DrmCertificate_EncryptionKey_descriptor;
			}

			@java.lang.Override
			protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
				return WvProto2.internal_static_DrmCertificate_EncryptionKey_fieldAccessorTable
						.ensureFieldAccessorsInitialized(
								WvProto2.DrmCertificate.EncryptionKey.class,
								WvProto2.DrmCertificate.EncryptionKey.Builder.class);
			}

			private int bitField0_;
			public static final int PUBLIC_KEY_FIELD_NUMBER = 1;
			private ByteString publicKey_ = ByteString.EMPTY;

			/**
			 * <pre>
			 * Device public key. PKCS#1 ASN.1 DER-encoded. Required.
			 * </pre>
			 *
			 * <code>optional bytes public_key = 1;</code>
			 * 
			 * @return Whether the publicKey field is set.
			 */
			@java.lang.Override
			public boolean hasPublicKey() {
				return ((bitField0_ & 0x00000001) != 0);
			}

			/**
			 * <pre>
			 * Device public key. PKCS#1 ASN.1 DER-encoded. Required.
			 * </pre>
			 *
			 * <code>optional bytes public_key = 1;</code>
			 * 
			 * @return The publicKey.
			 */
			@java.lang.Override
			public ByteString getPublicKey() {
				return publicKey_;
			}

			public static final int ALGORITHM_FIELD_NUMBER = 2;
			private int algorithm_ = 1;

			/**
			 * <pre>
			 * Required. The algorithm field contains the curve used to create the
			 * |public_key| if algorithm is one of the ECC types.
			 * The |algorithm| is used for both to determine the if the certificate is
			 * ECC or RSA. The |algorithm| also specifies the parameters that were used
			 * to create |public_key| and are used to create an ephemeral session key.
			 * </pre>
			 *
			 * <code>optional .DrmCertificate.Algorithm algorithm = 2 [default = RSA];</code>
			 * 
			 * @return Whether the algorithm field is set.
			 */
			@java.lang.Override
			public boolean hasAlgorithm() {
				return ((bitField0_ & 0x00000002) != 0);
			}

			/**
			 * <pre>
			 * Required. The algorithm field contains the curve used to create the
			 * |public_key| if algorithm is one of the ECC types.
			 * The |algorithm| is used for both to determine the if the certificate is
			 * ECC or RSA. The |algorithm| also specifies the parameters that were used
			 * to create |public_key| and are used to create an ephemeral session key.
			 * </pre>
			 *
			 * <code>optional .DrmCertificate.Algorithm algorithm = 2 [default = RSA];</code>
			 * 
			 * @return The algorithm.
			 */
			@java.lang.Override
			public WvProto2.DrmCertificate.Algorithm getAlgorithm() {
				WvProto2.DrmCertificate.Algorithm result = WvProto2.DrmCertificate.Algorithm
						.forNumber(algorithm_);
				return result == null ? WvProto2.DrmCertificate.Algorithm.RSA : result;
			}

			private byte memoizedIsInitialized = -1;

			@java.lang.Override
			public final boolean isInitialized() {
				byte isInitialized = memoizedIsInitialized;
				if (isInitialized == 1)
					return true;
				if (isInitialized == 0)
					return false;

				memoizedIsInitialized = 1;
				return true;
			}

			@java.lang.Override
			public void writeTo(CodedOutputStream output) throws java.io.IOException {
				if (((bitField0_ & 0x00000001) != 0)) {
					output.writeBytes(1, publicKey_);
				}
				if (((bitField0_ & 0x00000002) != 0)) {
					output.writeEnum(2, algorithm_);
				}
				getUnknownFields().writeTo(output);
			}

			@java.lang.Override
			public int getSerializedSize() {
				int size = memoizedSize;
				if (size != -1)
					return size;

				size = 0;
				if (((bitField0_ & 0x00000001) != 0)) {
					size += CodedOutputStream.computeBytesSize(1, publicKey_);
				}
				if (((bitField0_ & 0x00000002) != 0)) {
					size += CodedOutputStream.computeEnumSize(2, algorithm_);
				}
				size += getUnknownFields().getSerializedSize();
				memoizedSize = size;
				return size;
			}

			@java.lang.Override
			public boolean equals(final java.lang.Object obj) {
				if (obj == this) {
					return true;
				}
				if (!(obj instanceof WvProto2.DrmCertificate.EncryptionKey)) {
					return super.equals(obj);
				}
				WvProto2.DrmCertificate.EncryptionKey other = (WvProto2.DrmCertificate.EncryptionKey) obj;

				if (hasPublicKey() != other.hasPublicKey())
					return false;
				if (hasPublicKey()) {
					if (!getPublicKey().equals(other.getPublicKey()))
						return false;
				}
				if (hasAlgorithm() != other.hasAlgorithm())
					return false;
				if (hasAlgorithm()) {
					if (algorithm_ != other.algorithm_)
						return false;
				}
				if (!getUnknownFields().equals(other.getUnknownFields()))
					return false;
				return true;
			}

			@SuppressWarnings("unchecked")
			@java.lang.Override
			public int hashCode() {
				if (memoizedHashCode != 0) {
					return memoizedHashCode;
				}
				int hash = 41;
				hash = (19 * hash) + getDescriptor().hashCode();
				if (hasPublicKey()) {
					hash = (37 * hash) + PUBLIC_KEY_FIELD_NUMBER;
					hash = (53 * hash) + getPublicKey().hashCode();
				}
				if (hasAlgorithm()) {
					hash = (37 * hash) + ALGORITHM_FIELD_NUMBER;
					hash = (53 * hash) + algorithm_;
				}
				hash = (29 * hash) + getUnknownFields().hashCode();
				memoizedHashCode = hash;
				return hash;
			}

			public static WvProto2.DrmCertificate.EncryptionKey parseFrom(
					java.nio.ByteBuffer data) throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data);
			}

			public static WvProto2.DrmCertificate.EncryptionKey parseFrom(
					java.nio.ByteBuffer data, ExtensionRegistryLite extensionRegistry)
					throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data, extensionRegistry);
			}

			public static WvProto2.DrmCertificate.EncryptionKey parseFrom(ByteString data)
					throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data);
			}

			public static WvProto2.DrmCertificate.EncryptionKey parseFrom(ByteString data,
					ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data, extensionRegistry);
			}

			public static WvProto2.DrmCertificate.EncryptionKey parseFrom(byte[] data)
					throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data);
			}

			public static WvProto2.DrmCertificate.EncryptionKey parseFrom(byte[] data,
					ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data, extensionRegistry);
			}

			public static WvProto2.DrmCertificate.EncryptionKey parseFrom(
					java.io.InputStream input) throws java.io.IOException {
				return GeneratedMessageV3.parseWithIOException(PARSER, input);
			}

			public static WvProto2.DrmCertificate.EncryptionKey parseFrom(
					java.io.InputStream input, ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
				return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
			}

			public static WvProto2.DrmCertificate.EncryptionKey parseDelimitedFrom(
					java.io.InputStream input) throws java.io.IOException {
				return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
			}

			public static WvProto2.DrmCertificate.EncryptionKey parseDelimitedFrom(
					java.io.InputStream input, ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
				return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input, extensionRegistry);
			}

			public static WvProto2.DrmCertificate.EncryptionKey parseFrom(
					CodedInputStream input) throws java.io.IOException {
				return GeneratedMessageV3.parseWithIOException(PARSER, input);
			}

			public static WvProto2.DrmCertificate.EncryptionKey parseFrom(
					CodedInputStream input, ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
				return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
			}

			@java.lang.Override
			public Builder newBuilderForType() {
				return newBuilder();
			}

			public static Builder newBuilder() {
				return DEFAULT_INSTANCE.toBuilder();
			}

			public static Builder newBuilder(WvProto2.DrmCertificate.EncryptionKey prototype) {
				return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
			}

			@java.lang.Override
			public Builder toBuilder() {
				return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
			}

			@java.lang.Override
			protected Builder newBuilderForType(GeneratedMessageV3.BuilderParent parent) {
				Builder builder = new Builder(parent);
				return builder;
			}

			/**
			 * Protobuf type {@code DrmCertificate.EncryptionKey}
			 */
			public static final class Builder extends GeneratedMessageV3.Builder<Builder> implements
					// @@protoc_insertion_point(builder_implements:DrmCertificate.EncryptionKey)
					WvProto2.DrmCertificate.EncryptionKeyOrBuilder {
				public static final Descriptors.Descriptor getDescriptor() {
					return WvProto2.internal_static_DrmCertificate_EncryptionKey_descriptor;
				}

				@java.lang.Override
				protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
					return WvProto2.internal_static_DrmCertificate_EncryptionKey_fieldAccessorTable
							.ensureFieldAccessorsInitialized(
									WvProto2.DrmCertificate.EncryptionKey.class,
									WvProto2.DrmCertificate.EncryptionKey.Builder.class);
				}

				// Construct using
				// WvProto2.DrmCertificate.EncryptionKey.newBuilder()
				private Builder() {

				}

				private Builder(GeneratedMessageV3.BuilderParent parent) {
					super(parent);

				}

				@java.lang.Override
				public Builder clear() {
					super.clear();
					bitField0_ = 0;
					publicKey_ = ByteString.EMPTY;
					algorithm_ = 1;
					return this;
				}

				@java.lang.Override
				public Descriptors.Descriptor getDescriptorForType() {
					return WvProto2.internal_static_DrmCertificate_EncryptionKey_descriptor;
				}

				@java.lang.Override
				public WvProto2.DrmCertificate.EncryptionKey getDefaultInstanceForType() {
					return WvProto2.DrmCertificate.EncryptionKey.getDefaultInstance();
				}

				@java.lang.Override
				public WvProto2.DrmCertificate.EncryptionKey build() {
					WvProto2.DrmCertificate.EncryptionKey result = buildPartial();
					if (!result.isInitialized()) {
						throw newUninitializedMessageException(result);
					}
					return result;
				}

				@java.lang.Override
				public WvProto2.DrmCertificate.EncryptionKey buildPartial() {
					WvProto2.DrmCertificate.EncryptionKey result = new WvProto2.DrmCertificate.EncryptionKey(
							this);
					if (bitField0_ != 0) {
						buildPartial0(result);
					}
					onBuilt();
					return result;
				}

				private void buildPartial0(WvProto2.DrmCertificate.EncryptionKey result) {
					int from_bitField0_ = bitField0_;
					int to_bitField0_ = 0;
					if (((from_bitField0_ & 0x00000001) != 0)) {
						result.publicKey_ = publicKey_;
						to_bitField0_ |= 0x00000001;
					}
					if (((from_bitField0_ & 0x00000002) != 0)) {
						result.algorithm_ = algorithm_;
						to_bitField0_ |= 0x00000002;
					}
					result.bitField0_ |= to_bitField0_;
				}

				@java.lang.Override
				public Builder mergeFrom(Message other) {
					if (other instanceof WvProto2.DrmCertificate.EncryptionKey) {
						return mergeFrom((WvProto2.DrmCertificate.EncryptionKey) other);
					}
					super.mergeFrom(other);
					return this;
				}

				public Builder mergeFrom(WvProto2.DrmCertificate.EncryptionKey other) {
					if (other == WvProto2.DrmCertificate.EncryptionKey.getDefaultInstance())
						return this;
					if (other.hasPublicKey()) {
						setPublicKey(other.getPublicKey());
					}
					if (other.hasAlgorithm()) {
						setAlgorithm(other.getAlgorithm());
					}
					this.mergeUnknownFields(other.getUnknownFields());
					onChanged();
					return this;
				}

				@java.lang.Override
				public final boolean isInitialized() {
					return true;
				}

				@java.lang.Override
				public Builder mergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
						throws java.io.IOException {
					if (extensionRegistry == null) {
						throw new java.lang.NullPointerException();
					}
					try {
						boolean done = false;
						while (!done) {
							int tag = input.readTag();
							switch (tag) {
							case 0:
								done = true;
								break;
							case 10: {
								publicKey_ = input.readBytes();
								bitField0_ |= 0x00000001;
								break;
							} // case 10
							case 16: {
								int tmpRaw = input.readEnum();
								WvProto2.DrmCertificate.Algorithm tmpValue = WvProto2.DrmCertificate.Algorithm
										.forNumber(tmpRaw);
								if (tmpValue == null) {
									mergeUnknownVarintField(2, tmpRaw);
								} else {
									algorithm_ = tmpRaw;
									bitField0_ |= 0x00000002;
								}
								break;
							} // case 16
							default: {
								if (!super.parseUnknownField(input, extensionRegistry, tag)) {
									done = true; // was an endgroup tag
								}
								break;
							} // default:
							} // switch (tag)
						} // while (!done)
					} catch (InvalidProtocolBufferException e) {
						throw e.unwrapIOException();
					}
					finally {
						onChanged();
					} // finally
					return this;
				}

				private int bitField0_;

				private ByteString publicKey_ = ByteString.EMPTY;

				/**
				 * <pre>
				 * Device public key. PKCS#1 ASN.1 DER-encoded. Required.
				 * </pre>
				 *
				 * <code>optional bytes public_key = 1;</code>
				 * 
				 * @return Whether the publicKey field is set.
				 */
				@java.lang.Override
				public boolean hasPublicKey() {
					return ((bitField0_ & 0x00000001) != 0);
				}

				/**
				 * <pre>
				 * Device public key. PKCS#1 ASN.1 DER-encoded. Required.
				 * </pre>
				 *
				 * <code>optional bytes public_key = 1;</code>
				 * 
				 * @return The publicKey.
				 */
				@java.lang.Override
				public ByteString getPublicKey() {
					return publicKey_;
				}

				/**
				 * <pre>
				 * Device public key. PKCS#1 ASN.1 DER-encoded. Required.
				 * </pre>
				 *
				 * <code>optional bytes public_key = 1;</code>
				 * 
				 * @param value The publicKey to set.
				 * @return This builder for chaining.
				 */
				public Builder setPublicKey(ByteString value) {
					if (value == null) {
						throw new NullPointerException();
					}
					publicKey_ = value;
					bitField0_ |= 0x00000001;
					onChanged();
					return this;
				}

				/**
				 * <pre>
				 * Device public key. PKCS#1 ASN.1 DER-encoded. Required.
				 * </pre>
				 *
				 * <code>optional bytes public_key = 1;</code>
				 * 
				 * @return This builder for chaining.
				 */
				public Builder clearPublicKey() {
					bitField0_ = (bitField0_ & ~0x00000001);
					publicKey_ = getDefaultInstance().getPublicKey();
					onChanged();
					return this;
				}

				private int algorithm_ = 1;

				/**
				 * <pre>
				 * Required. The algorithm field contains the curve used to create the
				 * |public_key| if algorithm is one of the ECC types.
				 * The |algorithm| is used for both to determine the if the certificate is
				 * ECC or RSA. The |algorithm| also specifies the parameters that were used
				 * to create |public_key| and are used to create an ephemeral session key.
				 * </pre>
				 *
				 * <code>optional .DrmCertificate.Algorithm algorithm = 2 [default = RSA];</code>
				 * 
				 * @return Whether the algorithm field is set.
				 */
				@java.lang.Override
				public boolean hasAlgorithm() {
					return ((bitField0_ & 0x00000002) != 0);
				}

				/**
				 * <pre>
				 * Required. The algorithm field contains the curve used to create the
				 * |public_key| if algorithm is one of the ECC types.
				 * The |algorithm| is used for both to determine the if the certificate is
				 * ECC or RSA. The |algorithm| also specifies the parameters that were used
				 * to create |public_key| and are used to create an ephemeral session key.
				 * </pre>
				 *
				 * <code>optional .DrmCertificate.Algorithm algorithm = 2 [default = RSA];</code>
				 * 
				 * @return The algorithm.
				 */
				@java.lang.Override
				public WvProto2.DrmCertificate.Algorithm getAlgorithm() {
					WvProto2.DrmCertificate.Algorithm result = WvProto2.DrmCertificate.Algorithm
							.forNumber(algorithm_);
					return result == null ? WvProto2.DrmCertificate.Algorithm.RSA : result;
				}

				/**
				 * <pre>
				 * Required. The algorithm field contains the curve used to create the
				 * |public_key| if algorithm is one of the ECC types.
				 * The |algorithm| is used for both to determine the if the certificate is
				 * ECC or RSA. The |algorithm| also specifies the parameters that were used
				 * to create |public_key| and are used to create an ephemeral session key.
				 * </pre>
				 *
				 * <code>optional .DrmCertificate.Algorithm algorithm = 2 [default = RSA];</code>
				 * 
				 * @param value The algorithm to set.
				 * @return This builder for chaining.
				 */
				public Builder setAlgorithm(WvProto2.DrmCertificate.Algorithm value) {
					if (value == null) {
						throw new NullPointerException();
					}
					bitField0_ |= 0x00000002;
					algorithm_ = value.getNumber();
					onChanged();
					return this;
				}

				/**
				 * <pre>
				 * Required. The algorithm field contains the curve used to create the
				 * |public_key| if algorithm is one of the ECC types.
				 * The |algorithm| is used for both to determine the if the certificate is
				 * ECC or RSA. The |algorithm| also specifies the parameters that were used
				 * to create |public_key| and are used to create an ephemeral session key.
				 * </pre>
				 *
				 * <code>optional .DrmCertificate.Algorithm algorithm = 2 [default = RSA];</code>
				 * 
				 * @return This builder for chaining.
				 */
				public Builder clearAlgorithm() {
					bitField0_ = (bitField0_ & ~0x00000002);
					algorithm_ = 1;
					onChanged();
					return this;
				}

				@java.lang.Override
				public final Builder setUnknownFields(final UnknownFieldSet unknownFields) {
					return super.setUnknownFields(unknownFields);
				}

				@java.lang.Override
				public final Builder mergeUnknownFields(final UnknownFieldSet unknownFields) {
					return super.mergeUnknownFields(unknownFields);
				}

				// @@protoc_insertion_point(builder_scope:DrmCertificate.EncryptionKey)
			}

			// @@protoc_insertion_point(class_scope:DrmCertificate.EncryptionKey)
			private static final WvProto2.DrmCertificate.EncryptionKey DEFAULT_INSTANCE;
			static {
				DEFAULT_INSTANCE = new WvProto2.DrmCertificate.EncryptionKey();
			}

			public static WvProto2.DrmCertificate.EncryptionKey getDefaultInstance() {
				return DEFAULT_INSTANCE;
			}

			@java.lang.Deprecated public static final Parser<EncryptionKey> PARSER = new AbstractParser<>() {
				@java.lang.Override
				public EncryptionKey parsePartialFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
						throws InvalidProtocolBufferException {
					Builder builder = newBuilder();
					try {
						builder.mergeFrom(input, extensionRegistry);
					} catch (InvalidProtocolBufferException e) {
						throw e.setUnfinishedMessage(builder.buildPartial());
					} catch (UninitializedMessageException e) {
						throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
					} catch (java.io.IOException e) {
						throw new InvalidProtocolBufferException(e).setUnfinishedMessage(builder.buildPartial());
					}
					return builder.buildPartial();
				}
			};

			public static Parser<EncryptionKey> parser() {
				return PARSER;
			}

			@java.lang.Override
			public Parser<EncryptionKey> getParserForType() {
				return PARSER;
			}

			@java.lang.Override
			public WvProto2.DrmCertificate.EncryptionKey getDefaultInstanceForType() {
				return DEFAULT_INSTANCE;
			}

		}

		private int bitField0_;
		public static final int TYPE_FIELD_NUMBER = 1;
		private int type_ = 0;

		/**
		 * <pre>
		 * Type of certificate. Required.
		 * </pre>
		 *
		 * <code>optional .DrmCertificate.Type type = 1;</code>
		 * 
		 * @return Whether the type field is set.
		 */
		@java.lang.Override
		public boolean hasType() {
			return ((bitField0_ & 0x00000001) != 0);
		}

		/**
		 * <pre>
		 * Type of certificate. Required.
		 * </pre>
		 *
		 * <code>optional .DrmCertificate.Type type = 1;</code>
		 * 
		 * @return The type.
		 */
		@java.lang.Override
		public WvProto2.DrmCertificate.Type getType() {
			WvProto2.DrmCertificate.Type result = WvProto2.DrmCertificate.Type
					.forNumber(type_);
			return result == null ? WvProto2.DrmCertificate.Type.ROOT : result;
		}

		public static final int SERIAL_NUMBER_FIELD_NUMBER = 2;
		private ByteString serialNumber_ = ByteString.EMPTY;

		/**
		 * <pre>
		 * 128-bit globally unique serial number of certificate.
		 * Value is 0 for root certificate. Required.
		 * </pre>
		 *
		 * <code>optional bytes serial_number = 2;</code>
		 * 
		 * @return Whether the serialNumber field is set.
		 */
		@java.lang.Override
		public boolean hasSerialNumber() {
			return ((bitField0_ & 0x00000002) != 0);
		}

		/**
		 * <pre>
		 * 128-bit globally unique serial number of certificate.
		 * Value is 0 for root certificate. Required.
		 * </pre>
		 *
		 * <code>optional bytes serial_number = 2;</code>
		 * 
		 * @return The serialNumber.
		 */
		@java.lang.Override
		public ByteString getSerialNumber() {
			return serialNumber_;
		}

		public static final int CREATION_TIME_SECONDS_FIELD_NUMBER = 3;
		private int creationTimeSeconds_ = 0;

		/**
		 * <pre>
		 * POSIX time, in seconds, when the certificate was created. Required.
		 * </pre>
		 *
		 * <code>optional uint32 creation_time_seconds = 3;</code>
		 * 
		 * @return Whether the creationTimeSeconds field is set.
		 */
		@java.lang.Override
		public boolean hasCreationTimeSeconds() {
			return ((bitField0_ & 0x00000004) != 0);
		}

		/**
		 * <pre>
		 * POSIX time, in seconds, when the certificate was created. Required.
		 * </pre>
		 *
		 * <code>optional uint32 creation_time_seconds = 3;</code>
		 * 
		 * @return The creationTimeSeconds.
		 */
		@java.lang.Override
		public int getCreationTimeSeconds() {
			return creationTimeSeconds_;
		}

		public static final int EXPIRATION_TIME_SECONDS_FIELD_NUMBER = 12;
		private int expirationTimeSeconds_ = 0;

		/**
		 * <pre>
		 * POSIX time, in seconds, when the certificate should expire. Value of zero
		 * denotes indefinite expiry time. For more information on limited lifespan
		 * DRM certificates see (go/limited-lifespan-drm-certificates).
		 * </pre>
		 *
		 * <code>optional uint32 expiration_time_seconds = 12;</code>
		 * 
		 * @return Whether the expirationTimeSeconds field is set.
		 */
		@java.lang.Override
		public boolean hasExpirationTimeSeconds() {
			return ((bitField0_ & 0x00000008) != 0);
		}

		/**
		 * <pre>
		 * POSIX time, in seconds, when the certificate should expire. Value of zero
		 * denotes indefinite expiry time. For more information on limited lifespan
		 * DRM certificates see (go/limited-lifespan-drm-certificates).
		 * </pre>
		 *
		 * <code>optional uint32 expiration_time_seconds = 12;</code>
		 * 
		 * @return The expirationTimeSeconds.
		 */
		@java.lang.Override
		public int getExpirationTimeSeconds() {
			return expirationTimeSeconds_;
		}

		public static final int PUBLIC_KEY_FIELD_NUMBER = 4;
		private ByteString publicKey_ = ByteString.EMPTY;

		/**
		 * <pre>
		 * Device public key. PKCS#1 ASN.1 DER-encoded. Required.
		 * </pre>
		 *
		 * <code>optional bytes public_key = 4;</code>
		 * 
		 * @return Whether the publicKey field is set.
		 */
		@java.lang.Override
		public boolean hasPublicKey() {
			return ((bitField0_ & 0x00000010) != 0);
		}

		/**
		 * <pre>
		 * Device public key. PKCS#1 ASN.1 DER-encoded. Required.
		 * </pre>
		 *
		 * <code>optional bytes public_key = 4;</code>
		 * 
		 * @return The publicKey.
		 */
		@java.lang.Override
		public ByteString getPublicKey() {
			return publicKey_;
		}

		public static final int SYSTEM_ID_FIELD_NUMBER = 5;
		private int systemId_ = 0;

		/**
		 * <pre>
		 * Widevine system ID for the device. Required for intermediate and
		 * user device certificates.
		 * </pre>
		 *
		 * <code>optional uint32 system_id = 5;</code>
		 * 
		 * @return Whether the systemId field is set.
		 */
		@java.lang.Override
		public boolean hasSystemId() {
			return ((bitField0_ & 0x00000020) != 0);
		}

		/**
		 * <pre>
		 * Widevine system ID for the device. Required for intermediate and
		 * user device certificates.
		 * </pre>
		 *
		 * <code>optional uint32 system_id = 5;</code>
		 * 
		 * @return The systemId.
		 */
		@java.lang.Override
		public int getSystemId() {
			return systemId_;
		}

		public static final int TEST_DEVICE_DEPRECATED_FIELD_NUMBER = 6;
		private boolean testDeviceDeprecated_ = false;

		/**
		 * <pre>
		 * Deprecated field, which used to indicate whether the device was a test
		 * (non-production) device. The test_device field in ProvisionedDeviceInfo
		 * below should be observed instead.
		 * </pre>
		 *
		 * <code>optional bool test_device_deprecated = 6 [deprecated = true];</code>
		 * 
		 * @deprecated DrmCertificate.test_device_deprecated is deprecated. See
		 *             wv_proto2.proto;l=598
		 * @return Whether the testDeviceDeprecated field is set.
		 */
		@java.lang.Override
		@java.lang.Deprecated
		public boolean hasTestDeviceDeprecated() {
			return ((bitField0_ & 0x00000040) != 0);
		}

		/**
		 * <pre>
		 * Deprecated field, which used to indicate whether the device was a test
		 * (non-production) device. The test_device field in ProvisionedDeviceInfo
		 * below should be observed instead.
		 * </pre>
		 *
		 * <code>optional bool test_device_deprecated = 6 [deprecated = true];</code>
		 * 
		 * @deprecated DrmCertificate.test_device_deprecated is deprecated. See
		 *             wv_proto2.proto;l=598
		 * @return The testDeviceDeprecated.
		 */
		@java.lang.Override
		@java.lang.Deprecated
		public boolean getTestDeviceDeprecated() {
			return testDeviceDeprecated_;
		}

		public static final int PROVIDER_ID_FIELD_NUMBER = 7;

		private volatile java.lang.Object providerId_ = "";

		/**
		 * <pre>
		 * Service identifier (web origin) for the provider which owns the
		 * certificate. Required for service and provisioner certificates.
		 * </pre>
		 *
		 * <code>optional string provider_id = 7;</code>
		 * 
		 * @return Whether the providerId field is set.
		 */
		@java.lang.Override
		public boolean hasProviderId() {
			return ((bitField0_ & 0x00000080) != 0);
		}

		/**
		 * <pre>
		 * Service identifier (web origin) for the provider which owns the
		 * certificate. Required for service and provisioner certificates.
		 * </pre>
		 *
		 * <code>optional string provider_id = 7;</code>
		 * 
		 * @return The providerId.
		 */
		@java.lang.Override
		public java.lang.String getProviderId() {
			java.lang.Object ref = providerId_;
			if (ref instanceof java.lang.String) {
				return (java.lang.String) ref;
			}
			ByteString bs = (ByteString) ref;
			java.lang.String s = bs.toStringUtf8();
			if (bs.isValidUtf8()) {
				providerId_ = s;
			}
			return s;
		}

		/**
		 * <pre>
		 * Service identifier (web origin) for the provider which owns the
		 * certificate. Required for service and provisioner certificates.
		 * </pre>
		 *
		 * <code>optional string provider_id = 7;</code>
		 * 
		 * @return The bytes for providerId.
		 */
		@java.lang.Override
		public ByteString getProviderIdBytes() {
			java.lang.Object ref = providerId_;
			if (ref instanceof java.lang.String) {
				ByteString b = ByteString.copyFromUtf8((java.lang.String) ref);
				providerId_ = b;
				return b;
			}
			return (ByteString) ref;
		}

		public static final int SERVICE_TYPES_FIELD_NUMBER = 8;

		private java.util.List<java.lang.Integer> serviceTypes_;
		private static final Internal.ListAdapter.Converter<java.lang.Integer, WvProto2.DrmCertificate.ServiceType> serviceTypes_converter_ = new Internal.ListAdapter.Converter<>() {
			@Override
			public WvProto2.DrmCertificate.ServiceType convert(java.lang.Integer from) {
				WvProto2.DrmCertificate.ServiceType result = WvProto2.DrmCertificate.ServiceType
						.forNumber(from);
				return result == null ? WvProto2.DrmCertificate.ServiceType.UNKNOWN_SERVICE_TYPE
						: result;
			}
		};

		/**
		 * <pre>
		 * This field is used only when type = SERVICE to specify which SDK uses
		 * service certificate. This repeated field is treated as a set. A certificate
		 * may be used for the specified service SDK if the appropriate ServiceType
		 * is specified in this field.
		 * </pre>
		 *
		 * <code>repeated .DrmCertificate.ServiceType service_types = 8;</code>
		 * 
		 * @return A list containing the serviceTypes.
		 */
		@java.lang.Override
		public java.util.List<WvProto2.DrmCertificate.ServiceType> getServiceTypesList() {
			return new Internal.ListAdapter<>(serviceTypes_, serviceTypes_converter_);
		}

		/**
		 * <pre>
		 * This field is used only when type = SERVICE to specify which SDK uses
		 * service certificate. This repeated field is treated as a set. A certificate
		 * may be used for the specified service SDK if the appropriate ServiceType
		 * is specified in this field.
		 * </pre>
		 *
		 * <code>repeated .DrmCertificate.ServiceType service_types = 8;</code>
		 * 
		 * @return The count of serviceTypes.
		 */
		@java.lang.Override
		public int getServiceTypesCount() {
			return serviceTypes_.size();
		}

		/**
		 * <pre>
		 * This field is used only when type = SERVICE to specify which SDK uses
		 * service certificate. This repeated field is treated as a set. A certificate
		 * may be used for the specified service SDK if the appropriate ServiceType
		 * is specified in this field.
		 * </pre>
		 *
		 * <code>repeated .DrmCertificate.ServiceType service_types = 8;</code>
		 * 
		 * @param index The index of the element to return.
		 * @return The serviceTypes at the given index.
		 */
		@java.lang.Override
		public WvProto2.DrmCertificate.ServiceType getServiceTypes(int index) {
			return serviceTypes_converter_.convert(serviceTypes_.get(index));
		}

		public static final int ALGORITHM_FIELD_NUMBER = 9;
		private int algorithm_ = 1;

		/**
		 * <pre>
		 * Required. The algorithm field contains the curve used to create the
		 * |public_key| if algorithm is one of the ECC types.
		 * The |algorithm| is used for both to determine the if the certificate is ECC
		 * or RSA. The |algorithm| also specifies the parameters that were used to
		 * create |public_key| and are used to create an ephemeral session key.
		 * </pre>
		 *
		 * <code>optional .DrmCertificate.Algorithm algorithm = 9 [default = RSA];</code>
		 * 
		 * @return Whether the algorithm field is set.
		 */
		@java.lang.Override
		public boolean hasAlgorithm() {
			return ((bitField0_ & 0x00000100) != 0);
		}

		/**
		 * <pre>
		 * Required. The algorithm field contains the curve used to create the
		 * |public_key| if algorithm is one of the ECC types.
		 * The |algorithm| is used for both to determine the if the certificate is ECC
		 * or RSA. The |algorithm| also specifies the parameters that were used to
		 * create |public_key| and are used to create an ephemeral session key.
		 * </pre>
		 *
		 * <code>optional .DrmCertificate.Algorithm algorithm = 9 [default = RSA];</code>
		 * 
		 * @return The algorithm.
		 */
		@java.lang.Override
		public WvProto2.DrmCertificate.Algorithm getAlgorithm() {
			WvProto2.DrmCertificate.Algorithm result = WvProto2.DrmCertificate.Algorithm
					.forNumber(algorithm_);
			return result == null ? WvProto2.DrmCertificate.Algorithm.RSA : result;
		}

		public static final int ROT_ID_FIELD_NUMBER = 10;
		private ByteString rotId_ = ByteString.EMPTY;

		/**
		 * <pre>
		 * Optional. May be present in DEVICE certificate types. This is the root
		 * of trust identifier that holds an encrypted value that identifies the
		 * keybox or other root of trust that was used to provision a DEVICE drm
		 * certificate.
		 * </pre>
		 *
		 * <code>optional bytes rot_id = 10;</code>
		 * 
		 * @return Whether the rotId field is set.
		 */
		@java.lang.Override
		public boolean hasRotId() {
			return ((bitField0_ & 0x00000200) != 0);
		}

		/**
		 * <pre>
		 * Optional. May be present in DEVICE certificate types. This is the root
		 * of trust identifier that holds an encrypted value that identifies the
		 * keybox or other root of trust that was used to provision a DEVICE drm
		 * certificate.
		 * </pre>
		 *
		 * <code>optional bytes rot_id = 10;</code>
		 * 
		 * @return The rotId.
		 */
		@java.lang.Override
		public ByteString getRotId() {
			return rotId_;
		}

		public static final int ENCRYPTION_KEY_FIELD_NUMBER = 11;
		private WvProto2.DrmCertificate.EncryptionKey encryptionKey_;

		/**
		 * <pre>
		 * Optional. May be present in devices that explicitly support dual keys. When
		 * present the |public_key| is used for verification of received license
		 * request messages.
		 * </pre>
		 *
		 * <code>optional .DrmCertificate.EncryptionKey encryption_key = 11;</code>
		 * 
		 * @return Whether the encryptionKey field is set.
		 */
		@java.lang.Override
		public boolean hasEncryptionKey() {
			return ((bitField0_ & 0x00000400) != 0);
		}

		/**
		 * <pre>
		 * Optional. May be present in devices that explicitly support dual keys. When
		 * present the |public_key| is used for verification of received license
		 * request messages.
		 * </pre>
		 *
		 * <code>optional .DrmCertificate.EncryptionKey encryption_key = 11;</code>
		 * 
		 * @return The encryptionKey.
		 */
		@java.lang.Override
		public WvProto2.DrmCertificate.EncryptionKey getEncryptionKey() {
			return encryptionKey_ == null
					? WvProto2.DrmCertificate.EncryptionKey.getDefaultInstance()
					: encryptionKey_;
		}

		/**
		 * <pre>
		 * Optional. May be present in devices that explicitly support dual keys. When
		 * present the |public_key| is used for verification of received license
		 * request messages.
		 * </pre>
		 *
		 * <code>optional .DrmCertificate.EncryptionKey encryption_key = 11;</code>
		 */
		@java.lang.Override
		public WvProto2.DrmCertificate.EncryptionKeyOrBuilder getEncryptionKeyOrBuilder() {
			return encryptionKey_ == null
					? WvProto2.DrmCertificate.EncryptionKey.getDefaultInstance()
					: encryptionKey_;
		}

		private byte memoizedIsInitialized = -1;

		@java.lang.Override
		public final boolean isInitialized() {
			byte isInitialized = memoizedIsInitialized;
			if (isInitialized == 1)
				return true;
			if (isInitialized == 0)
				return false;

			memoizedIsInitialized = 1;
			return true;
		}

		@java.lang.Override
		public void writeTo(CodedOutputStream output) throws java.io.IOException {
			if (((bitField0_ & 0x00000001) != 0)) {
				output.writeEnum(1, type_);
			}
			if (((bitField0_ & 0x00000002) != 0)) {
				output.writeBytes(2, serialNumber_);
			}
			if (((bitField0_ & 0x00000004) != 0)) {
				output.writeUInt32(3, creationTimeSeconds_);
			}
			if (((bitField0_ & 0x00000010) != 0)) {
				output.writeBytes(4, publicKey_);
			}
			if (((bitField0_ & 0x00000020) != 0)) {
				output.writeUInt32(5, systemId_);
			}
			if (((bitField0_ & 0x00000040) != 0)) {
				output.writeBool(6, testDeviceDeprecated_);
			}
			if (((bitField0_ & 0x00000080) != 0)) {
				GeneratedMessageV3.writeString(output, 7, providerId_);
			}
			for (int i = 0; i < serviceTypes_.size(); i++) {
				output.writeEnum(8, serviceTypes_.get(i));
			}
			if (((bitField0_ & 0x00000100) != 0)) {
				output.writeEnum(9, algorithm_);
			}
			if (((bitField0_ & 0x00000200) != 0)) {
				output.writeBytes(10, rotId_);
			}
			if (((bitField0_ & 0x00000400) != 0)) {
				output.writeMessage(11, getEncryptionKey());
			}
			if (((bitField0_ & 0x00000008) != 0)) {
				output.writeUInt32(12, expirationTimeSeconds_);
			}
			getUnknownFields().writeTo(output);
		}

		@java.lang.Override
		public int getSerializedSize() {
			int size = memoizedSize;
			if (size != -1)
				return size;

			size = 0;
			if (((bitField0_ & 0x00000001) != 0)) {
				size += CodedOutputStream.computeEnumSize(1, type_);
			}
			if (((bitField0_ & 0x00000002) != 0)) {
				size += CodedOutputStream.computeBytesSize(2, serialNumber_);
			}
			if (((bitField0_ & 0x00000004) != 0)) {
				size += CodedOutputStream.computeUInt32Size(3, creationTimeSeconds_);
			}
			if (((bitField0_ & 0x00000010) != 0)) {
				size += CodedOutputStream.computeBytesSize(4, publicKey_);
			}
			if (((bitField0_ & 0x00000020) != 0)) {
				size += CodedOutputStream.computeUInt32Size(5, systemId_);
			}
			if (((bitField0_ & 0x00000040) != 0)) {
				size += CodedOutputStream.computeBoolSize(6, testDeviceDeprecated_);
			}
			if (((bitField0_ & 0x00000080) != 0)) {
				size += GeneratedMessageV3.computeStringSize(7, providerId_);
			}
			{
				int dataSize = 0;
				for (int i = 0; i < serviceTypes_.size(); i++) {
					dataSize += CodedOutputStream.computeEnumSizeNoTag(serviceTypes_.get(i));
				}
				size += dataSize;
				size += 1 * serviceTypes_.size();
			}
			if (((bitField0_ & 0x00000100) != 0)) {
				size += CodedOutputStream.computeEnumSize(9, algorithm_);
			}
			if (((bitField0_ & 0x00000200) != 0)) {
				size += CodedOutputStream.computeBytesSize(10, rotId_);
			}
			if (((bitField0_ & 0x00000400) != 0)) {
				size += CodedOutputStream.computeMessageSize(11, getEncryptionKey());
			}
			if (((bitField0_ & 0x00000008) != 0)) {
				size += CodedOutputStream.computeUInt32Size(12, expirationTimeSeconds_);
			}
			size += getUnknownFields().getSerializedSize();
			memoizedSize = size;
			return size;
		}

		@java.lang.Override
		public boolean equals(final java.lang.Object obj) {
			if (obj == this) {
				return true;
			}
			if (!(obj instanceof WvProto2.DrmCertificate)) {
				return super.equals(obj);
			}
			WvProto2.DrmCertificate other = (WvProto2.DrmCertificate) obj;

			if (hasType() != other.hasType())
				return false;
			if (hasType()) {
				if (type_ != other.type_)
					return false;
			}
			if (hasSerialNumber() != other.hasSerialNumber())
				return false;
			if (hasSerialNumber()) {
				if (!getSerialNumber().equals(other.getSerialNumber()))
					return false;
			}
			if (hasCreationTimeSeconds() != other.hasCreationTimeSeconds())
				return false;
			if (hasCreationTimeSeconds()) {
				if (getCreationTimeSeconds() != other.getCreationTimeSeconds())
					return false;
			}
			if (hasExpirationTimeSeconds() != other.hasExpirationTimeSeconds())
				return false;
			if (hasExpirationTimeSeconds()) {
				if (getExpirationTimeSeconds() != other.getExpirationTimeSeconds())
					return false;
			}
			if (hasPublicKey() != other.hasPublicKey())
				return false;
			if (hasPublicKey()) {
				if (!getPublicKey().equals(other.getPublicKey()))
					return false;
			}
			if (hasSystemId() != other.hasSystemId())
				return false;
			if (hasSystemId()) {
				if (getSystemId() != other.getSystemId())
					return false;
			}
			if (hasTestDeviceDeprecated() != other.hasTestDeviceDeprecated())
				return false;
			if (hasTestDeviceDeprecated()) {
				if (getTestDeviceDeprecated() != other.getTestDeviceDeprecated())
					return false;
			}
			if (hasProviderId() != other.hasProviderId())
				return false;
			if (hasProviderId()) {
				if (!getProviderId().equals(other.getProviderId()))
					return false;
			}
			if (!serviceTypes_.equals(other.serviceTypes_))
				return false;
			if (hasAlgorithm() != other.hasAlgorithm())
				return false;
			if (hasAlgorithm()) {
				if (algorithm_ != other.algorithm_)
					return false;
			}
			if (hasRotId() != other.hasRotId())
				return false;
			if (hasRotId()) {
				if (!getRotId().equals(other.getRotId()))
					return false;
			}
			if (hasEncryptionKey() != other.hasEncryptionKey())
				return false;
			if (hasEncryptionKey()) {
				if (!getEncryptionKey().equals(other.getEncryptionKey()))
					return false;
			}
			if (!getUnknownFields().equals(other.getUnknownFields()))
				return false;
			return true;
		}

		@SuppressWarnings("unchecked")
		@java.lang.Override
		public int hashCode() {
			if (memoizedHashCode != 0) {
				return memoizedHashCode;
			}
			int hash = 41;
			hash = (19 * hash) + getDescriptor().hashCode();
			if (hasType()) {
				hash = (37 * hash) + TYPE_FIELD_NUMBER;
				hash = (53 * hash) + type_;
			}
			if (hasSerialNumber()) {
				hash = (37 * hash) + SERIAL_NUMBER_FIELD_NUMBER;
				hash = (53 * hash) + getSerialNumber().hashCode();
			}
			if (hasCreationTimeSeconds()) {
				hash = (37 * hash) + CREATION_TIME_SECONDS_FIELD_NUMBER;
				hash = (53 * hash) + getCreationTimeSeconds();
			}
			if (hasExpirationTimeSeconds()) {
				hash = (37 * hash) + EXPIRATION_TIME_SECONDS_FIELD_NUMBER;
				hash = (53 * hash) + getExpirationTimeSeconds();
			}
			if (hasPublicKey()) {
				hash = (37 * hash) + PUBLIC_KEY_FIELD_NUMBER;
				hash = (53 * hash) + getPublicKey().hashCode();
			}
			if (hasSystemId()) {
				hash = (37 * hash) + SYSTEM_ID_FIELD_NUMBER;
				hash = (53 * hash) + getSystemId();
			}
			if (hasTestDeviceDeprecated()) {
				hash = (37 * hash) + TEST_DEVICE_DEPRECATED_FIELD_NUMBER;
				hash = (53 * hash) + Internal.hashBoolean(getTestDeviceDeprecated());
			}
			if (hasProviderId()) {
				hash = (37 * hash) + PROVIDER_ID_FIELD_NUMBER;
				hash = (53 * hash) + getProviderId().hashCode();
			}
			if (getServiceTypesCount() > 0) {
				hash = (37 * hash) + SERVICE_TYPES_FIELD_NUMBER;
				hash = (53 * hash) + serviceTypes_.hashCode();
			}
			if (hasAlgorithm()) {
				hash = (37 * hash) + ALGORITHM_FIELD_NUMBER;
				hash = (53 * hash) + algorithm_;
			}
			if (hasRotId()) {
				hash = (37 * hash) + ROT_ID_FIELD_NUMBER;
				hash = (53 * hash) + getRotId().hashCode();
			}
			if (hasEncryptionKey()) {
				hash = (37 * hash) + ENCRYPTION_KEY_FIELD_NUMBER;
				hash = (53 * hash) + getEncryptionKey().hashCode();
			}
			hash = (29 * hash) + getUnknownFields().hashCode();
			memoizedHashCode = hash;
			return hash;
		}

		public static WvProto2.DrmCertificate parseFrom(java.nio.ByteBuffer data)
				throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data);
		}

		public static WvProto2.DrmCertificate parseFrom(java.nio.ByteBuffer data,
				ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data, extensionRegistry);
		}

		public static WvProto2.DrmCertificate parseFrom(ByteString data)
				throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data);
		}

		public static WvProto2.DrmCertificate parseFrom(ByteString data,
				ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data, extensionRegistry);
		}

		public static WvProto2.DrmCertificate parseFrom(byte[] data)
				throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data);
		}

		public static WvProto2.DrmCertificate parseFrom(byte[] data,
				ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data, extensionRegistry);
		}

		public static WvProto2.DrmCertificate parseFrom(java.io.InputStream input)
				throws java.io.IOException {
			return GeneratedMessageV3.parseWithIOException(PARSER, input);
		}

		public static WvProto2.DrmCertificate parseFrom(java.io.InputStream input,
				ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
			return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
		}

		public static WvProto2.DrmCertificate parseDelimitedFrom(java.io.InputStream input)
				throws java.io.IOException {
			return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
		}

		public static WvProto2.DrmCertificate parseDelimitedFrom(java.io.InputStream input,
				ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
			return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input, extensionRegistry);
		}

		public static WvProto2.DrmCertificate parseFrom(CodedInputStream input)
				throws java.io.IOException {
			return GeneratedMessageV3.parseWithIOException(PARSER, input);
		}

		public static WvProto2.DrmCertificate parseFrom(CodedInputStream input,
				ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
			return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
		}

		@java.lang.Override
		public Builder newBuilderForType() {
			return newBuilder();
		}

		public static Builder newBuilder() {
			return DEFAULT_INSTANCE.toBuilder();
		}

		public static Builder newBuilder(WvProto2.DrmCertificate prototype) {
			return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
		}

		@java.lang.Override
		public Builder toBuilder() {
			return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
		}

		@java.lang.Override
		protected Builder newBuilderForType(GeneratedMessageV3.BuilderParent parent) {
			Builder builder = new Builder(parent);
			return builder;
		}

		/**
		 * <pre>
		 * DRM certificate definition for user devices, intermediate, service, and root
		 * certificates.
		 * </pre>
		 *
		 * Protobuf type {@code DrmCertificate}
		 */
		public static final class Builder extends GeneratedMessageV3.Builder<Builder> implements
				// @@protoc_insertion_point(builder_implements:DrmCertificate)
				WvProto2.DrmCertificateOrBuilder {
			public static final Descriptors.Descriptor getDescriptor() {
				return WvProto2.internal_static_DrmCertificate_descriptor;
			}

			@java.lang.Override
			protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
				return WvProto2.internal_static_DrmCertificate_fieldAccessorTable
						.ensureFieldAccessorsInitialized(WvProto2.DrmCertificate.class,
								WvProto2.DrmCertificate.Builder.class);
			}

			// Construct using WvProto2.DrmCertificate.newBuilder()
			private Builder() {
				maybeForceBuilderInitialization();
			}

			private Builder(GeneratedMessageV3.BuilderParent parent) {
				super(parent);
				maybeForceBuilderInitialization();
			}

			private void maybeForceBuilderInitialization() {
				if (GeneratedMessageV3.alwaysUseFieldBuilders) {
					getEncryptionKeyFieldBuilder();
				}
			}

			@java.lang.Override
			public Builder clear() {
				super.clear();
				bitField0_ = 0;
				type_ = 0;
				serialNumber_ = ByteString.EMPTY;
				creationTimeSeconds_ = 0;
				expirationTimeSeconds_ = 0;
				publicKey_ = ByteString.EMPTY;
				systemId_ = 0;
				testDeviceDeprecated_ = false;
				providerId_ = "";
				serviceTypes_ = java.util.Collections.emptyList();
				bitField0_ = (bitField0_ & ~0x00000100);
				algorithm_ = 1;
				rotId_ = ByteString.EMPTY;
				encryptionKey_ = null;
				if (encryptionKeyBuilder_ != null) {
					encryptionKeyBuilder_.dispose();
					encryptionKeyBuilder_ = null;
				}
				return this;
			}

			@java.lang.Override
			public Descriptors.Descriptor getDescriptorForType() {
				return WvProto2.internal_static_DrmCertificate_descriptor;
			}

			@java.lang.Override
			public WvProto2.DrmCertificate getDefaultInstanceForType() {
				return WvProto2.DrmCertificate.getDefaultInstance();
			}

			@java.lang.Override
			public WvProto2.DrmCertificate build() {
				WvProto2.DrmCertificate result = buildPartial();
				if (!result.isInitialized()) {
					throw newUninitializedMessageException(result);
				}
				return result;
			}

			@java.lang.Override
			public WvProto2.DrmCertificate buildPartial() {
				WvProto2.DrmCertificate result = new WvProto2.DrmCertificate(
						this);
				buildPartialRepeatedFields(result);
				if (bitField0_ != 0) {
					buildPartial0(result);
				}
				onBuilt();
				return result;
			}

			private void buildPartialRepeatedFields(WvProto2.DrmCertificate result) {
				if (((bitField0_ & 0x00000100) != 0)) {
					serviceTypes_ = java.util.Collections.unmodifiableList(serviceTypes_);
					bitField0_ = (bitField0_ & ~0x00000100);
				}
				result.serviceTypes_ = serviceTypes_;
			}

			private void buildPartial0(WvProto2.DrmCertificate result) {
				int from_bitField0_ = bitField0_;
				int to_bitField0_ = 0;
				if (((from_bitField0_ & 0x00000001) != 0)) {
					result.type_ = type_;
					to_bitField0_ |= 0x00000001;
				}
				if (((from_bitField0_ & 0x00000002) != 0)) {
					result.serialNumber_ = serialNumber_;
					to_bitField0_ |= 0x00000002;
				}
				if (((from_bitField0_ & 0x00000004) != 0)) {
					result.creationTimeSeconds_ = creationTimeSeconds_;
					to_bitField0_ |= 0x00000004;
				}
				if (((from_bitField0_ & 0x00000008) != 0)) {
					result.expirationTimeSeconds_ = expirationTimeSeconds_;
					to_bitField0_ |= 0x00000008;
				}
				if (((from_bitField0_ & 0x00000010) != 0)) {
					result.publicKey_ = publicKey_;
					to_bitField0_ |= 0x00000010;
				}
				if (((from_bitField0_ & 0x00000020) != 0)) {
					result.systemId_ = systemId_;
					to_bitField0_ |= 0x00000020;
				}
				if (((from_bitField0_ & 0x00000040) != 0)) {
					result.testDeviceDeprecated_ = testDeviceDeprecated_;
					to_bitField0_ |= 0x00000040;
				}
				if (((from_bitField0_ & 0x00000080) != 0)) {
					result.providerId_ = providerId_;
					to_bitField0_ |= 0x00000080;
				}
				if (((from_bitField0_ & 0x00000200) != 0)) {
					result.algorithm_ = algorithm_;
					to_bitField0_ |= 0x00000100;
				}
				if (((from_bitField0_ & 0x00000400) != 0)) {
					result.rotId_ = rotId_;
					to_bitField0_ |= 0x00000200;
				}
				if (((from_bitField0_ & 0x00000800) != 0)) {
					result.encryptionKey_ = encryptionKeyBuilder_ == null ? encryptionKey_
							: encryptionKeyBuilder_.build();
					to_bitField0_ |= 0x00000400;
				}
				result.bitField0_ |= to_bitField0_;
			}

			@java.lang.Override
			public Builder mergeFrom(Message other) {
				if (other instanceof WvProto2.DrmCertificate) {
					return mergeFrom((WvProto2.DrmCertificate) other);
				}
				super.mergeFrom(other);
				return this;
			}

			public Builder mergeFrom(WvProto2.DrmCertificate other) {
				if (other == WvProto2.DrmCertificate.getDefaultInstance())
					return this;
				if (other.hasType()) {
					setType(other.getType());
				}
				if (other.hasSerialNumber()) {
					setSerialNumber(other.getSerialNumber());
				}
				if (other.hasCreationTimeSeconds()) {
					setCreationTimeSeconds(other.getCreationTimeSeconds());
				}
				if (other.hasExpirationTimeSeconds()) {
					setExpirationTimeSeconds(other.getExpirationTimeSeconds());
				}
				if (other.hasPublicKey()) {
					setPublicKey(other.getPublicKey());
				}
				if (other.hasSystemId()) {
					setSystemId(other.getSystemId());
				}
				if (other.hasTestDeviceDeprecated()) {
					setTestDeviceDeprecated(other.getTestDeviceDeprecated());
				}
				if (other.hasProviderId()) {
					providerId_ = other.providerId_;
					bitField0_ |= 0x00000080;
					onChanged();
				}
				if (!other.serviceTypes_.isEmpty()) {
					if (serviceTypes_.isEmpty()) {
						serviceTypes_ = other.serviceTypes_;
						bitField0_ = (bitField0_ & ~0x00000100);
					} else {
						ensureServiceTypesIsMutable();
						serviceTypes_.addAll(other.serviceTypes_);
					}
					onChanged();
				}
				if (other.hasAlgorithm()) {
					setAlgorithm(other.getAlgorithm());
				}
				if (other.hasRotId()) {
					setRotId(other.getRotId());
				}
				if (other.hasEncryptionKey()) {
					mergeEncryptionKey(other.getEncryptionKey());
				}
				this.mergeUnknownFields(other.getUnknownFields());
				onChanged();
				return this;
			}

			@java.lang.Override
			public final boolean isInitialized() {
				return true;
			}

			@java.lang.Override
			public Builder mergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
					throws java.io.IOException {
				if (extensionRegistry == null) {
					throw new java.lang.NullPointerException();
				}
				try {
					boolean done = false;
					while (!done) {
						int tag = input.readTag();
						switch (tag) {
						case 0:
							done = true;
							break;
						case 8: {
							int tmpRaw = input.readEnum();
							WvProto2.DrmCertificate.Type tmpValue = WvProto2.DrmCertificate.Type
									.forNumber(tmpRaw);
							if (tmpValue == null) {
								mergeUnknownVarintField(1, tmpRaw);
							} else {
								type_ = tmpRaw;
								bitField0_ |= 0x00000001;
							}
							break;
						} // case 8
						case 18: {
							serialNumber_ = input.readBytes();
							bitField0_ |= 0x00000002;
							break;
						} // case 18
						case 24: {
							creationTimeSeconds_ = input.readUInt32();
							bitField0_ |= 0x00000004;
							break;
						} // case 24
						case 34: {
							publicKey_ = input.readBytes();
							bitField0_ |= 0x00000010;
							break;
						} // case 34
						case 40: {
							systemId_ = input.readUInt32();
							bitField0_ |= 0x00000020;
							break;
						} // case 40
						case 48: {
							testDeviceDeprecated_ = input.readBool();
							bitField0_ |= 0x00000040;
							break;
						} // case 48
						case 58: {
							providerId_ = input.readBytes();
							bitField0_ |= 0x00000080;
							break;
						} // case 58
						case 64: {
							int tmpRaw = input.readEnum();
							WvProto2.DrmCertificate.ServiceType tmpValue = WvProto2.DrmCertificate.ServiceType
									.forNumber(tmpRaw);
							if (tmpValue == null) {
								mergeUnknownVarintField(8, tmpRaw);
							} else {
								ensureServiceTypesIsMutable();
								serviceTypes_.add(tmpRaw);
							}
							break;
						} // case 64
						case 66: {
							int length = input.readRawVarint32();
							int oldLimit = input.pushLimit(length);
							while (input.getBytesUntilLimit() > 0) {
								int tmpRaw = input.readEnum();
								WvProto2.DrmCertificate.ServiceType tmpValue = WvProto2.DrmCertificate.ServiceType
										.forNumber(tmpRaw);
								if (tmpValue == null) {
									mergeUnknownVarintField(8, tmpRaw);
								} else {
									ensureServiceTypesIsMutable();
									serviceTypes_.add(tmpRaw);
								}
							}
							input.popLimit(oldLimit);
							break;
						} // case 66
						case 72: {
							int tmpRaw = input.readEnum();
							WvProto2.DrmCertificate.Algorithm tmpValue = WvProto2.DrmCertificate.Algorithm
									.forNumber(tmpRaw);
							if (tmpValue == null) {
								mergeUnknownVarintField(9, tmpRaw);
							} else {
								algorithm_ = tmpRaw;
								bitField0_ |= 0x00000200;
							}
							break;
						} // case 72
						case 82: {
							rotId_ = input.readBytes();
							bitField0_ |= 0x00000400;
							break;
						} // case 82
						case 90: {
							input.readMessage(getEncryptionKeyFieldBuilder().getBuilder(), extensionRegistry);
							bitField0_ |= 0x00000800;
							break;
						} // case 90
						case 96: {
							expirationTimeSeconds_ = input.readUInt32();
							bitField0_ |= 0x00000008;
							break;
						} // case 96
						default: {
							if (!super.parseUnknownField(input, extensionRegistry, tag)) {
								done = true; // was an endgroup tag
							}
							break;
						} // default:
						} // switch (tag)
					} // while (!done)
				} catch (InvalidProtocolBufferException e) {
					throw e.unwrapIOException();
				}
				finally {
					onChanged();
				} // finally
				return this;
			}

			private int bitField0_;

			private int type_ = 0;

			/**
			 * <pre>
			 * Type of certificate. Required.
			 * </pre>
			 *
			 * <code>optional .DrmCertificate.Type type = 1;</code>
			 * 
			 * @return Whether the type field is set.
			 */
			@java.lang.Override
			public boolean hasType() {
				return ((bitField0_ & 0x00000001) != 0);
			}

			/**
			 * <pre>
			 * Type of certificate. Required.
			 * </pre>
			 *
			 * <code>optional .DrmCertificate.Type type = 1;</code>
			 * 
			 * @return The type.
			 */
			@java.lang.Override
			public WvProto2.DrmCertificate.Type getType() {
				WvProto2.DrmCertificate.Type result = WvProto2.DrmCertificate.Type
						.forNumber(type_);
				return result == null ? WvProto2.DrmCertificate.Type.ROOT : result;
			}

			/**
			 * <pre>
			 * Type of certificate. Required.
			 * </pre>
			 *
			 * <code>optional .DrmCertificate.Type type = 1;</code>
			 * 
			 * @param value The type to set.
			 * @return This builder for chaining.
			 */
			public Builder setType(WvProto2.DrmCertificate.Type value) {
				if (value == null) {
					throw new NullPointerException();
				}
				bitField0_ |= 0x00000001;
				type_ = value.getNumber();
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Type of certificate. Required.
			 * </pre>
			 *
			 * <code>optional .DrmCertificate.Type type = 1;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearType() {
				bitField0_ = (bitField0_ & ~0x00000001);
				type_ = 0;
				onChanged();
				return this;
			}

			private ByteString serialNumber_ = ByteString.EMPTY;

			/**
			 * <pre>
			 * 128-bit globally unique serial number of certificate.
			 * Value is 0 for root certificate. Required.
			 * </pre>
			 *
			 * <code>optional bytes serial_number = 2;</code>
			 * 
			 * @return Whether the serialNumber field is set.
			 */
			@java.lang.Override
			public boolean hasSerialNumber() {
				return ((bitField0_ & 0x00000002) != 0);
			}

			/**
			 * <pre>
			 * 128-bit globally unique serial number of certificate.
			 * Value is 0 for root certificate. Required.
			 * </pre>
			 *
			 * <code>optional bytes serial_number = 2;</code>
			 * 
			 * @return The serialNumber.
			 */
			@java.lang.Override
			public ByteString getSerialNumber() {
				return serialNumber_;
			}

			/**
			 * <pre>
			 * 128-bit globally unique serial number of certificate.
			 * Value is 0 for root certificate. Required.
			 * </pre>
			 *
			 * <code>optional bytes serial_number = 2;</code>
			 * 
			 * @param value The serialNumber to set.
			 * @return This builder for chaining.
			 */
			public Builder setSerialNumber(ByteString value) {
				if (value == null) {
					throw new NullPointerException();
				}
				serialNumber_ = value;
				bitField0_ |= 0x00000002;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * 128-bit globally unique serial number of certificate.
			 * Value is 0 for root certificate. Required.
			 * </pre>
			 *
			 * <code>optional bytes serial_number = 2;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearSerialNumber() {
				bitField0_ = (bitField0_ & ~0x00000002);
				serialNumber_ = getDefaultInstance().getSerialNumber();
				onChanged();
				return this;
			}

			private int creationTimeSeconds_;

			/**
			 * <pre>
			 * POSIX time, in seconds, when the certificate was created. Required.
			 * </pre>
			 *
			 * <code>optional uint32 creation_time_seconds = 3;</code>
			 * 
			 * @return Whether the creationTimeSeconds field is set.
			 */
			@java.lang.Override
			public boolean hasCreationTimeSeconds() {
				return ((bitField0_ & 0x00000004) != 0);
			}

			/**
			 * <pre>
			 * POSIX time, in seconds, when the certificate was created. Required.
			 * </pre>
			 *
			 * <code>optional uint32 creation_time_seconds = 3;</code>
			 * 
			 * @return The creationTimeSeconds.
			 */
			@java.lang.Override
			public int getCreationTimeSeconds() {
				return creationTimeSeconds_;
			}

			/**
			 * <pre>
			 * POSIX time, in seconds, when the certificate was created. Required.
			 * </pre>
			 *
			 * <code>optional uint32 creation_time_seconds = 3;</code>
			 * 
			 * @param value The creationTimeSeconds to set.
			 * @return This builder for chaining.
			 */
			public Builder setCreationTimeSeconds(int value) {

				creationTimeSeconds_ = value;
				bitField0_ |= 0x00000004;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * POSIX time, in seconds, when the certificate was created. Required.
			 * </pre>
			 *
			 * <code>optional uint32 creation_time_seconds = 3;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearCreationTimeSeconds() {
				bitField0_ = (bitField0_ & ~0x00000004);
				creationTimeSeconds_ = 0;
				onChanged();
				return this;
			}

			private int expirationTimeSeconds_;

			/**
			 * <pre>
			 * POSIX time, in seconds, when the certificate should expire. Value of zero
			 * denotes indefinite expiry time. For more information on limited lifespan
			 * DRM certificates see (go/limited-lifespan-drm-certificates).
			 * </pre>
			 *
			 * <code>optional uint32 expiration_time_seconds = 12;</code>
			 * 
			 * @return Whether the expirationTimeSeconds field is set.
			 */
			@java.lang.Override
			public boolean hasExpirationTimeSeconds() {
				return ((bitField0_ & 0x00000008) != 0);
			}

			/**
			 * <pre>
			 * POSIX time, in seconds, when the certificate should expire. Value of zero
			 * denotes indefinite expiry time. For more information on limited lifespan
			 * DRM certificates see (go/limited-lifespan-drm-certificates).
			 * </pre>
			 *
			 * <code>optional uint32 expiration_time_seconds = 12;</code>
			 * 
			 * @return The expirationTimeSeconds.
			 */
			@java.lang.Override
			public int getExpirationTimeSeconds() {
				return expirationTimeSeconds_;
			}

			/**
			 * <pre>
			 * POSIX time, in seconds, when the certificate should expire. Value of zero
			 * denotes indefinite expiry time. For more information on limited lifespan
			 * DRM certificates see (go/limited-lifespan-drm-certificates).
			 * </pre>
			 *
			 * <code>optional uint32 expiration_time_seconds = 12;</code>
			 * 
			 * @param value The expirationTimeSeconds to set.
			 * @return This builder for chaining.
			 */
			public Builder setExpirationTimeSeconds(int value) {

				expirationTimeSeconds_ = value;
				bitField0_ |= 0x00000008;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * POSIX time, in seconds, when the certificate should expire. Value of zero
			 * denotes indefinite expiry time. For more information on limited lifespan
			 * DRM certificates see (go/limited-lifespan-drm-certificates).
			 * </pre>
			 *
			 * <code>optional uint32 expiration_time_seconds = 12;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearExpirationTimeSeconds() {
				bitField0_ = (bitField0_ & ~0x00000008);
				expirationTimeSeconds_ = 0;
				onChanged();
				return this;
			}

			private ByteString publicKey_ = ByteString.EMPTY;

			/**
			 * <pre>
			 * Device public key. PKCS#1 ASN.1 DER-encoded. Required.
			 * </pre>
			 *
			 * <code>optional bytes public_key = 4;</code>
			 * 
			 * @return Whether the publicKey field is set.
			 */
			@java.lang.Override
			public boolean hasPublicKey() {
				return ((bitField0_ & 0x00000010) != 0);
			}

			/**
			 * <pre>
			 * Device public key. PKCS#1 ASN.1 DER-encoded. Required.
			 * </pre>
			 *
			 * <code>optional bytes public_key = 4;</code>
			 * 
			 * @return The publicKey.
			 */
			@java.lang.Override
			public ByteString getPublicKey() {
				return publicKey_;
			}

			/**
			 * <pre>
			 * Device public key. PKCS#1 ASN.1 DER-encoded. Required.
			 * </pre>
			 *
			 * <code>optional bytes public_key = 4;</code>
			 * 
			 * @param value The publicKey to set.
			 * @return This builder for chaining.
			 */
			public Builder setPublicKey(ByteString value) {
				if (value == null) {
					throw new NullPointerException();
				}
				publicKey_ = value;
				bitField0_ |= 0x00000010;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Device public key. PKCS#1 ASN.1 DER-encoded. Required.
			 * </pre>
			 *
			 * <code>optional bytes public_key = 4;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearPublicKey() {
				bitField0_ = (bitField0_ & ~0x00000010);
				publicKey_ = getDefaultInstance().getPublicKey();
				onChanged();
				return this;
			}

			private int systemId_;

			/**
			 * <pre>
			 * Widevine system ID for the device. Required for intermediate and
			 * user device certificates.
			 * </pre>
			 *
			 * <code>optional uint32 system_id = 5;</code>
			 * 
			 * @return Whether the systemId field is set.
			 */
			@java.lang.Override
			public boolean hasSystemId() {
				return ((bitField0_ & 0x00000020) != 0);
			}

			/**
			 * <pre>
			 * Widevine system ID for the device. Required for intermediate and
			 * user device certificates.
			 * </pre>
			 *
			 * <code>optional uint32 system_id = 5;</code>
			 * 
			 * @return The systemId.
			 */
			@java.lang.Override
			public int getSystemId() {
				return systemId_;
			}

			/**
			 * <pre>
			 * Widevine system ID for the device. Required for intermediate and
			 * user device certificates.
			 * </pre>
			 *
			 * <code>optional uint32 system_id = 5;</code>
			 * 
			 * @param value The systemId to set.
			 * @return This builder for chaining.
			 */
			public Builder setSystemId(int value) {

				systemId_ = value;
				bitField0_ |= 0x00000020;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Widevine system ID for the device. Required for intermediate and
			 * user device certificates.
			 * </pre>
			 *
			 * <code>optional uint32 system_id = 5;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearSystemId() {
				bitField0_ = (bitField0_ & ~0x00000020);
				systemId_ = 0;
				onChanged();
				return this;
			}

			private boolean testDeviceDeprecated_;

			/**
			 * <pre>
			 * Deprecated field, which used to indicate whether the device was a test
			 * (non-production) device. The test_device field in ProvisionedDeviceInfo
			 * below should be observed instead.
			 * </pre>
			 *
			 * <code>optional bool test_device_deprecated = 6 [deprecated = true];</code>
			 * 
			 * @deprecated DrmCertificate.test_device_deprecated is deprecated. See
			 *             wv_proto2.proto;l=598
			 * @return Whether the testDeviceDeprecated field is set.
			 */
			@java.lang.Override
			@java.lang.Deprecated
			public boolean hasTestDeviceDeprecated() {
				return ((bitField0_ & 0x00000040) != 0);
			}

			/**
			 * <pre>
			 * Deprecated field, which used to indicate whether the device was a test
			 * (non-production) device. The test_device field in ProvisionedDeviceInfo
			 * below should be observed instead.
			 * </pre>
			 *
			 * <code>optional bool test_device_deprecated = 6 [deprecated = true];</code>
			 * 
			 * @deprecated DrmCertificate.test_device_deprecated is deprecated. See
			 *             wv_proto2.proto;l=598
			 * @return The testDeviceDeprecated.
			 */
			@java.lang.Override
			@java.lang.Deprecated
			public boolean getTestDeviceDeprecated() {
				return testDeviceDeprecated_;
			}

			/**
			 * <pre>
			 * Deprecated field, which used to indicate whether the device was a test
			 * (non-production) device. The test_device field in ProvisionedDeviceInfo
			 * below should be observed instead.
			 * </pre>
			 *
			 * <code>optional bool test_device_deprecated = 6 [deprecated = true];</code>
			 * 
			 * @deprecated DrmCertificate.test_device_deprecated is deprecated. See
			 *             wv_proto2.proto;l=598
			 * @param value The testDeviceDeprecated to set.
			 * @return This builder for chaining.
			 */
			@java.lang.Deprecated
			public Builder setTestDeviceDeprecated(boolean value) {

				testDeviceDeprecated_ = value;
				bitField0_ |= 0x00000040;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Deprecated field, which used to indicate whether the device was a test
			 * (non-production) device. The test_device field in ProvisionedDeviceInfo
			 * below should be observed instead.
			 * </pre>
			 *
			 * <code>optional bool test_device_deprecated = 6 [deprecated = true];</code>
			 * 
			 * @deprecated DrmCertificate.test_device_deprecated is deprecated. See
			 *             wv_proto2.proto;l=598
			 * @return This builder for chaining.
			 */
			@java.lang.Deprecated
			public Builder clearTestDeviceDeprecated() {
				bitField0_ = (bitField0_ & ~0x00000040);
				testDeviceDeprecated_ = false;
				onChanged();
				return this;
			}

			private java.lang.Object providerId_ = "";

			/**
			 * <pre>
			 * Service identifier (web origin) for the provider which owns the
			 * certificate. Required for service and provisioner certificates.
			 * </pre>
			 *
			 * <code>optional string provider_id = 7;</code>
			 * 
			 * @return Whether the providerId field is set.
			 */
			@Override
			public boolean hasProviderId() {
				return ((bitField0_ & 0x00000080) != 0);
			}

			/**
			 * <pre>
			 * Service identifier (web origin) for the provider which owns the
			 * certificate. Required for service and provisioner certificates.
			 * </pre>
			 *
			 * <code>optional string provider_id = 7;</code>
			 * 
			 * @return The providerId.
			 */
			@Override
			public java.lang.String getProviderId() {
				java.lang.Object ref = providerId_;
				if (!(ref instanceof java.lang.String)) {
					ByteString bs = (ByteString) ref;
					java.lang.String s = bs.toStringUtf8();
					if (bs.isValidUtf8()) {
						providerId_ = s;
					}
					return s;
				}
				return (java.lang.String) ref;
			}

			/**
			 * <pre>
			 * Service identifier (web origin) for the provider which owns the
			 * certificate. Required for service and provisioner certificates.
			 * </pre>
			 *
			 * <code>optional string provider_id = 7;</code>
			 * 
			 * @return The bytes for providerId.
			 */
			@Override
			public ByteString getProviderIdBytes() {
				java.lang.Object ref = providerId_;
				if (ref instanceof String) {
					ByteString b = ByteString.copyFromUtf8((java.lang.String) ref);
					providerId_ = b;
					return b;
				}
				return (ByteString) ref;
			}

			/**
			 * <pre>
			 * Service identifier (web origin) for the provider which owns the
			 * certificate. Required for service and provisioner certificates.
			 * </pre>
			 *
			 * <code>optional string provider_id = 7;</code>
			 * 
			 * @param value The providerId to set.
			 * @return This builder for chaining.
			 */
			public Builder setProviderId(java.lang.String value) {
				if (value == null) {
					throw new NullPointerException();
				}
				providerId_ = value;
				bitField0_ |= 0x00000080;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Service identifier (web origin) for the provider which owns the
			 * certificate. Required for service and provisioner certificates.
			 * </pre>
			 *
			 * <code>optional string provider_id = 7;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearProviderId() {
				providerId_ = getDefaultInstance().getProviderId();
				bitField0_ = (bitField0_ & ~0x00000080);
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Service identifier (web origin) for the provider which owns the
			 * certificate. Required for service and provisioner certificates.
			 * </pre>
			 *
			 * <code>optional string provider_id = 7;</code>
			 * 
			 * @param value The bytes for providerId to set.
			 * @return This builder for chaining.
			 */
			public Builder setProviderIdBytes(ByteString value) {
				if (value == null) {
					throw new NullPointerException();
				}
				providerId_ = value;
				bitField0_ |= 0x00000080;
				onChanged();
				return this;
			}

			private java.util.List<java.lang.Integer> serviceTypes_ = java.util.Collections.emptyList();

			private void ensureServiceTypesIsMutable() {
				if (!((bitField0_ & 0x00000100) != 0)) {
					serviceTypes_ = new java.util.ArrayList<>(serviceTypes_);
					bitField0_ |= 0x00000100;
				}
			}

			/**
			 * <pre>
			 * This field is used only when type = SERVICE to specify which SDK uses
			 * service certificate. This repeated field is treated as a set. A certificate
			 * may be used for the specified service SDK if the appropriate ServiceType
			 * is specified in this field.
			 * </pre>
			 *
			 * <code>repeated .DrmCertificate.ServiceType service_types = 8;</code>
			 * 
			 * @return A list containing the serviceTypes.
			 */
			@Override
			public java.util.List<WvProto2.DrmCertificate.ServiceType> getServiceTypesList() {
				return new Internal.ListAdapter<>(serviceTypes_, serviceTypes_converter_);
			}

			/**
			 * <pre>
			 * This field is used only when type = SERVICE to specify which SDK uses
			 * service certificate. This repeated field is treated as a set. A certificate
			 * may be used for the specified service SDK if the appropriate ServiceType
			 * is specified in this field.
			 * </pre>
			 *
			 * <code>repeated .DrmCertificate.ServiceType service_types = 8;</code>
			 * 
			 * @return The count of serviceTypes.
			 */
			@Override
			public int getServiceTypesCount() {
				return serviceTypes_.size();
			}

			/**
			 * <pre>
			 * This field is used only when type = SERVICE to specify which SDK uses
			 * service certificate. This repeated field is treated as a set. A certificate
			 * may be used for the specified service SDK if the appropriate ServiceType
			 * is specified in this field.
			 * </pre>
			 *
			 * <code>repeated .DrmCertificate.ServiceType service_types = 8;</code>
			 * 
			 * @param index The index of the element to return.
			 * @return The serviceTypes at the given index.
			 */
			@Override
			public WvProto2.DrmCertificate.ServiceType getServiceTypes(int index) {
				return serviceTypes_converter_.convert(serviceTypes_.get(index));
			}

			/**
			 * <pre>
			 * This field is used only when type = SERVICE to specify which SDK uses
			 * service certificate. This repeated field is treated as a set. A certificate
			 * may be used for the specified service SDK if the appropriate ServiceType
			 * is specified in this field.
			 * </pre>
			 *
			 * <code>repeated .DrmCertificate.ServiceType service_types = 8;</code>
			 * 
			 * @param index The index to set the value at.
			 * @param value The serviceTypes to set.
			 * @return This builder for chaining.
			 */
			public Builder setServiceTypes(int index,
					WvProto2.DrmCertificate.ServiceType value) {
				if (value == null) {
					throw new NullPointerException();
				}
				ensureServiceTypesIsMutable();
				serviceTypes_.set(index, value.getNumber());
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * This field is used only when type = SERVICE to specify which SDK uses
			 * service certificate. This repeated field is treated as a set. A certificate
			 * may be used for the specified service SDK if the appropriate ServiceType
			 * is specified in this field.
			 * </pre>
			 *
			 * <code>repeated .DrmCertificate.ServiceType service_types = 8;</code>
			 * 
			 * @param value The serviceTypes to add.
			 * @return This builder for chaining.
			 */
			public Builder addServiceTypes(WvProto2.DrmCertificate.ServiceType value) {
				if (value == null) {
					throw new NullPointerException();
				}
				ensureServiceTypesIsMutable();
				serviceTypes_.add(value.getNumber());
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * This field is used only when type = SERVICE to specify which SDK uses
			 * service certificate. This repeated field is treated as a set. A certificate
			 * may be used for the specified service SDK if the appropriate ServiceType
			 * is specified in this field.
			 * </pre>
			 *
			 * <code>repeated .DrmCertificate.ServiceType service_types = 8;</code>
			 * 
			 * @param values The serviceTypes to add.
			 * @return This builder for chaining.
			 */
			public Builder addAllServiceTypes(
					java.lang.Iterable<? extends WvProto2.DrmCertificate.ServiceType> values) {
				ensureServiceTypesIsMutable();
				for (WvProto2.DrmCertificate.ServiceType value : values) {
					serviceTypes_.add(value.getNumber());
				}
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * This field is used only when type = SERVICE to specify which SDK uses
			 * service certificate. This repeated field is treated as a set. A certificate
			 * may be used for the specified service SDK if the appropriate ServiceType
			 * is specified in this field.
			 * </pre>
			 *
			 * <code>repeated .DrmCertificate.ServiceType service_types = 8;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearServiceTypes() {
				serviceTypes_ = java.util.Collections.emptyList();
				bitField0_ = (bitField0_ & ~0x00000100);
				onChanged();
				return this;
			}

			private int algorithm_ = 1;

			/**
			 * <pre>
			 * Required. The algorithm field contains the curve used to create the
			 * |public_key| if algorithm is one of the ECC types.
			 * The |algorithm| is used for both to determine the if the certificate is ECC
			 * or RSA. The |algorithm| also specifies the parameters that were used to
			 * create |public_key| and are used to create an ephemeral session key.
			 * </pre>
			 *
			 * <code>optional .DrmCertificate.Algorithm algorithm = 9 [default = RSA];</code>
			 * 
			 * @return Whether the algorithm field is set.
			 */
			@java.lang.Override
			public boolean hasAlgorithm() {
				return ((bitField0_ & 0x00000200) != 0);
			}

			/**
			 * <pre>
			 * Required. The algorithm field contains the curve used to create the
			 * |public_key| if algorithm is one of the ECC types.
			 * The |algorithm| is used for both to determine the if the certificate is ECC
			 * or RSA. The |algorithm| also specifies the parameters that were used to
			 * create |public_key| and are used to create an ephemeral session key.
			 * </pre>
			 *
			 * <code>optional .DrmCertificate.Algorithm algorithm = 9 [default = RSA];</code>
			 * 
			 * @return The algorithm.
			 */
			@java.lang.Override
			public WvProto2.DrmCertificate.Algorithm getAlgorithm() {
				WvProto2.DrmCertificate.Algorithm result = WvProto2.DrmCertificate.Algorithm
						.forNumber(algorithm_);
				return result == null ? WvProto2.DrmCertificate.Algorithm.RSA : result;
			}

			/**
			 * <pre>
			 * Required. The algorithm field contains the curve used to create the
			 * |public_key| if algorithm is one of the ECC types.
			 * The |algorithm| is used for both to determine the if the certificate is ECC
			 * or RSA. The |algorithm| also specifies the parameters that were used to
			 * create |public_key| and are used to create an ephemeral session key.
			 * </pre>
			 *
			 * <code>optional .DrmCertificate.Algorithm algorithm = 9 [default = RSA];</code>
			 * 
			 * @param value The algorithm to set.
			 * @return This builder for chaining.
			 */
			public Builder setAlgorithm(WvProto2.DrmCertificate.Algorithm value) {
				if (value == null) {
					throw new NullPointerException();
				}
				bitField0_ |= 0x00000200;
				algorithm_ = value.getNumber();
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Required. The algorithm field contains the curve used to create the
			 * |public_key| if algorithm is one of the ECC types.
			 * The |algorithm| is used for both to determine the if the certificate is ECC
			 * or RSA. The |algorithm| also specifies the parameters that were used to
			 * create |public_key| and are used to create an ephemeral session key.
			 * </pre>
			 *
			 * <code>optional .DrmCertificate.Algorithm algorithm = 9 [default = RSA];</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearAlgorithm() {
				bitField0_ = (bitField0_ & ~0x00000200);
				algorithm_ = 1;
				onChanged();
				return this;
			}

			private ByteString rotId_ = ByteString.EMPTY;

			/**
			 * <pre>
			 * Optional. May be present in DEVICE certificate types. This is the root
			 * of trust identifier that holds an encrypted value that identifies the
			 * keybox or other root of trust that was used to provision a DEVICE drm
			 * certificate.
			 * </pre>
			 *
			 * <code>optional bytes rot_id = 10;</code>
			 * 
			 * @return Whether the rotId field is set.
			 */
			@java.lang.Override
			public boolean hasRotId() {
				return ((bitField0_ & 0x00000400) != 0);
			}

			/**
			 * <pre>
			 * Optional. May be present in DEVICE certificate types. This is the root
			 * of trust identifier that holds an encrypted value that identifies the
			 * keybox or other root of trust that was used to provision a DEVICE drm
			 * certificate.
			 * </pre>
			 *
			 * <code>optional bytes rot_id = 10;</code>
			 * 
			 * @return The rotId.
			 */
			@java.lang.Override
			public ByteString getRotId() {
				return rotId_;
			}

			/**
			 * <pre>
			 * Optional. May be present in DEVICE certificate types. This is the root
			 * of trust identifier that holds an encrypted value that identifies the
			 * keybox or other root of trust that was used to provision a DEVICE drm
			 * certificate.
			 * </pre>
			 *
			 * <code>optional bytes rot_id = 10;</code>
			 * 
			 * @param value The rotId to set.
			 * @return This builder for chaining.
			 */
			public Builder setRotId(ByteString value) {
				if (value == null) {
					throw new NullPointerException();
				}
				rotId_ = value;
				bitField0_ |= 0x00000400;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Optional. May be present in DEVICE certificate types. This is the root
			 * of trust identifier that holds an encrypted value that identifies the
			 * keybox or other root of trust that was used to provision a DEVICE drm
			 * certificate.
			 * </pre>
			 *
			 * <code>optional bytes rot_id = 10;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearRotId() {
				bitField0_ = (bitField0_ & ~0x00000400);
				rotId_ = getDefaultInstance().getRotId();
				onChanged();
				return this;
			}

			private WvProto2.DrmCertificate.EncryptionKey encryptionKey_;
			private SingleFieldBuilderV3<WvProto2.DrmCertificate.EncryptionKey, WvProto2.DrmCertificate.EncryptionKey.Builder, WvProto2.DrmCertificate.EncryptionKeyOrBuilder> encryptionKeyBuilder_;

			/**
			 * <pre>
			 * Optional. May be present in devices that explicitly support dual keys. When
			 * present the |public_key| is used for verification of received license
			 * request messages.
			 * </pre>
			 *
			 * <code>optional .DrmCertificate.EncryptionKey encryption_key = 11;</code>
			 * 
			 * @return Whether the encryptionKey field is set.
			 */
			@Override
			public boolean hasEncryptionKey() {
				return ((bitField0_ & 0x00000800) != 0);
			}

			/**
			 * <pre>
			 * Optional. May be present in devices that explicitly support dual keys. When
			 * present the |public_key| is used for verification of received license
			 * request messages.
			 * </pre>
			 *
			 * <code>optional .DrmCertificate.EncryptionKey encryption_key = 11;</code>
			 * 
			 * @return The encryptionKey.
			 */
			@Override
			public WvProto2.DrmCertificate.EncryptionKey getEncryptionKey() {
				if (encryptionKeyBuilder_ == null) {
					return encryptionKey_ == null
							? WvProto2.DrmCertificate.EncryptionKey.getDefaultInstance()
							: encryptionKey_;
				}
				return encryptionKeyBuilder_.getMessage();
			}

			/**
			 * <pre>
			 * Optional. May be present in devices that explicitly support dual keys. When
			 * present the |public_key| is used for verification of received license
			 * request messages.
			 * </pre>
			 *
			 * <code>optional .DrmCertificate.EncryptionKey encryption_key = 11;</code>
			 */
			public Builder setEncryptionKey(WvProto2.DrmCertificate.EncryptionKey value) {
				if (encryptionKeyBuilder_ == null) {
					if (value == null) {
						throw new NullPointerException();
					}
					encryptionKey_ = value;
				} else {
					encryptionKeyBuilder_.setMessage(value);
				}
				bitField0_ |= 0x00000800;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Optional. May be present in devices that explicitly support dual keys. When
			 * present the |public_key| is used for verification of received license
			 * request messages.
			 * </pre>
			 *
			 * <code>optional .DrmCertificate.EncryptionKey encryption_key = 11;</code>
			 */
			public Builder setEncryptionKey(
					WvProto2.DrmCertificate.EncryptionKey.Builder builderForValue) {
				if (encryptionKeyBuilder_ == null) {
					encryptionKey_ = builderForValue.build();
				} else {
					encryptionKeyBuilder_.setMessage(builderForValue.build());
				}
				bitField0_ |= 0x00000800;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Optional. May be present in devices that explicitly support dual keys. When
			 * present the |public_key| is used for verification of received license
			 * request messages.
			 * </pre>
			 *
			 * <code>optional .DrmCertificate.EncryptionKey encryption_key = 11;</code>
			 */
			public Builder mergeEncryptionKey(WvProto2.DrmCertificate.EncryptionKey value) {
				if (encryptionKeyBuilder_ == null) {
					if (((bitField0_ & 0x00000800) != 0) && encryptionKey_ != null
							&& encryptionKey_ != WvProto2.DrmCertificate.EncryptionKey
									.getDefaultInstance()) {
						getEncryptionKeyBuilder().mergeFrom(value);
					} else {
						encryptionKey_ = value;
					}
				} else {
					encryptionKeyBuilder_.mergeFrom(value);
				}
				bitField0_ |= 0x00000800;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Optional. May be present in devices that explicitly support dual keys. When
			 * present the |public_key| is used for verification of received license
			 * request messages.
			 * </pre>
			 *
			 * <code>optional .DrmCertificate.EncryptionKey encryption_key = 11;</code>
			 */
			public Builder clearEncryptionKey() {
				bitField0_ = (bitField0_ & ~0x00000800);
				encryptionKey_ = null;
				if (encryptionKeyBuilder_ != null) {
					encryptionKeyBuilder_.dispose();
					encryptionKeyBuilder_ = null;
				}
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Optional. May be present in devices that explicitly support dual keys. When
			 * present the |public_key| is used for verification of received license
			 * request messages.
			 * </pre>
			 *
			 * <code>optional .DrmCertificate.EncryptionKey encryption_key = 11;</code>
			 */
			public WvProto2.DrmCertificate.EncryptionKey.Builder getEncryptionKeyBuilder() {
				bitField0_ |= 0x00000800;
				onChanged();
				return getEncryptionKeyFieldBuilder().getBuilder();
			}

			/**
			 * <pre>
			 * Optional. May be present in devices that explicitly support dual keys. When
			 * present the |public_key| is used for verification of received license
			 * request messages.
			 * </pre>
			 *
			 * <code>optional .DrmCertificate.EncryptionKey encryption_key = 11;</code>
			 */
			@Override
			public WvProto2.DrmCertificate.EncryptionKeyOrBuilder getEncryptionKeyOrBuilder() {
				if (encryptionKeyBuilder_ != null) {
					return encryptionKeyBuilder_.getMessageOrBuilder();
				}
				return encryptionKey_ == null
						? WvProto2.DrmCertificate.EncryptionKey.getDefaultInstance()
						: encryptionKey_;
			}

			/**
			 * <pre>
			 * Optional. May be present in devices that explicitly support dual keys. When
			 * present the |public_key| is used for verification of received license
			 * request messages.
			 * </pre>
			 *
			 * <code>optional .DrmCertificate.EncryptionKey encryption_key = 11;</code>
			 */
			private SingleFieldBuilderV3<WvProto2.DrmCertificate.EncryptionKey, WvProto2.DrmCertificate.EncryptionKey.Builder, WvProto2.DrmCertificate.EncryptionKeyOrBuilder> getEncryptionKeyFieldBuilder() {
				if (encryptionKeyBuilder_ == null) {
					encryptionKeyBuilder_ = new SingleFieldBuilderV3<>(getEncryptionKey(), getParentForChildren(),
							isClean());
					encryptionKey_ = null;
				}
				return encryptionKeyBuilder_;
			}

			@java.lang.Override
			public final Builder setUnknownFields(final UnknownFieldSet unknownFields) {
				return super.setUnknownFields(unknownFields);
			}

			@java.lang.Override
			public final Builder mergeUnknownFields(final UnknownFieldSet unknownFields) {
				return super.mergeUnknownFields(unknownFields);
			}

			// @@protoc_insertion_point(builder_scope:DrmCertificate)
		}

		// @@protoc_insertion_point(class_scope:DrmCertificate)
		private static final WvProto2.DrmCertificate DEFAULT_INSTANCE;
		static {
			DEFAULT_INSTANCE = new WvProto2.DrmCertificate();
		}

		public static WvProto2.DrmCertificate getDefaultInstance() {
			return DEFAULT_INSTANCE;
		}

		@java.lang.Deprecated public static final Parser<DrmCertificate> PARSER = new AbstractParser<>() {
			@java.lang.Override
			public DrmCertificate parsePartialFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
					throws InvalidProtocolBufferException {
				Builder builder = newBuilder();
				try {
					builder.mergeFrom(input, extensionRegistry);
				} catch (InvalidProtocolBufferException e) {
					throw e.setUnfinishedMessage(builder.buildPartial());
				} catch (UninitializedMessageException e) {
					throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
				} catch (java.io.IOException e) {
					throw new InvalidProtocolBufferException(e).setUnfinishedMessage(builder.buildPartial());
				}
				return builder.buildPartial();
			}
		};

		public static Parser<DrmCertificate> parser() {
			return PARSER;
		}

		@java.lang.Override
		public Parser<DrmCertificate> getParserForType() {
			return PARSER;
		}

		@java.lang.Override
		public WvProto2.DrmCertificate getDefaultInstanceForType() {
			return DEFAULT_INSTANCE;
		}

	}

	public interface SignedDrmCertificateOrBuilder extends
			// @@protoc_insertion_point(interface_extends:SignedDrmCertificate)
			MessageOrBuilder {

		/**
		 * <pre>
		 * Serialized certificate. Required.
		 * </pre>
		 *
		 * <code>optional bytes drm_certificate = 1;</code>
		 * 
		 * @return Whether the drmCertificate field is set.
		 */
		boolean hasDrmCertificate();

		/**
		 * <pre>
		 * Serialized certificate. Required.
		 * </pre>
		 *
		 * <code>optional bytes drm_certificate = 1;</code>
		 * 
		 * @return The drmCertificate.
		 */
		ByteString getDrmCertificate();

		/**
		 * <pre>
		 * Signature of certificate. Signed with root or intermediate
		 * certificate specified below. Required.
		 * </pre>
		 *
		 * <code>optional bytes signature = 2;</code>
		 * 
		 * @return Whether the signature field is set.
		 */
		boolean hasSignature();

		/**
		 * <pre>
		 * Signature of certificate. Signed with root or intermediate
		 * certificate specified below. Required.
		 * </pre>
		 *
		 * <code>optional bytes signature = 2;</code>
		 * 
		 * @return The signature.
		 */
		ByteString getSignature();

		/**
		 * <pre>
		 * SignedDrmCertificate used to sign this certificate.
		 * </pre>
		 *
		 * <code>optional .SignedDrmCertificate signer = 3;</code>
		 * 
		 * @return Whether the signer field is set.
		 */
		boolean hasSigner();

		/**
		 * <pre>
		 * SignedDrmCertificate used to sign this certificate.
		 * </pre>
		 *
		 * <code>optional .SignedDrmCertificate signer = 3;</code>
		 * 
		 * @return The signer.
		 */
		WvProto2.SignedDrmCertificate getSigner();

		/**
		 * <pre>
		 * SignedDrmCertificate used to sign this certificate.
		 * </pre>
		 *
		 * <code>optional .SignedDrmCertificate signer = 3;</code>
		 */
		WvProto2.SignedDrmCertificateOrBuilder getSignerOrBuilder();

		/**
		 * <pre>
		 * Optional field that indicates the hash algorithm used in signature scheme.
		 * </pre>
		 *
		 * <code>optional .HashAlgorithmProto hash_algorithm = 4;</code>
		 * 
		 * @return Whether the hashAlgorithm field is set.
		 */
		boolean hasHashAlgorithm();

		/**
		 * <pre>
		 * Optional field that indicates the hash algorithm used in signature scheme.
		 * </pre>
		 *
		 * <code>optional .HashAlgorithmProto hash_algorithm = 4;</code>
		 * 
		 * @return The hashAlgorithm.
		 */
		WvProto2.HashAlgorithmProto getHashAlgorithm();
	}

	/**
	 * <pre>
	 * DrmCertificate signed by a higher (CA) DRM certificate.
	 * </pre>
	 *
	 * Protobuf type {@code SignedDrmCertificate}
	 */
	public static final class SignedDrmCertificate extends GeneratedMessageV3 implements
			// @@protoc_insertion_point(message_implements:SignedDrmCertificate)
			SignedDrmCertificateOrBuilder {
		private static final long serialVersionUID = 0L;

		// Use SignedDrmCertificate.newBuilder() to construct.
		private SignedDrmCertificate(GeneratedMessageV3.Builder<?> builder) {
			super(builder);
		}

		private SignedDrmCertificate() {
			drmCertificate_ = ByteString.EMPTY;
			signature_ = ByteString.EMPTY;
			hashAlgorithm_ = 0;
		}

		@java.lang.Override

		protected java.lang.Object newInstance(UnusedPrivateParameter unused) {
			return new SignedDrmCertificate();
		}

		public static final Descriptors.Descriptor getDescriptor() {
			return WvProto2.internal_static_SignedDrmCertificate_descriptor;
		}

		@java.lang.Override
		protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
			return WvProto2.internal_static_SignedDrmCertificate_fieldAccessorTable
					.ensureFieldAccessorsInitialized(WvProto2.SignedDrmCertificate.class,
							WvProto2.SignedDrmCertificate.Builder.class);
		}

		private int bitField0_;
		public static final int DRM_CERTIFICATE_FIELD_NUMBER = 1;
		private ByteString drmCertificate_ = ByteString.EMPTY;

		/**
		 * <pre>
		 * Serialized certificate. Required.
		 * </pre>
		 *
		 * <code>optional bytes drm_certificate = 1;</code>
		 * 
		 * @return Whether the drmCertificate field is set.
		 */
		@java.lang.Override
		public boolean hasDrmCertificate() {
			return ((bitField0_ & 0x00000001) != 0);
		}

		/**
		 * <pre>
		 * Serialized certificate. Required.
		 * </pre>
		 *
		 * <code>optional bytes drm_certificate = 1;</code>
		 * 
		 * @return The drmCertificate.
		 */
		@java.lang.Override
		public ByteString getDrmCertificate() {
			return drmCertificate_;
		}

		public static final int SIGNATURE_FIELD_NUMBER = 2;
		private ByteString signature_ = ByteString.EMPTY;

		/**
		 * <pre>
		 * Signature of certificate. Signed with root or intermediate
		 * certificate specified below. Required.
		 * </pre>
		 *
		 * <code>optional bytes signature = 2;</code>
		 * 
		 * @return Whether the signature field is set.
		 */
		@java.lang.Override
		public boolean hasSignature() {
			return ((bitField0_ & 0x00000002) != 0);
		}

		/**
		 * <pre>
		 * Signature of certificate. Signed with root or intermediate
		 * certificate specified below. Required.
		 * </pre>
		 *
		 * <code>optional bytes signature = 2;</code>
		 * 
		 * @return The signature.
		 */
		@java.lang.Override
		public ByteString getSignature() {
			return signature_;
		}

		public static final int SIGNER_FIELD_NUMBER = 3;
		private WvProto2.SignedDrmCertificate signer_;

		/**
		 * <pre>
		 * SignedDrmCertificate used to sign this certificate.
		 * </pre>
		 *
		 * <code>optional .SignedDrmCertificate signer = 3;</code>
		 * 
		 * @return Whether the signer field is set.
		 */
		@java.lang.Override
		public boolean hasSigner() {
			return ((bitField0_ & 0x00000004) != 0);
		}

		/**
		 * <pre>
		 * SignedDrmCertificate used to sign this certificate.
		 * </pre>
		 *
		 * <code>optional .SignedDrmCertificate signer = 3;</code>
		 * 
		 * @return The signer.
		 */
		@java.lang.Override
		public WvProto2.SignedDrmCertificate getSigner() {
			return signer_ == null ? WvProto2.SignedDrmCertificate.getDefaultInstance()
					: signer_;
		}

		/**
		 * <pre>
		 * SignedDrmCertificate used to sign this certificate.
		 * </pre>
		 *
		 * <code>optional .SignedDrmCertificate signer = 3;</code>
		 */
		@java.lang.Override
		public WvProto2.SignedDrmCertificateOrBuilder getSignerOrBuilder() {
			return signer_ == null ? WvProto2.SignedDrmCertificate.getDefaultInstance()
					: signer_;
		}

		public static final int HASH_ALGORITHM_FIELD_NUMBER = 4;
		private int hashAlgorithm_ = 0;

		/**
		 * <pre>
		 * Optional field that indicates the hash algorithm used in signature scheme.
		 * </pre>
		 *
		 * <code>optional .HashAlgorithmProto hash_algorithm = 4;</code>
		 * 
		 * @return Whether the hashAlgorithm field is set.
		 */
		@java.lang.Override
		public boolean hasHashAlgorithm() {
			return ((bitField0_ & 0x00000008) != 0);
		}

		/**
		 * <pre>
		 * Optional field that indicates the hash algorithm used in signature scheme.
		 * </pre>
		 *
		 * <code>optional .HashAlgorithmProto hash_algorithm = 4;</code>
		 * 
		 * @return The hashAlgorithm.
		 */
		@java.lang.Override
		public WvProto2.HashAlgorithmProto getHashAlgorithm() {
			WvProto2.HashAlgorithmProto result = WvProto2.HashAlgorithmProto
					.forNumber(hashAlgorithm_);
			return result == null ? WvProto2.HashAlgorithmProto.HASH_ALGORITHM_UNSPECIFIED
					: result;
		}

		private byte memoizedIsInitialized = -1;

		@java.lang.Override
		public final boolean isInitialized() {
			byte isInitialized = memoizedIsInitialized;
			if (isInitialized == 1)
				return true;
			if (isInitialized == 0)
				return false;

			memoizedIsInitialized = 1;
			return true;
		}

		@java.lang.Override
		public void writeTo(CodedOutputStream output) throws java.io.IOException {
			if (((bitField0_ & 0x00000001) != 0)) {
				output.writeBytes(1, drmCertificate_);
			}
			if (((bitField0_ & 0x00000002) != 0)) {
				output.writeBytes(2, signature_);
			}
			if (((bitField0_ & 0x00000004) != 0)) {
				output.writeMessage(3, getSigner());
			}
			if (((bitField0_ & 0x00000008) != 0)) {
				output.writeEnum(4, hashAlgorithm_);
			}
			getUnknownFields().writeTo(output);
		}

		@java.lang.Override
		public int getSerializedSize() {
			int size = memoizedSize;
			if (size != -1)
				return size;

			size = 0;
			if (((bitField0_ & 0x00000001) != 0)) {
				size += CodedOutputStream.computeBytesSize(1, drmCertificate_);
			}
			if (((bitField0_ & 0x00000002) != 0)) {
				size += CodedOutputStream.computeBytesSize(2, signature_);
			}
			if (((bitField0_ & 0x00000004) != 0)) {
				size += CodedOutputStream.computeMessageSize(3, getSigner());
			}
			if (((bitField0_ & 0x00000008) != 0)) {
				size += CodedOutputStream.computeEnumSize(4, hashAlgorithm_);
			}
			size += getUnknownFields().getSerializedSize();
			memoizedSize = size;
			return size;
		}

		@java.lang.Override
		public boolean equals(final java.lang.Object obj) {
			if (obj == this) {
				return true;
			}
			if (!(obj instanceof WvProto2.SignedDrmCertificate)) {
				return super.equals(obj);
			}
			WvProto2.SignedDrmCertificate other = (WvProto2.SignedDrmCertificate) obj;

			if (hasDrmCertificate() != other.hasDrmCertificate())
				return false;
			if (hasDrmCertificate()) {
				if (!getDrmCertificate().equals(other.getDrmCertificate()))
					return false;
			}
			if (hasSignature() != other.hasSignature())
				return false;
			if (hasSignature()) {
				if (!getSignature().equals(other.getSignature()))
					return false;
			}
			if (hasSigner() != other.hasSigner())
				return false;
			if (hasSigner()) {
				if (!getSigner().equals(other.getSigner()))
					return false;
			}
			if (hasHashAlgorithm() != other.hasHashAlgorithm())
				return false;
			if (hasHashAlgorithm()) {
				if (hashAlgorithm_ != other.hashAlgorithm_)
					return false;
			}
			if (!getUnknownFields().equals(other.getUnknownFields()))
				return false;
			return true;
		}

		@SuppressWarnings("unchecked")
		@java.lang.Override
		public int hashCode() {
			if (memoizedHashCode != 0) {
				return memoizedHashCode;
			}
			int hash = 41;
			hash = (19 * hash) + getDescriptor().hashCode();
			if (hasDrmCertificate()) {
				hash = (37 * hash) + DRM_CERTIFICATE_FIELD_NUMBER;
				hash = (53 * hash) + getDrmCertificate().hashCode();
			}
			if (hasSignature()) {
				hash = (37 * hash) + SIGNATURE_FIELD_NUMBER;
				hash = (53 * hash) + getSignature().hashCode();
			}
			if (hasSigner()) {
				hash = (37 * hash) + SIGNER_FIELD_NUMBER;
				hash = (53 * hash) + getSigner().hashCode();
			}
			if (hasHashAlgorithm()) {
				hash = (37 * hash) + HASH_ALGORITHM_FIELD_NUMBER;
				hash = (53 * hash) + hashAlgorithm_;
			}
			hash = (29 * hash) + getUnknownFields().hashCode();
			memoizedHashCode = hash;
			return hash;
		}

		public static WvProto2.SignedDrmCertificate parseFrom(java.nio.ByteBuffer data)
				throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data);
		}

		public static WvProto2.SignedDrmCertificate parseFrom(java.nio.ByteBuffer data,
				ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data, extensionRegistry);
		}

		public static WvProto2.SignedDrmCertificate parseFrom(ByteString data)
				throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data);
		}

		public static WvProto2.SignedDrmCertificate parseFrom(ByteString data,
				ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data, extensionRegistry);
		}

		public static WvProto2.SignedDrmCertificate parseFrom(byte[] data)
				throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data);
		}

		public static WvProto2.SignedDrmCertificate parseFrom(byte[] data,
				ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data, extensionRegistry);
		}

		public static WvProto2.SignedDrmCertificate parseFrom(java.io.InputStream input)
				throws java.io.IOException {
			return GeneratedMessageV3.parseWithIOException(PARSER, input);
		}

		public static WvProto2.SignedDrmCertificate parseFrom(java.io.InputStream input,
				ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
			return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
		}

		public static WvProto2.SignedDrmCertificate parseDelimitedFrom(
				java.io.InputStream input) throws java.io.IOException {
			return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
		}

		public static WvProto2.SignedDrmCertificate parseDelimitedFrom(
				java.io.InputStream input, ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
			return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input, extensionRegistry);
		}

		public static WvProto2.SignedDrmCertificate parseFrom(CodedInputStream input)
				throws java.io.IOException {
			return GeneratedMessageV3.parseWithIOException(PARSER, input);
		}

		public static WvProto2.SignedDrmCertificate parseFrom(CodedInputStream input,
				ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
			return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
		}

		@java.lang.Override
		public Builder newBuilderForType() {
			return newBuilder();
		}

		public static Builder newBuilder() {
			return DEFAULT_INSTANCE.toBuilder();
		}

		public static Builder newBuilder(WvProto2.SignedDrmCertificate prototype) {
			return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
		}

		@java.lang.Override
		public Builder toBuilder() {
			return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
		}

		@java.lang.Override
		protected Builder newBuilderForType(GeneratedMessageV3.BuilderParent parent) {
			Builder builder = new Builder(parent);
			return builder;
		}

		/**
		 * <pre>
		 * DrmCertificate signed by a higher (CA) DRM certificate.
		 * </pre>
		 *
		 * Protobuf type {@code SignedDrmCertificate}
		 */
		public static final class Builder extends GeneratedMessageV3.Builder<Builder> implements
				// @@protoc_insertion_point(builder_implements:SignedDrmCertificate)
				WvProto2.SignedDrmCertificateOrBuilder {
			public static final Descriptors.Descriptor getDescriptor() {
				return WvProto2.internal_static_SignedDrmCertificate_descriptor;
			}

			@java.lang.Override
			protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
				return WvProto2.internal_static_SignedDrmCertificate_fieldAccessorTable
						.ensureFieldAccessorsInitialized(WvProto2.SignedDrmCertificate.class,
								WvProto2.SignedDrmCertificate.Builder.class);
			}

			// Construct using
			// WvProto2.SignedDrmCertificate.newBuilder()
			private Builder() {
				maybeForceBuilderInitialization();
			}

			private Builder(GeneratedMessageV3.BuilderParent parent) {
				super(parent);
				maybeForceBuilderInitialization();
			}

			private void maybeForceBuilderInitialization() {
				if (GeneratedMessageV3.alwaysUseFieldBuilders) {
					getSignerFieldBuilder();
				}
			}

			@java.lang.Override
			public Builder clear() {
				super.clear();
				bitField0_ = 0;
				drmCertificate_ = ByteString.EMPTY;
				signature_ = ByteString.EMPTY;
				signer_ = null;
				if (signerBuilder_ != null) {
					signerBuilder_.dispose();
					signerBuilder_ = null;
				}
				hashAlgorithm_ = 0;
				return this;
			}

			@java.lang.Override
			public Descriptors.Descriptor getDescriptorForType() {
				return WvProto2.internal_static_SignedDrmCertificate_descriptor;
			}

			@java.lang.Override
			public WvProto2.SignedDrmCertificate getDefaultInstanceForType() {
				return WvProto2.SignedDrmCertificate.getDefaultInstance();
			}

			@java.lang.Override
			public WvProto2.SignedDrmCertificate build() {
				WvProto2.SignedDrmCertificate result = buildPartial();
				if (!result.isInitialized()) {
					throw newUninitializedMessageException(result);
				}
				return result;
			}

			@java.lang.Override
			public WvProto2.SignedDrmCertificate buildPartial() {
				WvProto2.SignedDrmCertificate result = new WvProto2.SignedDrmCertificate(
						this);
				if (bitField0_ != 0) {
					buildPartial0(result);
				}
				onBuilt();
				return result;
			}

			private void buildPartial0(WvProto2.SignedDrmCertificate result) {
				int from_bitField0_ = bitField0_;
				int to_bitField0_ = 0;
				if (((from_bitField0_ & 0x00000001) != 0)) {
					result.drmCertificate_ = drmCertificate_;
					to_bitField0_ |= 0x00000001;
				}
				if (((from_bitField0_ & 0x00000002) != 0)) {
					result.signature_ = signature_;
					to_bitField0_ |= 0x00000002;
				}
				if (((from_bitField0_ & 0x00000004) != 0)) {
					result.signer_ = signerBuilder_ == null ? signer_ : signerBuilder_.build();
					to_bitField0_ |= 0x00000004;
				}
				if (((from_bitField0_ & 0x00000008) != 0)) {
					result.hashAlgorithm_ = hashAlgorithm_;
					to_bitField0_ |= 0x00000008;
				}
				result.bitField0_ |= to_bitField0_;
			}

			@java.lang.Override
			public Builder mergeFrom(Message other) {
				if (other instanceof WvProto2.SignedDrmCertificate) {
					return mergeFrom((WvProto2.SignedDrmCertificate) other);
				}
				super.mergeFrom(other);
				return this;
			}

			public Builder mergeFrom(WvProto2.SignedDrmCertificate other) {
				if (other == WvProto2.SignedDrmCertificate.getDefaultInstance())
					return this;
				if (other.hasDrmCertificate()) {
					setDrmCertificate(other.getDrmCertificate());
				}
				if (other.hasSignature()) {
					setSignature(other.getSignature());
				}
				if (other.hasSigner()) {
					mergeSigner(other.getSigner());
				}
				if (other.hasHashAlgorithm()) {
					setHashAlgorithm(other.getHashAlgorithm());
				}
				this.mergeUnknownFields(other.getUnknownFields());
				onChanged();
				return this;
			}

			@java.lang.Override
			public final boolean isInitialized() {
				return true;
			}

			@java.lang.Override
			public Builder mergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
					throws java.io.IOException {
				if (extensionRegistry == null) {
					throw new java.lang.NullPointerException();
				}
				try {
					boolean done = false;
					while (!done) {
						int tag = input.readTag();
						switch (tag) {
						case 0:
							done = true;
							break;
						case 10: {
							drmCertificate_ = input.readBytes();
							bitField0_ |= 0x00000001;
							break;
						} // case 10
						case 18: {
							signature_ = input.readBytes();
							bitField0_ |= 0x00000002;
							break;
						} // case 18
						case 26: {
							input.readMessage(getSignerFieldBuilder().getBuilder(), extensionRegistry);
							bitField0_ |= 0x00000004;
							break;
						} // case 26
						case 32: {
							int tmpRaw = input.readEnum();
							WvProto2.HashAlgorithmProto tmpValue = WvProto2.HashAlgorithmProto
									.forNumber(tmpRaw);
							if (tmpValue == null) {
								mergeUnknownVarintField(4, tmpRaw);
							} else {
								hashAlgorithm_ = tmpRaw;
								bitField0_ |= 0x00000008;
							}
							break;
						} // case 32
						default: {
							if (!super.parseUnknownField(input, extensionRegistry, tag)) {
								done = true; // was an endgroup tag
							}
							break;
						} // default:
						} // switch (tag)
					} // while (!done)
				} catch (InvalidProtocolBufferException e) {
					throw e.unwrapIOException();
				}
				finally {
					onChanged();
				} // finally
				return this;
			}

			private int bitField0_;

			private ByteString drmCertificate_ = ByteString.EMPTY;

			/**
			 * <pre>
			 * Serialized certificate. Required.
			 * </pre>
			 *
			 * <code>optional bytes drm_certificate = 1;</code>
			 * 
			 * @return Whether the drmCertificate field is set.
			 */
			@java.lang.Override
			public boolean hasDrmCertificate() {
				return ((bitField0_ & 0x00000001) != 0);
			}

			/**
			 * <pre>
			 * Serialized certificate. Required.
			 * </pre>
			 *
			 * <code>optional bytes drm_certificate = 1;</code>
			 * 
			 * @return The drmCertificate.
			 */
			@java.lang.Override
			public ByteString getDrmCertificate() {
				return drmCertificate_;
			}

			/**
			 * <pre>
			 * Serialized certificate. Required.
			 * </pre>
			 *
			 * <code>optional bytes drm_certificate = 1;</code>
			 * 
			 * @param value The drmCertificate to set.
			 * @return This builder for chaining.
			 */
			public Builder setDrmCertificate(ByteString value) {
				if (value == null) {
					throw new NullPointerException();
				}
				drmCertificate_ = value;
				bitField0_ |= 0x00000001;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Serialized certificate. Required.
			 * </pre>
			 *
			 * <code>optional bytes drm_certificate = 1;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearDrmCertificate() {
				bitField0_ = (bitField0_ & ~0x00000001);
				drmCertificate_ = getDefaultInstance().getDrmCertificate();
				onChanged();
				return this;
			}

			private ByteString signature_ = ByteString.EMPTY;

			/**
			 * <pre>
			 * Signature of certificate. Signed with root or intermediate
			 * certificate specified below. Required.
			 * </pre>
			 *
			 * <code>optional bytes signature = 2;</code>
			 * 
			 * @return Whether the signature field is set.
			 */
			@java.lang.Override
			public boolean hasSignature() {
				return ((bitField0_ & 0x00000002) != 0);
			}

			/**
			 * <pre>
			 * Signature of certificate. Signed with root or intermediate
			 * certificate specified below. Required.
			 * </pre>
			 *
			 * <code>optional bytes signature = 2;</code>
			 * 
			 * @return The signature.
			 */
			@java.lang.Override
			public ByteString getSignature() {
				return signature_;
			}

			/**
			 * <pre>
			 * Signature of certificate. Signed with root or intermediate
			 * certificate specified below. Required.
			 * </pre>
			 *
			 * <code>optional bytes signature = 2;</code>
			 * 
			 * @param value The signature to set.
			 * @return This builder for chaining.
			 */
			public Builder setSignature(ByteString value) {
				if (value == null) {
					throw new NullPointerException();
				}
				signature_ = value;
				bitField0_ |= 0x00000002;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Signature of certificate. Signed with root or intermediate
			 * certificate specified below. Required.
			 * </pre>
			 *
			 * <code>optional bytes signature = 2;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearSignature() {
				bitField0_ = (bitField0_ & ~0x00000002);
				signature_ = getDefaultInstance().getSignature();
				onChanged();
				return this;
			}

			private WvProto2.SignedDrmCertificate signer_;
			private SingleFieldBuilderV3<WvProto2.SignedDrmCertificate, WvProto2.SignedDrmCertificate.Builder, WvProto2.SignedDrmCertificateOrBuilder> signerBuilder_;

			/**
			 * <pre>
			 * SignedDrmCertificate used to sign this certificate.
			 * </pre>
			 *
			 * <code>optional .SignedDrmCertificate signer = 3;</code>
			 * 
			 * @return Whether the signer field is set.
			 */
			@Override
			public boolean hasSigner() {
				return ((bitField0_ & 0x00000004) != 0);
			}

			/**
			 * <pre>
			 * SignedDrmCertificate used to sign this certificate.
			 * </pre>
			 *
			 * <code>optional .SignedDrmCertificate signer = 3;</code>
			 * 
			 * @return The signer.
			 */
			@Override
			public WvProto2.SignedDrmCertificate getSigner() {
				if (signerBuilder_ == null) {
					return signer_ == null ? WvProto2.SignedDrmCertificate.getDefaultInstance()
							: signer_;
				}
				return signerBuilder_.getMessage();
			}

			/**
			 * <pre>
			 * SignedDrmCertificate used to sign this certificate.
			 * </pre>
			 *
			 * <code>optional .SignedDrmCertificate signer = 3;</code>
			 */
			public Builder setSigner(WvProto2.SignedDrmCertificate value) {
				if (signerBuilder_ == null) {
					if (value == null) {
						throw new NullPointerException();
					}
					signer_ = value;
				} else {
					signerBuilder_.setMessage(value);
				}
				bitField0_ |= 0x00000004;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * SignedDrmCertificate used to sign this certificate.
			 * </pre>
			 *
			 * <code>optional .SignedDrmCertificate signer = 3;</code>
			 */
			public Builder setSigner(WvProto2.SignedDrmCertificate.Builder builderForValue) {
				if (signerBuilder_ == null) {
					signer_ = builderForValue.build();
				} else {
					signerBuilder_.setMessage(builderForValue.build());
				}
				bitField0_ |= 0x00000004;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * SignedDrmCertificate used to sign this certificate.
			 * </pre>
			 *
			 * <code>optional .SignedDrmCertificate signer = 3;</code>
			 */
			public Builder mergeSigner(WvProto2.SignedDrmCertificate value) {
				if (signerBuilder_ == null) {
					if (((bitField0_ & 0x00000004) != 0) && signer_ != null
							&& signer_ != WvProto2.SignedDrmCertificate.getDefaultInstance()) {
						getSignerBuilder().mergeFrom(value);
					} else {
						signer_ = value;
					}
				} else {
					signerBuilder_.mergeFrom(value);
				}
				bitField0_ |= 0x00000004;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * SignedDrmCertificate used to sign this certificate.
			 * </pre>
			 *
			 * <code>optional .SignedDrmCertificate signer = 3;</code>
			 */
			public Builder clearSigner() {
				bitField0_ = (bitField0_ & ~0x00000004);
				signer_ = null;
				if (signerBuilder_ != null) {
					signerBuilder_.dispose();
					signerBuilder_ = null;
				}
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * SignedDrmCertificate used to sign this certificate.
			 * </pre>
			 *
			 * <code>optional .SignedDrmCertificate signer = 3;</code>
			 */
			public WvProto2.SignedDrmCertificate.Builder getSignerBuilder() {
				bitField0_ |= 0x00000004;
				onChanged();
				return getSignerFieldBuilder().getBuilder();
			}

			/**
			 * <pre>
			 * SignedDrmCertificate used to sign this certificate.
			 * </pre>
			 *
			 * <code>optional .SignedDrmCertificate signer = 3;</code>
			 */
			@Override
			public WvProto2.SignedDrmCertificateOrBuilder getSignerOrBuilder() {
				if (signerBuilder_ != null) {
					return signerBuilder_.getMessageOrBuilder();
				}
				return signer_ == null ? WvProto2.SignedDrmCertificate.getDefaultInstance()
						: signer_;
			}

			/**
			 * <pre>
			 * SignedDrmCertificate used to sign this certificate.
			 * </pre>
			 *
			 * <code>optional .SignedDrmCertificate signer = 3;</code>
			 */
			private SingleFieldBuilderV3<WvProto2.SignedDrmCertificate, WvProto2.SignedDrmCertificate.Builder, WvProto2.SignedDrmCertificateOrBuilder> getSignerFieldBuilder() {
				if (signerBuilder_ == null) {
					signerBuilder_ = new SingleFieldBuilderV3<>(getSigner(), getParentForChildren(), isClean());
					signer_ = null;
				}
				return signerBuilder_;
			}

			private int hashAlgorithm_ = 0;

			/**
			 * <pre>
			 * Optional field that indicates the hash algorithm used in signature scheme.
			 * </pre>
			 *
			 * <code>optional .HashAlgorithmProto hash_algorithm = 4;</code>
			 * 
			 * @return Whether the hashAlgorithm field is set.
			 */
			@java.lang.Override
			public boolean hasHashAlgorithm() {
				return ((bitField0_ & 0x00000008) != 0);
			}

			/**
			 * <pre>
			 * Optional field that indicates the hash algorithm used in signature scheme.
			 * </pre>
			 *
			 * <code>optional .HashAlgorithmProto hash_algorithm = 4;</code>
			 * 
			 * @return The hashAlgorithm.
			 */
			@java.lang.Override
			public WvProto2.HashAlgorithmProto getHashAlgorithm() {
				WvProto2.HashAlgorithmProto result = WvProto2.HashAlgorithmProto
						.forNumber(hashAlgorithm_);
				return result == null ? WvProto2.HashAlgorithmProto.HASH_ALGORITHM_UNSPECIFIED
						: result;
			}

			/**
			 * <pre>
			 * Optional field that indicates the hash algorithm used in signature scheme.
			 * </pre>
			 *
			 * <code>optional .HashAlgorithmProto hash_algorithm = 4;</code>
			 * 
			 * @param value The hashAlgorithm to set.
			 * @return This builder for chaining.
			 */
			public Builder setHashAlgorithm(WvProto2.HashAlgorithmProto value) {
				if (value == null) {
					throw new NullPointerException();
				}
				bitField0_ |= 0x00000008;
				hashAlgorithm_ = value.getNumber();
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Optional field that indicates the hash algorithm used in signature scheme.
			 * </pre>
			 *
			 * <code>optional .HashAlgorithmProto hash_algorithm = 4;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearHashAlgorithm() {
				bitField0_ = (bitField0_ & ~0x00000008);
				hashAlgorithm_ = 0;
				onChanged();
				return this;
			}

			@java.lang.Override
			public final Builder setUnknownFields(final UnknownFieldSet unknownFields) {
				return super.setUnknownFields(unknownFields);
			}

			@java.lang.Override
			public final Builder mergeUnknownFields(final UnknownFieldSet unknownFields) {
				return super.mergeUnknownFields(unknownFields);
			}

			// @@protoc_insertion_point(builder_scope:SignedDrmCertificate)
		}

		// @@protoc_insertion_point(class_scope:SignedDrmCertificate)
		private static final WvProto2.SignedDrmCertificate DEFAULT_INSTANCE;
		static {
			DEFAULT_INSTANCE = new WvProto2.SignedDrmCertificate();
		}

		public static WvProto2.SignedDrmCertificate getDefaultInstance() {
			return DEFAULT_INSTANCE;
		}

		@java.lang.Deprecated public static final Parser<SignedDrmCertificate> PARSER = new AbstractParser<>() {
			@java.lang.Override
			public SignedDrmCertificate parsePartialFrom(CodedInputStream input,
					ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
				Builder builder = newBuilder();
				try {
					builder.mergeFrom(input, extensionRegistry);
				} catch (InvalidProtocolBufferException e) {
					throw e.setUnfinishedMessage(builder.buildPartial());
				} catch (UninitializedMessageException e) {
					throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
				} catch (java.io.IOException e) {
					throw new InvalidProtocolBufferException(e).setUnfinishedMessage(builder.buildPartial());
				}
				return builder.buildPartial();
			}
		};

		public static Parser<SignedDrmCertificate> parser() {
			return PARSER;
		}

		@java.lang.Override
		public Parser<SignedDrmCertificate> getParserForType() {
			return PARSER;
		}

		@java.lang.Override
		public WvProto2.SignedDrmCertificate getDefaultInstanceForType() {
			return DEFAULT_INSTANCE;
		}

	}

	public interface WidevinePsshDataOrBuilder extends
			// @@protoc_insertion_point(interface_extends:WidevinePsshData)
			MessageOrBuilder {

		/**
		 * <pre>
		 * Entitlement or content key IDs. Can onnly present in SINGLE or ENTITLEMENT
		 * PSSHs. May be repeated to facilitate delivery of multiple keys in a
		 * single license. Cannot be used in conjunction with content_id or
		 * group_ids, which are the preferred mechanism.
		 * </pre>
		 *
		 * <code>repeated bytes key_ids = 2;</code>
		 * 
		 * @return A list containing the keyIds.
		 */
		java.util.List<ByteString> getKeyIdsList();

		/**
		 * <pre>
		 * Entitlement or content key IDs. Can onnly present in SINGLE or ENTITLEMENT
		 * PSSHs. May be repeated to facilitate delivery of multiple keys in a
		 * single license. Cannot be used in conjunction with content_id or
		 * group_ids, which are the preferred mechanism.
		 * </pre>
		 *
		 * <code>repeated bytes key_ids = 2;</code>
		 * 
		 * @return The count of keyIds.
		 */
		int getKeyIdsCount();

		/**
		 * <pre>
		 * Entitlement or content key IDs. Can onnly present in SINGLE or ENTITLEMENT
		 * PSSHs. May be repeated to facilitate delivery of multiple keys in a
		 * single license. Cannot be used in conjunction with content_id or
		 * group_ids, which are the preferred mechanism.
		 * </pre>
		 *
		 * <code>repeated bytes key_ids = 2;</code>
		 * 
		 * @param index The index of the element to return.
		 * @return The keyIds at the given index.
		 */
		ByteString getKeyIds(int index);

		/**
		 * <pre>
		 * Content identifier which may map to multiple entitlement or content key
		 * IDs to facilitate the delivery of multiple keys in a single license.
		 * Cannot be present in conjunction with key_ids, but if used must be in all
		 * PSSHs.
		 * </pre>
		 *
		 * <code>optional bytes content_id = 4;</code>
		 * 
		 * @return Whether the contentId field is set.
		 */
		boolean hasContentId();

		/**
		 * <pre>
		 * Content identifier which may map to multiple entitlement or content key
		 * IDs to facilitate the delivery of multiple keys in a single license.
		 * Cannot be present in conjunction with key_ids, but if used must be in all
		 * PSSHs.
		 * </pre>
		 *
		 * <code>optional bytes content_id = 4;</code>
		 * 
		 * @return The contentId.
		 */
		ByteString getContentId();

		/**
		 * <pre>
		 * Crypto period index, for media using key rotation. Always corresponds to
		 * The content key period. This means that if using entitlement licensing
		 * the ENTITLED_KEY PSSHs will have sequential crypto_period_index's, whereas
		 * the ENTITELEMENT PSSHs will have gaps in the sequence. Required if doing
		 * key rotation.
		 * </pre>
		 *
		 * <code>optional uint32 crypto_period_index = 7;</code>
		 * 
		 * @return Whether the cryptoPeriodIndex field is set.
		 */
		boolean hasCryptoPeriodIndex();

		/**
		 * <pre>
		 * Crypto period index, for media using key rotation. Always corresponds to
		 * The content key period. This means that if using entitlement licensing
		 * the ENTITLED_KEY PSSHs will have sequential crypto_period_index's, whereas
		 * the ENTITELEMENT PSSHs will have gaps in the sequence. Required if doing
		 * key rotation.
		 * </pre>
		 *
		 * <code>optional uint32 crypto_period_index = 7;</code>
		 * 
		 * @return The cryptoPeriodIndex.
		 */
		int getCryptoPeriodIndex();

		/**
		 * <pre>
		 * Protection scheme identifying the encryption algorithm. The protection
		 * scheme is represented as a uint32 value. The uint32 contains 4 bytes each
		 * representing a single ascii character in one of the 4CC protection scheme
		 * values. To be deprecated in favor of signaling from content.
		 * 'cenc' (AES-CTR) protection_scheme = 0x63656E63,
		 * 'cbc1' (AES-CBC) protection_scheme = 0x63626331,
		 * 'cens' (AES-CTR pattern encryption) protection_scheme = 0x63656E73,
		 * 'cbcs' (AES-CBC pattern encryption) protection_scheme = 0x63626373.
		 * </pre>
		 *
		 * <code>optional uint32 protection_scheme = 9;</code>
		 * 
		 * @return Whether the protectionScheme field is set.
		 */
		boolean hasProtectionScheme();

		/**
		 * <pre>
		 * Protection scheme identifying the encryption algorithm. The protection
		 * scheme is represented as a uint32 value. The uint32 contains 4 bytes each
		 * representing a single ascii character in one of the 4CC protection scheme
		 * values. To be deprecated in favor of signaling from content.
		 * 'cenc' (AES-CTR) protection_scheme = 0x63656E63,
		 * 'cbc1' (AES-CBC) protection_scheme = 0x63626331,
		 * 'cens' (AES-CTR pattern encryption) protection_scheme = 0x63656E73,
		 * 'cbcs' (AES-CBC pattern encryption) protection_scheme = 0x63626373.
		 * </pre>
		 *
		 * <code>optional uint32 protection_scheme = 9;</code>
		 * 
		 * @return The protectionScheme.
		 */
		int getProtectionScheme();

		/**
		 * <pre>
		 * Optional. For media using key rotation, this represents the duration
		 * of each crypto period in seconds.
		 * </pre>
		 *
		 * <code>optional uint32 crypto_period_seconds = 10;</code>
		 * 
		 * @return Whether the cryptoPeriodSeconds field is set.
		 */
		boolean hasCryptoPeriodSeconds();

		/**
		 * <pre>
		 * Optional. For media using key rotation, this represents the duration
		 * of each crypto period in seconds.
		 * </pre>
		 *
		 * <code>optional uint32 crypto_period_seconds = 10;</code>
		 * 
		 * @return The cryptoPeriodSeconds.
		 */
		int getCryptoPeriodSeconds();

		/**
		 * <pre>
		 * Type of PSSH. Required if not SINGLE.
		 * </pre>
		 *
		 * <code>optional .WidevinePsshData.Type type = 11 [default = SINGLE];</code>
		 * 
		 * @return Whether the type field is set.
		 */
		boolean hasType();

		/**
		 * <pre>
		 * Type of PSSH. Required if not SINGLE.
		 * </pre>
		 *
		 * <code>optional .WidevinePsshData.Type type = 11 [default = SINGLE];</code>
		 * 
		 * @return The type.
		 */
		WvProto2.WidevinePsshData.Type getType();

		/**
		 * <pre>
		 * Key sequence for Widevine-managed keys. Optional.
		 * </pre>
		 *
		 * <code>optional uint32 key_sequence = 12;</code>
		 * 
		 * @return Whether the keySequence field is set.
		 */
		boolean hasKeySequence();

		/**
		 * <pre>
		 * Key sequence for Widevine-managed keys. Optional.
		 * </pre>
		 *
		 * <code>optional uint32 key_sequence = 12;</code>
		 * 
		 * @return The keySequence.
		 */
		int getKeySequence();

		/**
		 * <pre>
		 * Group identifiers for all groups to which the content belongs. This can
		 * be used to deliver licenses to unlock multiple titles / channels.
		 * Optional, and may only be present in ENTITLEMENT and ENTITLED_KEY PSSHs, and
		 * not in conjunction with key_ids.
		 * </pre>
		 *
		 * <code>repeated bytes group_ids = 13;</code>
		 * 
		 * @return A list containing the groupIds.
		 */
		java.util.List<ByteString> getGroupIdsList();

		/**
		 * <pre>
		 * Group identifiers for all groups to which the content belongs. This can
		 * be used to deliver licenses to unlock multiple titles / channels.
		 * Optional, and may only be present in ENTITLEMENT and ENTITLED_KEY PSSHs, and
		 * not in conjunction with key_ids.
		 * </pre>
		 *
		 * <code>repeated bytes group_ids = 13;</code>
		 * 
		 * @return The count of groupIds.
		 */
		int getGroupIdsCount();

		/**
		 * <pre>
		 * Group identifiers for all groups to which the content belongs. This can
		 * be used to deliver licenses to unlock multiple titles / channels.
		 * Optional, and may only be present in ENTITLEMENT and ENTITLED_KEY PSSHs, and
		 * not in conjunction with key_ids.
		 * </pre>
		 *
		 * <code>repeated bytes group_ids = 13;</code>
		 * 
		 * @param index The index of the element to return.
		 * @return The groupIds at the given index.
		 */
		ByteString getGroupIds(int index);

		/**
		 * <pre>
		 * Copy/copies of the content key used to decrypt the media stream in which
		 * the PSSH box is embedded, each wrapped with a different entitlement key.
		 * May also contain sub-licenses to support devices with OEMCrypto 13 or
		 * older. May be repeated if using group entitlement keys. Present only in
		 * PSSHs of type ENTITLED_KEY.
		 * </pre>
		 *
		 * <code>repeated .WidevinePsshData.EntitledKey entitled_keys = 14;</code>
		 */
		java.util.List<WvProto2.WidevinePsshData.EntitledKey> getEntitledKeysList();

		/**
		 * <pre>
		 * Copy/copies of the content key used to decrypt the media stream in which
		 * the PSSH box is embedded, each wrapped with a different entitlement key.
		 * May also contain sub-licenses to support devices with OEMCrypto 13 or
		 * older. May be repeated if using group entitlement keys. Present only in
		 * PSSHs of type ENTITLED_KEY.
		 * </pre>
		 *
		 * <code>repeated .WidevinePsshData.EntitledKey entitled_keys = 14;</code>
		 */
		WvProto2.WidevinePsshData.EntitledKey getEntitledKeys(int index);

		/**
		 * <pre>
		 * Copy/copies of the content key used to decrypt the media stream in which
		 * the PSSH box is embedded, each wrapped with a different entitlement key.
		 * May also contain sub-licenses to support devices with OEMCrypto 13 or
		 * older. May be repeated if using group entitlement keys. Present only in
		 * PSSHs of type ENTITLED_KEY.
		 * </pre>
		 *
		 * <code>repeated .WidevinePsshData.EntitledKey entitled_keys = 14;</code>
		 */
		int getEntitledKeysCount();

		/**
		 * <pre>
		 * Copy/copies of the content key used to decrypt the media stream in which
		 * the PSSH box is embedded, each wrapped with a different entitlement key.
		 * May also contain sub-licenses to support devices with OEMCrypto 13 or
		 * older. May be repeated if using group entitlement keys. Present only in
		 * PSSHs of type ENTITLED_KEY.
		 * </pre>
		 *
		 * <code>repeated .WidevinePsshData.EntitledKey entitled_keys = 14;</code>
		 */
		java.util.List<? extends WvProto2.WidevinePsshData.EntitledKeyOrBuilder> getEntitledKeysOrBuilderList();

		/**
		 * <pre>
		 * Copy/copies of the content key used to decrypt the media stream in which
		 * the PSSH box is embedded, each wrapped with a different entitlement key.
		 * May also contain sub-licenses to support devices with OEMCrypto 13 or
		 * older. May be repeated if using group entitlement keys. Present only in
		 * PSSHs of type ENTITLED_KEY.
		 * </pre>
		 *
		 * <code>repeated .WidevinePsshData.EntitledKey entitled_keys = 14;</code>
		 */
		WvProto2.WidevinePsshData.EntitledKeyOrBuilder getEntitledKeysOrBuilder(int index);

		/**
		 * <pre>
		 * Video feature identifier, which is used in conjunction with |content_id|
		 * to determine the set of keys to be returned in the license. Cannot be
		 * present in conjunction with |key_ids|.
		 * Current values are "HDR".
		 * </pre>
		 *
		 * <code>optional string video_feature = 15;</code>
		 * 
		 * @return Whether the videoFeature field is set.
		 */
		boolean hasVideoFeature();

		/**
		 * <pre>
		 * Video feature identifier, which is used in conjunction with |content_id|
		 * to determine the set of keys to be returned in the license. Cannot be
		 * present in conjunction with |key_ids|.
		 * Current values are "HDR".
		 * </pre>
		 *
		 * <code>optional string video_feature = 15;</code>
		 * 
		 * @return The videoFeature.
		 */
		java.lang.String getVideoFeature();

		/**
		 * <pre>
		 * Video feature identifier, which is used in conjunction with |content_id|
		 * to determine the set of keys to be returned in the license. Cannot be
		 * present in conjunction with |key_ids|.
		 * Current values are "HDR".
		 * </pre>
		 *
		 * <code>optional string video_feature = 15;</code>
		 * 
		 * @return The bytes for videoFeature.
		 */
		ByteString getVideoFeatureBytes();

		/**
		 * <code>optional .WidevinePsshData.Algorithm algorithm = 1 [deprecated = true];</code>
		 * 
		 * @deprecated WidevinePsshData.algorithm is deprecated. See
		 *             wv_proto2.proto;l=720
		 * @return Whether the algorithm field is set.
		 */
		@java.lang.Deprecated
		boolean hasAlgorithm();

		/**
		 * <code>optional .WidevinePsshData.Algorithm algorithm = 1 [deprecated = true];</code>
		 * 
		 * @deprecated WidevinePsshData.algorithm is deprecated. See
		 *             wv_proto2.proto;l=720
		 * @return The algorithm.
		 */
		@java.lang.Deprecated
		WvProto2.WidevinePsshData.Algorithm getAlgorithm();

		/**
		 * <pre>
		 * Content provider name.
		 * </pre>
		 *
		 * <code>optional string provider = 3 [deprecated = true];</code>
		 * 
		 * @deprecated WidevinePsshData.provider is deprecated. See
		 *             wv_proto2.proto;l=723
		 * @return Whether the provider field is set.
		 */
		@java.lang.Deprecated
		boolean hasProvider();

		/**
		 * <pre>
		 * Content provider name.
		 * </pre>
		 *
		 * <code>optional string provider = 3 [deprecated = true];</code>
		 * 
		 * @deprecated WidevinePsshData.provider is deprecated. See
		 *             wv_proto2.proto;l=723
		 * @return The provider.
		 */
		@java.lang.Deprecated
		java.lang.String getProvider();

		/**
		 * <pre>
		 * Content provider name.
		 * </pre>
		 *
		 * <code>optional string provider = 3 [deprecated = true];</code>
		 * 
		 * @deprecated WidevinePsshData.provider is deprecated. See
		 *             wv_proto2.proto;l=723
		 * @return The bytes for provider.
		 */
		@java.lang.Deprecated
		ByteString getProviderBytes();

		/**
		 * <pre>
		 * Track type. Acceptable values are SD, HD and AUDIO. Used to
		 * differentiate content keys used by an asset.
		 * </pre>
		 *
		 * <code>optional string track_type = 5 [deprecated = true];</code>
		 * 
		 * @deprecated WidevinePsshData.track_type is deprecated. See
		 *             wv_proto2.proto;l=727
		 * @return Whether the trackType field is set.
		 */
		@java.lang.Deprecated
		boolean hasTrackType();

		/**
		 * <pre>
		 * Track type. Acceptable values are SD, HD and AUDIO. Used to
		 * differentiate content keys used by an asset.
		 * </pre>
		 *
		 * <code>optional string track_type = 5 [deprecated = true];</code>
		 * 
		 * @deprecated WidevinePsshData.track_type is deprecated. See
		 *             wv_proto2.proto;l=727
		 * @return The trackType.
		 */
		@java.lang.Deprecated
		java.lang.String getTrackType();

		/**
		 * <pre>
		 * Track type. Acceptable values are SD, HD and AUDIO. Used to
		 * differentiate content keys used by an asset.
		 * </pre>
		 *
		 * <code>optional string track_type = 5 [deprecated = true];</code>
		 * 
		 * @deprecated WidevinePsshData.track_type is deprecated. See
		 *             wv_proto2.proto;l=727
		 * @return The bytes for trackType.
		 */
		@java.lang.Deprecated
		ByteString getTrackTypeBytes();

		/**
		 * <pre>
		 * The name of a registered policy to be used for this asset.
		 * </pre>
		 *
		 * <code>optional string policy = 6 [deprecated = true];</code>
		 * 
		 * @deprecated WidevinePsshData.policy is deprecated. See wv_proto2.proto;l=730
		 * @return Whether the policy field is set.
		 */
		@java.lang.Deprecated
		boolean hasPolicy();

		/**
		 * <pre>
		 * The name of a registered policy to be used for this asset.
		 * </pre>
		 *
		 * <code>optional string policy = 6 [deprecated = true];</code>
		 * 
		 * @deprecated WidevinePsshData.policy is deprecated. See wv_proto2.proto;l=730
		 * @return The policy.
		 */
		@java.lang.Deprecated
		java.lang.String getPolicy();

		/**
		 * <pre>
		 * The name of a registered policy to be used for this asset.
		 * </pre>
		 *
		 * <code>optional string policy = 6 [deprecated = true];</code>
		 * 
		 * @deprecated WidevinePsshData.policy is deprecated. See wv_proto2.proto;l=730
		 * @return The bytes for policy.
		 */
		@java.lang.Deprecated
		ByteString getPolicyBytes();

		/**
		 * <pre>
		 * Optional protected context for group content. The grouped_license is a
		 * serialized SignedMessage.
		 * </pre>
		 *
		 * <code>optional bytes grouped_license = 8 [deprecated = true];</code>
		 * 
		 * @deprecated WidevinePsshData.grouped_license is deprecated. See
		 *             wv_proto2.proto;l=734
		 * @return Whether the groupedLicense field is set.
		 */
		@java.lang.Deprecated
		boolean hasGroupedLicense();

		/**
		 * <pre>
		 * Optional protected context for group content. The grouped_license is a
		 * serialized SignedMessage.
		 * </pre>
		 *
		 * <code>optional bytes grouped_license = 8 [deprecated = true];</code>
		 * 
		 * @deprecated WidevinePsshData.grouped_license is deprecated. See
		 *             wv_proto2.proto;l=734
		 * @return The groupedLicense.
		 */
		@java.lang.Deprecated
		ByteString getGroupedLicense();
	}

	/**
	 * Protobuf type {@code WidevinePsshData}
	 */
	public static final class WidevinePsshData extends GeneratedMessageV3 implements
			// @@protoc_insertion_point(message_implements:WidevinePsshData)
			WidevinePsshDataOrBuilder {
		private static final long serialVersionUID = 0L;

		// Use WidevinePsshData.newBuilder() to construct.
		private WidevinePsshData(GeneratedMessageV3.Builder<?> builder) {
			super(builder);
		}

		private WidevinePsshData() {
			keyIds_ = java.util.Collections.emptyList();
			contentId_ = ByteString.EMPTY;
			type_ = 0;
			groupIds_ = java.util.Collections.emptyList();
			entitledKeys_ = java.util.Collections.emptyList();
			videoFeature_ = "";
			algorithm_ = 0;
			provider_ = "";
			trackType_ = "";
			policy_ = "";
			groupedLicense_ = ByteString.EMPTY;
		}

		@java.lang.Override

		protected java.lang.Object newInstance(UnusedPrivateParameter unused) {
			return new WidevinePsshData();
		}

		public static final Descriptors.Descriptor getDescriptor() {
			return WvProto2.internal_static_WidevinePsshData_descriptor;
		}

		@java.lang.Override
		protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
			return WvProto2.internal_static_WidevinePsshData_fieldAccessorTable
					.ensureFieldAccessorsInitialized(WvProto2.WidevinePsshData.class,
							WvProto2.WidevinePsshData.Builder.class);
		}

		/**
		 * Protobuf enum {@code WidevinePsshData.Type}
		 */
		public enum Type implements ProtocolMessageEnum {
			/**
			 * <pre>
			 * Single PSSH to be used to retrieve content keys.
			 * </pre>
			 *
			 * <code>SINGLE = 0;</code>
			 */
			SINGLE(0),
			/**
			 * <pre>
			 * Primary PSSH used to retrieve entitlement keys.
			 * </pre>
			 *
			 * <code>ENTITLEMENT = 1;</code>
			 */
			ENTITLEMENT(1),
			/**
			 * <pre>
			 * Secondary PSSH containing entitled key(s).
			 * </pre>
			 *
			 * <code>ENTITLED_KEY = 2;</code>
			 */
			ENTITLED_KEY(2),;

			/**
			 * <pre>
			 * Single PSSH to be used to retrieve content keys.
			 * </pre>
			 *
			 * <code>SINGLE = 0;</code>
			 */
			public static final int SINGLE_VALUE = 0;
			/**
			 * <pre>
			 * Primary PSSH used to retrieve entitlement keys.
			 * </pre>
			 *
			 * <code>ENTITLEMENT = 1;</code>
			 */
			public static final int ENTITLEMENT_VALUE = 1;
			/**
			 * <pre>
			 * Secondary PSSH containing entitled key(s).
			 * </pre>
			 *
			 * <code>ENTITLED_KEY = 2;</code>
			 */
			public static final int ENTITLED_KEY_VALUE = 2;

			@Override
			public final int getNumber() {
				return value;
			}

			/**
			 * @param value The numeric wire value of the corresponding enum entry.
			 * @return The enum associated with the given numeric wire value.
			 * @deprecated Use {@link #forNumber(int)} instead.
			 */
			@java.lang.Deprecated
			public static Type valueOf(int value) {
				return forNumber(value);
			}

			/**
			 * @param value The numeric wire value of the corresponding enum entry.
			 * @return The enum associated with the given numeric wire value.
			 */
			public static Type forNumber(int value) {
				switch (value) {
				case 0:
					return SINGLE;
				case 1:
					return ENTITLEMENT;
				case 2:
					return ENTITLED_KEY;
				default:
					return null;
				}
			}

			public static Internal.EnumLiteMap<Type> internalGetValueMap() {
				return internalValueMap;
			}

			private static final Internal.EnumLiteMap<Type> internalValueMap = new Internal.EnumLiteMap<>() {
				@Override
				public Type findValueByNumber(int number) {
					return Type.forNumber(number);
				}
			};

			@Override
			public final Descriptors.EnumValueDescriptor getValueDescriptor() {
				return getDescriptor().getValues().get(ordinal());
			}

			@Override
			public final Descriptors.EnumDescriptor getDescriptorForType() {
				return getDescriptor();
			}

			public static final Descriptors.EnumDescriptor getDescriptor() {
				return WvProto2.WidevinePsshData.getDescriptor().getEnumTypes().get(0);
			}

			private static final Type[] VALUES = values();

			public static Type valueOf(Descriptors.EnumValueDescriptor desc) {
				if (desc.getType() != getDescriptor()) {
					throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
				}
				return VALUES[desc.getIndex()];
			}

			private final int value;

			private Type(int value) {
				this.value = value;
			}

			// @@protoc_insertion_point(enum_scope:WidevinePsshData.Type)
		}

		/**
		 * <pre>
		 * &#47;///////////////////////// Deprecated Fields
		 * &#47;///////////////////////// ////////////////////////////
		 * </pre>
		 *
		 * Protobuf enum {@code WidevinePsshData.Algorithm}
		 */
		public enum Algorithm implements ProtocolMessageEnum {
			/**
			 * <code>UNENCRYPTED = 0;</code>
			 */
			UNENCRYPTED(0),
			/**
			 * <code>AESCTR = 1;</code>
			 */
			AESCTR(1),;

			/**
			 * <code>UNENCRYPTED = 0;</code>
			 */
			public static final int UNENCRYPTED_VALUE = 0;
			/**
			 * <code>AESCTR = 1;</code>
			 */
			public static final int AESCTR_VALUE = 1;

			@Override
			public final int getNumber() {
				return value;
			}

			/**
			 * @param value The numeric wire value of the corresponding enum entry.
			 * @return The enum associated with the given numeric wire value.
			 * @deprecated Use {@link #forNumber(int)} instead.
			 */
			@java.lang.Deprecated
			public static Algorithm valueOf(int value) {
				return forNumber(value);
			}

			/**
			 * @param value The numeric wire value of the corresponding enum entry.
			 * @return The enum associated with the given numeric wire value.
			 */
			public static Algorithm forNumber(int value) {
				switch (value) {
				case 0:
					return UNENCRYPTED;
				case 1:
					return AESCTR;
				default:
					return null;
				}
			}

			public static Internal.EnumLiteMap<Algorithm> internalGetValueMap() {
				return internalValueMap;
			}

			private static final Internal.EnumLiteMap<Algorithm> internalValueMap = new Internal.EnumLiteMap<>() {
				@Override
				public Algorithm findValueByNumber(int number) {
					return Algorithm.forNumber(number);
				}
			};

			@Override
			public final Descriptors.EnumValueDescriptor getValueDescriptor() {
				return getDescriptor().getValues().get(ordinal());
			}

			@Override
			public final Descriptors.EnumDescriptor getDescriptorForType() {
				return getDescriptor();
			}

			public static final Descriptors.EnumDescriptor getDescriptor() {
				return WvProto2.WidevinePsshData.getDescriptor().getEnumTypes().get(1);
			}

			private static final Algorithm[] VALUES = values();

			public static Algorithm valueOf(Descriptors.EnumValueDescriptor desc) {
				if (desc.getType() != getDescriptor()) {
					throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
				}
				return VALUES[desc.getIndex()];
			}

			private final int value;

			private Algorithm(int value) {
				this.value = value;
			}

			// @@protoc_insertion_point(enum_scope:WidevinePsshData.Algorithm)
		}

		public interface EntitledKeyOrBuilder extends
				// @@protoc_insertion_point(interface_extends:WidevinePsshData.EntitledKey)
				MessageOrBuilder {

			/**
			 * <pre>
			 * ID of entitlement key used for wrapping |key|.
			 * </pre>
			 *
			 * <code>optional bytes entitlement_key_id = 1;</code>
			 * 
			 * @return Whether the entitlementKeyId field is set.
			 */
			boolean hasEntitlementKeyId();

			/**
			 * <pre>
			 * ID of entitlement key used for wrapping |key|.
			 * </pre>
			 *
			 * <code>optional bytes entitlement_key_id = 1;</code>
			 * 
			 * @return The entitlementKeyId.
			 */
			ByteString getEntitlementKeyId();

			/**
			 * <pre>
			 * ID of the entitled key.
			 * </pre>
			 *
			 * <code>optional bytes key_id = 2;</code>
			 * 
			 * @return Whether the keyId field is set.
			 */
			boolean hasKeyId();

			/**
			 * <pre>
			 * ID of the entitled key.
			 * </pre>
			 *
			 * <code>optional bytes key_id = 2;</code>
			 * 
			 * @return The keyId.
			 */
			ByteString getKeyId();

			/**
			 * <pre>
			 * Wrapped key. Required.
			 * </pre>
			 *
			 * <code>optional bytes key = 3;</code>
			 * 
			 * @return Whether the key field is set.
			 */
			boolean hasKey();

			/**
			 * <pre>
			 * Wrapped key. Required.
			 * </pre>
			 *
			 * <code>optional bytes key = 3;</code>
			 * 
			 * @return The key.
			 */
			ByteString getKey();

			/**
			 * <pre>
			 * IV used for wrapping |key|. Required.
			 * </pre>
			 *
			 * <code>optional bytes iv = 4;</code>
			 * 
			 * @return Whether the iv field is set.
			 */
			boolean hasIv();

			/**
			 * <pre>
			 * IV used for wrapping |key|. Required.
			 * </pre>
			 *
			 * <code>optional bytes iv = 4;</code>
			 * 
			 * @return The iv.
			 */
			ByteString getIv();

			/**
			 * <pre>
			 * Size of entitlement key used for wrapping |key|.
			 * </pre>
			 *
			 * <code>optional uint32 entitlement_key_size_bytes = 5 [default = 32];</code>
			 * 
			 * @return Whether the entitlementKeySizeBytes field is set.
			 */
			boolean hasEntitlementKeySizeBytes();

			/**
			 * <pre>
			 * Size of entitlement key used for wrapping |key|.
			 * </pre>
			 *
			 * <code>optional uint32 entitlement_key_size_bytes = 5 [default = 32];</code>
			 * 
			 * @return The entitlementKeySizeBytes.
			 */
			int getEntitlementKeySizeBytes();
		}

		/**
		 * Protobuf type {@code WidevinePsshData.EntitledKey}
		 */
		public static final class EntitledKey extends GeneratedMessageV3 implements
				// @@protoc_insertion_point(message_implements:WidevinePsshData.EntitledKey)
				EntitledKeyOrBuilder {
			private static final long serialVersionUID = 0L;

			// Use EntitledKey.newBuilder() to construct.
			private EntitledKey(GeneratedMessageV3.Builder<?> builder) {
				super(builder);
			}

			private EntitledKey() {
				entitlementKeyId_ = ByteString.EMPTY;
				keyId_ = ByteString.EMPTY;
				key_ = ByteString.EMPTY;
				iv_ = ByteString.EMPTY;
				entitlementKeySizeBytes_ = 32;
			}

			@java.lang.Override

			protected java.lang.Object newInstance(UnusedPrivateParameter unused) {
				return new EntitledKey();
			}

			public static final Descriptors.Descriptor getDescriptor() {
				return WvProto2.internal_static_WidevinePsshData_EntitledKey_descriptor;
			}

			@java.lang.Override
			protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
				return WvProto2.internal_static_WidevinePsshData_EntitledKey_fieldAccessorTable
						.ensureFieldAccessorsInitialized(
								WvProto2.WidevinePsshData.EntitledKey.class,
								WvProto2.WidevinePsshData.EntitledKey.Builder.class);
			}

			private int bitField0_;
			public static final int ENTITLEMENT_KEY_ID_FIELD_NUMBER = 1;
			private ByteString entitlementKeyId_ = ByteString.EMPTY;

			/**
			 * <pre>
			 * ID of entitlement key used for wrapping |key|.
			 * </pre>
			 *
			 * <code>optional bytes entitlement_key_id = 1;</code>
			 * 
			 * @return Whether the entitlementKeyId field is set.
			 */
			@java.lang.Override
			public boolean hasEntitlementKeyId() {
				return ((bitField0_ & 0x00000001) != 0);
			}

			/**
			 * <pre>
			 * ID of entitlement key used for wrapping |key|.
			 * </pre>
			 *
			 * <code>optional bytes entitlement_key_id = 1;</code>
			 * 
			 * @return The entitlementKeyId.
			 */
			@java.lang.Override
			public ByteString getEntitlementKeyId() {
				return entitlementKeyId_;
			}

			public static final int KEY_ID_FIELD_NUMBER = 2;
			private ByteString keyId_ = ByteString.EMPTY;

			/**
			 * <pre>
			 * ID of the entitled key.
			 * </pre>
			 *
			 * <code>optional bytes key_id = 2;</code>
			 * 
			 * @return Whether the keyId field is set.
			 */
			@java.lang.Override
			public boolean hasKeyId() {
				return ((bitField0_ & 0x00000002) != 0);
			}

			/**
			 * <pre>
			 * ID of the entitled key.
			 * </pre>
			 *
			 * <code>optional bytes key_id = 2;</code>
			 * 
			 * @return The keyId.
			 */
			@java.lang.Override
			public ByteString getKeyId() {
				return keyId_;
			}

			public static final int KEY_FIELD_NUMBER = 3;
			private ByteString key_ = ByteString.EMPTY;

			/**
			 * <pre>
			 * Wrapped key. Required.
			 * </pre>
			 *
			 * <code>optional bytes key = 3;</code>
			 * 
			 * @return Whether the key field is set.
			 */
			@java.lang.Override
			public boolean hasKey() {
				return ((bitField0_ & 0x00000004) != 0);
			}

			/**
			 * <pre>
			 * Wrapped key. Required.
			 * </pre>
			 *
			 * <code>optional bytes key = 3;</code>
			 * 
			 * @return The key.
			 */
			@java.lang.Override
			public ByteString getKey() {
				return key_;
			}

			public static final int IV_FIELD_NUMBER = 4;
			private ByteString iv_ = ByteString.EMPTY;

			/**
			 * <pre>
			 * IV used for wrapping |key|. Required.
			 * </pre>
			 *
			 * <code>optional bytes iv = 4;</code>
			 * 
			 * @return Whether the iv field is set.
			 */
			@java.lang.Override
			public boolean hasIv() {
				return ((bitField0_ & 0x00000008) != 0);
			}

			/**
			 * <pre>
			 * IV used for wrapping |key|. Required.
			 * </pre>
			 *
			 * <code>optional bytes iv = 4;</code>
			 * 
			 * @return The iv.
			 */
			@java.lang.Override
			public ByteString getIv() {
				return iv_;
			}

			public static final int ENTITLEMENT_KEY_SIZE_BYTES_FIELD_NUMBER = 5;
			private int entitlementKeySizeBytes_ = 32;

			/**
			 * <pre>
			 * Size of entitlement key used for wrapping |key|.
			 * </pre>
			 *
			 * <code>optional uint32 entitlement_key_size_bytes = 5 [default = 32];</code>
			 * 
			 * @return Whether the entitlementKeySizeBytes field is set.
			 */
			@java.lang.Override
			public boolean hasEntitlementKeySizeBytes() {
				return ((bitField0_ & 0x00000010) != 0);
			}

			/**
			 * <pre>
			 * Size of entitlement key used for wrapping |key|.
			 * </pre>
			 *
			 * <code>optional uint32 entitlement_key_size_bytes = 5 [default = 32];</code>
			 * 
			 * @return The entitlementKeySizeBytes.
			 */
			@java.lang.Override
			public int getEntitlementKeySizeBytes() {
				return entitlementKeySizeBytes_;
			}

			private byte memoizedIsInitialized = -1;

			@java.lang.Override
			public final boolean isInitialized() {
				byte isInitialized = memoizedIsInitialized;
				if (isInitialized == 1)
					return true;
				if (isInitialized == 0)
					return false;

				memoizedIsInitialized = 1;
				return true;
			}

			@java.lang.Override
			public void writeTo(CodedOutputStream output) throws java.io.IOException {
				if (((bitField0_ & 0x00000001) != 0)) {
					output.writeBytes(1, entitlementKeyId_);
				}
				if (((bitField0_ & 0x00000002) != 0)) {
					output.writeBytes(2, keyId_);
				}
				if (((bitField0_ & 0x00000004) != 0)) {
					output.writeBytes(3, key_);
				}
				if (((bitField0_ & 0x00000008) != 0)) {
					output.writeBytes(4, iv_);
				}
				if (((bitField0_ & 0x00000010) != 0)) {
					output.writeUInt32(5, entitlementKeySizeBytes_);
				}
				getUnknownFields().writeTo(output);
			}

			@java.lang.Override
			public int getSerializedSize() {
				int size = memoizedSize;
				if (size != -1)
					return size;

				size = 0;
				if (((bitField0_ & 0x00000001) != 0)) {
					size += CodedOutputStream.computeBytesSize(1, entitlementKeyId_);
				}
				if (((bitField0_ & 0x00000002) != 0)) {
					size += CodedOutputStream.computeBytesSize(2, keyId_);
				}
				if (((bitField0_ & 0x00000004) != 0)) {
					size += CodedOutputStream.computeBytesSize(3, key_);
				}
				if (((bitField0_ & 0x00000008) != 0)) {
					size += CodedOutputStream.computeBytesSize(4, iv_);
				}
				if (((bitField0_ & 0x00000010) != 0)) {
					size += CodedOutputStream.computeUInt32Size(5, entitlementKeySizeBytes_);
				}
				size += getUnknownFields().getSerializedSize();
				memoizedSize = size;
				return size;
			}

			@java.lang.Override
			public boolean equals(final java.lang.Object obj) {
				if (obj == this) {
					return true;
				}
				if (!(obj instanceof WvProto2.WidevinePsshData.EntitledKey)) {
					return super.equals(obj);
				}
				WvProto2.WidevinePsshData.EntitledKey other = (WvProto2.WidevinePsshData.EntitledKey) obj;

				if (hasEntitlementKeyId() != other.hasEntitlementKeyId())
					return false;
				if (hasEntitlementKeyId()) {
					if (!getEntitlementKeyId().equals(other.getEntitlementKeyId()))
						return false;
				}
				if (hasKeyId() != other.hasKeyId())
					return false;
				if (hasKeyId()) {
					if (!getKeyId().equals(other.getKeyId()))
						return false;
				}
				if (hasKey() != other.hasKey())
					return false;
				if (hasKey()) {
					if (!getKey().equals(other.getKey()))
						return false;
				}
				if (hasIv() != other.hasIv())
					return false;
				if (hasIv()) {
					if (!getIv().equals(other.getIv()))
						return false;
				}
				if (hasEntitlementKeySizeBytes() != other.hasEntitlementKeySizeBytes())
					return false;
				if (hasEntitlementKeySizeBytes()) {
					if (getEntitlementKeySizeBytes() != other.getEntitlementKeySizeBytes())
						return false;
				}
				if (!getUnknownFields().equals(other.getUnknownFields()))
					return false;
				return true;
			}

			@SuppressWarnings("unchecked")
			@java.lang.Override
			public int hashCode() {
				if (memoizedHashCode != 0) {
					return memoizedHashCode;
				}
				int hash = 41;
				hash = (19 * hash) + getDescriptor().hashCode();
				if (hasEntitlementKeyId()) {
					hash = (37 * hash) + ENTITLEMENT_KEY_ID_FIELD_NUMBER;
					hash = (53 * hash) + getEntitlementKeyId().hashCode();
				}
				if (hasKeyId()) {
					hash = (37 * hash) + KEY_ID_FIELD_NUMBER;
					hash = (53 * hash) + getKeyId().hashCode();
				}
				if (hasKey()) {
					hash = (37 * hash) + KEY_FIELD_NUMBER;
					hash = (53 * hash) + getKey().hashCode();
				}
				if (hasIv()) {
					hash = (37 * hash) + IV_FIELD_NUMBER;
					hash = (53 * hash) + getIv().hashCode();
				}
				if (hasEntitlementKeySizeBytes()) {
					hash = (37 * hash) + ENTITLEMENT_KEY_SIZE_BYTES_FIELD_NUMBER;
					hash = (53 * hash) + getEntitlementKeySizeBytes();
				}
				hash = (29 * hash) + getUnknownFields().hashCode();
				memoizedHashCode = hash;
				return hash;
			}

			public static WvProto2.WidevinePsshData.EntitledKey parseFrom(
					java.nio.ByteBuffer data) throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data);
			}

			public static WvProto2.WidevinePsshData.EntitledKey parseFrom(
					java.nio.ByteBuffer data, ExtensionRegistryLite extensionRegistry)
					throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data, extensionRegistry);
			}

			public static WvProto2.WidevinePsshData.EntitledKey parseFrom(ByteString data)
					throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data);
			}

			public static WvProto2.WidevinePsshData.EntitledKey parseFrom(ByteString data,
					ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data, extensionRegistry);
			}

			public static WvProto2.WidevinePsshData.EntitledKey parseFrom(byte[] data)
					throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data);
			}

			public static WvProto2.WidevinePsshData.EntitledKey parseFrom(byte[] data,
					ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data, extensionRegistry);
			}

			public static WvProto2.WidevinePsshData.EntitledKey parseFrom(
					java.io.InputStream input) throws java.io.IOException {
				return GeneratedMessageV3.parseWithIOException(PARSER, input);
			}

			public static WvProto2.WidevinePsshData.EntitledKey parseFrom(
					java.io.InputStream input, ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
				return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
			}

			public static WvProto2.WidevinePsshData.EntitledKey parseDelimitedFrom(
					java.io.InputStream input) throws java.io.IOException {
				return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
			}

			public static WvProto2.WidevinePsshData.EntitledKey parseDelimitedFrom(
					java.io.InputStream input, ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
				return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input, extensionRegistry);
			}

			public static WvProto2.WidevinePsshData.EntitledKey parseFrom(
					CodedInputStream input) throws java.io.IOException {
				return GeneratedMessageV3.parseWithIOException(PARSER, input);
			}

			public static WvProto2.WidevinePsshData.EntitledKey parseFrom(
					CodedInputStream input, ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
				return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
			}

			@java.lang.Override
			public Builder newBuilderForType() {
				return newBuilder();
			}

			public static Builder newBuilder() {
				return DEFAULT_INSTANCE.toBuilder();
			}

			public static Builder newBuilder(WvProto2.WidevinePsshData.EntitledKey prototype) {
				return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
			}

			@java.lang.Override
			public Builder toBuilder() {
				return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
			}

			@java.lang.Override
			protected Builder newBuilderForType(GeneratedMessageV3.BuilderParent parent) {
				Builder builder = new Builder(parent);
				return builder;
			}

			/**
			 * Protobuf type {@code WidevinePsshData.EntitledKey}
			 */
			public static final class Builder extends GeneratedMessageV3.Builder<Builder> implements
					// @@protoc_insertion_point(builder_implements:WidevinePsshData.EntitledKey)
					WvProto2.WidevinePsshData.EntitledKeyOrBuilder {
				public static final Descriptors.Descriptor getDescriptor() {
					return WvProto2.internal_static_WidevinePsshData_EntitledKey_descriptor;
				}

				@java.lang.Override
				protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
					return WvProto2.internal_static_WidevinePsshData_EntitledKey_fieldAccessorTable
							.ensureFieldAccessorsInitialized(
									WvProto2.WidevinePsshData.EntitledKey.class,
									WvProto2.WidevinePsshData.EntitledKey.Builder.class);
				}

				// Construct using
				// WvProto2.WidevinePsshData.EntitledKey.newBuilder()
				private Builder() {

				}

				private Builder(GeneratedMessageV3.BuilderParent parent) {
					super(parent);

				}

				@java.lang.Override
				public Builder clear() {
					super.clear();
					bitField0_ = 0;
					entitlementKeyId_ = ByteString.EMPTY;
					keyId_ = ByteString.EMPTY;
					key_ = ByteString.EMPTY;
					iv_ = ByteString.EMPTY;
					entitlementKeySizeBytes_ = 32;
					return this;
				}

				@java.lang.Override
				public Descriptors.Descriptor getDescriptorForType() {
					return WvProto2.internal_static_WidevinePsshData_EntitledKey_descriptor;
				}

				@java.lang.Override
				public WvProto2.WidevinePsshData.EntitledKey getDefaultInstanceForType() {
					return WvProto2.WidevinePsshData.EntitledKey.getDefaultInstance();
				}

				@java.lang.Override
				public WvProto2.WidevinePsshData.EntitledKey build() {
					WvProto2.WidevinePsshData.EntitledKey result = buildPartial();
					if (!result.isInitialized()) {
						throw newUninitializedMessageException(result);
					}
					return result;
				}

				@java.lang.Override
				public WvProto2.WidevinePsshData.EntitledKey buildPartial() {
					WvProto2.WidevinePsshData.EntitledKey result = new WvProto2.WidevinePsshData.EntitledKey(
							this);
					if (bitField0_ != 0) {
						buildPartial0(result);
					}
					onBuilt();
					return result;
				}

				private void buildPartial0(WvProto2.WidevinePsshData.EntitledKey result) {
					int from_bitField0_ = bitField0_;
					int to_bitField0_ = 0;
					if (((from_bitField0_ & 0x00000001) != 0)) {
						result.entitlementKeyId_ = entitlementKeyId_;
						to_bitField0_ |= 0x00000001;
					}
					if (((from_bitField0_ & 0x00000002) != 0)) {
						result.keyId_ = keyId_;
						to_bitField0_ |= 0x00000002;
					}
					if (((from_bitField0_ & 0x00000004) != 0)) {
						result.key_ = key_;
						to_bitField0_ |= 0x00000004;
					}
					if (((from_bitField0_ & 0x00000008) != 0)) {
						result.iv_ = iv_;
						to_bitField0_ |= 0x00000008;
					}
					if (((from_bitField0_ & 0x00000010) != 0)) {
						result.entitlementKeySizeBytes_ = entitlementKeySizeBytes_;
						to_bitField0_ |= 0x00000010;
					}
					result.bitField0_ |= to_bitField0_;
				}

				@java.lang.Override
				public Builder mergeFrom(Message other) {
					if (other instanceof WvProto2.WidevinePsshData.EntitledKey) {
						return mergeFrom((WvProto2.WidevinePsshData.EntitledKey) other);
					}
					super.mergeFrom(other);
					return this;
				}

				public Builder mergeFrom(WvProto2.WidevinePsshData.EntitledKey other) {
					if (other == WvProto2.WidevinePsshData.EntitledKey.getDefaultInstance())
						return this;
					if (other.hasEntitlementKeyId()) {
						setEntitlementKeyId(other.getEntitlementKeyId());
					}
					if (other.hasKeyId()) {
						setKeyId(other.getKeyId());
					}
					if (other.hasKey()) {
						setKey(other.getKey());
					}
					if (other.hasIv()) {
						setIv(other.getIv());
					}
					if (other.hasEntitlementKeySizeBytes()) {
						setEntitlementKeySizeBytes(other.getEntitlementKeySizeBytes());
					}
					this.mergeUnknownFields(other.getUnknownFields());
					onChanged();
					return this;
				}

				@java.lang.Override
				public final boolean isInitialized() {
					return true;
				}

				@java.lang.Override
				public Builder mergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
						throws java.io.IOException {
					if (extensionRegistry == null) {
						throw new java.lang.NullPointerException();
					}
					try {
						boolean done = false;
						while (!done) {
							int tag = input.readTag();
							switch (tag) {
							case 0:
								done = true;
								break;
							case 10: {
								entitlementKeyId_ = input.readBytes();
								bitField0_ |= 0x00000001;
								break;
							} // case 10
							case 18: {
								keyId_ = input.readBytes();
								bitField0_ |= 0x00000002;
								break;
							} // case 18
							case 26: {
								key_ = input.readBytes();
								bitField0_ |= 0x00000004;
								break;
							} // case 26
							case 34: {
								iv_ = input.readBytes();
								bitField0_ |= 0x00000008;
								break;
							} // case 34
							case 40: {
								entitlementKeySizeBytes_ = input.readUInt32();
								bitField0_ |= 0x00000010;
								break;
							} // case 40
							default: {
								if (!super.parseUnknownField(input, extensionRegistry, tag)) {
									done = true; // was an endgroup tag
								}
								break;
							} // default:
							} // switch (tag)
						} // while (!done)
					} catch (InvalidProtocolBufferException e) {
						throw e.unwrapIOException();
					}
					finally {
						onChanged();
					} // finally
					return this;
				}

				private int bitField0_;

				private ByteString entitlementKeyId_ = ByteString.EMPTY;

				/**
				 * <pre>
				 * ID of entitlement key used for wrapping |key|.
				 * </pre>
				 *
				 * <code>optional bytes entitlement_key_id = 1;</code>
				 * 
				 * @return Whether the entitlementKeyId field is set.
				 */
				@java.lang.Override
				public boolean hasEntitlementKeyId() {
					return ((bitField0_ & 0x00000001) != 0);
				}

				/**
				 * <pre>
				 * ID of entitlement key used for wrapping |key|.
				 * </pre>
				 *
				 * <code>optional bytes entitlement_key_id = 1;</code>
				 * 
				 * @return The entitlementKeyId.
				 */
				@java.lang.Override
				public ByteString getEntitlementKeyId() {
					return entitlementKeyId_;
				}

				/**
				 * <pre>
				 * ID of entitlement key used for wrapping |key|.
				 * </pre>
				 *
				 * <code>optional bytes entitlement_key_id = 1;</code>
				 * 
				 * @param value The entitlementKeyId to set.
				 * @return This builder for chaining.
				 */
				public Builder setEntitlementKeyId(ByteString value) {
					if (value == null) {
						throw new NullPointerException();
					}
					entitlementKeyId_ = value;
					bitField0_ |= 0x00000001;
					onChanged();
					return this;
				}

				/**
				 * <pre>
				 * ID of entitlement key used for wrapping |key|.
				 * </pre>
				 *
				 * <code>optional bytes entitlement_key_id = 1;</code>
				 * 
				 * @return This builder for chaining.
				 */
				public Builder clearEntitlementKeyId() {
					bitField0_ = (bitField0_ & ~0x00000001);
					entitlementKeyId_ = getDefaultInstance().getEntitlementKeyId();
					onChanged();
					return this;
				}

				private ByteString keyId_ = ByteString.EMPTY;

				/**
				 * <pre>
				 * ID of the entitled key.
				 * </pre>
				 *
				 * <code>optional bytes key_id = 2;</code>
				 * 
				 * @return Whether the keyId field is set.
				 */
				@java.lang.Override
				public boolean hasKeyId() {
					return ((bitField0_ & 0x00000002) != 0);
				}

				/**
				 * <pre>
				 * ID of the entitled key.
				 * </pre>
				 *
				 * <code>optional bytes key_id = 2;</code>
				 * 
				 * @return The keyId.
				 */
				@java.lang.Override
				public ByteString getKeyId() {
					return keyId_;
				}

				/**
				 * <pre>
				 * ID of the entitled key.
				 * </pre>
				 *
				 * <code>optional bytes key_id = 2;</code>
				 * 
				 * @param value The keyId to set.
				 * @return This builder for chaining.
				 */
				public Builder setKeyId(ByteString value) {
					if (value == null) {
						throw new NullPointerException();
					}
					keyId_ = value;
					bitField0_ |= 0x00000002;
					onChanged();
					return this;
				}

				/**
				 * <pre>
				 * ID of the entitled key.
				 * </pre>
				 *
				 * <code>optional bytes key_id = 2;</code>
				 * 
				 * @return This builder for chaining.
				 */
				public Builder clearKeyId() {
					bitField0_ = (bitField0_ & ~0x00000002);
					keyId_ = getDefaultInstance().getKeyId();
					onChanged();
					return this;
				}

				private ByteString key_ = ByteString.EMPTY;

				/**
				 * <pre>
				 * Wrapped key. Required.
				 * </pre>
				 *
				 * <code>optional bytes key = 3;</code>
				 * 
				 * @return Whether the key field is set.
				 */
				@java.lang.Override
				public boolean hasKey() {
					return ((bitField0_ & 0x00000004) != 0);
				}

				/**
				 * <pre>
				 * Wrapped key. Required.
				 * </pre>
				 *
				 * <code>optional bytes key = 3;</code>
				 * 
				 * @return The key.
				 */
				@java.lang.Override
				public ByteString getKey() {
					return key_;
				}

				/**
				 * <pre>
				 * Wrapped key. Required.
				 * </pre>
				 *
				 * <code>optional bytes key = 3;</code>
				 * 
				 * @param value The key to set.
				 * @return This builder for chaining.
				 */
				public Builder setKey(ByteString value) {
					if (value == null) {
						throw new NullPointerException();
					}
					key_ = value;
					bitField0_ |= 0x00000004;
					onChanged();
					return this;
				}

				/**
				 * <pre>
				 * Wrapped key. Required.
				 * </pre>
				 *
				 * <code>optional bytes key = 3;</code>
				 * 
				 * @return This builder for chaining.
				 */
				public Builder clearKey() {
					bitField0_ = (bitField0_ & ~0x00000004);
					key_ = getDefaultInstance().getKey();
					onChanged();
					return this;
				}

				private ByteString iv_ = ByteString.EMPTY;

				/**
				 * <pre>
				 * IV used for wrapping |key|. Required.
				 * </pre>
				 *
				 * <code>optional bytes iv = 4;</code>
				 * 
				 * @return Whether the iv field is set.
				 */
				@java.lang.Override
				public boolean hasIv() {
					return ((bitField0_ & 0x00000008) != 0);
				}

				/**
				 * <pre>
				 * IV used for wrapping |key|. Required.
				 * </pre>
				 *
				 * <code>optional bytes iv = 4;</code>
				 * 
				 * @return The iv.
				 */
				@java.lang.Override
				public ByteString getIv() {
					return iv_;
				}

				/**
				 * <pre>
				 * IV used for wrapping |key|. Required.
				 * </pre>
				 *
				 * <code>optional bytes iv = 4;</code>
				 * 
				 * @param value The iv to set.
				 * @return This builder for chaining.
				 */
				public Builder setIv(ByteString value) {
					if (value == null) {
						throw new NullPointerException();
					}
					iv_ = value;
					bitField0_ |= 0x00000008;
					onChanged();
					return this;
				}

				/**
				 * <pre>
				 * IV used for wrapping |key|. Required.
				 * </pre>
				 *
				 * <code>optional bytes iv = 4;</code>
				 * 
				 * @return This builder for chaining.
				 */
				public Builder clearIv() {
					bitField0_ = (bitField0_ & ~0x00000008);
					iv_ = getDefaultInstance().getIv();
					onChanged();
					return this;
				}

				private int entitlementKeySizeBytes_ = 32;

				/**
				 * <pre>
				 * Size of entitlement key used for wrapping |key|.
				 * </pre>
				 *
				 * <code>optional uint32 entitlement_key_size_bytes = 5 [default = 32];</code>
				 * 
				 * @return Whether the entitlementKeySizeBytes field is set.
				 */
				@java.lang.Override
				public boolean hasEntitlementKeySizeBytes() {
					return ((bitField0_ & 0x00000010) != 0);
				}

				/**
				 * <pre>
				 * Size of entitlement key used for wrapping |key|.
				 * </pre>
				 *
				 * <code>optional uint32 entitlement_key_size_bytes = 5 [default = 32];</code>
				 * 
				 * @return The entitlementKeySizeBytes.
				 */
				@java.lang.Override
				public int getEntitlementKeySizeBytes() {
					return entitlementKeySizeBytes_;
				}

				/**
				 * <pre>
				 * Size of entitlement key used for wrapping |key|.
				 * </pre>
				 *
				 * <code>optional uint32 entitlement_key_size_bytes = 5 [default = 32];</code>
				 * 
				 * @param value The entitlementKeySizeBytes to set.
				 * @return This builder for chaining.
				 */
				public Builder setEntitlementKeySizeBytes(int value) {

					entitlementKeySizeBytes_ = value;
					bitField0_ |= 0x00000010;
					onChanged();
					return this;
				}

				/**
				 * <pre>
				 * Size of entitlement key used for wrapping |key|.
				 * </pre>
				 *
				 * <code>optional uint32 entitlement_key_size_bytes = 5 [default = 32];</code>
				 * 
				 * @return This builder for chaining.
				 */
				public Builder clearEntitlementKeySizeBytes() {
					bitField0_ = (bitField0_ & ~0x00000010);
					entitlementKeySizeBytes_ = 32;
					onChanged();
					return this;
				}

				@java.lang.Override
				public final Builder setUnknownFields(final UnknownFieldSet unknownFields) {
					return super.setUnknownFields(unknownFields);
				}

				@java.lang.Override
				public final Builder mergeUnknownFields(final UnknownFieldSet unknownFields) {
					return super.mergeUnknownFields(unknownFields);
				}

				// @@protoc_insertion_point(builder_scope:WidevinePsshData.EntitledKey)
			}

			// @@protoc_insertion_point(class_scope:WidevinePsshData.EntitledKey)
			private static final WvProto2.WidevinePsshData.EntitledKey DEFAULT_INSTANCE;
			static {
				DEFAULT_INSTANCE = new WvProto2.WidevinePsshData.EntitledKey();
			}

			public static WvProto2.WidevinePsshData.EntitledKey getDefaultInstance() {
				return DEFAULT_INSTANCE;
			}

			@java.lang.Deprecated public static final Parser<EntitledKey> PARSER = new AbstractParser<>() {
				@java.lang.Override
				public EntitledKey parsePartialFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
						throws InvalidProtocolBufferException {
					Builder builder = newBuilder();
					try {
						builder.mergeFrom(input, extensionRegistry);
					} catch (InvalidProtocolBufferException e) {
						throw e.setUnfinishedMessage(builder.buildPartial());
					} catch (UninitializedMessageException e) {
						throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
					} catch (java.io.IOException e) {
						throw new InvalidProtocolBufferException(e).setUnfinishedMessage(builder.buildPartial());
					}
					return builder.buildPartial();
				}
			};

			public static Parser<EntitledKey> parser() {
				return PARSER;
			}

			@java.lang.Override
			public Parser<EntitledKey> getParserForType() {
				return PARSER;
			}

			@java.lang.Override
			public WvProto2.WidevinePsshData.EntitledKey getDefaultInstanceForType() {
				return DEFAULT_INSTANCE;
			}

		}

		private int bitField0_;
		public static final int KEY_IDS_FIELD_NUMBER = 2;

		private java.util.List<ByteString> keyIds_;

		/**
		 * <pre>
		 * Entitlement or content key IDs. Can onnly present in SINGLE or ENTITLEMENT
		 * PSSHs. May be repeated to facilitate delivery of multiple keys in a
		 * single license. Cannot be used in conjunction with content_id or
		 * group_ids, which are the preferred mechanism.
		 * </pre>
		 *
		 * <code>repeated bytes key_ids = 2;</code>
		 * 
		 * @return A list containing the keyIds.
		 */
		@java.lang.Override
		public java.util.List<ByteString> getKeyIdsList() {
			return keyIds_;
		}

		/**
		 * <pre>
		 * Entitlement or content key IDs. Can onnly present in SINGLE or ENTITLEMENT
		 * PSSHs. May be repeated to facilitate delivery of multiple keys in a
		 * single license. Cannot be used in conjunction with content_id or
		 * group_ids, which are the preferred mechanism.
		 * </pre>
		 *
		 * <code>repeated bytes key_ids = 2;</code>
		 * 
		 * @return The count of keyIds.
		 */
		@Override
		public int getKeyIdsCount() {
			return keyIds_.size();
		}

		/**
		 * <pre>
		 * Entitlement or content key IDs. Can onnly present in SINGLE or ENTITLEMENT
		 * PSSHs. May be repeated to facilitate delivery of multiple keys in a
		 * single license. Cannot be used in conjunction with content_id or
		 * group_ids, which are the preferred mechanism.
		 * </pre>
		 *
		 * <code>repeated bytes key_ids = 2;</code>
		 * 
		 * @param index The index of the element to return.
		 * @return The keyIds at the given index.
		 */
		@Override
		public ByteString getKeyIds(int index) {
			return keyIds_.get(index);
		}

		public static final int CONTENT_ID_FIELD_NUMBER = 4;
		private ByteString contentId_ = ByteString.EMPTY;

		/**
		 * <pre>
		 * Content identifier which may map to multiple entitlement or content key
		 * IDs to facilitate the delivery of multiple keys in a single license.
		 * Cannot be present in conjunction with key_ids, but if used must be in all
		 * PSSHs.
		 * </pre>
		 *
		 * <code>optional bytes content_id = 4;</code>
		 * 
		 * @return Whether the contentId field is set.
		 */
		@java.lang.Override
		public boolean hasContentId() {
			return ((bitField0_ & 0x00000001) != 0);
		}

		/**
		 * <pre>
		 * Content identifier which may map to multiple entitlement or content key
		 * IDs to facilitate the delivery of multiple keys in a single license.
		 * Cannot be present in conjunction with key_ids, but if used must be in all
		 * PSSHs.
		 * </pre>
		 *
		 * <code>optional bytes content_id = 4;</code>
		 * 
		 * @return The contentId.
		 */
		@java.lang.Override
		public ByteString getContentId() {
			return contentId_;
		}

		public static final int CRYPTO_PERIOD_INDEX_FIELD_NUMBER = 7;
		private int cryptoPeriodIndex_ = 0;

		/**
		 * <pre>
		 * Crypto period index, for media using key rotation. Always corresponds to
		 * The content key period. This means that if using entitlement licensing
		 * the ENTITLED_KEY PSSHs will have sequential crypto_period_index's, whereas
		 * the ENTITELEMENT PSSHs will have gaps in the sequence. Required if doing
		 * key rotation.
		 * </pre>
		 *
		 * <code>optional uint32 crypto_period_index = 7;</code>
		 * 
		 * @return Whether the cryptoPeriodIndex field is set.
		 */
		@java.lang.Override
		public boolean hasCryptoPeriodIndex() {
			return ((bitField0_ & 0x00000002) != 0);
		}

		/**
		 * <pre>
		 * Crypto period index, for media using key rotation. Always corresponds to
		 * The content key period. This means that if using entitlement licensing
		 * the ENTITLED_KEY PSSHs will have sequential crypto_period_index's, whereas
		 * the ENTITELEMENT PSSHs will have gaps in the sequence. Required if doing
		 * key rotation.
		 * </pre>
		 *
		 * <code>optional uint32 crypto_period_index = 7;</code>
		 * 
		 * @return The cryptoPeriodIndex.
		 */
		@java.lang.Override
		public int getCryptoPeriodIndex() {
			return cryptoPeriodIndex_;
		}

		public static final int PROTECTION_SCHEME_FIELD_NUMBER = 9;
		private int protectionScheme_ = 0;

		/**
		 * <pre>
		 * Protection scheme identifying the encryption algorithm. The protection
		 * scheme is represented as a uint32 value. The uint32 contains 4 bytes each
		 * representing a single ascii character in one of the 4CC protection scheme
		 * values. To be deprecated in favor of signaling from content.
		 * 'cenc' (AES-CTR) protection_scheme = 0x63656E63,
		 * 'cbc1' (AES-CBC) protection_scheme = 0x63626331,
		 * 'cens' (AES-CTR pattern encryption) protection_scheme = 0x63656E73,
		 * 'cbcs' (AES-CBC pattern encryption) protection_scheme = 0x63626373.
		 * </pre>
		 *
		 * <code>optional uint32 protection_scheme = 9;</code>
		 * 
		 * @return Whether the protectionScheme field is set.
		 */
		@java.lang.Override
		public boolean hasProtectionScheme() {
			return ((bitField0_ & 0x00000004) != 0);
		}

		/**
		 * <pre>
		 * Protection scheme identifying the encryption algorithm. The protection
		 * scheme is represented as a uint32 value. The uint32 contains 4 bytes each
		 * representing a single ascii character in one of the 4CC protection scheme
		 * values. To be deprecated in favor of signaling from content.
		 * 'cenc' (AES-CTR) protection_scheme = 0x63656E63,
		 * 'cbc1' (AES-CBC) protection_scheme = 0x63626331,
		 * 'cens' (AES-CTR pattern encryption) protection_scheme = 0x63656E73,
		 * 'cbcs' (AES-CBC pattern encryption) protection_scheme = 0x63626373.
		 * </pre>
		 *
		 * <code>optional uint32 protection_scheme = 9;</code>
		 * 
		 * @return The protectionScheme.
		 */
		@java.lang.Override
		public int getProtectionScheme() {
			return protectionScheme_;
		}

		public static final int CRYPTO_PERIOD_SECONDS_FIELD_NUMBER = 10;
		private int cryptoPeriodSeconds_ = 0;

		/**
		 * <pre>
		 * Optional. For media using key rotation, this represents the duration
		 * of each crypto period in seconds.
		 * </pre>
		 *
		 * <code>optional uint32 crypto_period_seconds = 10;</code>
		 * 
		 * @return Whether the cryptoPeriodSeconds field is set.
		 */
		@java.lang.Override
		public boolean hasCryptoPeriodSeconds() {
			return ((bitField0_ & 0x00000008) != 0);
		}

		/**
		 * <pre>
		 * Optional. For media using key rotation, this represents the duration
		 * of each crypto period in seconds.
		 * </pre>
		 *
		 * <code>optional uint32 crypto_period_seconds = 10;</code>
		 * 
		 * @return The cryptoPeriodSeconds.
		 */
		@java.lang.Override
		public int getCryptoPeriodSeconds() {
			return cryptoPeriodSeconds_;
		}

		public static final int TYPE_FIELD_NUMBER = 11;
		private int type_ = 0;

		/**
		 * <pre>
		 * Type of PSSH. Required if not SINGLE.
		 * </pre>
		 *
		 * <code>optional .WidevinePsshData.Type type = 11 [default = SINGLE];</code>
		 * 
		 * @return Whether the type field is set.
		 */
		@java.lang.Override
		public boolean hasType() {
			return ((bitField0_ & 0x00000010) != 0);
		}

		/**
		 * <pre>
		 * Type of PSSH. Required if not SINGLE.
		 * </pre>
		 *
		 * <code>optional .WidevinePsshData.Type type = 11 [default = SINGLE];</code>
		 * 
		 * @return The type.
		 */
		@java.lang.Override
		public WvProto2.WidevinePsshData.Type getType() {
			WvProto2.WidevinePsshData.Type result = WvProto2.WidevinePsshData.Type
					.forNumber(type_);
			return result == null ? WvProto2.WidevinePsshData.Type.SINGLE : result;
		}

		public static final int KEY_SEQUENCE_FIELD_NUMBER = 12;
		private int keySequence_ = 0;

		/**
		 * <pre>
		 * Key sequence for Widevine-managed keys. Optional.
		 * </pre>
		 *
		 * <code>optional uint32 key_sequence = 12;</code>
		 * 
		 * @return Whether the keySequence field is set.
		 */
		@java.lang.Override
		public boolean hasKeySequence() {
			return ((bitField0_ & 0x00000020) != 0);
		}

		/**
		 * <pre>
		 * Key sequence for Widevine-managed keys. Optional.
		 * </pre>
		 *
		 * <code>optional uint32 key_sequence = 12;</code>
		 * 
		 * @return The keySequence.
		 */
		@java.lang.Override
		public int getKeySequence() {
			return keySequence_;
		}

		public static final int GROUP_IDS_FIELD_NUMBER = 13;

		private java.util.List<ByteString> groupIds_;

		/**
		 * <pre>
		 * Group identifiers for all groups to which the content belongs. This can
		 * be used to deliver licenses to unlock multiple titles / channels.
		 * Optional, and may only be present in ENTITLEMENT and ENTITLED_KEY PSSHs, and
		 * not in conjunction with key_ids.
		 * </pre>
		 *
		 * <code>repeated bytes group_ids = 13;</code>
		 * 
		 * @return A list containing the groupIds.
		 */
		@java.lang.Override
		public java.util.List<ByteString> getGroupIdsList() {
			return groupIds_;
		}

		/**
		 * <pre>
		 * Group identifiers for all groups to which the content belongs. This can
		 * be used to deliver licenses to unlock multiple titles / channels.
		 * Optional, and may only be present in ENTITLEMENT and ENTITLED_KEY PSSHs, and
		 * not in conjunction with key_ids.
		 * </pre>
		 *
		 * <code>repeated bytes group_ids = 13;</code>
		 * 
		 * @return The count of groupIds.
		 */
		@Override
		public int getGroupIdsCount() {
			return groupIds_.size();
		}

		/**
		 * <pre>
		 * Group identifiers for all groups to which the content belongs. This can
		 * be used to deliver licenses to unlock multiple titles / channels.
		 * Optional, and may only be present in ENTITLEMENT and ENTITLED_KEY PSSHs, and
		 * not in conjunction with key_ids.
		 * </pre>
		 *
		 * <code>repeated bytes group_ids = 13;</code>
		 * 
		 * @param index The index of the element to return.
		 * @return The groupIds at the given index.
		 */
		@Override
		public ByteString getGroupIds(int index) {
			return groupIds_.get(index);
		}

		public static final int ENTITLED_KEYS_FIELD_NUMBER = 14;

		private java.util.List<WvProto2.WidevinePsshData.EntitledKey> entitledKeys_;

		/**
		 * <pre>
		 * Copy/copies of the content key used to decrypt the media stream in which
		 * the PSSH box is embedded, each wrapped with a different entitlement key.
		 * May also contain sub-licenses to support devices with OEMCrypto 13 or
		 * older. May be repeated if using group entitlement keys. Present only in
		 * PSSHs of type ENTITLED_KEY.
		 * </pre>
		 *
		 * <code>repeated .WidevinePsshData.EntitledKey entitled_keys = 14;</code>
		 */
		@java.lang.Override
		public java.util.List<WvProto2.WidevinePsshData.EntitledKey> getEntitledKeysList() {
			return entitledKeys_;
		}

		/**
		 * <pre>
		 * Copy/copies of the content key used to decrypt the media stream in which
		 * the PSSH box is embedded, each wrapped with a different entitlement key.
		 * May also contain sub-licenses to support devices with OEMCrypto 13 or
		 * older. May be repeated if using group entitlement keys. Present only in
		 * PSSHs of type ENTITLED_KEY.
		 * </pre>
		 *
		 * <code>repeated .WidevinePsshData.EntitledKey entitled_keys = 14;</code>
		 */
		@java.lang.Override
		public java.util.List<? extends WvProto2.WidevinePsshData.EntitledKeyOrBuilder> getEntitledKeysOrBuilderList() {
			return entitledKeys_;
		}

		/**
		 * <pre>
		 * Copy/copies of the content key used to decrypt the media stream in which
		 * the PSSH box is embedded, each wrapped with a different entitlement key.
		 * May also contain sub-licenses to support devices with OEMCrypto 13 or
		 * older. May be repeated if using group entitlement keys. Present only in
		 * PSSHs of type ENTITLED_KEY.
		 * </pre>
		 *
		 * <code>repeated .WidevinePsshData.EntitledKey entitled_keys = 14;</code>
		 */
		@java.lang.Override
		public int getEntitledKeysCount() {
			return entitledKeys_.size();
		}

		/**
		 * <pre>
		 * Copy/copies of the content key used to decrypt the media stream in which
		 * the PSSH box is embedded, each wrapped with a different entitlement key.
		 * May also contain sub-licenses to support devices with OEMCrypto 13 or
		 * older. May be repeated if using group entitlement keys. Present only in
		 * PSSHs of type ENTITLED_KEY.
		 * </pre>
		 *
		 * <code>repeated .WidevinePsshData.EntitledKey entitled_keys = 14;</code>
		 */
		@java.lang.Override
		public WvProto2.WidevinePsshData.EntitledKey getEntitledKeys(int index) {
			return entitledKeys_.get(index);
		}

		/**
		 * <pre>
		 * Copy/copies of the content key used to decrypt the media stream in which
		 * the PSSH box is embedded, each wrapped with a different entitlement key.
		 * May also contain sub-licenses to support devices with OEMCrypto 13 or
		 * older. May be repeated if using group entitlement keys. Present only in
		 * PSSHs of type ENTITLED_KEY.
		 * </pre>
		 *
		 * <code>repeated .WidevinePsshData.EntitledKey entitled_keys = 14;</code>
		 */
		@java.lang.Override
		public WvProto2.WidevinePsshData.EntitledKeyOrBuilder getEntitledKeysOrBuilder(
				int index) {
			return entitledKeys_.get(index);
		}

		public static final int VIDEO_FEATURE_FIELD_NUMBER = 15;

		private volatile java.lang.Object videoFeature_ = "";

		/**
		 * <pre>
		 * Video feature identifier, which is used in conjunction with |content_id|
		 * to determine the set of keys to be returned in the license. Cannot be
		 * present in conjunction with |key_ids|.
		 * Current values are "HDR".
		 * </pre>
		 *
		 * <code>optional string video_feature = 15;</code>
		 * 
		 * @return Whether the videoFeature field is set.
		 */
		@java.lang.Override
		public boolean hasVideoFeature() {
			return ((bitField0_ & 0x00000040) != 0);
		}

		/**
		 * <pre>
		 * Video feature identifier, which is used in conjunction with |content_id|
		 * to determine the set of keys to be returned in the license. Cannot be
		 * present in conjunction with |key_ids|.
		 * Current values are "HDR".
		 * </pre>
		 *
		 * <code>optional string video_feature = 15;</code>
		 * 
		 * @return The videoFeature.
		 */
		@java.lang.Override
		public java.lang.String getVideoFeature() {
			java.lang.Object ref = videoFeature_;
			if (ref instanceof java.lang.String) {
				return (java.lang.String) ref;
			}
			ByteString bs = (ByteString) ref;
			java.lang.String s = bs.toStringUtf8();
			if (bs.isValidUtf8()) {
				videoFeature_ = s;
			}
			return s;
		}

		/**
		 * <pre>
		 * Video feature identifier, which is used in conjunction with |content_id|
		 * to determine the set of keys to be returned in the license. Cannot be
		 * present in conjunction with |key_ids|.
		 * Current values are "HDR".
		 * </pre>
		 *
		 * <code>optional string video_feature = 15;</code>
		 * 
		 * @return The bytes for videoFeature.
		 */
		@java.lang.Override
		public ByteString getVideoFeatureBytes() {
			java.lang.Object ref = videoFeature_;
			if (ref instanceof java.lang.String) {
				ByteString b = ByteString.copyFromUtf8((java.lang.String) ref);
				videoFeature_ = b;
				return b;
			}
			return (ByteString) ref;
		}

		public static final int ALGORITHM_FIELD_NUMBER = 1;
		private int algorithm_ = 0;

		/**
		 * <code>optional .WidevinePsshData.Algorithm algorithm = 1 [deprecated = true];</code>
		 * 
		 * @deprecated WidevinePsshData.algorithm is deprecated. See
		 *             wv_proto2.proto;l=720
		 * @return Whether the algorithm field is set.
		 */
		@java.lang.Override
		@java.lang.Deprecated
		public boolean hasAlgorithm() {
			return ((bitField0_ & 0x00000080) != 0);
		}

		/**
		 * <code>optional .WidevinePsshData.Algorithm algorithm = 1 [deprecated = true];</code>
		 * 
		 * @deprecated WidevinePsshData.algorithm is deprecated. See
		 *             wv_proto2.proto;l=720
		 * @return The algorithm.
		 */
		@java.lang.Override
		@java.lang.Deprecated
		public WvProto2.WidevinePsshData.Algorithm getAlgorithm() {
			WvProto2.WidevinePsshData.Algorithm result = WvProto2.WidevinePsshData.Algorithm
					.forNumber(algorithm_);
			return result == null ? WvProto2.WidevinePsshData.Algorithm.UNENCRYPTED : result;
		}

		public static final int PROVIDER_FIELD_NUMBER = 3;

		private volatile java.lang.Object provider_ = "";

		/**
		 * <pre>
		 * Content provider name.
		 * </pre>
		 *
		 * <code>optional string provider = 3 [deprecated = true];</code>
		 * 
		 * @deprecated WidevinePsshData.provider is deprecated. See
		 *             wv_proto2.proto;l=723
		 * @return Whether the provider field is set.
		 */
		@java.lang.Override
		@java.lang.Deprecated
		public boolean hasProvider() {
			return ((bitField0_ & 0x00000100) != 0);
		}

		/**
		 * <pre>
		 * Content provider name.
		 * </pre>
		 *
		 * <code>optional string provider = 3 [deprecated = true];</code>
		 * 
		 * @deprecated WidevinePsshData.provider is deprecated. See
		 *             wv_proto2.proto;l=723
		 * @return The provider.
		 */
		@java.lang.Override
		@java.lang.Deprecated
		public java.lang.String getProvider() {
			java.lang.Object ref = provider_;
			if (ref instanceof java.lang.String) {
				return (java.lang.String) ref;
			}
			ByteString bs = (ByteString) ref;
			java.lang.String s = bs.toStringUtf8();
			if (bs.isValidUtf8()) {
				provider_ = s;
			}
			return s;
		}

		/**
		 * <pre>
		 * Content provider name.
		 * </pre>
		 *
		 * <code>optional string provider = 3 [deprecated = true];</code>
		 * 
		 * @deprecated WidevinePsshData.provider is deprecated. See
		 *             wv_proto2.proto;l=723
		 * @return The bytes for provider.
		 */
		@java.lang.Override
		@java.lang.Deprecated
		public ByteString getProviderBytes() {
			java.lang.Object ref = provider_;
			if (ref instanceof java.lang.String) {
				ByteString b = ByteString.copyFromUtf8((java.lang.String) ref);
				provider_ = b;
				return b;
			}
			return (ByteString) ref;
		}

		public static final int TRACK_TYPE_FIELD_NUMBER = 5;

		private volatile java.lang.Object trackType_ = "";

		/**
		 * <pre>
		 * Track type. Acceptable values are SD, HD and AUDIO. Used to
		 * differentiate content keys used by an asset.
		 * </pre>
		 *
		 * <code>optional string track_type = 5 [deprecated = true];</code>
		 * 
		 * @deprecated WidevinePsshData.track_type is deprecated. See
		 *             wv_proto2.proto;l=727
		 * @return Whether the trackType field is set.
		 */
		@java.lang.Override
		@java.lang.Deprecated
		public boolean hasTrackType() {
			return ((bitField0_ & 0x00000200) != 0);
		}

		/**
		 * <pre>
		 * Track type. Acceptable values are SD, HD and AUDIO. Used to
		 * differentiate content keys used by an asset.
		 * </pre>
		 *
		 * <code>optional string track_type = 5 [deprecated = true];</code>
		 * 
		 * @deprecated WidevinePsshData.track_type is deprecated. See
		 *             wv_proto2.proto;l=727
		 * @return The trackType.
		 */
		@java.lang.Override
		@java.lang.Deprecated
		public java.lang.String getTrackType() {
			java.lang.Object ref = trackType_;
			if (ref instanceof java.lang.String) {
				return (java.lang.String) ref;
			}
			ByteString bs = (ByteString) ref;
			java.lang.String s = bs.toStringUtf8();
			if (bs.isValidUtf8()) {
				trackType_ = s;
			}
			return s;
		}

		/**
		 * <pre>
		 * Track type. Acceptable values are SD, HD and AUDIO. Used to
		 * differentiate content keys used by an asset.
		 * </pre>
		 *
		 * <code>optional string track_type = 5 [deprecated = true];</code>
		 * 
		 * @deprecated WidevinePsshData.track_type is deprecated. See
		 *             wv_proto2.proto;l=727
		 * @return The bytes for trackType.
		 */
		@java.lang.Override
		@java.lang.Deprecated
		public ByteString getTrackTypeBytes() {
			java.lang.Object ref = trackType_;
			if (ref instanceof java.lang.String) {
				ByteString b = ByteString.copyFromUtf8((java.lang.String) ref);
				trackType_ = b;
				return b;
			}
			return (ByteString) ref;
		}

		public static final int POLICY_FIELD_NUMBER = 6;

		private volatile java.lang.Object policy_ = "";

		/**
		 * <pre>
		 * The name of a registered policy to be used for this asset.
		 * </pre>
		 *
		 * <code>optional string policy = 6 [deprecated = true];</code>
		 * 
		 * @deprecated WidevinePsshData.policy is deprecated. See wv_proto2.proto;l=730
		 * @return Whether the policy field is set.
		 */
		@java.lang.Override
		@java.lang.Deprecated
		public boolean hasPolicy() {
			return ((bitField0_ & 0x00000400) != 0);
		}

		/**
		 * <pre>
		 * The name of a registered policy to be used for this asset.
		 * </pre>
		 *
		 * <code>optional string policy = 6 [deprecated = true];</code>
		 * 
		 * @deprecated WidevinePsshData.policy is deprecated. See wv_proto2.proto;l=730
		 * @return The policy.
		 */
		@java.lang.Override
		@java.lang.Deprecated
		public java.lang.String getPolicy() {
			java.lang.Object ref = policy_;
			if (ref instanceof java.lang.String) {
				return (java.lang.String) ref;
			}
			ByteString bs = (ByteString) ref;
			java.lang.String s = bs.toStringUtf8();
			if (bs.isValidUtf8()) {
				policy_ = s;
			}
			return s;
		}

		/**
		 * <pre>
		 * The name of a registered policy to be used for this asset.
		 * </pre>
		 *
		 * <code>optional string policy = 6 [deprecated = true];</code>
		 * 
		 * @deprecated WidevinePsshData.policy is deprecated. See wv_proto2.proto;l=730
		 * @return The bytes for policy.
		 */
		@java.lang.Override
		@java.lang.Deprecated
		public ByteString getPolicyBytes() {
			java.lang.Object ref = policy_;
			if (ref instanceof java.lang.String) {
				ByteString b = ByteString.copyFromUtf8((java.lang.String) ref);
				policy_ = b;
				return b;
			}
			return (ByteString) ref;
		}

		public static final int GROUPED_LICENSE_FIELD_NUMBER = 8;
		private ByteString groupedLicense_ = ByteString.EMPTY;

		/**
		 * <pre>
		 * Optional protected context for group content. The grouped_license is a
		 * serialized SignedMessage.
		 * </pre>
		 *
		 * <code>optional bytes grouped_license = 8 [deprecated = true];</code>
		 * 
		 * @deprecated WidevinePsshData.grouped_license is deprecated. See
		 *             wv_proto2.proto;l=734
		 * @return Whether the groupedLicense field is set.
		 */
		@java.lang.Override
		@java.lang.Deprecated
		public boolean hasGroupedLicense() {
			return ((bitField0_ & 0x00000800) != 0);
		}

		/**
		 * <pre>
		 * Optional protected context for group content. The grouped_license is a
		 * serialized SignedMessage.
		 * </pre>
		 *
		 * <code>optional bytes grouped_license = 8 [deprecated = true];</code>
		 * 
		 * @deprecated WidevinePsshData.grouped_license is deprecated. See
		 *             wv_proto2.proto;l=734
		 * @return The groupedLicense.
		 */
		@java.lang.Override
		@java.lang.Deprecated
		public ByteString getGroupedLicense() {
			return groupedLicense_;
		}

		private byte memoizedIsInitialized = -1;

		@java.lang.Override
		public final boolean isInitialized() {
			byte isInitialized = memoizedIsInitialized;
			if (isInitialized == 1)
				return true;
			if (isInitialized == 0)
				return false;

			memoizedIsInitialized = 1;
			return true;
		}

		@java.lang.Override
		public void writeTo(CodedOutputStream output) throws java.io.IOException {
			if (((bitField0_ & 0x00000080) != 0)) {
				output.writeEnum(1, algorithm_);
			}
			for (int i = 0; i < keyIds_.size(); i++) {
				output.writeBytes(2, keyIds_.get(i));
			}
			if (((bitField0_ & 0x00000100) != 0)) {
				GeneratedMessageV3.writeString(output, 3, provider_);
			}
			if (((bitField0_ & 0x00000001) != 0)) {
				output.writeBytes(4, contentId_);
			}
			if (((bitField0_ & 0x00000200) != 0)) {
				GeneratedMessageV3.writeString(output, 5, trackType_);
			}
			if (((bitField0_ & 0x00000400) != 0)) {
				GeneratedMessageV3.writeString(output, 6, policy_);
			}
			if (((bitField0_ & 0x00000002) != 0)) {
				output.writeUInt32(7, cryptoPeriodIndex_);
			}
			if (((bitField0_ & 0x00000800) != 0)) {
				output.writeBytes(8, groupedLicense_);
			}
			if (((bitField0_ & 0x00000004) != 0)) {
				output.writeUInt32(9, protectionScheme_);
			}
			if (((bitField0_ & 0x00000008) != 0)) {
				output.writeUInt32(10, cryptoPeriodSeconds_);
			}
			if (((bitField0_ & 0x00000010) != 0)) {
				output.writeEnum(11, type_);
			}
			if (((bitField0_ & 0x00000020) != 0)) {
				output.writeUInt32(12, keySequence_);
			}
			for (int i = 0; i < groupIds_.size(); i++) {
				output.writeBytes(13, groupIds_.get(i));
			}
			for (int i = 0; i < entitledKeys_.size(); i++) {
				output.writeMessage(14, entitledKeys_.get(i));
			}
			if (((bitField0_ & 0x00000040) != 0)) {
				GeneratedMessageV3.writeString(output, 15, videoFeature_);
			}
			getUnknownFields().writeTo(output);
		}

		@java.lang.Override
		public int getSerializedSize() {
			int size = memoizedSize;
			if (size != -1)
				return size;

			size = 0;
			if (((bitField0_ & 0x00000080) != 0)) {
				size += CodedOutputStream.computeEnumSize(1, algorithm_);
			}
			{
				int dataSize = 0;
				for (int i = 0; i < keyIds_.size(); i++) {
					dataSize += CodedOutputStream.computeBytesSizeNoTag(keyIds_.get(i));
				}
				size += dataSize;
				size += 1 * getKeyIdsList().size();
			}
			if (((bitField0_ & 0x00000100) != 0)) {
				size += GeneratedMessageV3.computeStringSize(3, provider_);
			}
			if (((bitField0_ & 0x00000001) != 0)) {
				size += CodedOutputStream.computeBytesSize(4, contentId_);
			}
			if (((bitField0_ & 0x00000200) != 0)) {
				size += GeneratedMessageV3.computeStringSize(5, trackType_);
			}
			if (((bitField0_ & 0x00000400) != 0)) {
				size += GeneratedMessageV3.computeStringSize(6, policy_);
			}
			if (((bitField0_ & 0x00000002) != 0)) {
				size += CodedOutputStream.computeUInt32Size(7, cryptoPeriodIndex_);
			}
			if (((bitField0_ & 0x00000800) != 0)) {
				size += CodedOutputStream.computeBytesSize(8, groupedLicense_);
			}
			if (((bitField0_ & 0x00000004) != 0)) {
				size += CodedOutputStream.computeUInt32Size(9, protectionScheme_);
			}
			if (((bitField0_ & 0x00000008) != 0)) {
				size += CodedOutputStream.computeUInt32Size(10, cryptoPeriodSeconds_);
			}
			if (((bitField0_ & 0x00000010) != 0)) {
				size += CodedOutputStream.computeEnumSize(11, type_);
			}
			if (((bitField0_ & 0x00000020) != 0)) {
				size += CodedOutputStream.computeUInt32Size(12, keySequence_);
			}
			{
				int dataSize = 0;
				for (int i = 0; i < groupIds_.size(); i++) {
					dataSize += CodedOutputStream.computeBytesSizeNoTag(groupIds_.get(i));
				}
				size += dataSize;
				size += 1 * getGroupIdsList().size();
			}
			for (int i = 0; i < entitledKeys_.size(); i++) {
				size += CodedOutputStream.computeMessageSize(14, entitledKeys_.get(i));
			}
			if (((bitField0_ & 0x00000040) != 0)) {
				size += GeneratedMessageV3.computeStringSize(15, videoFeature_);
			}
			size += getUnknownFields().getSerializedSize();
			memoizedSize = size;
			return size;
		}

		@java.lang.Override
		public boolean equals(final java.lang.Object obj) {
			if (obj == this) {
				return true;
			}
			if (!(obj instanceof WvProto2.WidevinePsshData)) {
				return super.equals(obj);
			}
			WvProto2.WidevinePsshData other = (WvProto2.WidevinePsshData) obj;

			if (!getKeyIdsList().equals(other.getKeyIdsList()))
				return false;
			if (hasContentId() != other.hasContentId())
				return false;
			if (hasContentId()) {
				if (!getContentId().equals(other.getContentId()))
					return false;
			}
			if (hasCryptoPeriodIndex() != other.hasCryptoPeriodIndex())
				return false;
			if (hasCryptoPeriodIndex()) {
				if (getCryptoPeriodIndex() != other.getCryptoPeriodIndex())
					return false;
			}
			if (hasProtectionScheme() != other.hasProtectionScheme())
				return false;
			if (hasProtectionScheme()) {
				if (getProtectionScheme() != other.getProtectionScheme())
					return false;
			}
			if (hasCryptoPeriodSeconds() != other.hasCryptoPeriodSeconds())
				return false;
			if (hasCryptoPeriodSeconds()) {
				if (getCryptoPeriodSeconds() != other.getCryptoPeriodSeconds())
					return false;
			}
			if (hasType() != other.hasType())
				return false;
			if (hasType()) {
				if (type_ != other.type_)
					return false;
			}
			if (hasKeySequence() != other.hasKeySequence())
				return false;
			if (hasKeySequence()) {
				if (getKeySequence() != other.getKeySequence())
					return false;
			}
			if (!getGroupIdsList().equals(other.getGroupIdsList()))
				return false;
			if (!getEntitledKeysList().equals(other.getEntitledKeysList()))
				return false;
			if (hasVideoFeature() != other.hasVideoFeature())
				return false;
			if (hasVideoFeature()) {
				if (!getVideoFeature().equals(other.getVideoFeature()))
					return false;
			}
			if (hasAlgorithm() != other.hasAlgorithm())
				return false;
			if (hasAlgorithm()) {
				if (algorithm_ != other.algorithm_)
					return false;
			}
			if (hasProvider() != other.hasProvider())
				return false;
			if (hasProvider()) {
				if (!getProvider().equals(other.getProvider()))
					return false;
			}
			if (hasTrackType() != other.hasTrackType())
				return false;
			if (hasTrackType()) {
				if (!getTrackType().equals(other.getTrackType()))
					return false;
			}
			if (hasPolicy() != other.hasPolicy())
				return false;
			if (hasPolicy()) {
				if (!getPolicy().equals(other.getPolicy()))
					return false;
			}
			if (hasGroupedLicense() != other.hasGroupedLicense())
				return false;
			if (hasGroupedLicense()) {
				if (!getGroupedLicense().equals(other.getGroupedLicense()))
					return false;
			}
			if (!getUnknownFields().equals(other.getUnknownFields()))
				return false;
			return true;
		}

		@SuppressWarnings("unchecked")
		@java.lang.Override
		public int hashCode() {
			if (memoizedHashCode != 0) {
				return memoizedHashCode;
			}
			int hash = 41;
			hash = (19 * hash) + getDescriptor().hashCode();
			if (getKeyIdsCount() > 0) {
				hash = (37 * hash) + KEY_IDS_FIELD_NUMBER;
				hash = (53 * hash) + getKeyIdsList().hashCode();
			}
			if (hasContentId()) {
				hash = (37 * hash) + CONTENT_ID_FIELD_NUMBER;
				hash = (53 * hash) + getContentId().hashCode();
			}
			if (hasCryptoPeriodIndex()) {
				hash = (37 * hash) + CRYPTO_PERIOD_INDEX_FIELD_NUMBER;
				hash = (53 * hash) + getCryptoPeriodIndex();
			}
			if (hasProtectionScheme()) {
				hash = (37 * hash) + PROTECTION_SCHEME_FIELD_NUMBER;
				hash = (53 * hash) + getProtectionScheme();
			}
			if (hasCryptoPeriodSeconds()) {
				hash = (37 * hash) + CRYPTO_PERIOD_SECONDS_FIELD_NUMBER;
				hash = (53 * hash) + getCryptoPeriodSeconds();
			}
			if (hasType()) {
				hash = (37 * hash) + TYPE_FIELD_NUMBER;
				hash = (53 * hash) + type_;
			}
			if (hasKeySequence()) {
				hash = (37 * hash) + KEY_SEQUENCE_FIELD_NUMBER;
				hash = (53 * hash) + getKeySequence();
			}
			if (getGroupIdsCount() > 0) {
				hash = (37 * hash) + GROUP_IDS_FIELD_NUMBER;
				hash = (53 * hash) + getGroupIdsList().hashCode();
			}
			if (getEntitledKeysCount() > 0) {
				hash = (37 * hash) + ENTITLED_KEYS_FIELD_NUMBER;
				hash = (53 * hash) + getEntitledKeysList().hashCode();
			}
			if (hasVideoFeature()) {
				hash = (37 * hash) + VIDEO_FEATURE_FIELD_NUMBER;
				hash = (53 * hash) + getVideoFeature().hashCode();
			}
			if (hasAlgorithm()) {
				hash = (37 * hash) + ALGORITHM_FIELD_NUMBER;
				hash = (53 * hash) + algorithm_;
			}
			if (hasProvider()) {
				hash = (37 * hash) + PROVIDER_FIELD_NUMBER;
				hash = (53 * hash) + getProvider().hashCode();
			}
			if (hasTrackType()) {
				hash = (37 * hash) + TRACK_TYPE_FIELD_NUMBER;
				hash = (53 * hash) + getTrackType().hashCode();
			}
			if (hasPolicy()) {
				hash = (37 * hash) + POLICY_FIELD_NUMBER;
				hash = (53 * hash) + getPolicy().hashCode();
			}
			if (hasGroupedLicense()) {
				hash = (37 * hash) + GROUPED_LICENSE_FIELD_NUMBER;
				hash = (53 * hash) + getGroupedLicense().hashCode();
			}
			hash = (29 * hash) + getUnknownFields().hashCode();
			memoizedHashCode = hash;
			return hash;
		}

		public static WvProto2.WidevinePsshData parseFrom(java.nio.ByteBuffer data)
				throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data);
		}

		public static WvProto2.WidevinePsshData parseFrom(java.nio.ByteBuffer data,
				ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data, extensionRegistry);
		}

		public static WvProto2.WidevinePsshData parseFrom(ByteString data)
				throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data);
		}

		public static WvProto2.WidevinePsshData parseFrom(ByteString data,
				ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data, extensionRegistry);
		}

		public static WvProto2.WidevinePsshData parseFrom(byte[] data)
				throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data);
		}

		public static WvProto2.WidevinePsshData parseFrom(byte[] data,
				ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data, extensionRegistry);
		}

		public static WvProto2.WidevinePsshData parseFrom(java.io.InputStream input)
				throws java.io.IOException {
			return GeneratedMessageV3.parseWithIOException(PARSER, input);
		}

		public static WvProto2.WidevinePsshData parseFrom(java.io.InputStream input,
				ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
			return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
		}

		public static WvProto2.WidevinePsshData parseDelimitedFrom(java.io.InputStream input)
				throws java.io.IOException {
			return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
		}

		public static WvProto2.WidevinePsshData parseDelimitedFrom(java.io.InputStream input,
				ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
			return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input, extensionRegistry);
		}

		public static WvProto2.WidevinePsshData parseFrom(CodedInputStream input)
				throws java.io.IOException {
			return GeneratedMessageV3.parseWithIOException(PARSER, input);
		}

		public static WvProto2.WidevinePsshData parseFrom(CodedInputStream input,
				ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
			return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
		}

		@java.lang.Override
		public Builder newBuilderForType() {
			return newBuilder();
		}

		public static Builder newBuilder() {
			return DEFAULT_INSTANCE.toBuilder();
		}

		public static Builder newBuilder(WvProto2.WidevinePsshData prototype) {
			return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
		}

		@java.lang.Override
		public Builder toBuilder() {
			return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
		}

		@java.lang.Override
		protected Builder newBuilderForType(GeneratedMessageV3.BuilderParent parent) {
			Builder builder = new Builder(parent);
			return builder;
		}

		/**
		 * Protobuf type {@code WidevinePsshData}
		 */
		public static final class Builder extends GeneratedMessageV3.Builder<Builder> implements
				// @@protoc_insertion_point(builder_implements:WidevinePsshData)
				WvProto2.WidevinePsshDataOrBuilder {
			public static final Descriptors.Descriptor getDescriptor() {
				return WvProto2.internal_static_WidevinePsshData_descriptor;
			}

			@java.lang.Override
			protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
				return WvProto2.internal_static_WidevinePsshData_fieldAccessorTable
						.ensureFieldAccessorsInitialized(WvProto2.WidevinePsshData.class,
								WvProto2.WidevinePsshData.Builder.class);
			}

			// Construct using
			// WvProto2.WidevinePsshData.newBuilder()
			private Builder() {

			}

			private Builder(GeneratedMessageV3.BuilderParent parent) {
				super(parent);

			}

			@java.lang.Override
			public Builder clear() {
				super.clear();
				bitField0_ = 0;
				keyIds_ = java.util.Collections.emptyList();
				contentId_ = ByteString.EMPTY;
				cryptoPeriodIndex_ = 0;
				protectionScheme_ = 0;
				cryptoPeriodSeconds_ = 0;
				type_ = 0;
				keySequence_ = 0;
				groupIds_ = java.util.Collections.emptyList();
				if (entitledKeysBuilder_ == null) {
					entitledKeys_ = java.util.Collections.emptyList();
				} else {
					entitledKeys_ = null;
					entitledKeysBuilder_.clear();
				}
				bitField0_ = (bitField0_ & ~0x00000100);
				videoFeature_ = "";
				algorithm_ = 0;
				provider_ = "";
				trackType_ = "";
				policy_ = "";
				groupedLicense_ = ByteString.EMPTY;
				return this;
			}

			@java.lang.Override
			public Descriptors.Descriptor getDescriptorForType() {
				return WvProto2.internal_static_WidevinePsshData_descriptor;
			}

			@java.lang.Override
			public WvProto2.WidevinePsshData getDefaultInstanceForType() {
				return WvProto2.WidevinePsshData.getDefaultInstance();
			}

			@java.lang.Override
			public WvProto2.WidevinePsshData build() {
				WvProto2.WidevinePsshData result = buildPartial();
				if (!result.isInitialized()) {
					throw newUninitializedMessageException(result);
				}
				return result;
			}

			@java.lang.Override
			public WvProto2.WidevinePsshData buildPartial() {
				WvProto2.WidevinePsshData result = new WvProto2.WidevinePsshData(
						this);
				buildPartialRepeatedFields(result);
				if (bitField0_ != 0) {
					buildPartial0(result);
				}
				onBuilt();
				return result;
			}

			private void buildPartialRepeatedFields(WvProto2.WidevinePsshData result) {
				if (((bitField0_ & 0x00000001) != 0)) {
					keyIds_ = java.util.Collections.unmodifiableList(keyIds_);
					bitField0_ = (bitField0_ & ~0x00000001);
				}
				result.keyIds_ = keyIds_;
				if (((bitField0_ & 0x00000080) != 0)) {
					groupIds_ = java.util.Collections.unmodifiableList(groupIds_);
					bitField0_ = (bitField0_ & ~0x00000080);
				}
				result.groupIds_ = groupIds_;
				if (entitledKeysBuilder_ == null) {
					if (((bitField0_ & 0x00000100) != 0)) {
						entitledKeys_ = java.util.Collections.unmodifiableList(entitledKeys_);
						bitField0_ = (bitField0_ & ~0x00000100);
					}
					result.entitledKeys_ = entitledKeys_;
				} else {
					result.entitledKeys_ = entitledKeysBuilder_.build();
				}
			}

			private void buildPartial0(WvProto2.WidevinePsshData result) {
				int from_bitField0_ = bitField0_;
				int to_bitField0_ = 0;
				if (((from_bitField0_ & 0x00000002) != 0)) {
					result.contentId_ = contentId_;
					to_bitField0_ |= 0x00000001;
				}
				if (((from_bitField0_ & 0x00000004) != 0)) {
					result.cryptoPeriodIndex_ = cryptoPeriodIndex_;
					to_bitField0_ |= 0x00000002;
				}
				if (((from_bitField0_ & 0x00000008) != 0)) {
					result.protectionScheme_ = protectionScheme_;
					to_bitField0_ |= 0x00000004;
				}
				if (((from_bitField0_ & 0x00000010) != 0)) {
					result.cryptoPeriodSeconds_ = cryptoPeriodSeconds_;
					to_bitField0_ |= 0x00000008;
				}
				if (((from_bitField0_ & 0x00000020) != 0)) {
					result.type_ = type_;
					to_bitField0_ |= 0x00000010;
				}
				if (((from_bitField0_ & 0x00000040) != 0)) {
					result.keySequence_ = keySequence_;
					to_bitField0_ |= 0x00000020;
				}
				if (((from_bitField0_ & 0x00000200) != 0)) {
					result.videoFeature_ = videoFeature_;
					to_bitField0_ |= 0x00000040;
				}
				if (((from_bitField0_ & 0x00000400) != 0)) {
					result.algorithm_ = algorithm_;
					to_bitField0_ |= 0x00000080;
				}
				if (((from_bitField0_ & 0x00000800) != 0)) {
					result.provider_ = provider_;
					to_bitField0_ |= 0x00000100;
				}
				if (((from_bitField0_ & 0x00001000) != 0)) {
					result.trackType_ = trackType_;
					to_bitField0_ |= 0x00000200;
				}
				if (((from_bitField0_ & 0x00002000) != 0)) {
					result.policy_ = policy_;
					to_bitField0_ |= 0x00000400;
				}
				if (((from_bitField0_ & 0x00004000) != 0)) {
					result.groupedLicense_ = groupedLicense_;
					to_bitField0_ |= 0x00000800;
				}
				result.bitField0_ |= to_bitField0_;
			}

			@java.lang.Override
			public Builder mergeFrom(Message other) {
				if (other instanceof WvProto2.WidevinePsshData) {
					return mergeFrom((WvProto2.WidevinePsshData) other);
				}
				super.mergeFrom(other);
				return this;
			}

			public Builder mergeFrom(WvProto2.WidevinePsshData other) {
				if (other == WvProto2.WidevinePsshData.getDefaultInstance())
					return this;
				if (!other.keyIds_.isEmpty()) {
					if (keyIds_.isEmpty()) {
						keyIds_ = other.keyIds_;
						bitField0_ = (bitField0_ & ~0x00000001);
					} else {
						ensureKeyIdsIsMutable();
						keyIds_.addAll(other.keyIds_);
					}
					onChanged();
				}
				if (other.hasContentId()) {
					setContentId(other.getContentId());
				}
				if (other.hasCryptoPeriodIndex()) {
					setCryptoPeriodIndex(other.getCryptoPeriodIndex());
				}
				if (other.hasProtectionScheme()) {
					setProtectionScheme(other.getProtectionScheme());
				}
				if (other.hasCryptoPeriodSeconds()) {
					setCryptoPeriodSeconds(other.getCryptoPeriodSeconds());
				}
				if (other.hasType()) {
					setType(other.getType());
				}
				if (other.hasKeySequence()) {
					setKeySequence(other.getKeySequence());
				}
				if (!other.groupIds_.isEmpty()) {
					if (groupIds_.isEmpty()) {
						groupIds_ = other.groupIds_;
						bitField0_ = (bitField0_ & ~0x00000080);
					} else {
						ensureGroupIdsIsMutable();
						groupIds_.addAll(other.groupIds_);
					}
					onChanged();
				}
				if (entitledKeysBuilder_ == null) {
					if (!other.entitledKeys_.isEmpty()) {
						if (entitledKeys_.isEmpty()) {
							entitledKeys_ = other.entitledKeys_;
							bitField0_ = (bitField0_ & ~0x00000100);
						} else {
							ensureEntitledKeysIsMutable();
							entitledKeys_.addAll(other.entitledKeys_);
						}
						onChanged();
					}
				} else {
					if (!other.entitledKeys_.isEmpty()) {
						if (entitledKeysBuilder_.isEmpty()) {
							entitledKeysBuilder_.dispose();
							entitledKeysBuilder_ = null;
							entitledKeys_ = other.entitledKeys_;
							bitField0_ = (bitField0_ & ~0x00000100);
							entitledKeysBuilder_ = GeneratedMessageV3.alwaysUseFieldBuilders
									? getEntitledKeysFieldBuilder()
									: null;
						} else {
							entitledKeysBuilder_.addAllMessages(other.entitledKeys_);
						}
					}
				}
				if (other.hasVideoFeature()) {
					videoFeature_ = other.videoFeature_;
					bitField0_ |= 0x00000200;
					onChanged();
				}
				if (other.hasAlgorithm()) {
					setAlgorithm(other.getAlgorithm());
				}
				if (other.hasProvider()) {
					provider_ = other.provider_;
					bitField0_ |= 0x00000800;
					onChanged();
				}
				if (other.hasTrackType()) {
					trackType_ = other.trackType_;
					bitField0_ |= 0x00001000;
					onChanged();
				}
				if (other.hasPolicy()) {
					policy_ = other.policy_;
					bitField0_ |= 0x00002000;
					onChanged();
				}
				if (other.hasGroupedLicense()) {
					setGroupedLicense(other.getGroupedLicense());
				}
				this.mergeUnknownFields(other.getUnknownFields());
				onChanged();
				return this;
			}

			@java.lang.Override
			public final boolean isInitialized() {
				return true;
			}

			@java.lang.Override
			public Builder mergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
					throws java.io.IOException {
				if (extensionRegistry == null) {
					throw new java.lang.NullPointerException();
				}
				try {
					boolean done = false;
					while (!done) {
						int tag = input.readTag();
						switch (tag) {
						case 0:
							done = true;
							break;
						case 8: {
							int tmpRaw = input.readEnum();
							WvProto2.WidevinePsshData.Algorithm tmpValue = WvProto2.WidevinePsshData.Algorithm
									.forNumber(tmpRaw);
							if (tmpValue == null) {
								mergeUnknownVarintField(1, tmpRaw);
							} else {
								algorithm_ = tmpRaw;
								bitField0_ |= 0x00000400;
							}
							break;
						} // case 8
						case 18: {
							ByteString v = input.readBytes();
							ensureKeyIdsIsMutable();
							keyIds_.add(v);
							break;
						} // case 18
						case 26: {
							provider_ = input.readBytes();
							bitField0_ |= 0x00000800;
							break;
						} // case 26
						case 34: {
							contentId_ = input.readBytes();
							bitField0_ |= 0x00000002;
							break;
						} // case 34
						case 42: {
							trackType_ = input.readBytes();
							bitField0_ |= 0x00001000;
							break;
						} // case 42
						case 50: {
							policy_ = input.readBytes();
							bitField0_ |= 0x00002000;
							break;
						} // case 50
						case 56: {
							cryptoPeriodIndex_ = input.readUInt32();
							bitField0_ |= 0x00000004;
							break;
						} // case 56
						case 66: {
							groupedLicense_ = input.readBytes();
							bitField0_ |= 0x00004000;
							break;
						} // case 66
						case 72: {
							protectionScheme_ = input.readUInt32();
							bitField0_ |= 0x00000008;
							break;
						} // case 72
						case 80: {
							cryptoPeriodSeconds_ = input.readUInt32();
							bitField0_ |= 0x00000010;
							break;
						} // case 80
						case 88: {
							int tmpRaw = input.readEnum();
							WvProto2.WidevinePsshData.Type tmpValue = WvProto2.WidevinePsshData.Type
									.forNumber(tmpRaw);
							if (tmpValue == null) {
								mergeUnknownVarintField(11, tmpRaw);
							} else {
								type_ = tmpRaw;
								bitField0_ |= 0x00000020;
							}
							break;
						} // case 88
						case 96: {
							keySequence_ = input.readUInt32();
							bitField0_ |= 0x00000040;
							break;
						} // case 96
						case 106: {
							ByteString v = input.readBytes();
							ensureGroupIdsIsMutable();
							groupIds_.add(v);
							break;
						} // case 106
						case 114: {
							WvProto2.WidevinePsshData.EntitledKey m = input.readMessage(
									WvProto2.WidevinePsshData.EntitledKey.PARSER,
									extensionRegistry);
							if (entitledKeysBuilder_ == null) {
								ensureEntitledKeysIsMutable();
								entitledKeys_.add(m);
							} else {
								entitledKeysBuilder_.addMessage(m);
							}
							break;
						} // case 114
						case 122: {
							videoFeature_ = input.readBytes();
							bitField0_ |= 0x00000200;
							break;
						} // case 122
						default: {
							if (!super.parseUnknownField(input, extensionRegistry, tag)) {
								done = true; // was an endgroup tag
							}
							break;
						} // default:
						} // switch (tag)
					} // while (!done)
				} catch (InvalidProtocolBufferException e) {
					throw e.unwrapIOException();
				}
				finally {
					onChanged();
				} // finally
				return this;
			}

			private int bitField0_;

			private java.util.List<ByteString> keyIds_ = java.util.Collections.emptyList();

			private void ensureKeyIdsIsMutable() {
				if (!((bitField0_ & 0x00000001) != 0)) {
					keyIds_ = new java.util.ArrayList<>(keyIds_);
					bitField0_ |= 0x00000001;
				}
			}

			/**
			 * <pre>
			 * Entitlement or content key IDs. Can onnly present in SINGLE or ENTITLEMENT
			 * PSSHs. May be repeated to facilitate delivery of multiple keys in a
			 * single license. Cannot be used in conjunction with content_id or
			 * group_ids, which are the preferred mechanism.
			 * </pre>
			 *
			 * <code>repeated bytes key_ids = 2;</code>
			 * 
			 * @return A list containing the keyIds.
			 */
			@Override
			public java.util.List<ByteString> getKeyIdsList() {
				return ((bitField0_ & 0x00000001) != 0) ? java.util.Collections.unmodifiableList(keyIds_) : keyIds_;
			}

			/**
			 * <pre>
			 * Entitlement or content key IDs. Can onnly present in SINGLE or ENTITLEMENT
			 * PSSHs. May be repeated to facilitate delivery of multiple keys in a
			 * single license. Cannot be used in conjunction with content_id or
			 * group_ids, which are the preferred mechanism.
			 * </pre>
			 *
			 * <code>repeated bytes key_ids = 2;</code>
			 * 
			 * @return The count of keyIds.
			 */
			@Override
			public int getKeyIdsCount() {
				return keyIds_.size();
			}

			/**
			 * <pre>
			 * Entitlement or content key IDs. Can onnly present in SINGLE or ENTITLEMENT
			 * PSSHs. May be repeated to facilitate delivery of multiple keys in a
			 * single license. Cannot be used in conjunction with content_id or
			 * group_ids, which are the preferred mechanism.
			 * </pre>
			 *
			 * <code>repeated bytes key_ids = 2;</code>
			 * 
			 * @param index The index of the element to return.
			 * @return The keyIds at the given index.
			 */
			@Override
			public ByteString getKeyIds(int index) {
				return keyIds_.get(index);
			}

			/**
			 * <pre>
			 * Entitlement or content key IDs. Can onnly present in SINGLE or ENTITLEMENT
			 * PSSHs. May be repeated to facilitate delivery of multiple keys in a
			 * single license. Cannot be used in conjunction with content_id or
			 * group_ids, which are the preferred mechanism.
			 * </pre>
			 *
			 * <code>repeated bytes key_ids = 2;</code>
			 * 
			 * @param index The index to set the value at.
			 * @param value The keyIds to set.
			 * @return This builder for chaining.
			 */
			public Builder setKeyIds(int index, ByteString value) {
				if (value == null) {
					throw new NullPointerException();
				}
				ensureKeyIdsIsMutable();
				keyIds_.set(index, value);
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Entitlement or content key IDs. Can onnly present in SINGLE or ENTITLEMENT
			 * PSSHs. May be repeated to facilitate delivery of multiple keys in a
			 * single license. Cannot be used in conjunction with content_id or
			 * group_ids, which are the preferred mechanism.
			 * </pre>
			 *
			 * <code>repeated bytes key_ids = 2;</code>
			 * 
			 * @param value The keyIds to add.
			 * @return This builder for chaining.
			 */
			public Builder addKeyIds(ByteString value) {
				if (value == null) {
					throw new NullPointerException();
				}
				ensureKeyIdsIsMutable();
				keyIds_.add(value);
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Entitlement or content key IDs. Can onnly present in SINGLE or ENTITLEMENT
			 * PSSHs. May be repeated to facilitate delivery of multiple keys in a
			 * single license. Cannot be used in conjunction with content_id or
			 * group_ids, which are the preferred mechanism.
			 * </pre>
			 *
			 * <code>repeated bytes key_ids = 2;</code>
			 * 
			 * @param values The keyIds to add.
			 * @return This builder for chaining.
			 */
			public Builder addAllKeyIds(java.lang.Iterable<? extends ByteString> values) {
				ensureKeyIdsIsMutable();
				AbstractMessageLite.Builder.addAll(values, keyIds_);
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Entitlement or content key IDs. Can onnly present in SINGLE or ENTITLEMENT
			 * PSSHs. May be repeated to facilitate delivery of multiple keys in a
			 * single license. Cannot be used in conjunction with content_id or
			 * group_ids, which are the preferred mechanism.
			 * </pre>
			 *
			 * <code>repeated bytes key_ids = 2;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearKeyIds() {
				keyIds_ = java.util.Collections.emptyList();
				bitField0_ = (bitField0_ & ~0x00000001);
				onChanged();
				return this;
			}

			private ByteString contentId_ = ByteString.EMPTY;

			/**
			 * <pre>
			 * Content identifier which may map to multiple entitlement or content key
			 * IDs to facilitate the delivery of multiple keys in a single license.
			 * Cannot be present in conjunction with key_ids, but if used must be in all
			 * PSSHs.
			 * </pre>
			 *
			 * <code>optional bytes content_id = 4;</code>
			 * 
			 * @return Whether the contentId field is set.
			 */
			@java.lang.Override
			public boolean hasContentId() {
				return ((bitField0_ & 0x00000002) != 0);
			}

			/**
			 * <pre>
			 * Content identifier which may map to multiple entitlement or content key
			 * IDs to facilitate the delivery of multiple keys in a single license.
			 * Cannot be present in conjunction with key_ids, but if used must be in all
			 * PSSHs.
			 * </pre>
			 *
			 * <code>optional bytes content_id = 4;</code>
			 * 
			 * @return The contentId.
			 */
			@java.lang.Override
			public ByteString getContentId() {
				return contentId_;
			}

			/**
			 * <pre>
			 * Content identifier which may map to multiple entitlement or content key
			 * IDs to facilitate the delivery of multiple keys in a single license.
			 * Cannot be present in conjunction with key_ids, but if used must be in all
			 * PSSHs.
			 * </pre>
			 *
			 * <code>optional bytes content_id = 4;</code>
			 * 
			 * @param value The contentId to set.
			 * @return This builder for chaining.
			 */
			public Builder setContentId(ByteString value) {
				if (value == null) {
					throw new NullPointerException();
				}
				contentId_ = value;
				bitField0_ |= 0x00000002;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Content identifier which may map to multiple entitlement or content key
			 * IDs to facilitate the delivery of multiple keys in a single license.
			 * Cannot be present in conjunction with key_ids, but if used must be in all
			 * PSSHs.
			 * </pre>
			 *
			 * <code>optional bytes content_id = 4;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearContentId() {
				bitField0_ = (bitField0_ & ~0x00000002);
				contentId_ = getDefaultInstance().getContentId();
				onChanged();
				return this;
			}

			private int cryptoPeriodIndex_;

			/**
			 * <pre>
			 * Crypto period index, for media using key rotation. Always corresponds to
			 * The content key period. This means that if using entitlement licensing
			 * the ENTITLED_KEY PSSHs will have sequential crypto_period_index's, whereas
			 * the ENTITELEMENT PSSHs will have gaps in the sequence. Required if doing
			 * key rotation.
			 * </pre>
			 *
			 * <code>optional uint32 crypto_period_index = 7;</code>
			 * 
			 * @return Whether the cryptoPeriodIndex field is set.
			 */
			@java.lang.Override
			public boolean hasCryptoPeriodIndex() {
				return ((bitField0_ & 0x00000004) != 0);
			}

			/**
			 * <pre>
			 * Crypto period index, for media using key rotation. Always corresponds to
			 * The content key period. This means that if using entitlement licensing
			 * the ENTITLED_KEY PSSHs will have sequential crypto_period_index's, whereas
			 * the ENTITELEMENT PSSHs will have gaps in the sequence. Required if doing
			 * key rotation.
			 * </pre>
			 *
			 * <code>optional uint32 crypto_period_index = 7;</code>
			 * 
			 * @return The cryptoPeriodIndex.
			 */
			@java.lang.Override
			public int getCryptoPeriodIndex() {
				return cryptoPeriodIndex_;
			}

			/**
			 * <pre>
			 * Crypto period index, for media using key rotation. Always corresponds to
			 * The content key period. This means that if using entitlement licensing
			 * the ENTITLED_KEY PSSHs will have sequential crypto_period_index's, whereas
			 * the ENTITELEMENT PSSHs will have gaps in the sequence. Required if doing
			 * key rotation.
			 * </pre>
			 *
			 * <code>optional uint32 crypto_period_index = 7;</code>
			 * 
			 * @param value The cryptoPeriodIndex to set.
			 * @return This builder for chaining.
			 */
			public Builder setCryptoPeriodIndex(int value) {

				cryptoPeriodIndex_ = value;
				bitField0_ |= 0x00000004;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Crypto period index, for media using key rotation. Always corresponds to
			 * The content key period. This means that if using entitlement licensing
			 * the ENTITLED_KEY PSSHs will have sequential crypto_period_index's, whereas
			 * the ENTITELEMENT PSSHs will have gaps in the sequence. Required if doing
			 * key rotation.
			 * </pre>
			 *
			 * <code>optional uint32 crypto_period_index = 7;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearCryptoPeriodIndex() {
				bitField0_ = (bitField0_ & ~0x00000004);
				cryptoPeriodIndex_ = 0;
				onChanged();
				return this;
			}

			private int protectionScheme_;

			/**
			 * <pre>
			 * Protection scheme identifying the encryption algorithm. The protection
			 * scheme is represented as a uint32 value. The uint32 contains 4 bytes each
			 * representing a single ascii character in one of the 4CC protection scheme
			 * values. To be deprecated in favor of signaling from content.
			 * 'cenc' (AES-CTR) protection_scheme = 0x63656E63,
			 * 'cbc1' (AES-CBC) protection_scheme = 0x63626331,
			 * 'cens' (AES-CTR pattern encryption) protection_scheme = 0x63656E73,
			 * 'cbcs' (AES-CBC pattern encryption) protection_scheme = 0x63626373.
			 * </pre>
			 *
			 * <code>optional uint32 protection_scheme = 9;</code>
			 * 
			 * @return Whether the protectionScheme field is set.
			 */
			@java.lang.Override
			public boolean hasProtectionScheme() {
				return ((bitField0_ & 0x00000008) != 0);
			}

			/**
			 * <pre>
			 * Protection scheme identifying the encryption algorithm. The protection
			 * scheme is represented as a uint32 value. The uint32 contains 4 bytes each
			 * representing a single ascii character in one of the 4CC protection scheme
			 * values. To be deprecated in favor of signaling from content.
			 * 'cenc' (AES-CTR) protection_scheme = 0x63656E63,
			 * 'cbc1' (AES-CBC) protection_scheme = 0x63626331,
			 * 'cens' (AES-CTR pattern encryption) protection_scheme = 0x63656E73,
			 * 'cbcs' (AES-CBC pattern encryption) protection_scheme = 0x63626373.
			 * </pre>
			 *
			 * <code>optional uint32 protection_scheme = 9;</code>
			 * 
			 * @return The protectionScheme.
			 */
			@java.lang.Override
			public int getProtectionScheme() {
				return protectionScheme_;
			}

			/**
			 * <pre>
			 * Protection scheme identifying the encryption algorithm. The protection
			 * scheme is represented as a uint32 value. The uint32 contains 4 bytes each
			 * representing a single ascii character in one of the 4CC protection scheme
			 * values. To be deprecated in favor of signaling from content.
			 * 'cenc' (AES-CTR) protection_scheme = 0x63656E63,
			 * 'cbc1' (AES-CBC) protection_scheme = 0x63626331,
			 * 'cens' (AES-CTR pattern encryption) protection_scheme = 0x63656E73,
			 * 'cbcs' (AES-CBC pattern encryption) protection_scheme = 0x63626373.
			 * </pre>
			 *
			 * <code>optional uint32 protection_scheme = 9;</code>
			 * 
			 * @param value The protectionScheme to set.
			 * @return This builder for chaining.
			 */
			public Builder setProtectionScheme(int value) {

				protectionScheme_ = value;
				bitField0_ |= 0x00000008;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Protection scheme identifying the encryption algorithm. The protection
			 * scheme is represented as a uint32 value. The uint32 contains 4 bytes each
			 * representing a single ascii character in one of the 4CC protection scheme
			 * values. To be deprecated in favor of signaling from content.
			 * 'cenc' (AES-CTR) protection_scheme = 0x63656E63,
			 * 'cbc1' (AES-CBC) protection_scheme = 0x63626331,
			 * 'cens' (AES-CTR pattern encryption) protection_scheme = 0x63656E73,
			 * 'cbcs' (AES-CBC pattern encryption) protection_scheme = 0x63626373.
			 * </pre>
			 *
			 * <code>optional uint32 protection_scheme = 9;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearProtectionScheme() {
				bitField0_ = (bitField0_ & ~0x00000008);
				protectionScheme_ = 0;
				onChanged();
				return this;
			}

			private int cryptoPeriodSeconds_;

			/**
			 * <pre>
			 * Optional. For media using key rotation, this represents the duration
			 * of each crypto period in seconds.
			 * </pre>
			 *
			 * <code>optional uint32 crypto_period_seconds = 10;</code>
			 * 
			 * @return Whether the cryptoPeriodSeconds field is set.
			 */
			@java.lang.Override
			public boolean hasCryptoPeriodSeconds() {
				return ((bitField0_ & 0x00000010) != 0);
			}

			/**
			 * <pre>
			 * Optional. For media using key rotation, this represents the duration
			 * of each crypto period in seconds.
			 * </pre>
			 *
			 * <code>optional uint32 crypto_period_seconds = 10;</code>
			 * 
			 * @return The cryptoPeriodSeconds.
			 */
			@java.lang.Override
			public int getCryptoPeriodSeconds() {
				return cryptoPeriodSeconds_;
			}

			/**
			 * <pre>
			 * Optional. For media using key rotation, this represents the duration
			 * of each crypto period in seconds.
			 * </pre>
			 *
			 * <code>optional uint32 crypto_period_seconds = 10;</code>
			 * 
			 * @param value The cryptoPeriodSeconds to set.
			 * @return This builder for chaining.
			 */
			public Builder setCryptoPeriodSeconds(int value) {

				cryptoPeriodSeconds_ = value;
				bitField0_ |= 0x00000010;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Optional. For media using key rotation, this represents the duration
			 * of each crypto period in seconds.
			 * </pre>
			 *
			 * <code>optional uint32 crypto_period_seconds = 10;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearCryptoPeriodSeconds() {
				bitField0_ = (bitField0_ & ~0x00000010);
				cryptoPeriodSeconds_ = 0;
				onChanged();
				return this;
			}

			private int type_ = 0;

			/**
			 * <pre>
			 * Type of PSSH. Required if not SINGLE.
			 * </pre>
			 *
			 * <code>optional .WidevinePsshData.Type type = 11 [default = SINGLE];</code>
			 * 
			 * @return Whether the type field is set.
			 */
			@java.lang.Override
			public boolean hasType() {
				return ((bitField0_ & 0x00000020) != 0);
			}

			/**
			 * <pre>
			 * Type of PSSH. Required if not SINGLE.
			 * </pre>
			 *
			 * <code>optional .WidevinePsshData.Type type = 11 [default = SINGLE];</code>
			 * 
			 * @return The type.
			 */
			@java.lang.Override
			public WvProto2.WidevinePsshData.Type getType() {
				WvProto2.WidevinePsshData.Type result = WvProto2.WidevinePsshData.Type
						.forNumber(type_);
				return result == null ? WvProto2.WidevinePsshData.Type.SINGLE : result;
			}

			/**
			 * <pre>
			 * Type of PSSH. Required if not SINGLE.
			 * </pre>
			 *
			 * <code>optional .WidevinePsshData.Type type = 11 [default = SINGLE];</code>
			 * 
			 * @param value The type to set.
			 * @return This builder for chaining.
			 */
			public Builder setType(WvProto2.WidevinePsshData.Type value) {
				if (value == null) {
					throw new NullPointerException();
				}
				bitField0_ |= 0x00000020;
				type_ = value.getNumber();
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Type of PSSH. Required if not SINGLE.
			 * </pre>
			 *
			 * <code>optional .WidevinePsshData.Type type = 11 [default = SINGLE];</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearType() {
				bitField0_ = (bitField0_ & ~0x00000020);
				type_ = 0;
				onChanged();
				return this;
			}

			private int keySequence_;

			/**
			 * <pre>
			 * Key sequence for Widevine-managed keys. Optional.
			 * </pre>
			 *
			 * <code>optional uint32 key_sequence = 12;</code>
			 * 
			 * @return Whether the keySequence field is set.
			 */
			@java.lang.Override
			public boolean hasKeySequence() {
				return ((bitField0_ & 0x00000040) != 0);
			}

			/**
			 * <pre>
			 * Key sequence for Widevine-managed keys. Optional.
			 * </pre>
			 *
			 * <code>optional uint32 key_sequence = 12;</code>
			 * 
			 * @return The keySequence.
			 */
			@java.lang.Override
			public int getKeySequence() {
				return keySequence_;
			}

			/**
			 * <pre>
			 * Key sequence for Widevine-managed keys. Optional.
			 * </pre>
			 *
			 * <code>optional uint32 key_sequence = 12;</code>
			 * 
			 * @param value The keySequence to set.
			 * @return This builder for chaining.
			 */
			public Builder setKeySequence(int value) {

				keySequence_ = value;
				bitField0_ |= 0x00000040;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Key sequence for Widevine-managed keys. Optional.
			 * </pre>
			 *
			 * <code>optional uint32 key_sequence = 12;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearKeySequence() {
				bitField0_ = (bitField0_ & ~0x00000040);
				keySequence_ = 0;
				onChanged();
				return this;
			}

			private java.util.List<ByteString> groupIds_ = java.util.Collections.emptyList();

			private void ensureGroupIdsIsMutable() {
				if (!((bitField0_ & 0x00000080) != 0)) {
					groupIds_ = new java.util.ArrayList<>(groupIds_);
					bitField0_ |= 0x00000080;
				}
			}

			/**
			 * <pre>
			 * Group identifiers for all groups to which the content belongs. This can
			 * be used to deliver licenses to unlock multiple titles / channels.
			 * Optional, and may only be present in ENTITLEMENT and ENTITLED_KEY PSSHs, and
			 * not in conjunction with key_ids.
			 * </pre>
			 *
			 * <code>repeated bytes group_ids = 13;</code>
			 * 
			 * @return A list containing the groupIds.
			 */
			@Override
			public java.util.List<ByteString> getGroupIdsList() {
				return ((bitField0_ & 0x00000080) != 0) ? java.util.Collections.unmodifiableList(groupIds_) : groupIds_;
			}

			/**
			 * <pre>
			 * Group identifiers for all groups to which the content belongs. This can
			 * be used to deliver licenses to unlock multiple titles / channels.
			 * Optional, and may only be present in ENTITLEMENT and ENTITLED_KEY PSSHs, and
			 * not in conjunction with key_ids.
			 * </pre>
			 *
			 * <code>repeated bytes group_ids = 13;</code>
			 * 
			 * @return The count of groupIds.
			 */
			@Override
			public int getGroupIdsCount() {
				return groupIds_.size();
			}

			/**
			 * <pre>
			 * Group identifiers for all groups to which the content belongs. This can
			 * be used to deliver licenses to unlock multiple titles / channels.
			 * Optional, and may only be present in ENTITLEMENT and ENTITLED_KEY PSSHs, and
			 * not in conjunction with key_ids.
			 * </pre>
			 *
			 * <code>repeated bytes group_ids = 13;</code>
			 * 
			 * @param index The index of the element to return.
			 * @return The groupIds at the given index.
			 */
			@Override
			public ByteString getGroupIds(int index) {
				return groupIds_.get(index);
			}

			/**
			 * <pre>
			 * Group identifiers for all groups to which the content belongs. This can
			 * be used to deliver licenses to unlock multiple titles / channels.
			 * Optional, and may only be present in ENTITLEMENT and ENTITLED_KEY PSSHs, and
			 * not in conjunction with key_ids.
			 * </pre>
			 *
			 * <code>repeated bytes group_ids = 13;</code>
			 * 
			 * @param index The index to set the value at.
			 * @param value The groupIds to set.
			 * @return This builder for chaining.
			 */
			public Builder setGroupIds(int index, ByteString value) {
				if (value == null) {
					throw new NullPointerException();
				}
				ensureGroupIdsIsMutable();
				groupIds_.set(index, value);
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Group identifiers for all groups to which the content belongs. This can
			 * be used to deliver licenses to unlock multiple titles / channels.
			 * Optional, and may only be present in ENTITLEMENT and ENTITLED_KEY PSSHs, and
			 * not in conjunction with key_ids.
			 * </pre>
			 *
			 * <code>repeated bytes group_ids = 13;</code>
			 * 
			 * @param value The groupIds to add.
			 * @return This builder for chaining.
			 */
			public Builder addGroupIds(ByteString value) {
				if (value == null) {
					throw new NullPointerException();
				}
				ensureGroupIdsIsMutable();
				groupIds_.add(value);
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Group identifiers for all groups to which the content belongs. This can
			 * be used to deliver licenses to unlock multiple titles / channels.
			 * Optional, and may only be present in ENTITLEMENT and ENTITLED_KEY PSSHs, and
			 * not in conjunction with key_ids.
			 * </pre>
			 *
			 * <code>repeated bytes group_ids = 13;</code>
			 * 
			 * @param values The groupIds to add.
			 * @return This builder for chaining.
			 */
			public Builder addAllGroupIds(java.lang.Iterable<? extends ByteString> values) {
				ensureGroupIdsIsMutable();
				AbstractMessageLite.Builder.addAll(values, groupIds_);
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Group identifiers for all groups to which the content belongs. This can
			 * be used to deliver licenses to unlock multiple titles / channels.
			 * Optional, and may only be present in ENTITLEMENT and ENTITLED_KEY PSSHs, and
			 * not in conjunction with key_ids.
			 * </pre>
			 *
			 * <code>repeated bytes group_ids = 13;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearGroupIds() {
				groupIds_ = java.util.Collections.emptyList();
				bitField0_ = (bitField0_ & ~0x00000080);
				onChanged();
				return this;
			}

			private java.util.List<WvProto2.WidevinePsshData.EntitledKey> entitledKeys_ = java.util.Collections
					.emptyList();

			private void ensureEntitledKeysIsMutable() {
				if (!((bitField0_ & 0x00000100) != 0)) {
					entitledKeys_ = new java.util.ArrayList<>(entitledKeys_);
					bitField0_ |= 0x00000100;
				}
			}

			private RepeatedFieldBuilderV3<WvProto2.WidevinePsshData.EntitledKey, WvProto2.WidevinePsshData.EntitledKey.Builder, WvProto2.WidevinePsshData.EntitledKeyOrBuilder> entitledKeysBuilder_;

			/**
			 * <pre>
			 * Copy/copies of the content key used to decrypt the media stream in which
			 * the PSSH box is embedded, each wrapped with a different entitlement key.
			 * May also contain sub-licenses to support devices with OEMCrypto 13 or
			 * older. May be repeated if using group entitlement keys. Present only in
			 * PSSHs of type ENTITLED_KEY.
			 * </pre>
			 *
			 * <code>repeated .WidevinePsshData.EntitledKey entitled_keys = 14;</code>
			 */
			@Override
			public java.util.List<WvProto2.WidevinePsshData.EntitledKey> getEntitledKeysList() {
				if (entitledKeysBuilder_ == null) {
					return java.util.Collections.unmodifiableList(entitledKeys_);
				}
				return entitledKeysBuilder_.getMessageList();
			}

			/**
			 * <pre>
			 * Copy/copies of the content key used to decrypt the media stream in which
			 * the PSSH box is embedded, each wrapped with a different entitlement key.
			 * May also contain sub-licenses to support devices with OEMCrypto 13 or
			 * older. May be repeated if using group entitlement keys. Present only in
			 * PSSHs of type ENTITLED_KEY.
			 * </pre>
			 *
			 * <code>repeated .WidevinePsshData.EntitledKey entitled_keys = 14;</code>
			 */
			@Override
			public int getEntitledKeysCount() {
				if (entitledKeysBuilder_ == null) {
					return entitledKeys_.size();
				}
				return entitledKeysBuilder_.getCount();
			}

			/**
			 * <pre>
			 * Copy/copies of the content key used to decrypt the media stream in which
			 * the PSSH box is embedded, each wrapped with a different entitlement key.
			 * May also contain sub-licenses to support devices with OEMCrypto 13 or
			 * older. May be repeated if using group entitlement keys. Present only in
			 * PSSHs of type ENTITLED_KEY.
			 * </pre>
			 *
			 * <code>repeated .WidevinePsshData.EntitledKey entitled_keys = 14;</code>
			 */
			@Override
			public WvProto2.WidevinePsshData.EntitledKey getEntitledKeys(int index) {
				if (entitledKeysBuilder_ == null) {
					return entitledKeys_.get(index);
				}
				return entitledKeysBuilder_.getMessage(index);
			}

			/**
			 * <pre>
			 * Copy/copies of the content key used to decrypt the media stream in which
			 * the PSSH box is embedded, each wrapped with a different entitlement key.
			 * May also contain sub-licenses to support devices with OEMCrypto 13 or
			 * older. May be repeated if using group entitlement keys. Present only in
			 * PSSHs of type ENTITLED_KEY.
			 * </pre>
			 *
			 * <code>repeated .WidevinePsshData.EntitledKey entitled_keys = 14;</code>
			 */
			public Builder setEntitledKeys(int index,
					WvProto2.WidevinePsshData.EntitledKey value) {
				if (entitledKeysBuilder_ == null) {
					if (value == null) {
						throw new NullPointerException();
					}
					ensureEntitledKeysIsMutable();
					entitledKeys_.set(index, value);
					onChanged();
				} else {
					entitledKeysBuilder_.setMessage(index, value);
				}
				return this;
			}

			/**
			 * <pre>
			 * Copy/copies of the content key used to decrypt the media stream in which
			 * the PSSH box is embedded, each wrapped with a different entitlement key.
			 * May also contain sub-licenses to support devices with OEMCrypto 13 or
			 * older. May be repeated if using group entitlement keys. Present only in
			 * PSSHs of type ENTITLED_KEY.
			 * </pre>
			 *
			 * <code>repeated .WidevinePsshData.EntitledKey entitled_keys = 14;</code>
			 */
			public Builder setEntitledKeys(int index,
					WvProto2.WidevinePsshData.EntitledKey.Builder builderForValue) {
				if (entitledKeysBuilder_ == null) {
					ensureEntitledKeysIsMutable();
					entitledKeys_.set(index, builderForValue.build());
					onChanged();
				} else {
					entitledKeysBuilder_.setMessage(index, builderForValue.build());
				}
				return this;
			}

			/**
			 * <pre>
			 * Copy/copies of the content key used to decrypt the media stream in which
			 * the PSSH box is embedded, each wrapped with a different entitlement key.
			 * May also contain sub-licenses to support devices with OEMCrypto 13 or
			 * older. May be repeated if using group entitlement keys. Present only in
			 * PSSHs of type ENTITLED_KEY.
			 * </pre>
			 *
			 * <code>repeated .WidevinePsshData.EntitledKey entitled_keys = 14;</code>
			 */
			public Builder addEntitledKeys(WvProto2.WidevinePsshData.EntitledKey value) {
				if (entitledKeysBuilder_ == null) {
					if (value == null) {
						throw new NullPointerException();
					}
					ensureEntitledKeysIsMutable();
					entitledKeys_.add(value);
					onChanged();
				} else {
					entitledKeysBuilder_.addMessage(value);
				}
				return this;
			}

			/**
			 * <pre>
			 * Copy/copies of the content key used to decrypt the media stream in which
			 * the PSSH box is embedded, each wrapped with a different entitlement key.
			 * May also contain sub-licenses to support devices with OEMCrypto 13 or
			 * older. May be repeated if using group entitlement keys. Present only in
			 * PSSHs of type ENTITLED_KEY.
			 * </pre>
			 *
			 * <code>repeated .WidevinePsshData.EntitledKey entitled_keys = 14;</code>
			 */
			public Builder addEntitledKeys(int index,
					WvProto2.WidevinePsshData.EntitledKey value) {
				if (entitledKeysBuilder_ == null) {
					if (value == null) {
						throw new NullPointerException();
					}
					ensureEntitledKeysIsMutable();
					entitledKeys_.add(index, value);
					onChanged();
				} else {
					entitledKeysBuilder_.addMessage(index, value);
				}
				return this;
			}

			/**
			 * <pre>
			 * Copy/copies of the content key used to decrypt the media stream in which
			 * the PSSH box is embedded, each wrapped with a different entitlement key.
			 * May also contain sub-licenses to support devices with OEMCrypto 13 or
			 * older. May be repeated if using group entitlement keys. Present only in
			 * PSSHs of type ENTITLED_KEY.
			 * </pre>
			 *
			 * <code>repeated .WidevinePsshData.EntitledKey entitled_keys = 14;</code>
			 */
			public Builder addEntitledKeys(
					WvProto2.WidevinePsshData.EntitledKey.Builder builderForValue) {
				if (entitledKeysBuilder_ == null) {
					ensureEntitledKeysIsMutable();
					entitledKeys_.add(builderForValue.build());
					onChanged();
				} else {
					entitledKeysBuilder_.addMessage(builderForValue.build());
				}
				return this;
			}

			/**
			 * <pre>
			 * Copy/copies of the content key used to decrypt the media stream in which
			 * the PSSH box is embedded, each wrapped with a different entitlement key.
			 * May also contain sub-licenses to support devices with OEMCrypto 13 or
			 * older. May be repeated if using group entitlement keys. Present only in
			 * PSSHs of type ENTITLED_KEY.
			 * </pre>
			 *
			 * <code>repeated .WidevinePsshData.EntitledKey entitled_keys = 14;</code>
			 */
			public Builder addEntitledKeys(int index,
					WvProto2.WidevinePsshData.EntitledKey.Builder builderForValue) {
				if (entitledKeysBuilder_ == null) {
					ensureEntitledKeysIsMutable();
					entitledKeys_.add(index, builderForValue.build());
					onChanged();
				} else {
					entitledKeysBuilder_.addMessage(index, builderForValue.build());
				}
				return this;
			}

			/**
			 * <pre>
			 * Copy/copies of the content key used to decrypt the media stream in which
			 * the PSSH box is embedded, each wrapped with a different entitlement key.
			 * May also contain sub-licenses to support devices with OEMCrypto 13 or
			 * older. May be repeated if using group entitlement keys. Present only in
			 * PSSHs of type ENTITLED_KEY.
			 * </pre>
			 *
			 * <code>repeated .WidevinePsshData.EntitledKey entitled_keys = 14;</code>
			 */
			public Builder addAllEntitledKeys(
					java.lang.Iterable<? extends WvProto2.WidevinePsshData.EntitledKey> values) {
				if (entitledKeysBuilder_ == null) {
					ensureEntitledKeysIsMutable();
					AbstractMessageLite.Builder.addAll(values, entitledKeys_);
					onChanged();
				} else {
					entitledKeysBuilder_.addAllMessages(values);
				}
				return this;
			}

			/**
			 * <pre>
			 * Copy/copies of the content key used to decrypt the media stream in which
			 * the PSSH box is embedded, each wrapped with a different entitlement key.
			 * May also contain sub-licenses to support devices with OEMCrypto 13 or
			 * older. May be repeated if using group entitlement keys. Present only in
			 * PSSHs of type ENTITLED_KEY.
			 * </pre>
			 *
			 * <code>repeated .WidevinePsshData.EntitledKey entitled_keys = 14;</code>
			 */
			public Builder clearEntitledKeys() {
				if (entitledKeysBuilder_ == null) {
					entitledKeys_ = java.util.Collections.emptyList();
					bitField0_ = (bitField0_ & ~0x00000100);
					onChanged();
				} else {
					entitledKeysBuilder_.clear();
				}
				return this;
			}

			/**
			 * <pre>
			 * Copy/copies of the content key used to decrypt the media stream in which
			 * the PSSH box is embedded, each wrapped with a different entitlement key.
			 * May also contain sub-licenses to support devices with OEMCrypto 13 or
			 * older. May be repeated if using group entitlement keys. Present only in
			 * PSSHs of type ENTITLED_KEY.
			 * </pre>
			 *
			 * <code>repeated .WidevinePsshData.EntitledKey entitled_keys = 14;</code>
			 */
			public Builder removeEntitledKeys(int index) {
				if (entitledKeysBuilder_ == null) {
					ensureEntitledKeysIsMutable();
					entitledKeys_.remove(index);
					onChanged();
				} else {
					entitledKeysBuilder_.remove(index);
				}
				return this;
			}

			/**
			 * <pre>
			 * Copy/copies of the content key used to decrypt the media stream in which
			 * the PSSH box is embedded, each wrapped with a different entitlement key.
			 * May also contain sub-licenses to support devices with OEMCrypto 13 or
			 * older. May be repeated if using group entitlement keys. Present only in
			 * PSSHs of type ENTITLED_KEY.
			 * </pre>
			 *
			 * <code>repeated .WidevinePsshData.EntitledKey entitled_keys = 14;</code>
			 */
			public WvProto2.WidevinePsshData.EntitledKey.Builder getEntitledKeysBuilder(
					int index) {
				return getEntitledKeysFieldBuilder().getBuilder(index);
			}

			/**
			 * <pre>
			 * Copy/copies of the content key used to decrypt the media stream in which
			 * the PSSH box is embedded, each wrapped with a different entitlement key.
			 * May also contain sub-licenses to support devices with OEMCrypto 13 or
			 * older. May be repeated if using group entitlement keys. Present only in
			 * PSSHs of type ENTITLED_KEY.
			 * </pre>
			 *
			 * <code>repeated .WidevinePsshData.EntitledKey entitled_keys = 14;</code>
			 */
			@Override
			public WvProto2.WidevinePsshData.EntitledKeyOrBuilder getEntitledKeysOrBuilder(
					int index) {
				if (entitledKeysBuilder_ == null) {
					return entitledKeys_.get(index);
				}
				return entitledKeysBuilder_.getMessageOrBuilder(index);
			}

			/**
			 * <pre>
			 * Copy/copies of the content key used to decrypt the media stream in which
			 * the PSSH box is embedded, each wrapped with a different entitlement key.
			 * May also contain sub-licenses to support devices with OEMCrypto 13 or
			 * older. May be repeated if using group entitlement keys. Present only in
			 * PSSHs of type ENTITLED_KEY.
			 * </pre>
			 *
			 * <code>repeated .WidevinePsshData.EntitledKey entitled_keys = 14;</code>
			 */
			@Override
			public java.util.List<? extends WvProto2.WidevinePsshData.EntitledKeyOrBuilder> getEntitledKeysOrBuilderList() {
				if (entitledKeysBuilder_ != null) {
					return entitledKeysBuilder_.getMessageOrBuilderList();
				}
				return java.util.Collections.unmodifiableList(entitledKeys_);
			}

			/**
			 * <pre>
			 * Copy/copies of the content key used to decrypt the media stream in which
			 * the PSSH box is embedded, each wrapped with a different entitlement key.
			 * May also contain sub-licenses to support devices with OEMCrypto 13 or
			 * older. May be repeated if using group entitlement keys. Present only in
			 * PSSHs of type ENTITLED_KEY.
			 * </pre>
			 *
			 * <code>repeated .WidevinePsshData.EntitledKey entitled_keys = 14;</code>
			 */
			public WvProto2.WidevinePsshData.EntitledKey.Builder addEntitledKeysBuilder() {
				return getEntitledKeysFieldBuilder()
						.addBuilder(WvProto2.WidevinePsshData.EntitledKey.getDefaultInstance());
			}

			/**
			 * <pre>
			 * Copy/copies of the content key used to decrypt the media stream in which
			 * the PSSH box is embedded, each wrapped with a different entitlement key.
			 * May also contain sub-licenses to support devices with OEMCrypto 13 or
			 * older. May be repeated if using group entitlement keys. Present only in
			 * PSSHs of type ENTITLED_KEY.
			 * </pre>
			 *
			 * <code>repeated .WidevinePsshData.EntitledKey entitled_keys = 14;</code>
			 */
			public WvProto2.WidevinePsshData.EntitledKey.Builder addEntitledKeysBuilder(
					int index) {
				return getEntitledKeysFieldBuilder().addBuilder(index,
						WvProto2.WidevinePsshData.EntitledKey.getDefaultInstance());
			}

			/**
			 * <pre>
			 * Copy/copies of the content key used to decrypt the media stream in which
			 * the PSSH box is embedded, each wrapped with a different entitlement key.
			 * May also contain sub-licenses to support devices with OEMCrypto 13 or
			 * older. May be repeated if using group entitlement keys. Present only in
			 * PSSHs of type ENTITLED_KEY.
			 * </pre>
			 *
			 * <code>repeated .WidevinePsshData.EntitledKey entitled_keys = 14;</code>
			 */
			public java.util.List<WvProto2.WidevinePsshData.EntitledKey.Builder> getEntitledKeysBuilderList() {
				return getEntitledKeysFieldBuilder().getBuilderList();
			}

			private RepeatedFieldBuilderV3<WvProto2.WidevinePsshData.EntitledKey, WvProto2.WidevinePsshData.EntitledKey.Builder, WvProto2.WidevinePsshData.EntitledKeyOrBuilder> getEntitledKeysFieldBuilder() {
				if (entitledKeysBuilder_ == null) {
					entitledKeysBuilder_ = new RepeatedFieldBuilderV3<>(entitledKeys_, ((bitField0_ & 0x00000100) != 0),
							getParentForChildren(), isClean());
					entitledKeys_ = null;
				}
				return entitledKeysBuilder_;
			}

			private java.lang.Object videoFeature_ = "";

			/**
			 * <pre>
			 * Video feature identifier, which is used in conjunction with |content_id|
			 * to determine the set of keys to be returned in the license. Cannot be
			 * present in conjunction with |key_ids|.
			 * Current values are "HDR".
			 * </pre>
			 *
			 * <code>optional string video_feature = 15;</code>
			 * 
			 * @return Whether the videoFeature field is set.
			 */
			@Override
			public boolean hasVideoFeature() {
				return ((bitField0_ & 0x00000200) != 0);
			}

			/**
			 * <pre>
			 * Video feature identifier, which is used in conjunction with |content_id|
			 * to determine the set of keys to be returned in the license. Cannot be
			 * present in conjunction with |key_ids|.
			 * Current values are "HDR".
			 * </pre>
			 *
			 * <code>optional string video_feature = 15;</code>
			 * 
			 * @return The videoFeature.
			 */
			@Override
			public java.lang.String getVideoFeature() {
				java.lang.Object ref = videoFeature_;
				if (!(ref instanceof java.lang.String)) {
					ByteString bs = (ByteString) ref;
					java.lang.String s = bs.toStringUtf8();
					if (bs.isValidUtf8()) {
						videoFeature_ = s;
					}
					return s;
				}
				return (java.lang.String) ref;
			}

			/**
			 * <pre>
			 * Video feature identifier, which is used in conjunction with |content_id|
			 * to determine the set of keys to be returned in the license. Cannot be
			 * present in conjunction with |key_ids|.
			 * Current values are "HDR".
			 * </pre>
			 *
			 * <code>optional string video_feature = 15;</code>
			 * 
			 * @return The bytes for videoFeature.
			 */
			@Override
			public ByteString getVideoFeatureBytes() {
				java.lang.Object ref = videoFeature_;
				if (ref instanceof String) {
					ByteString b = ByteString.copyFromUtf8((java.lang.String) ref);
					videoFeature_ = b;
					return b;
				}
				return (ByteString) ref;
			}

			/**
			 * <pre>
			 * Video feature identifier, which is used in conjunction with |content_id|
			 * to determine the set of keys to be returned in the license. Cannot be
			 * present in conjunction with |key_ids|.
			 * Current values are "HDR".
			 * </pre>
			 *
			 * <code>optional string video_feature = 15;</code>
			 * 
			 * @param value The videoFeature to set.
			 * @return This builder for chaining.
			 */
			public Builder setVideoFeature(java.lang.String value) {
				if (value == null) {
					throw new NullPointerException();
				}
				videoFeature_ = value;
				bitField0_ |= 0x00000200;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Video feature identifier, which is used in conjunction with |content_id|
			 * to determine the set of keys to be returned in the license. Cannot be
			 * present in conjunction with |key_ids|.
			 * Current values are "HDR".
			 * </pre>
			 *
			 * <code>optional string video_feature = 15;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearVideoFeature() {
				videoFeature_ = getDefaultInstance().getVideoFeature();
				bitField0_ = (bitField0_ & ~0x00000200);
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Video feature identifier, which is used in conjunction with |content_id|
			 * to determine the set of keys to be returned in the license. Cannot be
			 * present in conjunction with |key_ids|.
			 * Current values are "HDR".
			 * </pre>
			 *
			 * <code>optional string video_feature = 15;</code>
			 * 
			 * @param value The bytes for videoFeature to set.
			 * @return This builder for chaining.
			 */
			public Builder setVideoFeatureBytes(ByteString value) {
				if (value == null) {
					throw new NullPointerException();
				}
				videoFeature_ = value;
				bitField0_ |= 0x00000200;
				onChanged();
				return this;
			}

			private int algorithm_ = 0;

			/**
			 * <code>optional .WidevinePsshData.Algorithm algorithm = 1 [deprecated = true];</code>
			 * 
			 * @deprecated WidevinePsshData.algorithm is deprecated. See
			 *             wv_proto2.proto;l=720
			 * @return Whether the algorithm field is set.
			 */
			@java.lang.Override
			@java.lang.Deprecated
			public boolean hasAlgorithm() {
				return ((bitField0_ & 0x00000400) != 0);
			}

			/**
			 * <code>optional .WidevinePsshData.Algorithm algorithm = 1 [deprecated = true];</code>
			 * 
			 * @deprecated WidevinePsshData.algorithm is deprecated. See
			 *             wv_proto2.proto;l=720
			 * @return The algorithm.
			 */
			@java.lang.Override
			@java.lang.Deprecated
			public WvProto2.WidevinePsshData.Algorithm getAlgorithm() {
				WvProto2.WidevinePsshData.Algorithm result = WvProto2.WidevinePsshData.Algorithm
						.forNumber(algorithm_);
				return result == null ? WvProto2.WidevinePsshData.Algorithm.UNENCRYPTED
						: result;
			}

			/**
			 * <code>optional .WidevinePsshData.Algorithm algorithm = 1 [deprecated = true];</code>
			 * 
			 * @deprecated WidevinePsshData.algorithm is deprecated. See
			 *             wv_proto2.proto;l=720
			 * @param value The algorithm to set.
			 * @return This builder for chaining.
			 */
			@java.lang.Deprecated
			public Builder setAlgorithm(WvProto2.WidevinePsshData.Algorithm value) {
				if (value == null) {
					throw new NullPointerException();
				}
				bitField0_ |= 0x00000400;
				algorithm_ = value.getNumber();
				onChanged();
				return this;
			}

			/**
			 * <code>optional .WidevinePsshData.Algorithm algorithm = 1 [deprecated = true];</code>
			 * 
			 * @deprecated WidevinePsshData.algorithm is deprecated. See
			 *             wv_proto2.proto;l=720
			 * @return This builder for chaining.
			 */
			@java.lang.Deprecated
			public Builder clearAlgorithm() {
				bitField0_ = (bitField0_ & ~0x00000400);
				algorithm_ = 0;
				onChanged();
				return this;
			}

			private java.lang.Object provider_ = "";

			/**
			 * <pre>
			 * Content provider name.
			 * </pre>
			 *
			 * <code>optional string provider = 3 [deprecated = true];</code>
			 * 
			 * @deprecated WidevinePsshData.provider is deprecated. See
			 *             wv_proto2.proto;l=723
			 * @return Whether the provider field is set.
			 */
			@Override
			@java.lang.Deprecated
			public boolean hasProvider() {
				return ((bitField0_ & 0x00000800) != 0);
			}

			/**
			 * <pre>
			 * Content provider name.
			 * </pre>
			 *
			 * <code>optional string provider = 3 [deprecated = true];</code>
			 * 
			 * @deprecated WidevinePsshData.provider is deprecated. See
			 *             wv_proto2.proto;l=723
			 * @return The provider.
			 */
			@Override
			@java.lang.Deprecated
			public java.lang.String getProvider() {
				java.lang.Object ref = provider_;
				if (!(ref instanceof java.lang.String)) {
					ByteString bs = (ByteString) ref;
					java.lang.String s = bs.toStringUtf8();
					if (bs.isValidUtf8()) {
						provider_ = s;
					}
					return s;
				}
				return (java.lang.String) ref;
			}

			/**
			 * <pre>
			 * Content provider name.
			 * </pre>
			 *
			 * <code>optional string provider = 3 [deprecated = true];</code>
			 * 
			 * @deprecated WidevinePsshData.provider is deprecated. See
			 *             wv_proto2.proto;l=723
			 * @return The bytes for provider.
			 */
			@Override
			@java.lang.Deprecated
			public ByteString getProviderBytes() {
				java.lang.Object ref = provider_;
				if (ref instanceof String) {
					ByteString b = ByteString.copyFromUtf8((java.lang.String) ref);
					provider_ = b;
					return b;
				}
				return (ByteString) ref;
			}

			/**
			 * <pre>
			 * Content provider name.
			 * </pre>
			 *
			 * <code>optional string provider = 3 [deprecated = true];</code>
			 * 
			 * @deprecated WidevinePsshData.provider is deprecated. See
			 *             wv_proto2.proto;l=723
			 * @param value The provider to set.
			 * @return This builder for chaining.
			 */
			@java.lang.Deprecated
			public Builder setProvider(java.lang.String value) {
				if (value == null) {
					throw new NullPointerException();
				}
				provider_ = value;
				bitField0_ |= 0x00000800;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Content provider name.
			 * </pre>
			 *
			 * <code>optional string provider = 3 [deprecated = true];</code>
			 * 
			 * @deprecated WidevinePsshData.provider is deprecated. See
			 *             wv_proto2.proto;l=723
			 * @return This builder for chaining.
			 */
			@java.lang.Deprecated
			public Builder clearProvider() {
				provider_ = getDefaultInstance().getProvider();
				bitField0_ = (bitField0_ & ~0x00000800);
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Content provider name.
			 * </pre>
			 *
			 * <code>optional string provider = 3 [deprecated = true];</code>
			 * 
			 * @deprecated WidevinePsshData.provider is deprecated. See
			 *             wv_proto2.proto;l=723
			 * @param value The bytes for provider to set.
			 * @return This builder for chaining.
			 */
			@java.lang.Deprecated
			public Builder setProviderBytes(ByteString value) {
				if (value == null) {
					throw new NullPointerException();
				}
				provider_ = value;
				bitField0_ |= 0x00000800;
				onChanged();
				return this;
			}

			private java.lang.Object trackType_ = "";

			/**
			 * <pre>
			 * Track type. Acceptable values are SD, HD and AUDIO. Used to
			 * differentiate content keys used by an asset.
			 * </pre>
			 *
			 * <code>optional string track_type = 5 [deprecated = true];</code>
			 * 
			 * @deprecated WidevinePsshData.track_type is deprecated. See
			 *             wv_proto2.proto;l=727
			 * @return Whether the trackType field is set.
			 */
			@Override
			@java.lang.Deprecated
			public boolean hasTrackType() {
				return ((bitField0_ & 0x00001000) != 0);
			}

			/**
			 * <pre>
			 * Track type. Acceptable values are SD, HD and AUDIO. Used to
			 * differentiate content keys used by an asset.
			 * </pre>
			 *
			 * <code>optional string track_type = 5 [deprecated = true];</code>
			 * 
			 * @deprecated WidevinePsshData.track_type is deprecated. See
			 *             wv_proto2.proto;l=727
			 * @return The trackType.
			 */
			@Override
			@java.lang.Deprecated
			public java.lang.String getTrackType() {
				java.lang.Object ref = trackType_;
				if (!(ref instanceof java.lang.String)) {
					ByteString bs = (ByteString) ref;
					java.lang.String s = bs.toStringUtf8();
					if (bs.isValidUtf8()) {
						trackType_ = s;
					}
					return s;
				}
				return (java.lang.String) ref;
			}

			/**
			 * <pre>
			 * Track type. Acceptable values are SD, HD and AUDIO. Used to
			 * differentiate content keys used by an asset.
			 * </pre>
			 *
			 * <code>optional string track_type = 5 [deprecated = true];</code>
			 * 
			 * @deprecated WidevinePsshData.track_type is deprecated. See
			 *             wv_proto2.proto;l=727
			 * @return The bytes for trackType.
			 */
			@Override
			@java.lang.Deprecated
			public ByteString getTrackTypeBytes() {
				java.lang.Object ref = trackType_;
				if (ref instanceof String) {
					ByteString b = ByteString.copyFromUtf8((java.lang.String) ref);
					trackType_ = b;
					return b;
				}
				return (ByteString) ref;
			}

			/**
			 * <pre>
			 * Track type. Acceptable values are SD, HD and AUDIO. Used to
			 * differentiate content keys used by an asset.
			 * </pre>
			 *
			 * <code>optional string track_type = 5 [deprecated = true];</code>
			 * 
			 * @deprecated WidevinePsshData.track_type is deprecated. See
			 *             wv_proto2.proto;l=727
			 * @param value The trackType to set.
			 * @return This builder for chaining.
			 */
			@java.lang.Deprecated
			public Builder setTrackType(java.lang.String value) {
				if (value == null) {
					throw new NullPointerException();
				}
				trackType_ = value;
				bitField0_ |= 0x00001000;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Track type. Acceptable values are SD, HD and AUDIO. Used to
			 * differentiate content keys used by an asset.
			 * </pre>
			 *
			 * <code>optional string track_type = 5 [deprecated = true];</code>
			 * 
			 * @deprecated WidevinePsshData.track_type is deprecated. See
			 *             wv_proto2.proto;l=727
			 * @return This builder for chaining.
			 */
			@java.lang.Deprecated
			public Builder clearTrackType() {
				trackType_ = getDefaultInstance().getTrackType();
				bitField0_ = (bitField0_ & ~0x00001000);
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Track type. Acceptable values are SD, HD and AUDIO. Used to
			 * differentiate content keys used by an asset.
			 * </pre>
			 *
			 * <code>optional string track_type = 5 [deprecated = true];</code>
			 * 
			 * @deprecated WidevinePsshData.track_type is deprecated. See
			 *             wv_proto2.proto;l=727
			 * @param value The bytes for trackType to set.
			 * @return This builder for chaining.
			 */
			@java.lang.Deprecated
			public Builder setTrackTypeBytes(ByteString value) {
				if (value == null) {
					throw new NullPointerException();
				}
				trackType_ = value;
				bitField0_ |= 0x00001000;
				onChanged();
				return this;
			}

			private java.lang.Object policy_ = "";

			/**
			 * <pre>
			 * The name of a registered policy to be used for this asset.
			 * </pre>
			 *
			 * <code>optional string policy = 6 [deprecated = true];</code>
			 * 
			 * @deprecated WidevinePsshData.policy is deprecated. See wv_proto2.proto;l=730
			 * @return Whether the policy field is set.
			 */
			@Override
			@java.lang.Deprecated
			public boolean hasPolicy() {
				return ((bitField0_ & 0x00002000) != 0);
			}

			/**
			 * <pre>
			 * The name of a registered policy to be used for this asset.
			 * </pre>
			 *
			 * <code>optional string policy = 6 [deprecated = true];</code>
			 * 
			 * @deprecated WidevinePsshData.policy is deprecated. See wv_proto2.proto;l=730
			 * @return The policy.
			 */
			@Override
			@java.lang.Deprecated
			public java.lang.String getPolicy() {
				java.lang.Object ref = policy_;
				if (!(ref instanceof java.lang.String)) {
					ByteString bs = (ByteString) ref;
					java.lang.String s = bs.toStringUtf8();
					if (bs.isValidUtf8()) {
						policy_ = s;
					}
					return s;
				}
				return (java.lang.String) ref;
			}

			/**
			 * <pre>
			 * The name of a registered policy to be used for this asset.
			 * </pre>
			 *
			 * <code>optional string policy = 6 [deprecated = true];</code>
			 * 
			 * @deprecated WidevinePsshData.policy is deprecated. See wv_proto2.proto;l=730
			 * @return The bytes for policy.
			 */
			@Override
			@java.lang.Deprecated
			public ByteString getPolicyBytes() {
				java.lang.Object ref = policy_;
				if (ref instanceof String) {
					ByteString b = ByteString.copyFromUtf8((java.lang.String) ref);
					policy_ = b;
					return b;
				}
				return (ByteString) ref;
			}

			/**
			 * <pre>
			 * The name of a registered policy to be used for this asset.
			 * </pre>
			 *
			 * <code>optional string policy = 6 [deprecated = true];</code>
			 * 
			 * @deprecated WidevinePsshData.policy is deprecated. See wv_proto2.proto;l=730
			 * @param value The policy to set.
			 * @return This builder for chaining.
			 */
			@java.lang.Deprecated
			public Builder setPolicy(java.lang.String value) {
				if (value == null) {
					throw new NullPointerException();
				}
				policy_ = value;
				bitField0_ |= 0x00002000;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * The name of a registered policy to be used for this asset.
			 * </pre>
			 *
			 * <code>optional string policy = 6 [deprecated = true];</code>
			 * 
			 * @deprecated WidevinePsshData.policy is deprecated. See wv_proto2.proto;l=730
			 * @return This builder for chaining.
			 */
			@java.lang.Deprecated
			public Builder clearPolicy() {
				policy_ = getDefaultInstance().getPolicy();
				bitField0_ = (bitField0_ & ~0x00002000);
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * The name of a registered policy to be used for this asset.
			 * </pre>
			 *
			 * <code>optional string policy = 6 [deprecated = true];</code>
			 * 
			 * @deprecated WidevinePsshData.policy is deprecated. See wv_proto2.proto;l=730
			 * @param value The bytes for policy to set.
			 * @return This builder for chaining.
			 */
			@java.lang.Deprecated
			public Builder setPolicyBytes(ByteString value) {
				if (value == null) {
					throw new NullPointerException();
				}
				policy_ = value;
				bitField0_ |= 0x00002000;
				onChanged();
				return this;
			}

			private ByteString groupedLicense_ = ByteString.EMPTY;

			/**
			 * <pre>
			 * Optional protected context for group content. The grouped_license is a
			 * serialized SignedMessage.
			 * </pre>
			 *
			 * <code>optional bytes grouped_license = 8 [deprecated = true];</code>
			 * 
			 * @deprecated WidevinePsshData.grouped_license is deprecated. See
			 *             wv_proto2.proto;l=734
			 * @return Whether the groupedLicense field is set.
			 */
			@java.lang.Override
			@java.lang.Deprecated
			public boolean hasGroupedLicense() {
				return ((bitField0_ & 0x00004000) != 0);
			}

			/**
			 * <pre>
			 * Optional protected context for group content. The grouped_license is a
			 * serialized SignedMessage.
			 * </pre>
			 *
			 * <code>optional bytes grouped_license = 8 [deprecated = true];</code>
			 * 
			 * @deprecated WidevinePsshData.grouped_license is deprecated. See
			 *             wv_proto2.proto;l=734
			 * @return The groupedLicense.
			 */
			@java.lang.Override
			@java.lang.Deprecated
			public ByteString getGroupedLicense() {
				return groupedLicense_;
			}

			/**
			 * <pre>
			 * Optional protected context for group content. The grouped_license is a
			 * serialized SignedMessage.
			 * </pre>
			 *
			 * <code>optional bytes grouped_license = 8 [deprecated = true];</code>
			 * 
			 * @deprecated WidevinePsshData.grouped_license is deprecated. See
			 *             wv_proto2.proto;l=734
			 * @param value The groupedLicense to set.
			 * @return This builder for chaining.
			 */
			@java.lang.Deprecated
			public Builder setGroupedLicense(ByteString value) {
				if (value == null) {
					throw new NullPointerException();
				}
				groupedLicense_ = value;
				bitField0_ |= 0x00004000;
				onChanged();
				return this;
			}

			/**
			 * <pre>
			 * Optional protected context for group content. The grouped_license is a
			 * serialized SignedMessage.
			 * </pre>
			 *
			 * <code>optional bytes grouped_license = 8 [deprecated = true];</code>
			 * 
			 * @deprecated WidevinePsshData.grouped_license is deprecated. See
			 *             wv_proto2.proto;l=734
			 * @return This builder for chaining.
			 */
			@java.lang.Deprecated
			public Builder clearGroupedLicense() {
				bitField0_ = (bitField0_ & ~0x00004000);
				groupedLicense_ = getDefaultInstance().getGroupedLicense();
				onChanged();
				return this;
			}

			@java.lang.Override
			public final Builder setUnknownFields(final UnknownFieldSet unknownFields) {
				return super.setUnknownFields(unknownFields);
			}

			@java.lang.Override
			public final Builder mergeUnknownFields(final UnknownFieldSet unknownFields) {
				return super.mergeUnknownFields(unknownFields);
			}

			// @@protoc_insertion_point(builder_scope:WidevinePsshData)
		}

		// @@protoc_insertion_point(class_scope:WidevinePsshData)
		private static final WvProto2.WidevinePsshData DEFAULT_INSTANCE;
		static {
			DEFAULT_INSTANCE = new WvProto2.WidevinePsshData();
		}

		public static WvProto2.WidevinePsshData getDefaultInstance() {
			return DEFAULT_INSTANCE;
		}

		@java.lang.Deprecated public static final Parser<WidevinePsshData> PARSER = new AbstractParser<>() {
			@java.lang.Override
			public WidevinePsshData parsePartialFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
					throws InvalidProtocolBufferException {
				Builder builder = newBuilder();
				try {
					builder.mergeFrom(input, extensionRegistry);
				} catch (InvalidProtocolBufferException e) {
					throw e.setUnfinishedMessage(builder.buildPartial());
				} catch (UninitializedMessageException e) {
					throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
				} catch (java.io.IOException e) {
					throw new InvalidProtocolBufferException(e).setUnfinishedMessage(builder.buildPartial());
				}
				return builder.buildPartial();
			}
		};

		public static Parser<WidevinePsshData> parser() {
			return PARSER;
		}

		@java.lang.Override
		public Parser<WidevinePsshData> getParserForType() {
			return PARSER;
		}

		@java.lang.Override
		public WvProto2.WidevinePsshData getDefaultInstanceForType() {
			return DEFAULT_INSTANCE;
		}

	}

	public interface FileHashesOrBuilder extends
			// @@protoc_insertion_point(interface_extends:FileHashes)
			MessageOrBuilder {

		/**
		 * <code>optional bytes signer = 1;</code>
		 * 
		 * @return Whether the signer field is set.
		 */
		boolean hasSigner();

		/**
		 * <code>optional bytes signer = 1;</code>
		 * 
		 * @return The signer.
		 */
		ByteString getSigner();

		/**
		 * <code>repeated .FileHashes.Signature signatures = 2;</code>
		 */
		java.util.List<WvProto2.FileHashes.Signature> getSignaturesList();

		/**
		 * <code>repeated .FileHashes.Signature signatures = 2;</code>
		 */
		WvProto2.FileHashes.Signature getSignatures(int index);

		/**
		 * <code>repeated .FileHashes.Signature signatures = 2;</code>
		 */
		int getSignaturesCount();

		/**
		 * <code>repeated .FileHashes.Signature signatures = 2;</code>
		 */
		java.util.List<? extends WvProto2.FileHashes.SignatureOrBuilder> getSignaturesOrBuilderList();

		/**
		 * <code>repeated .FileHashes.Signature signatures = 2;</code>
		 */
		WvProto2.FileHashes.SignatureOrBuilder getSignaturesOrBuilder(int index);
	}

	/**
	 * <pre>
	 * File Hashes for Verified Media Path (VMP) support.
	 * </pre>
	 *
	 * Protobuf type {@code FileHashes}
	 */
	public static final class FileHashes extends GeneratedMessageV3 implements
			// @@protoc_insertion_point(message_implements:FileHashes)
			FileHashesOrBuilder {
		private static final long serialVersionUID = 0L;

		// Use FileHashes.newBuilder() to construct.
		private FileHashes(GeneratedMessageV3.Builder<?> builder) {
			super(builder);
		}

		private FileHashes() {
			signer_ = ByteString.EMPTY;
			signatures_ = java.util.Collections.emptyList();
		}

		@java.lang.Override

		protected java.lang.Object newInstance(UnusedPrivateParameter unused) {
			return new FileHashes();
		}

		public static final Descriptors.Descriptor getDescriptor() {
			return WvProto2.internal_static_FileHashes_descriptor;
		}

		@java.lang.Override
		protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
			return WvProto2.internal_static_FileHashes_fieldAccessorTable
					.ensureFieldAccessorsInitialized(WvProto2.FileHashes.class,
							WvProto2.FileHashes.Builder.class);
		}

		public interface SignatureOrBuilder extends
				// @@protoc_insertion_point(interface_extends:FileHashes.Signature)
				MessageOrBuilder {

			/**
			 * <code>optional string filename = 1;</code>
			 * 
			 * @return Whether the filename field is set.
			 */
			boolean hasFilename();

			/**
			 * <code>optional string filename = 1;</code>
			 * 
			 * @return The filename.
			 */
			java.lang.String getFilename();

			/**
			 * <code>optional string filename = 1;</code>
			 * 
			 * @return The bytes for filename.
			 */
			ByteString getFilenameBytes();

			/**
			 * <pre>
			 *0 - release, 1 - testing
			 * </pre>
			 *
			 * <code>optional bool test_signing = 2;</code>
			 * 
			 * @return Whether the testSigning field is set.
			 */
			boolean hasTestSigning();

			/**
			 * <pre>
			 *0 - release, 1 - testing
			 * </pre>
			 *
			 * <code>optional bool test_signing = 2;</code>
			 * 
			 * @return The testSigning.
			 */
			boolean getTestSigning();

			/**
			 * <code>optional bytes SHA512Hash = 3;</code>
			 * 
			 * @return Whether the sHA512Hash field is set.
			 */
			boolean hasSHA512Hash();

			/**
			 * <code>optional bytes SHA512Hash = 3;</code>
			 * 
			 * @return The sHA512Hash.
			 */
			ByteString getSHA512Hash();

			/**
			 * <pre>
			 *0 for dlls, 1 for exe, this is field 3 in file
			 * </pre>
			 *
			 * <code>optional bool main_exe = 4;</code>
			 * 
			 * @return Whether the mainExe field is set.
			 */
			boolean hasMainExe();

			/**
			 * <pre>
			 *0 for dlls, 1 for exe, this is field 3 in file
			 * </pre>
			 *
			 * <code>optional bool main_exe = 4;</code>
			 * 
			 * @return The mainExe.
			 */
			boolean getMainExe();

			/**
			 * <code>optional bytes signature = 5;</code>
			 * 
			 * @return Whether the signature field is set.
			 */
			boolean hasSignature();

			/**
			 * <code>optional bytes signature = 5;</code>
			 * 
			 * @return The signature.
			 */
			ByteString getSignature();
		}

		/**
		 * Protobuf type {@code FileHashes.Signature}
		 */
		public static final class Signature extends GeneratedMessageV3 implements
				// @@protoc_insertion_point(message_implements:FileHashes.Signature)
				SignatureOrBuilder {
			private static final long serialVersionUID = 0L;

			// Use Signature.newBuilder() to construct.
			private Signature(GeneratedMessageV3.Builder<?> builder) {
				super(builder);
			}

			private Signature() {
				filename_ = "";
				sHA512Hash_ = ByteString.EMPTY;
				signature_ = ByteString.EMPTY;
			}

			@java.lang.Override

			protected java.lang.Object newInstance(UnusedPrivateParameter unused) {
				return new Signature();
			}

			public static final Descriptors.Descriptor getDescriptor() {
				return WvProto2.internal_static_FileHashes_Signature_descriptor;
			}

			@java.lang.Override
			protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
				return WvProto2.internal_static_FileHashes_Signature_fieldAccessorTable
						.ensureFieldAccessorsInitialized(WvProto2.FileHashes.Signature.class,
								WvProto2.FileHashes.Signature.Builder.class);
			}

			private int bitField0_;
			public static final int FILENAME_FIELD_NUMBER = 1;

			private volatile java.lang.Object filename_ = "";

			/**
			 * <code>optional string filename = 1;</code>
			 * 
			 * @return Whether the filename field is set.
			 */
			@java.lang.Override
			public boolean hasFilename() {
				return ((bitField0_ & 0x00000001) != 0);
			}

			/**
			 * <code>optional string filename = 1;</code>
			 * 
			 * @return The filename.
			 */
			@java.lang.Override
			public java.lang.String getFilename() {
				java.lang.Object ref = filename_;
				if (ref instanceof java.lang.String) {
					return (java.lang.String) ref;
				}
				ByteString bs = (ByteString) ref;
				java.lang.String s = bs.toStringUtf8();
				if (bs.isValidUtf8()) {
					filename_ = s;
				}
				return s;
			}

			/**
			 * <code>optional string filename = 1;</code>
			 * 
			 * @return The bytes for filename.
			 */
			@java.lang.Override
			public ByteString getFilenameBytes() {
				java.lang.Object ref = filename_;
				if (ref instanceof java.lang.String) {
					ByteString b = ByteString.copyFromUtf8((java.lang.String) ref);
					filename_ = b;
					return b;
				}
				return (ByteString) ref;
			}

			public static final int TEST_SIGNING_FIELD_NUMBER = 2;
			private boolean testSigning_ = false;

			/**
			 * <pre>
			 *0 - release, 1 - testing
			 * </pre>
			 *
			 * <code>optional bool test_signing = 2;</code>
			 * 
			 * @return Whether the testSigning field is set.
			 */
			@java.lang.Override
			public boolean hasTestSigning() {
				return ((bitField0_ & 0x00000002) != 0);
			}

			/**
			 * <pre>
			 *0 - release, 1 - testing
			 * </pre>
			 *
			 * <code>optional bool test_signing = 2;</code>
			 * 
			 * @return The testSigning.
			 */
			@java.lang.Override
			public boolean getTestSigning() {
				return testSigning_;
			}

			public static final int SHA512HASH_FIELD_NUMBER = 3;
			private ByteString sHA512Hash_ = ByteString.EMPTY;

			/**
			 * <code>optional bytes SHA512Hash = 3;</code>
			 * 
			 * @return Whether the sHA512Hash field is set.
			 */
			@java.lang.Override
			public boolean hasSHA512Hash() {
				return ((bitField0_ & 0x00000004) != 0);
			}

			/**
			 * <code>optional bytes SHA512Hash = 3;</code>
			 * 
			 * @return The sHA512Hash.
			 */
			@java.lang.Override
			public ByteString getSHA512Hash() {
				return sHA512Hash_;
			}

			public static final int MAIN_EXE_FIELD_NUMBER = 4;
			private boolean mainExe_ = false;

			/**
			 * <pre>
			 *0 for dlls, 1 for exe, this is field 3 in file
			 * </pre>
			 *
			 * <code>optional bool main_exe = 4;</code>
			 * 
			 * @return Whether the mainExe field is set.
			 */
			@java.lang.Override
			public boolean hasMainExe() {
				return ((bitField0_ & 0x00000008) != 0);
			}

			/**
			 * <pre>
			 *0 for dlls, 1 for exe, this is field 3 in file
			 * </pre>
			 *
			 * <code>optional bool main_exe = 4;</code>
			 * 
			 * @return The mainExe.
			 */
			@java.lang.Override
			public boolean getMainExe() {
				return mainExe_;
			}

			public static final int SIGNATURE_FIELD_NUMBER = 5;
			private ByteString signature_ = ByteString.EMPTY;

			/**
			 * <code>optional bytes signature = 5;</code>
			 * 
			 * @return Whether the signature field is set.
			 */
			@java.lang.Override
			public boolean hasSignature() {
				return ((bitField0_ & 0x00000010) != 0);
			}

			/**
			 * <code>optional bytes signature = 5;</code>
			 * 
			 * @return The signature.
			 */
			@java.lang.Override
			public ByteString getSignature() {
				return signature_;
			}

			private byte memoizedIsInitialized = -1;

			@java.lang.Override
			public final boolean isInitialized() {
				byte isInitialized = memoizedIsInitialized;
				if (isInitialized == 1)
					return true;
				if (isInitialized == 0)
					return false;

				memoizedIsInitialized = 1;
				return true;
			}

			@java.lang.Override
			public void writeTo(CodedOutputStream output) throws java.io.IOException {
				if (((bitField0_ & 0x00000001) != 0)) {
					GeneratedMessageV3.writeString(output, 1, filename_);
				}
				if (((bitField0_ & 0x00000002) != 0)) {
					output.writeBool(2, testSigning_);
				}
				if (((bitField0_ & 0x00000004) != 0)) {
					output.writeBytes(3, sHA512Hash_);
				}
				if (((bitField0_ & 0x00000008) != 0)) {
					output.writeBool(4, mainExe_);
				}
				if (((bitField0_ & 0x00000010) != 0)) {
					output.writeBytes(5, signature_);
				}
				getUnknownFields().writeTo(output);
			}

			@java.lang.Override
			public int getSerializedSize() {
				int size = memoizedSize;
				if (size != -1)
					return size;

				size = 0;
				if (((bitField0_ & 0x00000001) != 0)) {
					size += GeneratedMessageV3.computeStringSize(1, filename_);
				}
				if (((bitField0_ & 0x00000002) != 0)) {
					size += CodedOutputStream.computeBoolSize(2, testSigning_);
				}
				if (((bitField0_ & 0x00000004) != 0)) {
					size += CodedOutputStream.computeBytesSize(3, sHA512Hash_);
				}
				if (((bitField0_ & 0x00000008) != 0)) {
					size += CodedOutputStream.computeBoolSize(4, mainExe_);
				}
				if (((bitField0_ & 0x00000010) != 0)) {
					size += CodedOutputStream.computeBytesSize(5, signature_);
				}
				size += getUnknownFields().getSerializedSize();
				memoizedSize = size;
				return size;
			}

			@java.lang.Override
			public boolean equals(final java.lang.Object obj) {
				if (obj == this) {
					return true;
				}
				if (!(obj instanceof WvProto2.FileHashes.Signature)) {
					return super.equals(obj);
				}
				WvProto2.FileHashes.Signature other = (WvProto2.FileHashes.Signature) obj;

				if (hasFilename() != other.hasFilename())
					return false;
				if (hasFilename()) {
					if (!getFilename().equals(other.getFilename()))
						return false;
				}
				if (hasTestSigning() != other.hasTestSigning())
					return false;
				if (hasTestSigning()) {
					if (getTestSigning() != other.getTestSigning())
						return false;
				}
				if (hasSHA512Hash() != other.hasSHA512Hash())
					return false;
				if (hasSHA512Hash()) {
					if (!getSHA512Hash().equals(other.getSHA512Hash()))
						return false;
				}
				if (hasMainExe() != other.hasMainExe())
					return false;
				if (hasMainExe()) {
					if (getMainExe() != other.getMainExe())
						return false;
				}
				if (hasSignature() != other.hasSignature())
					return false;
				if (hasSignature()) {
					if (!getSignature().equals(other.getSignature()))
						return false;
				}
				if (!getUnknownFields().equals(other.getUnknownFields()))
					return false;
				return true;
			}

			@SuppressWarnings("unchecked")
			@java.lang.Override
			public int hashCode() {
				if (memoizedHashCode != 0) {
					return memoizedHashCode;
				}
				int hash = 41;
				hash = (19 * hash) + getDescriptor().hashCode();
				if (hasFilename()) {
					hash = (37 * hash) + FILENAME_FIELD_NUMBER;
					hash = (53 * hash) + getFilename().hashCode();
				}
				if (hasTestSigning()) {
					hash = (37 * hash) + TEST_SIGNING_FIELD_NUMBER;
					hash = (53 * hash) + Internal.hashBoolean(getTestSigning());
				}
				if (hasSHA512Hash()) {
					hash = (37 * hash) + SHA512HASH_FIELD_NUMBER;
					hash = (53 * hash) + getSHA512Hash().hashCode();
				}
				if (hasMainExe()) {
					hash = (37 * hash) + MAIN_EXE_FIELD_NUMBER;
					hash = (53 * hash) + Internal.hashBoolean(getMainExe());
				}
				if (hasSignature()) {
					hash = (37 * hash) + SIGNATURE_FIELD_NUMBER;
					hash = (53 * hash) + getSignature().hashCode();
				}
				hash = (29 * hash) + getUnknownFields().hashCode();
				memoizedHashCode = hash;
				return hash;
			}

			public static WvProto2.FileHashes.Signature parseFrom(java.nio.ByteBuffer data)
					throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data);
			}

			public static WvProto2.FileHashes.Signature parseFrom(java.nio.ByteBuffer data,
					ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data, extensionRegistry);
			}

			public static WvProto2.FileHashes.Signature parseFrom(ByteString data)
					throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data);
			}

			public static WvProto2.FileHashes.Signature parseFrom(ByteString data,
					ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data, extensionRegistry);
			}

			public static WvProto2.FileHashes.Signature parseFrom(byte[] data)
					throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data);
			}

			public static WvProto2.FileHashes.Signature parseFrom(byte[] data,
					ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
				return PARSER.parseFrom(data, extensionRegistry);
			}

			public static WvProto2.FileHashes.Signature parseFrom(java.io.InputStream input)
					throws java.io.IOException {
				return GeneratedMessageV3.parseWithIOException(PARSER, input);
			}

			public static WvProto2.FileHashes.Signature parseFrom(java.io.InputStream input,
					ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
				return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
			}

			public static WvProto2.FileHashes.Signature parseDelimitedFrom(
					java.io.InputStream input) throws java.io.IOException {
				return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
			}

			public static WvProto2.FileHashes.Signature parseDelimitedFrom(
					java.io.InputStream input, ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
				return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input, extensionRegistry);
			}

			public static WvProto2.FileHashes.Signature parseFrom(CodedInputStream input)
					throws java.io.IOException {
				return GeneratedMessageV3.parseWithIOException(PARSER, input);
			}

			public static WvProto2.FileHashes.Signature parseFrom(CodedInputStream input,
					ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
				return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
			}

			@java.lang.Override
			public Builder newBuilderForType() {
				return newBuilder();
			}

			public static Builder newBuilder() {
				return DEFAULT_INSTANCE.toBuilder();
			}

			public static Builder newBuilder(WvProto2.FileHashes.Signature prototype) {
				return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
			}

			@java.lang.Override
			public Builder toBuilder() {
				return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
			}

			@java.lang.Override
			protected Builder newBuilderForType(GeneratedMessageV3.BuilderParent parent) {
				Builder builder = new Builder(parent);
				return builder;
			}

			/**
			 * Protobuf type {@code FileHashes.Signature}
			 */
			public static final class Builder extends GeneratedMessageV3.Builder<Builder> implements
					// @@protoc_insertion_point(builder_implements:FileHashes.Signature)
					WvProto2.FileHashes.SignatureOrBuilder {
				public static final Descriptors.Descriptor getDescriptor() {
					return WvProto2.internal_static_FileHashes_Signature_descriptor;
				}

				@java.lang.Override
				protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
					return WvProto2.internal_static_FileHashes_Signature_fieldAccessorTable
							.ensureFieldAccessorsInitialized(
									WvProto2.FileHashes.Signature.class,
									WvProto2.FileHashes.Signature.Builder.class);
				}

				// Construct using
				// WvProto2.FileHashes.Signature.newBuilder()
				private Builder() {

				}

				private Builder(GeneratedMessageV3.BuilderParent parent) {
					super(parent);

				}

				@java.lang.Override
				public Builder clear() {
					super.clear();
					bitField0_ = 0;
					filename_ = "";
					testSigning_ = false;
					sHA512Hash_ = ByteString.EMPTY;
					mainExe_ = false;
					signature_ = ByteString.EMPTY;
					return this;
				}

				@java.lang.Override
				public Descriptors.Descriptor getDescriptorForType() {
					return WvProto2.internal_static_FileHashes_Signature_descriptor;
				}

				@java.lang.Override
				public WvProto2.FileHashes.Signature getDefaultInstanceForType() {
					return WvProto2.FileHashes.Signature.getDefaultInstance();
				}

				@java.lang.Override
				public WvProto2.FileHashes.Signature build() {
					WvProto2.FileHashes.Signature result = buildPartial();
					if (!result.isInitialized()) {
						throw newUninitializedMessageException(result);
					}
					return result;
				}

				@java.lang.Override
				public WvProto2.FileHashes.Signature buildPartial() {
					WvProto2.FileHashes.Signature result = new WvProto2.FileHashes.Signature(
							this);
					if (bitField0_ != 0) {
						buildPartial0(result);
					}
					onBuilt();
					return result;
				}

				private void buildPartial0(WvProto2.FileHashes.Signature result) {
					int from_bitField0_ = bitField0_;
					int to_bitField0_ = 0;
					if (((from_bitField0_ & 0x00000001) != 0)) {
						result.filename_ = filename_;
						to_bitField0_ |= 0x00000001;
					}
					if (((from_bitField0_ & 0x00000002) != 0)) {
						result.testSigning_ = testSigning_;
						to_bitField0_ |= 0x00000002;
					}
					if (((from_bitField0_ & 0x00000004) != 0)) {
						result.sHA512Hash_ = sHA512Hash_;
						to_bitField0_ |= 0x00000004;
					}
					if (((from_bitField0_ & 0x00000008) != 0)) {
						result.mainExe_ = mainExe_;
						to_bitField0_ |= 0x00000008;
					}
					if (((from_bitField0_ & 0x00000010) != 0)) {
						result.signature_ = signature_;
						to_bitField0_ |= 0x00000010;
					}
					result.bitField0_ |= to_bitField0_;
				}

				@java.lang.Override
				public Builder mergeFrom(Message other) {
					if (other instanceof WvProto2.FileHashes.Signature) {
						return mergeFrom((WvProto2.FileHashes.Signature) other);
					}
					super.mergeFrom(other);
					return this;
				}

				public Builder mergeFrom(WvProto2.FileHashes.Signature other) {
					if (other == WvProto2.FileHashes.Signature.getDefaultInstance())
						return this;
					if (other.hasFilename()) {
						filename_ = other.filename_;
						bitField0_ |= 0x00000001;
						onChanged();
					}
					if (other.hasTestSigning()) {
						setTestSigning(other.getTestSigning());
					}
					if (other.hasSHA512Hash()) {
						setSHA512Hash(other.getSHA512Hash());
					}
					if (other.hasMainExe()) {
						setMainExe(other.getMainExe());
					}
					if (other.hasSignature()) {
						setSignature(other.getSignature());
					}
					this.mergeUnknownFields(other.getUnknownFields());
					onChanged();
					return this;
				}

				@java.lang.Override
				public final boolean isInitialized() {
					return true;
				}

				@java.lang.Override
				public Builder mergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
						throws java.io.IOException {
					if (extensionRegistry == null) {
						throw new java.lang.NullPointerException();
					}
					try {
						boolean done = false;
						while (!done) {
							int tag = input.readTag();
							switch (tag) {
							case 0:
								done = true;
								break;
							case 10: {
								filename_ = input.readBytes();
								bitField0_ |= 0x00000001;
								break;
							} // case 10
							case 16: {
								testSigning_ = input.readBool();
								bitField0_ |= 0x00000002;
								break;
							} // case 16
							case 26: {
								sHA512Hash_ = input.readBytes();
								bitField0_ |= 0x00000004;
								break;
							} // case 26
							case 32: {
								mainExe_ = input.readBool();
								bitField0_ |= 0x00000008;
								break;
							} // case 32
							case 42: {
								signature_ = input.readBytes();
								bitField0_ |= 0x00000010;
								break;
							} // case 42
							default: {
								if (!super.parseUnknownField(input, extensionRegistry, tag)) {
									done = true; // was an endgroup tag
								}
								break;
							} // default:
							} // switch (tag)
						} // while (!done)
					} catch (InvalidProtocolBufferException e) {
						throw e.unwrapIOException();
					}
					finally {
						onChanged();
					} // finally
					return this;
				}

				private int bitField0_;

				private java.lang.Object filename_ = "";

				/**
				 * <code>optional string filename = 1;</code>
				 * 
				 * @return Whether the filename field is set.
				 */
				@Override
				public boolean hasFilename() {
					return ((bitField0_ & 0x00000001) != 0);
				}

				/**
				 * <code>optional string filename = 1;</code>
				 * 
				 * @return The filename.
				 */
				@Override
				public java.lang.String getFilename() {
					java.lang.Object ref = filename_;
					if (!(ref instanceof java.lang.String)) {
						ByteString bs = (ByteString) ref;
						java.lang.String s = bs.toStringUtf8();
						if (bs.isValidUtf8()) {
							filename_ = s;
						}
						return s;
					}
					return (java.lang.String) ref;
				}

				/**
				 * <code>optional string filename = 1;</code>
				 * 
				 * @return The bytes for filename.
				 */
				@Override
				public ByteString getFilenameBytes() {
					java.lang.Object ref = filename_;
					if (ref instanceof String) {
						ByteString b = ByteString.copyFromUtf8((java.lang.String) ref);
						filename_ = b;
						return b;
					}
					return (ByteString) ref;
				}

				/**
				 * <code>optional string filename = 1;</code>
				 * 
				 * @param value The filename to set.
				 * @return This builder for chaining.
				 */
				public Builder setFilename(java.lang.String value) {
					if (value == null) {
						throw new NullPointerException();
					}
					filename_ = value;
					bitField0_ |= 0x00000001;
					onChanged();
					return this;
				}

				/**
				 * <code>optional string filename = 1;</code>
				 * 
				 * @return This builder for chaining.
				 */
				public Builder clearFilename() {
					filename_ = getDefaultInstance().getFilename();
					bitField0_ = (bitField0_ & ~0x00000001);
					onChanged();
					return this;
				}

				/**
				 * <code>optional string filename = 1;</code>
				 * 
				 * @param value The bytes for filename to set.
				 * @return This builder for chaining.
				 */
				public Builder setFilenameBytes(ByteString value) {
					if (value == null) {
						throw new NullPointerException();
					}
					filename_ = value;
					bitField0_ |= 0x00000001;
					onChanged();
					return this;
				}

				private boolean testSigning_;

				/**
				 * <pre>
				 *0 - release, 1 - testing
				 * </pre>
				 *
				 * <code>optional bool test_signing = 2;</code>
				 * 
				 * @return Whether the testSigning field is set.
				 */
				@java.lang.Override
				public boolean hasTestSigning() {
					return ((bitField0_ & 0x00000002) != 0);
				}

				/**
				 * <pre>
				 *0 - release, 1 - testing
				 * </pre>
				 *
				 * <code>optional bool test_signing = 2;</code>
				 * 
				 * @return The testSigning.
				 */
				@java.lang.Override
				public boolean getTestSigning() {
					return testSigning_;
				}

				/**
				 * <pre>
				 *0 - release, 1 - testing
				 * </pre>
				 *
				 * <code>optional bool test_signing = 2;</code>
				 * 
				 * @param value The testSigning to set.
				 * @return This builder for chaining.
				 */
				public Builder setTestSigning(boolean value) {

					testSigning_ = value;
					bitField0_ |= 0x00000002;
					onChanged();
					return this;
				}

				/**
				 * <pre>
				 *0 - release, 1 - testing
				 * </pre>
				 *
				 * <code>optional bool test_signing = 2;</code>
				 * 
				 * @return This builder for chaining.
				 */
				public Builder clearTestSigning() {
					bitField0_ = (bitField0_ & ~0x00000002);
					testSigning_ = false;
					onChanged();
					return this;
				}

				private ByteString sHA512Hash_ = ByteString.EMPTY;

				/**
				 * <code>optional bytes SHA512Hash = 3;</code>
				 * 
				 * @return Whether the sHA512Hash field is set.
				 */
				@java.lang.Override
				public boolean hasSHA512Hash() {
					return ((bitField0_ & 0x00000004) != 0);
				}

				/**
				 * <code>optional bytes SHA512Hash = 3;</code>
				 * 
				 * @return The sHA512Hash.
				 */
				@java.lang.Override
				public ByteString getSHA512Hash() {
					return sHA512Hash_;
				}

				/**
				 * <code>optional bytes SHA512Hash = 3;</code>
				 * 
				 * @param value The sHA512Hash to set.
				 * @return This builder for chaining.
				 */
				public Builder setSHA512Hash(ByteString value) {
					if (value == null) {
						throw new NullPointerException();
					}
					sHA512Hash_ = value;
					bitField0_ |= 0x00000004;
					onChanged();
					return this;
				}

				/**
				 * <code>optional bytes SHA512Hash = 3;</code>
				 * 
				 * @return This builder for chaining.
				 */
				public Builder clearSHA512Hash() {
					bitField0_ = (bitField0_ & ~0x00000004);
					sHA512Hash_ = getDefaultInstance().getSHA512Hash();
					onChanged();
					return this;
				}

				private boolean mainExe_;

				/**
				 * <pre>
				 *0 for dlls, 1 for exe, this is field 3 in file
				 * </pre>
				 *
				 * <code>optional bool main_exe = 4;</code>
				 * 
				 * @return Whether the mainExe field is set.
				 */
				@java.lang.Override
				public boolean hasMainExe() {
					return ((bitField0_ & 0x00000008) != 0);
				}

				/**
				 * <pre>
				 *0 for dlls, 1 for exe, this is field 3 in file
				 * </pre>
				 *
				 * <code>optional bool main_exe = 4;</code>
				 * 
				 * @return The mainExe.
				 */
				@java.lang.Override
				public boolean getMainExe() {
					return mainExe_;
				}

				/**
				 * <pre>
				 *0 for dlls, 1 for exe, this is field 3 in file
				 * </pre>
				 *
				 * <code>optional bool main_exe = 4;</code>
				 * 
				 * @param value The mainExe to set.
				 * @return This builder for chaining.
				 */
				public Builder setMainExe(boolean value) {

					mainExe_ = value;
					bitField0_ |= 0x00000008;
					onChanged();
					return this;
				}

				/**
				 * <pre>
				 *0 for dlls, 1 for exe, this is field 3 in file
				 * </pre>
				 *
				 * <code>optional bool main_exe = 4;</code>
				 * 
				 * @return This builder for chaining.
				 */
				public Builder clearMainExe() {
					bitField0_ = (bitField0_ & ~0x00000008);
					mainExe_ = false;
					onChanged();
					return this;
				}

				private ByteString signature_ = ByteString.EMPTY;

				/**
				 * <code>optional bytes signature = 5;</code>
				 * 
				 * @return Whether the signature field is set.
				 */
				@java.lang.Override
				public boolean hasSignature() {
					return ((bitField0_ & 0x00000010) != 0);
				}

				/**
				 * <code>optional bytes signature = 5;</code>
				 * 
				 * @return The signature.
				 */
				@java.lang.Override
				public ByteString getSignature() {
					return signature_;
				}

				/**
				 * <code>optional bytes signature = 5;</code>
				 * 
				 * @param value The signature to set.
				 * @return This builder for chaining.
				 */
				public Builder setSignature(ByteString value) {
					if (value == null) {
						throw new NullPointerException();
					}
					signature_ = value;
					bitField0_ |= 0x00000010;
					onChanged();
					return this;
				}

				/**
				 * <code>optional bytes signature = 5;</code>
				 * 
				 * @return This builder for chaining.
				 */
				public Builder clearSignature() {
					bitField0_ = (bitField0_ & ~0x00000010);
					signature_ = getDefaultInstance().getSignature();
					onChanged();
					return this;
				}

				@java.lang.Override
				public final Builder setUnknownFields(final UnknownFieldSet unknownFields) {
					return super.setUnknownFields(unknownFields);
				}

				@java.lang.Override
				public final Builder mergeUnknownFields(final UnknownFieldSet unknownFields) {
					return super.mergeUnknownFields(unknownFields);
				}

				// @@protoc_insertion_point(builder_scope:FileHashes.Signature)
			}

			// @@protoc_insertion_point(class_scope:FileHashes.Signature)
			private static final WvProto2.FileHashes.Signature DEFAULT_INSTANCE;
			static {
				DEFAULT_INSTANCE = new WvProto2.FileHashes.Signature();
			}

			public static WvProto2.FileHashes.Signature getDefaultInstance() {
				return DEFAULT_INSTANCE;
			}

			@java.lang.Deprecated public static final Parser<Signature> PARSER = new AbstractParser<>() {
				@java.lang.Override
				public Signature parsePartialFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
						throws InvalidProtocolBufferException {
					Builder builder = newBuilder();
					try {
						builder.mergeFrom(input, extensionRegistry);
					} catch (InvalidProtocolBufferException e) {
						throw e.setUnfinishedMessage(builder.buildPartial());
					} catch (UninitializedMessageException e) {
						throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
					} catch (java.io.IOException e) {
						throw new InvalidProtocolBufferException(e).setUnfinishedMessage(builder.buildPartial());
					}
					return builder.buildPartial();
				}
			};

			public static Parser<Signature> parser() {
				return PARSER;
			}

			@java.lang.Override
			public Parser<Signature> getParserForType() {
				return PARSER;
			}

			@java.lang.Override
			public WvProto2.FileHashes.Signature getDefaultInstanceForType() {
				return DEFAULT_INSTANCE;
			}

		}

		private int bitField0_;
		public static final int SIGNER_FIELD_NUMBER = 1;
		private ByteString signer_ = ByteString.EMPTY;

		/**
		 * <code>optional bytes signer = 1;</code>
		 * 
		 * @return Whether the signer field is set.
		 */
		@java.lang.Override
		public boolean hasSigner() {
			return ((bitField0_ & 0x00000001) != 0);
		}

		/**
		 * <code>optional bytes signer = 1;</code>
		 * 
		 * @return The signer.
		 */
		@java.lang.Override
		public ByteString getSigner() {
			return signer_;
		}

		public static final int SIGNATURES_FIELD_NUMBER = 2;

		private java.util.List<WvProto2.FileHashes.Signature> signatures_;

		/**
		 * <code>repeated .FileHashes.Signature signatures = 2;</code>
		 */
		@java.lang.Override
		public java.util.List<WvProto2.FileHashes.Signature> getSignaturesList() {
			return signatures_;
		}

		/**
		 * <code>repeated .FileHashes.Signature signatures = 2;</code>
		 */
		@java.lang.Override
		public java.util.List<? extends WvProto2.FileHashes.SignatureOrBuilder> getSignaturesOrBuilderList() {
			return signatures_;
		}

		/**
		 * <code>repeated .FileHashes.Signature signatures = 2;</code>
		 */
		@java.lang.Override
		public int getSignaturesCount() {
			return signatures_.size();
		}

		/**
		 * <code>repeated .FileHashes.Signature signatures = 2;</code>
		 */
		@java.lang.Override
		public WvProto2.FileHashes.Signature getSignatures(int index) {
			return signatures_.get(index);
		}

		/**
		 * <code>repeated .FileHashes.Signature signatures = 2;</code>
		 */
		@java.lang.Override
		public WvProto2.FileHashes.SignatureOrBuilder getSignaturesOrBuilder(int index) {
			return signatures_.get(index);
		}

		private byte memoizedIsInitialized = -1;

		@java.lang.Override
		public final boolean isInitialized() {
			byte isInitialized = memoizedIsInitialized;
			if (isInitialized == 1)
				return true;
			if (isInitialized == 0)
				return false;

			memoizedIsInitialized = 1;
			return true;
		}

		@java.lang.Override
		public void writeTo(CodedOutputStream output) throws java.io.IOException {
			if (((bitField0_ & 0x00000001) != 0)) {
				output.writeBytes(1, signer_);
			}
			for (int i = 0; i < signatures_.size(); i++) {
				output.writeMessage(2, signatures_.get(i));
			}
			getUnknownFields().writeTo(output);
		}

		@java.lang.Override
		public int getSerializedSize() {
			int size = memoizedSize;
			if (size != -1)
				return size;

			size = 0;
			if (((bitField0_ & 0x00000001) != 0)) {
				size += CodedOutputStream.computeBytesSize(1, signer_);
			}
			for (int i = 0; i < signatures_.size(); i++) {
				size += CodedOutputStream.computeMessageSize(2, signatures_.get(i));
			}
			size += getUnknownFields().getSerializedSize();
			memoizedSize = size;
			return size;
		}

		@java.lang.Override
		public boolean equals(final java.lang.Object obj) {
			if (obj == this) {
				return true;
			}
			if (!(obj instanceof WvProto2.FileHashes)) {
				return super.equals(obj);
			}
			WvProto2.FileHashes other = (WvProto2.FileHashes) obj;

			if (hasSigner() != other.hasSigner())
				return false;
			if (hasSigner()) {
				if (!getSigner().equals(other.getSigner()))
					return false;
			}
			if (!getSignaturesList().equals(other.getSignaturesList()))
				return false;
			if (!getUnknownFields().equals(other.getUnknownFields()))
				return false;
			return true;
		}

		@SuppressWarnings("unchecked")
		@java.lang.Override
		public int hashCode() {
			if (memoizedHashCode != 0) {
				return memoizedHashCode;
			}
			int hash = 41;
			hash = (19 * hash) + getDescriptor().hashCode();
			if (hasSigner()) {
				hash = (37 * hash) + SIGNER_FIELD_NUMBER;
				hash = (53 * hash) + getSigner().hashCode();
			}
			if (getSignaturesCount() > 0) {
				hash = (37 * hash) + SIGNATURES_FIELD_NUMBER;
				hash = (53 * hash) + getSignaturesList().hashCode();
			}
			hash = (29 * hash) + getUnknownFields().hashCode();
			memoizedHashCode = hash;
			return hash;
		}

		public static WvProto2.FileHashes parseFrom(java.nio.ByteBuffer data)
				throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data);
		}

		public static WvProto2.FileHashes parseFrom(java.nio.ByteBuffer data,
				ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data, extensionRegistry);
		}

		public static WvProto2.FileHashes parseFrom(ByteString data)
				throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data);
		}

		public static WvProto2.FileHashes parseFrom(ByteString data,
				ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data, extensionRegistry);
		}

		public static WvProto2.FileHashes parseFrom(byte[] data)
				throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data);
		}

		public static WvProto2.FileHashes parseFrom(byte[] data,
				ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data, extensionRegistry);
		}

		public static WvProto2.FileHashes parseFrom(java.io.InputStream input)
				throws java.io.IOException {
			return GeneratedMessageV3.parseWithIOException(PARSER, input);
		}

		public static WvProto2.FileHashes parseFrom(java.io.InputStream input,
				ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
			return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
		}

		public static WvProto2.FileHashes parseDelimitedFrom(java.io.InputStream input)
				throws java.io.IOException {
			return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
		}

		public static WvProto2.FileHashes parseDelimitedFrom(java.io.InputStream input,
				ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
			return GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input, extensionRegistry);
		}

		public static WvProto2.FileHashes parseFrom(CodedInputStream input)
				throws java.io.IOException {
			return GeneratedMessageV3.parseWithIOException(PARSER, input);
		}

		public static WvProto2.FileHashes parseFrom(CodedInputStream input,
				ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
			return GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);
		}

		@java.lang.Override
		public Builder newBuilderForType() {
			return newBuilder();
		}

		public static Builder newBuilder() {
			return DEFAULT_INSTANCE.toBuilder();
		}

		public static Builder newBuilder(WvProto2.FileHashes prototype) {
			return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
		}

		@java.lang.Override
		public Builder toBuilder() {
			return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
		}

		@java.lang.Override
		protected Builder newBuilderForType(GeneratedMessageV3.BuilderParent parent) {
			Builder builder = new Builder(parent);
			return builder;
		}

		/**
		 * <pre>
		 * File Hashes for Verified Media Path (VMP) support.
		 * </pre>
		 *
		 * Protobuf type {@code FileHashes}
		 */
		public static final class Builder extends GeneratedMessageV3.Builder<Builder> implements
				// @@protoc_insertion_point(builder_implements:FileHashes)
				WvProto2.FileHashesOrBuilder {
			public static final Descriptors.Descriptor getDescriptor() {
				return WvProto2.internal_static_FileHashes_descriptor;
			}

			@java.lang.Override
			protected GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
				return WvProto2.internal_static_FileHashes_fieldAccessorTable
						.ensureFieldAccessorsInitialized(WvProto2.FileHashes.class,
								WvProto2.FileHashes.Builder.class);
			}

			// Construct using WvProto2.FileHashes.newBuilder()
			private Builder() {

			}

			private Builder(GeneratedMessageV3.BuilderParent parent) {
				super(parent);

			}

			@java.lang.Override
			public Builder clear() {
				super.clear();
				bitField0_ = 0;
				signer_ = ByteString.EMPTY;
				if (signaturesBuilder_ == null) {
					signatures_ = java.util.Collections.emptyList();
				} else {
					signatures_ = null;
					signaturesBuilder_.clear();
				}
				bitField0_ = (bitField0_ & ~0x00000002);
				return this;
			}

			@java.lang.Override
			public Descriptors.Descriptor getDescriptorForType() {
				return WvProto2.internal_static_FileHashes_descriptor;
			}

			@java.lang.Override
			public WvProto2.FileHashes getDefaultInstanceForType() {
				return WvProto2.FileHashes.getDefaultInstance();
			}

			@java.lang.Override
			public WvProto2.FileHashes build() {
				WvProto2.FileHashes result = buildPartial();
				if (!result.isInitialized()) {
					throw newUninitializedMessageException(result);
				}
				return result;
			}

			@java.lang.Override
			public WvProto2.FileHashes buildPartial() {
				WvProto2.FileHashes result = new WvProto2.FileHashes(
						this);
				buildPartialRepeatedFields(result);
				if (bitField0_ != 0) {
					buildPartial0(result);
				}
				onBuilt();
				return result;
			}

			private void buildPartialRepeatedFields(WvProto2.FileHashes result) {
				if (signaturesBuilder_ == null) {
					if (((bitField0_ & 0x00000002) != 0)) {
						signatures_ = java.util.Collections.unmodifiableList(signatures_);
						bitField0_ = (bitField0_ & ~0x00000002);
					}
					result.signatures_ = signatures_;
				} else {
					result.signatures_ = signaturesBuilder_.build();
				}
			}

			private void buildPartial0(WvProto2.FileHashes result) {
				int from_bitField0_ = bitField0_;
				int to_bitField0_ = 0;
				if (((from_bitField0_ & 0x00000001) != 0)) {
					result.signer_ = signer_;
					to_bitField0_ |= 0x00000001;
				}
				result.bitField0_ |= to_bitField0_;
			}

			@java.lang.Override
			public Builder mergeFrom(Message other) {
				if (other instanceof WvProto2.FileHashes) {
					return mergeFrom((WvProto2.FileHashes) other);
				}
				super.mergeFrom(other);
				return this;
			}

			public Builder mergeFrom(WvProto2.FileHashes other) {
				if (other == WvProto2.FileHashes.getDefaultInstance())
					return this;
				if (other.hasSigner()) {
					setSigner(other.getSigner());
				}
				if (signaturesBuilder_ == null) {
					if (!other.signatures_.isEmpty()) {
						if (signatures_.isEmpty()) {
							signatures_ = other.signatures_;
							bitField0_ = (bitField0_ & ~0x00000002);
						} else {
							ensureSignaturesIsMutable();
							signatures_.addAll(other.signatures_);
						}
						onChanged();
					}
				} else {
					if (!other.signatures_.isEmpty()) {
						if (signaturesBuilder_.isEmpty()) {
							signaturesBuilder_.dispose();
							signaturesBuilder_ = null;
							signatures_ = other.signatures_;
							bitField0_ = (bitField0_ & ~0x00000002);
							signaturesBuilder_ = GeneratedMessageV3.alwaysUseFieldBuilders ? getSignaturesFieldBuilder()
									: null;
						} else {
							signaturesBuilder_.addAllMessages(other.signatures_);
						}
					}
				}
				this.mergeUnknownFields(other.getUnknownFields());
				onChanged();
				return this;
			}

			@java.lang.Override
			public final boolean isInitialized() {
				return true;
			}

			@java.lang.Override
			public Builder mergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
					throws java.io.IOException {
				if (extensionRegistry == null) {
					throw new java.lang.NullPointerException();
				}
				try {
					boolean done = false;
					while (!done) {
						int tag = input.readTag();
						switch (tag) {
						case 0:
							done = true;
							break;
						case 10: {
							signer_ = input.readBytes();
							bitField0_ |= 0x00000001;
							break;
						} // case 10
						case 18: {
							WvProto2.FileHashes.Signature m = input.readMessage(
									WvProto2.FileHashes.Signature.PARSER, extensionRegistry);
							if (signaturesBuilder_ == null) {
								ensureSignaturesIsMutable();
								signatures_.add(m);
							} else {
								signaturesBuilder_.addMessage(m);
							}
							break;
						} // case 18
						default: {
							if (!super.parseUnknownField(input, extensionRegistry, tag)) {
								done = true; // was an endgroup tag
							}
							break;
						} // default:
						} // switch (tag)
					} // while (!done)
				} catch (InvalidProtocolBufferException e) {
					throw e.unwrapIOException();
				}
				finally {
					onChanged();
				} // finally
				return this;
			}

			private int bitField0_;

			private ByteString signer_ = ByteString.EMPTY;

			/**
			 * <code>optional bytes signer = 1;</code>
			 * 
			 * @return Whether the signer field is set.
			 */
			@java.lang.Override
			public boolean hasSigner() {
				return ((bitField0_ & 0x00000001) != 0);
			}

			/**
			 * <code>optional bytes signer = 1;</code>
			 * 
			 * @return The signer.
			 */
			@java.lang.Override
			public ByteString getSigner() {
				return signer_;
			}

			/**
			 * <code>optional bytes signer = 1;</code>
			 * 
			 * @param value The signer to set.
			 * @return This builder for chaining.
			 */
			public Builder setSigner(ByteString value) {
				if (value == null) {
					throw new NullPointerException();
				}
				signer_ = value;
				bitField0_ |= 0x00000001;
				onChanged();
				return this;
			}

			/**
			 * <code>optional bytes signer = 1;</code>
			 * 
			 * @return This builder for chaining.
			 */
			public Builder clearSigner() {
				bitField0_ = (bitField0_ & ~0x00000001);
				signer_ = getDefaultInstance().getSigner();
				onChanged();
				return this;
			}

			private java.util.List<WvProto2.FileHashes.Signature> signatures_ = java.util.Collections
					.emptyList();

			private void ensureSignaturesIsMutable() {
				if (!((bitField0_ & 0x00000002) != 0)) {
					signatures_ = new java.util.ArrayList<>(signatures_);
					bitField0_ |= 0x00000002;
				}
			}

			private RepeatedFieldBuilderV3<WvProto2.FileHashes.Signature, WvProto2.FileHashes.Signature.Builder, WvProto2.FileHashes.SignatureOrBuilder> signaturesBuilder_;

			/**
			 * <code>repeated .FileHashes.Signature signatures = 2;</code>
			 */
			@Override
			public java.util.List<WvProto2.FileHashes.Signature> getSignaturesList() {
				if (signaturesBuilder_ == null) {
					return java.util.Collections.unmodifiableList(signatures_);
				}
				return signaturesBuilder_.getMessageList();
			}

			/**
			 * <code>repeated .FileHashes.Signature signatures = 2;</code>
			 */
			@Override
			public int getSignaturesCount() {
				if (signaturesBuilder_ == null) {
					return signatures_.size();
				}
				return signaturesBuilder_.getCount();
			}

			/**
			 * <code>repeated .FileHashes.Signature signatures = 2;</code>
			 */
			@Override
			public WvProto2.FileHashes.Signature getSignatures(int index) {
				if (signaturesBuilder_ == null) {
					return signatures_.get(index);
				}
				return signaturesBuilder_.getMessage(index);
			}

			/**
			 * <code>repeated .FileHashes.Signature signatures = 2;</code>
			 */
			public Builder setSignatures(int index, WvProto2.FileHashes.Signature value) {
				if (signaturesBuilder_ == null) {
					if (value == null) {
						throw new NullPointerException();
					}
					ensureSignaturesIsMutable();
					signatures_.set(index, value);
					onChanged();
				} else {
					signaturesBuilder_.setMessage(index, value);
				}
				return this;
			}

			/**
			 * <code>repeated .FileHashes.Signature signatures = 2;</code>
			 */
			public Builder setSignatures(int index,
					WvProto2.FileHashes.Signature.Builder builderForValue) {
				if (signaturesBuilder_ == null) {
					ensureSignaturesIsMutable();
					signatures_.set(index, builderForValue.build());
					onChanged();
				} else {
					signaturesBuilder_.setMessage(index, builderForValue.build());
				}
				return this;
			}

			/**
			 * <code>repeated .FileHashes.Signature signatures = 2;</code>
			 */
			public Builder addSignatures(WvProto2.FileHashes.Signature value) {
				if (signaturesBuilder_ == null) {
					if (value == null) {
						throw new NullPointerException();
					}
					ensureSignaturesIsMutable();
					signatures_.add(value);
					onChanged();
				} else {
					signaturesBuilder_.addMessage(value);
				}
				return this;
			}

			/**
			 * <code>repeated .FileHashes.Signature signatures = 2;</code>
			 */
			public Builder addSignatures(int index, WvProto2.FileHashes.Signature value) {
				if (signaturesBuilder_ == null) {
					if (value == null) {
						throw new NullPointerException();
					}
					ensureSignaturesIsMutable();
					signatures_.add(index, value);
					onChanged();
				} else {
					signaturesBuilder_.addMessage(index, value);
				}
				return this;
			}

			/**
			 * <code>repeated .FileHashes.Signature signatures = 2;</code>
			 */
			public Builder addSignatures(
					WvProto2.FileHashes.Signature.Builder builderForValue) {
				if (signaturesBuilder_ == null) {
					ensureSignaturesIsMutable();
					signatures_.add(builderForValue.build());
					onChanged();
				} else {
					signaturesBuilder_.addMessage(builderForValue.build());
				}
				return this;
			}

			/**
			 * <code>repeated .FileHashes.Signature signatures = 2;</code>
			 */
			public Builder addSignatures(int index,
					WvProto2.FileHashes.Signature.Builder builderForValue) {
				if (signaturesBuilder_ == null) {
					ensureSignaturesIsMutable();
					signatures_.add(index, builderForValue.build());
					onChanged();
				} else {
					signaturesBuilder_.addMessage(index, builderForValue.build());
				}
				return this;
			}

			/**
			 * <code>repeated .FileHashes.Signature signatures = 2;</code>
			 */
			public Builder addAllSignatures(
					java.lang.Iterable<? extends WvProto2.FileHashes.Signature> values) {
				if (signaturesBuilder_ == null) {
					ensureSignaturesIsMutable();
					AbstractMessageLite.Builder.addAll(values, signatures_);
					onChanged();
				} else {
					signaturesBuilder_.addAllMessages(values);
				}
				return this;
			}

			/**
			 * <code>repeated .FileHashes.Signature signatures = 2;</code>
			 */
			public Builder clearSignatures() {
				if (signaturesBuilder_ == null) {
					signatures_ = java.util.Collections.emptyList();
					bitField0_ = (bitField0_ & ~0x00000002);
					onChanged();
				} else {
					signaturesBuilder_.clear();
				}
				return this;
			}

			/**
			 * <code>repeated .FileHashes.Signature signatures = 2;</code>
			 */
			public Builder removeSignatures(int index) {
				if (signaturesBuilder_ == null) {
					ensureSignaturesIsMutable();
					signatures_.remove(index);
					onChanged();
				} else {
					signaturesBuilder_.remove(index);
				}
				return this;
			}

			/**
			 * <code>repeated .FileHashes.Signature signatures = 2;</code>
			 */
			public WvProto2.FileHashes.Signature.Builder getSignaturesBuilder(int index) {
				return getSignaturesFieldBuilder().getBuilder(index);
			}

			/**
			 * <code>repeated .FileHashes.Signature signatures = 2;</code>
			 */
			@Override
			public WvProto2.FileHashes.SignatureOrBuilder getSignaturesOrBuilder(int index) {
				if (signaturesBuilder_ == null) {
					return signatures_.get(index);
				}
				return signaturesBuilder_.getMessageOrBuilder(index);
			}

			/**
			 * <code>repeated .FileHashes.Signature signatures = 2;</code>
			 */
			@Override
			public java.util.List<? extends WvProto2.FileHashes.SignatureOrBuilder> getSignaturesOrBuilderList() {
				if (signaturesBuilder_ != null) {
					return signaturesBuilder_.getMessageOrBuilderList();
				}
				return java.util.Collections.unmodifiableList(signatures_);
			}

			/**
			 * <code>repeated .FileHashes.Signature signatures = 2;</code>
			 */
			public WvProto2.FileHashes.Signature.Builder addSignaturesBuilder() {
				return getSignaturesFieldBuilder()
						.addBuilder(WvProto2.FileHashes.Signature.getDefaultInstance());
			}

			/**
			 * <code>repeated .FileHashes.Signature signatures = 2;</code>
			 */
			public WvProto2.FileHashes.Signature.Builder addSignaturesBuilder(int index) {
				return getSignaturesFieldBuilder().addBuilder(index,
						WvProto2.FileHashes.Signature.getDefaultInstance());
			}

			/**
			 * <code>repeated .FileHashes.Signature signatures = 2;</code>
			 */
			public java.util.List<WvProto2.FileHashes.Signature.Builder> getSignaturesBuilderList() {
				return getSignaturesFieldBuilder().getBuilderList();
			}

			private RepeatedFieldBuilderV3<WvProto2.FileHashes.Signature, WvProto2.FileHashes.Signature.Builder, WvProto2.FileHashes.SignatureOrBuilder> getSignaturesFieldBuilder() {
				if (signaturesBuilder_ == null) {
					signaturesBuilder_ = new RepeatedFieldBuilderV3<>(signatures_, ((bitField0_ & 0x00000002) != 0),
							getParentForChildren(), isClean());
					signatures_ = null;
				}
				return signaturesBuilder_;
			}

			@java.lang.Override
			public final Builder setUnknownFields(final UnknownFieldSet unknownFields) {
				return super.setUnknownFields(unknownFields);
			}

			@java.lang.Override
			public final Builder mergeUnknownFields(final UnknownFieldSet unknownFields) {
				return super.mergeUnknownFields(unknownFields);
			}

			// @@protoc_insertion_point(builder_scope:FileHashes)
		}

		// @@protoc_insertion_point(class_scope:FileHashes)
		private static final WvProto2.FileHashes DEFAULT_INSTANCE;
		static {
			DEFAULT_INSTANCE = new WvProto2.FileHashes();
		}

		public static WvProto2.FileHashes getDefaultInstance() {
			return DEFAULT_INSTANCE;
		}

		@java.lang.Deprecated public static final Parser<FileHashes> PARSER = new AbstractParser<>() {
			@java.lang.Override
			public FileHashes parsePartialFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
					throws InvalidProtocolBufferException {
				Builder builder = newBuilder();
				try {
					builder.mergeFrom(input, extensionRegistry);
				} catch (InvalidProtocolBufferException e) {
					throw e.setUnfinishedMessage(builder.buildPartial());
				} catch (UninitializedMessageException e) {
					throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
				} catch (java.io.IOException e) {
					throw new InvalidProtocolBufferException(e).setUnfinishedMessage(builder.buildPartial());
				}
				return builder.buildPartial();
			}
		};

		public static Parser<FileHashes> parser() {
			return PARSER;
		}

		@java.lang.Override
		public Parser<FileHashes> getParserForType() {
			return PARSER;
		}

		@java.lang.Override
		public WvProto2.FileHashes getDefaultInstanceForType() {
			return DEFAULT_INSTANCE;
		}

	}

	private static final Descriptors.Descriptor internal_static_LicenseIdentification_descriptor;
	private static final GeneratedMessageV3.FieldAccessorTable internal_static_LicenseIdentification_fieldAccessorTable;
	private static final Descriptors.Descriptor internal_static_License_descriptor;
	private static final GeneratedMessageV3.FieldAccessorTable internal_static_License_fieldAccessorTable;
	private static final Descriptors.Descriptor internal_static_License_Policy_descriptor;
	private static final GeneratedMessageV3.FieldAccessorTable internal_static_License_Policy_fieldAccessorTable;
	private static final Descriptors.Descriptor internal_static_License_KeyContainer_descriptor;
	private static final GeneratedMessageV3.FieldAccessorTable internal_static_License_KeyContainer_fieldAccessorTable;
	private static final Descriptors.Descriptor internal_static_License_KeyContainer_KeyControl_descriptor;
	private static final GeneratedMessageV3.FieldAccessorTable internal_static_License_KeyContainer_KeyControl_fieldAccessorTable;
	private static final Descriptors.Descriptor internal_static_License_KeyContainer_OutputProtection_descriptor;
	private static final GeneratedMessageV3.FieldAccessorTable internal_static_License_KeyContainer_OutputProtection_fieldAccessorTable;
	private static final Descriptors.Descriptor internal_static_License_KeyContainer_VideoResolutionConstraint_descriptor;
	private static final GeneratedMessageV3.FieldAccessorTable internal_static_License_KeyContainer_VideoResolutionConstraint_fieldAccessorTable;
	private static final Descriptors.Descriptor internal_static_License_KeyContainer_OperatorSessionKeyPermissions_descriptor;
	private static final GeneratedMessageV3.FieldAccessorTable internal_static_License_KeyContainer_OperatorSessionKeyPermissions_fieldAccessorTable;
	private static final Descriptors.Descriptor internal_static_LicenseRequest_descriptor;
	private static final GeneratedMessageV3.FieldAccessorTable internal_static_LicenseRequest_fieldAccessorTable;
	private static final Descriptors.Descriptor internal_static_LicenseRequest_ContentIdentification_descriptor;
	private static final GeneratedMessageV3.FieldAccessorTable internal_static_LicenseRequest_ContentIdentification_fieldAccessorTable;
	private static final Descriptors.Descriptor internal_static_LicenseRequest_ContentIdentification_WidevinePsshData_descriptor;
	private static final GeneratedMessageV3.FieldAccessorTable internal_static_LicenseRequest_ContentIdentification_WidevinePsshData_fieldAccessorTable;
	private static final Descriptors.Descriptor internal_static_LicenseRequest_ContentIdentification_WebmKeyId_descriptor;
	private static final GeneratedMessageV3.FieldAccessorTable internal_static_LicenseRequest_ContentIdentification_WebmKeyId_fieldAccessorTable;
	private static final Descriptors.Descriptor internal_static_LicenseRequest_ContentIdentification_ExistingLicense_descriptor;
	private static final GeneratedMessageV3.FieldAccessorTable internal_static_LicenseRequest_ContentIdentification_ExistingLicense_fieldAccessorTable;
	private static final Descriptors.Descriptor internal_static_LicenseRequest_ContentIdentification_InitData_descriptor;
	private static final GeneratedMessageV3.FieldAccessorTable internal_static_LicenseRequest_ContentIdentification_InitData_fieldAccessorTable;
	private static final Descriptors.Descriptor internal_static_MetricData_descriptor;
	private static final GeneratedMessageV3.FieldAccessorTable internal_static_MetricData_fieldAccessorTable;
	private static final Descriptors.Descriptor internal_static_MetricData_TypeValue_descriptor;
	private static final GeneratedMessageV3.FieldAccessorTable internal_static_MetricData_TypeValue_fieldAccessorTable;
	private static final Descriptors.Descriptor internal_static_VersionInfo_descriptor;
	private static final GeneratedMessageV3.FieldAccessorTable internal_static_VersionInfo_fieldAccessorTable;
	private static final Descriptors.Descriptor internal_static_SignedMessage_descriptor;
	private static final GeneratedMessageV3.FieldAccessorTable internal_static_SignedMessage_fieldAccessorTable;
	private static final Descriptors.Descriptor internal_static_ClientIdentification_descriptor;
	private static final GeneratedMessageV3.FieldAccessorTable internal_static_ClientIdentification_fieldAccessorTable;
	private static final Descriptors.Descriptor internal_static_ClientIdentification_NameValue_descriptor;
	private static final GeneratedMessageV3.FieldAccessorTable internal_static_ClientIdentification_NameValue_fieldAccessorTable;
	private static final Descriptors.Descriptor internal_static_ClientIdentification_ClientCapabilities_descriptor;
	private static final GeneratedMessageV3.FieldAccessorTable internal_static_ClientIdentification_ClientCapabilities_fieldAccessorTable;
	private static final Descriptors.Descriptor internal_static_ClientIdentification_ClientCredentials_descriptor;
	private static final GeneratedMessageV3.FieldAccessorTable internal_static_ClientIdentification_ClientCredentials_fieldAccessorTable;
	private static final Descriptors.Descriptor internal_static_EncryptedClientIdentification_descriptor;
	private static final GeneratedMessageV3.FieldAccessorTable internal_static_EncryptedClientIdentification_fieldAccessorTable;
	private static final Descriptors.Descriptor internal_static_DrmCertificate_descriptor;
	private static final GeneratedMessageV3.FieldAccessorTable internal_static_DrmCertificate_fieldAccessorTable;
	private static final Descriptors.Descriptor internal_static_DrmCertificate_EncryptionKey_descriptor;
	private static final GeneratedMessageV3.FieldAccessorTable internal_static_DrmCertificate_EncryptionKey_fieldAccessorTable;
	private static final Descriptors.Descriptor internal_static_SignedDrmCertificate_descriptor;
	private static final GeneratedMessageV3.FieldAccessorTable internal_static_SignedDrmCertificate_fieldAccessorTable;
	private static final Descriptors.Descriptor internal_static_WidevinePsshData_descriptor;
	private static final GeneratedMessageV3.FieldAccessorTable internal_static_WidevinePsshData_fieldAccessorTable;
	private static final Descriptors.Descriptor internal_static_WidevinePsshData_EntitledKey_descriptor;
	private static final GeneratedMessageV3.FieldAccessorTable internal_static_WidevinePsshData_EntitledKey_fieldAccessorTable;
	private static final Descriptors.Descriptor internal_static_FileHashes_descriptor;
	private static final GeneratedMessageV3.FieldAccessorTable internal_static_FileHashes_fieldAccessorTable;
	private static final Descriptors.Descriptor internal_static_FileHashes_Signature_descriptor;
	private static final GeneratedMessageV3.FieldAccessorTable internal_static_FileHashes_Signature_fieldAccessorTable;

	public static Descriptors.FileDescriptor getDescriptor() {
		return descriptor;
	}

	private static Descriptors.FileDescriptor descriptor;
	static {
		java.lang.String[] descriptorData = { "\n\017wv_proto2.proto\"\241\001\n\025LicenseIdentificat"
				+ "ion\022\022\n\nrequest_id\030\001 \001(\014\022\022\n\nsession_id\030\002 "
				+ "\001(\014\022\023\n\013purchase_id\030\003 \001(\014\022\032\n\004type\030\004 \001(\0162\014"
				+ ".LicenseType\022\017\n\007version\030\005 \001(\005\022\036\n\026provide"
				+ "r_session_token\030\006 \001(\014\"\315\025\n\007License\022\"\n\002id\030"
				+ "\001 \001(\0132\026.LicenseIdentification\022\037\n\006policy\030"
				+ "\002 \001(\0132\017.License.Policy\022\"\n\003key\030\003 \003(\0132\025.Li"
				+ "cense.KeyContainer\022\032\n\022license_start_time"
				+ "\030\004 \001(\003\022*\n\033remote_attestation_verified\030\005 "
				+ "\001(\010:\005false\022\035\n\025provider_client_token\030\006 \001("
				+ "\014\022\031\n\021protection_scheme\030\007 \001(\r\022\027\n\017srm_requ"
				+ "irement\030\010 \001(\014\022\022\n\nsrm_update\030\t \001(\014\022[\n\034pla"
				+ "tform_verification_status\030\n \001(\0162\033.Platfo"
				+ "rmVerificationStatus:\030PLATFORM_NO_VERIFI"
				+ "CATION\022\021\n\tgroup_ids\030\013 \003(\014\032\256\004\n\006Policy\022\027\n\010"
				+ "can_play\030\001 \001(\010:\005false\022\032\n\013can_persist\030\002 \001"
				+ "(\010:\005false\022\030\n\tcan_renew\030\003 \001(\010:\005false\022\"\n\027r"
				+ "ental_duration_seconds\030\004 \001(\003:\0010\022$\n\031playb"
				+ "ack_duration_seconds\030\005 \001(\003:\0010\022#\n\030license"
				+ "_duration_seconds\030\006 \001(\003:\0010\022,\n!renewal_re"
				+ "covery_duration_seconds\030\007 \001(\003:\0010\022\032\n\022rene"
				+ "wal_server_url\030\010 \001(\t\022 \n\025renewal_delay_se"
				+ "conds\030\t \001(\003:\0010\022)\n\036renewal_retry_interval"
				+ "_seconds\030\n \001(\003:\0010\022\037\n\020renew_with_usage\030\013 "
				+ "\001(\010:\005false\022\'\n\030always_include_client_id\030\014"
				+ " \001(\010:\005false\022*\n\037play_start_grace_period_s"
				+ "econds\030\r \001(\003:\0010\022-\n\036soft_enforce_playback"
				+ "_duration\030\016 \001(\010:\005false\022*\n\034soft_enforce_r"
				+ "ental_duration\030\017 \001(\010:\004true\032\210\016\n\014KeyContai"
				+ "ner\022\n\n\002id\030\001 \001(\014\022\n\n\002iv\030\002 \001(\014\022\013\n\003key\030\003 \001(\014"
				+ "\022+\n\004type\030\004 \001(\0162\035.License.KeyContainer.Ke"
				+ "yType\022D\n\005level\030\005 \001(\0162#.License.KeyContai"
				+ "ner.SecurityLevel:\020SW_SECURE_CRYPTO\022C\n\023r"
				+ "equired_protection\030\006 \001(\0132&.License.KeyCo"
				+ "ntainer.OutputProtection\022D\n\024requested_pr"
				+ "otection\030\007 \001(\0132&.License.KeyContainer.Ou"
				+ "tputProtection\0225\n\013key_control\030\010 \001(\0132 .Li"
				+ "cense.KeyContainer.KeyControl\022]\n operato" + "r_session_key_permissions\030\t \001(\01323.Licens"
				+ "e.KeyContainer.OperatorSessionKeyPermiss" + "ions\022U\n\034video_resolution_constraints\030\n \003"
				+ "(\0132/.License.KeyContainer.VideoResolutio" + "nConstraint\022(\n\031anti_rollback_usage_table"
				+ "\030\013 \001(\010:\005false\022\023\n\013track_label\030\014 \001(\t\0323\n\nKe"
				+ "yControl\022\031\n\021key_control_block\030\001 \001(\014\022\n\n\002i"
				+ "v\030\002 \001(\014\032\310\004\n\020OutputProtection\022D\n\004hdcp\030\001 \001"
				+ "(\0162+.License.KeyContainer.OutputProtecti"
				+ "on.HDCP:\tHDCP_NONE\022J\n\ncgms_flags\030\002 \001(\0162+"
				+ ".License.KeyContainer.OutputProtection.C"
				+ "GMS:\tCGMS_NONE\022]\n\rhdcp_srm_rule\030\003 \001(\01622."
				+ "License.KeyContainer.OutputProtection.Hd" + "cpSrmRule:\022HDCP_SRM_RULE_NONE\022$\n\025disable"
				+ "_analog_output\030\004 \001(\010:\005false\022%\n\026disable_d"
				+ "igital_output\030\005 \001(\010:\005false\"y\n\004HDCP\022\r\n\tHD"
				+ "CP_NONE\020\000\022\013\n\007HDCP_V1\020\001\022\013\n\007HDCP_V2\020\002\022\r\n\tH"
				+ "DCP_V2_1\020\003\022\r\n\tHDCP_V2_2\020\004\022\r\n\tHDCP_V2_3\020\005"
				+ "\022\033\n\026HDCP_NO_DIGITAL_OUTPUT\020\377\001\"C\n\004CGMS\022\r\n"
				+ "\tCGMS_NONE\020*\022\r\n\tCOPY_FREE\020\000\022\r\n\tCOPY_ONCE"
				+ "\020\002\022\016\n\nCOPY_NEVER\020\003\"6\n\013HdcpSrmRule\022\026\n\022HDC"
				+ "P_SRM_RULE_NONE\020\000\022\017\n\013CURRENT_SRM\020\001\032\236\001\n\031V"
				+ "ideoResolutionConstraint\022\035\n\025min_resoluti"
				+ "on_pixels\030\001 \001(\r\022\035\n\025max_resolution_pixels"
				+ "\030\002 \001(\r\022C\n\023required_protection\030\003 \001(\0132&.Li"
				+ "cense.KeyContainer.OutputProtection\032\235\001\n\035"
				+ "OperatorSessionKeyPermissions\022\034\n\rallow_e"
				+ "ncrypt\030\001 \001(\010:\005false\022\034\n\rallow_decrypt\030\002 \001"
				+ "(\010:\005false\022\031\n\nallow_sign\030\003 \001(\010:\005false\022%\n\026"
				+ "allow_signature_verify\030\004 \001(\010:\005false\"l\n\007K"
				+ "eyType\022\013\n\007SIGNING\020\001\022\013\n\007CONTENT\020\002\022\017\n\013KEY_"
				+ "CONTROL\020\003\022\024\n\020OPERATOR_SESSION\020\004\022\017\n\013ENTIT"
				+ "LEMENT\020\005\022\017\n\013OEM_CONTENT\020\006\"z\n\rSecurityLev"
				+ "el\022\024\n\020SW_SECURE_CRYPTO\020\001\022\024\n\020SW_SECURE_DE"
				+ "CODE\020\002\022\024\n\020HW_SECURE_CRYPTO\020\003\022\024\n\020HW_SECUR"
				+ "E_DECODE\020\004\022\021\n\rHW_SECURE_ALL\020\005\"\265\n\n\016Licens"
				+ "eRequest\022(\n\tclient_id\030\001 \001(\0132\025.ClientIden"
				+ "tification\0229\n\ncontent_id\030\002 \001(\0132%.License"
				+ "Request.ContentIdentification\022)\n\004type\030\003 "
				+ "\001(\0162\033.LicenseRequest.RequestType\022\024\n\014requ"
				+ "est_time\030\004 \001(\003\022$\n\034key_control_nonce_depr"
				+ "ecated\030\005 \001(\014\0227\n\020protocol_version\030\006 \001(\0162\020"
				+ ".ProtocolVersion:\013VERSION_2_0\022\031\n\021key_con"
				+ "trol_nonce\030\007 \001(\r\022;\n\023encrypted_client_id\030"
				+ "\010 \001(\0132\036.EncryptedClientIdentification\032\223\007"
				+ "\n\025ContentIdentification\022T\n\022widevine_pssh"
				+ "_data\030\001 \001(\01326.LicenseRequest.ContentIden"
				+ "tification.WidevinePsshDataH\000\022F\n\013webm_ke"
				+ "y_id\030\002 \001(\0132/.LicenseRequest.ContentIdent"
				+ "ification.WebmKeyIdH\000\022Q\n\020existing_licens"
				+ "e\030\003 \001(\01325.LicenseRequest.ContentIdentifi"
				+ "cation.ExistingLicenseH\000\022C\n\tinit_data\030\004 "
				+ "\001(\0132..LicenseRequest.ContentIdentificati"
				+ "on.InitDataH\000\032]\n\020WidevinePsshData\022\021\n\tpss"
				+ "h_data\030\001 \003(\014\022\"\n\014license_type\030\002 \001(\0162\014.Lic"
				+ "enseType\022\022\n\nrequest_id\030\003 \001(\014\032S\n\tWebmKeyI"
				+ "d\022\016\n\006header\030\001 \001(\014\022\"\n\014license_type\030\002 \001(\0162"
				+ "\014.LicenseType\022\022\n\nrequest_id\030\003 \001(\014\032\242\001\n\017Ex"
				+ "istingLicense\022*\n\nlicense_id\030\001 \001(\0132\026.Lice"
				+ "nseIdentification\022\035\n\025seconds_since_start"
				+ "ed\030\002 \001(\003\022!\n\031seconds_since_last_played\030\003 "
				+ "\001(\003\022!\n\031session_usage_table_entry\030\004 \001(\014\032\324"
				+ "\001\n\010InitData\022Y\n\016init_data_type\030\001 \001(\0162;.Li"
				+ "censeRequest.ContentIdentification.InitD"
				+ "ata.InitDataType:\004CENC\022\021\n\tinit_data\030\002 \001("
				+ "\014\022\"\n\014license_type\030\003 \001(\0162\014.LicenseType\022\022\n"
				+ "\nrequest_id\030\004 \001(\014\"\"\n\014InitDataType\022\010\n\004CEN"
				+ "C\020\001\022\010\n\004WEBM\020\002B\024\n\022content_id_variant\"0\n\013R"
				+ "equestType\022\007\n\003NEW\020\001\022\013\n\007RENEWAL\020\002\022\013\n\007RELE"
				+ "ASE\020\003\"\273\001\n\nMetricData\022\022\n\nstage_name\030\001 \001(\t"
				+ "\022*\n\013metric_data\030\002 \003(\0132\025.MetricData.TypeV"
				+ "alue\032C\n\tTypeValue\022$\n\004type\030\001 \001(\0162\026.Metric"
				+ "Data.MetricType\022\020\n\005value\030\002 \001(\003:\0010\"(\n\nMet"
				+ "ricType\022\013\n\007LATENCY\020\001\022\r\n\tTIMESTAMP\020\002\"K\n\013V"
				+ "ersionInfo\022\033\n\023license_sdk_version\030\001 \001(\t\022"
				+ "\037\n\027license_service_version\030\002 \001(\t\"\206\005\n\rSig"
				+ "nedMessage\022(\n\004type\030\001 \001(\0162\032.SignedMessage"
				+ ".MessageType\022\013\n\003msg\030\002 \001(\014\022\021\n\tsignature\030\003"
				+ " \001(\014\022\023\n\013session_key\030\004 \001(\014\022\032\n\022remote_atte"
				+ "station\030\005 \001(\014\022 \n\013metric_data\030\006 \003(\0132\013.Met"
				+ "ricData\022*\n\024service_version_info\030\007 \001(\0132\014."
				+ "VersionInfo\022H\n\020session_key_type\030\010 \001(\0162\035."
				+ "SignedMessage.SessionKeyType:\017WRAPPED_AE"
				+ "S_KEY\022\036\n\026oemcrypto_core_message\030\t \001(\014\"\354\001"
				+ "\n\013MessageType\022\023\n\017LICENSE_REQUEST\020\001\022\013\n\007LI"
				+ "CENSE\020\002\022\022\n\016ERROR_RESPONSE\020\003\022\037\n\033SERVICE_C"
				+ "ERTIFICATE_REQUEST\020\004\022\027\n\023SERVICE_CERTIFIC"
				+ "ATE\020\005\022\017\n\013SUB_LICENSE\020\006\022\027\n\023CAS_LICENSE_RE"
				+ "QUEST\020\007\022\017\n\013CAS_LICENSE\020\010\022\034\n\030EXTERNAL_LIC"
				+ "ENSE_REQUEST\020\t\022\024\n\020EXTERNAL_LICENSE\020\n\"S\n\016"
				+ "SessionKeyType\022\r\n\tUNDEFINED\020\000\022\023\n\017WRAPPED"
				+ "_AES_KEY\020\001\022\035\n\031EPHERMERAL_ECC_PUBLIC_KEY\020"
				+ "\002\"\346\014\n\024ClientIdentification\0225\n\004type\030\001 \001(\016"
				+ "2\037.ClientIdentification.TokenType:\006KEYBO"
				+ "X\022\r\n\005token\030\002 \001(\014\0224\n\013client_info\030\003 \003(\0132\037."
				+ "ClientIdentification.NameValue\022\035\n\025provid"
				+ "er_client_token\030\004 \001(\014\022\027\n\017license_counter"
				+ "\030\005 \001(\r\022E\n\023client_capabilities\030\006 \001(\0132(.Cl"
				+ "ientIdentification.ClientCapabilities\022\020\n"
				+ "\010vmp_data\030\007 \001(\014\022C\n\022device_credentials\030\010 "
				+ "\003(\0132\'.ClientIdentification.ClientCredent"
				+ "ials\032(\n\tNameValue\022\014\n\004name\030\001 \001(\t\022\r\n\005value"
				+ "\030\002 \001(\t\032\201\010\n\022ClientCapabilities\022\033\n\014client_"
				+ "token\030\001 \001(\010:\005false\022\034\n\rsession_token\030\002 \001("
				+ "\010:\005false\022+\n\034video_resolution_constraints"
				+ "\030\003 \001(\010:\005false\022Y\n\020max_hdcp_version\030\004 \001(\0162"
				+ "4.ClientIdentification.ClientCapabilitie" + "s.HdcpVersion:\tHDCP_NONE\022\036\n\026oem_crypto_a"
				+ "pi_version\030\005 \001(\r\022(\n\031anti_rollback_usage_"
				+ "table\030\006 \001(\010:\005false\022\023\n\013srm_version\030\007 \001(\r\022"
				+ "\035\n\016can_update_srm\030\010 \001(\010:\005false\022c\n\036suppor"
				+ "ted_certificate_key_type\030\t \003(\0162;.ClientI" + "dentification.ClientCapabilities.Certifi"
				+ "cateKeyType\022|\n\032analog_output_capabilitie"
				+ "s\030\n \001(\0162A.ClientIdentification.ClientCap" + "abilities.AnalogOutputCapabilities:\025ANAL"
				+ "OG_OUTPUT_UNKNOWN\022(\n\031can_disable_analog_"
				+ "output\030\013 \001(\010:\005false\022\037\n\024resource_rating_t"
				+ "ier\030\014 \001(\r:\0010\"\200\001\n\013HdcpVersion\022\r\n\tHDCP_NON"
				+ "E\020\000\022\013\n\007HDCP_V1\020\001\022\013\n\007HDCP_V2\020\002\022\r\n\tHDCP_V2"
				+ "_1\020\003\022\r\n\tHDCP_V2_2\020\004\022\r\n\tHDCP_V2_3\020\005\022\033\n\026HD"
				+ "CP_NO_DIGITAL_OUTPUT\020\377\001\"i\n\022CertificateKe"
				+ "yType\022\014\n\010RSA_2048\020\000\022\014\n\010RSA_3072\020\001\022\021\n\rECC"
				+ "_SECP256R1\020\002\022\021\n\rECC_SECP384R1\020\003\022\021\n\rECC_S"
				+ "ECP521R1\020\004\"\215\001\n\030AnalogOutputCapabilities\022"
				+ "\031\n\025ANALOG_OUTPUT_UNKNOWN\020\000\022\026\n\022ANALOG_OUT"
				+ "PUT_NONE\020\001\022\033\n\027ANALOG_OUTPUT_SUPPORTED\020\002\022"
				+ "!\n\035ANALOG_OUTPUT_SUPPORTS_CGMS_A\020\003\032Y\n\021Cl"
				+ "ientCredentials\0225\n\004type\030\001 \001(\0162\037.ClientId"
				+ "entification.TokenType:\006KEYBOX\022\r\n\005token\030"
				+ "\002 \001(\014\"s\n\tTokenType\022\n\n\006KEYBOX\020\000\022\032\n\026DRM_DE"
				+ "VICE_CERTIFICATE\020\001\022\"\n\036REMOTE_ATTESTATION"
				+ "_CERTIFICATE\020\002\022\032\n\026OEM_DEVICE_CERTIFICATE"
				+ "\020\003\"\273\001\n\035EncryptedClientIdentification\022\023\n\013"
				+ "provider_id\030\001 \001(\t\022)\n!service_certificate"
				+ "_serial_number\030\002 \001(\014\022\033\n\023encrypted_client"
				+ "_id\030\003 \001(\014\022\036\n\026encrypted_client_id_iv\030\004 \001("
				+ "\014\022\035\n\025encrypted_privacy_key\030\005 \001(\014\"\256\006\n\016Drm"
				+ "Certificate\022\"\n\004type\030\001 \001(\0162\024.DrmCertifica"
				+ "te.Type\022\025\n\rserial_number\030\002 \001(\014\022\035\n\025creati"
				+ "on_time_seconds\030\003 \001(\r\022\037\n\027expiration_time"
				+ "_seconds\030\014 \001(\r\022\022\n\npublic_key\030\004 \001(\014\022\021\n\tsy"
				+ "stem_id\030\005 \001(\r\022\"\n\026test_device_deprecated\030"
				+ "\006 \001(\010B\002\030\001\022\023\n\013provider_id\030\007 \001(\t\0222\n\rservic"
				+ "e_types\030\010 \003(\0162\033.DrmCertificate.ServiceTy"
				+ "pe\0221\n\talgorithm\030\t \001(\0162\031.DrmCertificate.A"
				+ "lgorithm:\003RSA\022\016\n\006rot_id\030\n \001(\014\0225\n\016encrypt"
				+ "ion_key\030\013 \001(\0132\035.DrmCertificate.Encryptio"
				+ "nKey\032V\n\rEncryptionKey\022\022\n\npublic_key\030\001 \001("
				+ "\014\0221\n\talgorithm\030\002 \001(\0162\031.DrmCertificate.Al"
				+ "gorithm:\003RSA\"L\n\004Type\022\010\n\004ROOT\020\000\022\020\n\014DEVICE"
				+ "_MODEL\020\001\022\n\n\006DEVICE\020\002\022\013\n\007SERVICE\020\003\022\017\n\013PRO"
				+ "VISIONER\020\004\"\206\001\n\013ServiceType\022\030\n\024UNKNOWN_SE"
				+ "RVICE_TYPE\020\000\022\026\n\022LICENSE_SERVER_SDK\020\001\022\034\n\030"
				+ "LICENSE_SERVER_PROXY_SDK\020\002\022\024\n\020PROVISIONI"
				+ "NG_SDK\020\003\022\021\n\rCAS_PROXY_SDK\020\004\"d\n\tAlgorithm"
				+ "\022\025\n\021UNKNOWN_ALGORITHM\020\000\022\007\n\003RSA\020\001\022\021\n\rECC_"
				+ "SECP256R1\020\002\022\021\n\rECC_SECP384R1\020\003\022\021\n\rECC_SE"
				+ "CP521R1\020\004\"\226\001\n\024SignedDrmCertificate\022\027\n\017dr"
				+ "m_certificate\030\001 \001(\014\022\021\n\tsignature\030\002 \001(\014\022%"
				+ "\n\006signer\030\003 \001(\0132\025.SignedDrmCertificate\022+\n"
				+ "\016hash_algorithm\030\004 \001(\0162\023.HashAlgorithmPro"
				+ "to\"\242\005\n\020WidevinePsshData\022\017\n\007key_ids\030\002 \003(\014"
				+ "\022\022\n\ncontent_id\030\004 \001(\014\022\033\n\023crypto_period_in"
				+ "dex\030\007 \001(\r\022\031\n\021protection_scheme\030\t \001(\r\022\035\n\025"
				+ "crypto_period_seconds\030\n \001(\r\022,\n\004type\030\013 \001("
				+ "\0162\026.WidevinePsshData.Type:\006SINGLE\022\024\n\014key"
				+ "_sequence\030\014 \001(\r\022\021\n\tgroup_ids\030\r \003(\014\0224\n\ren"
				+ "titled_keys\030\016 \003(\0132\035.WidevinePsshData.Ent"
				+ "itledKey\022\025\n\rvideo_feature\030\017 \001(\t\0222\n\talgor"
				+ "ithm\030\001 \001(\0162\033.WidevinePsshData.AlgorithmB"
				+ "\002\030\001\022\024\n\010provider\030\003 \001(\tB\002\030\001\022\026\n\ntrack_type\030"
				+ "\005 \001(\tB\002\030\001\022\022\n\006policy\030\006 \001(\tB\002\030\001\022\033\n\017grouped"
				+ "_license\030\010 \001(\014B\002\030\001\032z\n\013EntitledKey\022\032\n\022ent"
				+ "itlement_key_id\030\001 \001(\014\022\016\n\006key_id\030\002 \001(\014\022\013\n"
				+ "\003key\030\003 \001(\014\022\n\n\002iv\030\004 \001(\014\022&\n\032entitlement_ke"
				+ "y_size_bytes\030\005 \001(\r:\00232\"5\n\004Type\022\n\n\006SINGLE"
				+ "\020\000\022\017\n\013ENTITLEMENT\020\001\022\020\n\014ENTITLED_KEY\020\002\"(\n"
				+ "\tAlgorithm\022\017\n\013UNENCRYPTED\020\000\022\n\n\006AESCTR\020\001\""
				+ "\265\001\n\nFileHashes\022\016\n\006signer\030\001 \001(\014\022)\n\nsignat"
				+ "ures\030\002 \003(\0132\025.FileHashes.Signature\032l\n\tSig"
				+ "nature\022\020\n\010filename\030\001 \001(\t\022\024\n\014test_signing"
				+ "\030\002 \001(\010\022\022\n\nSHA512Hash\030\003 \001(\014\022\020\n\010main_exe\030\004"
				+ " \001(\010\022\021\n\tsignature\030\005 \001(\014*8\n\013LicenseType\022\r"
				+ "\n\tSTREAMING\020\001\022\013\n\007OFFLINE\020\002\022\r\n\tAUTOMATIC\020"
				+ "\003*\331\001\n\032PlatformVerificationStatus\022\027\n\023PLAT"
				+ "FORM_UNVERIFIED\020\000\022\025\n\021PLATFORM_TAMPERED\020\001"
				+ "\022\036\n\032PLATFORM_SOFTWARE_VERIFIED\020\002\022\036\n\032PLAT"
				+ "FORM_HARDWARE_VERIFIED\020\003\022\034\n\030PLATFORM_NO_"
				+ "VERIFICATION\020\004\022-\n)PLATFORM_SECURE_STORAG"
				+ "E_SOFTWARE_VERIFIED\020\005*D\n\017ProtocolVersion"
				+ "\022\017\n\013VERSION_2_0\020\024\022\017\n\013VERSION_2_1\020\025\022\017\n\013VE"
				+ "RSION_2_2\020\026*\206\001\n\022HashAlgorithmProto\022\036\n\032HA"
				+ "SH_ALGORITHM_UNSPECIFIED\020\000\022\030\n\024HASH_ALGOR"
				+ "ITHM_SHA_1\020\001\022\032\n\026HASH_ALGORITHM_SHA_256\020\002"
				+ "\022\032\n\026HASH_ALGORITHM_SHA_384\020\003B%\n\027de.k7bot"
				+ ".lib.widevine4jB\010WvProto2P\000" };
		descriptor = Descriptors.FileDescriptor.internalBuildGeneratedFileFrom(descriptorData,
				new Descriptors.FileDescriptor[] {});
		internal_static_LicenseIdentification_descriptor = getDescriptor().getMessageTypes().get(0);
		internal_static_LicenseIdentification_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(
				internal_static_LicenseIdentification_descriptor, new java.lang.String[] { "RequestId", "SessionId",
						"PurchaseId", "Type", "Version", "ProviderSessionToken", });
		internal_static_License_descriptor = getDescriptor().getMessageTypes().get(1);
		internal_static_License_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(
				internal_static_License_descriptor,
				new java.lang.String[] { "Id", "Policy", "Key", "LicenseStartTime", "RemoteAttestationVerified",
						"ProviderClientToken", "ProtectionScheme", "SrmRequirement", "SrmUpdate",
						"PlatformVerificationStatus", "GroupIds", });
		internal_static_License_Policy_descriptor = internal_static_License_descriptor.getNestedTypes().get(0);
		internal_static_License_Policy_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(
				internal_static_License_Policy_descriptor,
				new java.lang.String[] { "CanPlay", "CanPersist", "CanRenew", "RentalDurationSeconds",
						"PlaybackDurationSeconds", "LicenseDurationSeconds", "RenewalRecoveryDurationSeconds",
						"RenewalServerUrl", "RenewalDelaySeconds", "RenewalRetryIntervalSeconds", "RenewWithUsage",
						"AlwaysIncludeClientId", "PlayStartGracePeriodSeconds", "SoftEnforcePlaybackDuration",
						"SoftEnforceRentalDuration", });
		internal_static_License_KeyContainer_descriptor = internal_static_License_descriptor.getNestedTypes().get(1);
		internal_static_License_KeyContainer_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(
				internal_static_License_KeyContainer_descriptor,
				new java.lang.String[] { "Id", "Iv", "Key", "Type", "Level", "RequiredProtection",
						"RequestedProtection", "KeyControl", "OperatorSessionKeyPermissions",
						"VideoResolutionConstraints", "AntiRollbackUsageTable", "TrackLabel", });
		internal_static_License_KeyContainer_KeyControl_descriptor = internal_static_License_KeyContainer_descriptor
				.getNestedTypes().get(0);
		internal_static_License_KeyContainer_KeyControl_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(
				internal_static_License_KeyContainer_KeyControl_descriptor,
				new java.lang.String[] { "KeyControlBlock", "Iv", });
		internal_static_License_KeyContainer_OutputProtection_descriptor = internal_static_License_KeyContainer_descriptor
				.getNestedTypes().get(1);
		internal_static_License_KeyContainer_OutputProtection_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(
				internal_static_License_KeyContainer_OutputProtection_descriptor, new java.lang.String[] { "Hdcp",
						"CgmsFlags", "HdcpSrmRule", "DisableAnalogOutput", "DisableDigitalOutput", });
		internal_static_License_KeyContainer_VideoResolutionConstraint_descriptor = internal_static_License_KeyContainer_descriptor
				.getNestedTypes().get(2);
		internal_static_License_KeyContainer_VideoResolutionConstraint_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(
				internal_static_License_KeyContainer_VideoResolutionConstraint_descriptor,
				new java.lang.String[] { "MinResolutionPixels", "MaxResolutionPixels", "RequiredProtection", });
		internal_static_License_KeyContainer_OperatorSessionKeyPermissions_descriptor = internal_static_License_KeyContainer_descriptor
				.getNestedTypes().get(3);
		internal_static_License_KeyContainer_OperatorSessionKeyPermissions_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(
				internal_static_License_KeyContainer_OperatorSessionKeyPermissions_descriptor,
				new java.lang.String[] { "AllowEncrypt", "AllowDecrypt", "AllowSign", "AllowSignatureVerify", });
		internal_static_LicenseRequest_descriptor = getDescriptor().getMessageTypes().get(2);
		internal_static_LicenseRequest_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(
				internal_static_LicenseRequest_descriptor,
				new java.lang.String[] { "ClientId", "ContentId", "Type", "RequestTime", "KeyControlNonceDeprecated",
						"ProtocolVersion", "KeyControlNonce", "EncryptedClientId", });
		internal_static_LicenseRequest_ContentIdentification_descriptor = internal_static_LicenseRequest_descriptor
				.getNestedTypes().get(0);
		internal_static_LicenseRequest_ContentIdentification_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(
				internal_static_LicenseRequest_ContentIdentification_descriptor, new java.lang.String[] {
						"WidevinePsshData", "WebmKeyId", "ExistingLicense", "InitData", "ContentIdVariant", });
		internal_static_LicenseRequest_ContentIdentification_WidevinePsshData_descriptor = internal_static_LicenseRequest_ContentIdentification_descriptor
				.getNestedTypes().get(0);
		internal_static_LicenseRequest_ContentIdentification_WidevinePsshData_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(
				internal_static_LicenseRequest_ContentIdentification_WidevinePsshData_descriptor,
				new java.lang.String[] { "PsshData", "LicenseType", "RequestId", });
		internal_static_LicenseRequest_ContentIdentification_WebmKeyId_descriptor = internal_static_LicenseRequest_ContentIdentification_descriptor
				.getNestedTypes().get(1);
		internal_static_LicenseRequest_ContentIdentification_WebmKeyId_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(
				internal_static_LicenseRequest_ContentIdentification_WebmKeyId_descriptor,
				new java.lang.String[] { "Header", "LicenseType", "RequestId", });
		internal_static_LicenseRequest_ContentIdentification_ExistingLicense_descriptor = internal_static_LicenseRequest_ContentIdentification_descriptor
				.getNestedTypes().get(2);
		internal_static_LicenseRequest_ContentIdentification_ExistingLicense_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(
				internal_static_LicenseRequest_ContentIdentification_ExistingLicense_descriptor,
				new java.lang.String[] { "LicenseId", "SecondsSinceStarted", "SecondsSinceLastPlayed",
						"SessionUsageTableEntry", });
		internal_static_LicenseRequest_ContentIdentification_InitData_descriptor = internal_static_LicenseRequest_ContentIdentification_descriptor
				.getNestedTypes().get(3);
		internal_static_LicenseRequest_ContentIdentification_InitData_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(
				internal_static_LicenseRequest_ContentIdentification_InitData_descriptor,
				new java.lang.String[] { "InitDataType", "InitData", "LicenseType", "RequestId", });
		internal_static_MetricData_descriptor = getDescriptor().getMessageTypes().get(3);
		internal_static_MetricData_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(
				internal_static_MetricData_descriptor, new java.lang.String[] { "StageName", "MetricData", });
		internal_static_MetricData_TypeValue_descriptor = internal_static_MetricData_descriptor.getNestedTypes().get(0);
		internal_static_MetricData_TypeValue_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(
				internal_static_MetricData_TypeValue_descriptor, new java.lang.String[] { "Type", "Value", });
		internal_static_VersionInfo_descriptor = getDescriptor().getMessageTypes().get(4);
		internal_static_VersionInfo_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(
				internal_static_VersionInfo_descriptor,
				new java.lang.String[] { "LicenseSdkVersion", "LicenseServiceVersion", });
		internal_static_SignedMessage_descriptor = getDescriptor().getMessageTypes().get(5);
		internal_static_SignedMessage_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(
				internal_static_SignedMessage_descriptor,
				new java.lang.String[] { "Type", "Msg", "Signature", "SessionKey", "RemoteAttestation", "MetricData",
						"ServiceVersionInfo", "SessionKeyType", "OemcryptoCoreMessage", });
		internal_static_ClientIdentification_descriptor = getDescriptor().getMessageTypes().get(6);
		internal_static_ClientIdentification_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(
				internal_static_ClientIdentification_descriptor,
				new java.lang.String[] { "Type", "Token", "ClientInfo", "ProviderClientToken", "LicenseCounter",
						"ClientCapabilities", "VmpData", "DeviceCredentials", });
		internal_static_ClientIdentification_NameValue_descriptor = internal_static_ClientIdentification_descriptor
				.getNestedTypes().get(0);
		internal_static_ClientIdentification_NameValue_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(
				internal_static_ClientIdentification_NameValue_descriptor, new java.lang.String[] { "Name", "Value", });
		internal_static_ClientIdentification_ClientCapabilities_descriptor = internal_static_ClientIdentification_descriptor
				.getNestedTypes().get(1);
		internal_static_ClientIdentification_ClientCapabilities_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(
				internal_static_ClientIdentification_ClientCapabilities_descriptor,
				new java.lang.String[] { "ClientToken", "SessionToken", "VideoResolutionConstraints", "MaxHdcpVersion",
						"OemCryptoApiVersion", "AntiRollbackUsageTable", "SrmVersion", "CanUpdateSrm",
						"SupportedCertificateKeyType", "AnalogOutputCapabilities", "CanDisableAnalogOutput",
						"ResourceRatingTier", });
		internal_static_ClientIdentification_ClientCredentials_descriptor = internal_static_ClientIdentification_descriptor
				.getNestedTypes().get(2);
		internal_static_ClientIdentification_ClientCredentials_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(
				internal_static_ClientIdentification_ClientCredentials_descriptor,
				new java.lang.String[] { "Type", "Token", });
		internal_static_EncryptedClientIdentification_descriptor = getDescriptor().getMessageTypes().get(7);
		internal_static_EncryptedClientIdentification_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(
				internal_static_EncryptedClientIdentification_descriptor,
				new java.lang.String[] { "ProviderId", "ServiceCertificateSerialNumber", "EncryptedClientId",
						"EncryptedClientIdIv", "EncryptedPrivacyKey", });
		internal_static_DrmCertificate_descriptor = getDescriptor().getMessageTypes().get(8);
		internal_static_DrmCertificate_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(
				internal_static_DrmCertificate_descriptor,
				new java.lang.String[] { "Type", "SerialNumber", "CreationTimeSeconds", "ExpirationTimeSeconds",
						"PublicKey", "SystemId", "TestDeviceDeprecated", "ProviderId", "ServiceTypes", "Algorithm",
						"RotId", "EncryptionKey", });
		internal_static_DrmCertificate_EncryptionKey_descriptor = internal_static_DrmCertificate_descriptor
				.getNestedTypes().get(0);
		internal_static_DrmCertificate_EncryptionKey_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(
				internal_static_DrmCertificate_EncryptionKey_descriptor,
				new java.lang.String[] { "PublicKey", "Algorithm", });
		internal_static_SignedDrmCertificate_descriptor = getDescriptor().getMessageTypes().get(9);
		internal_static_SignedDrmCertificate_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(
				internal_static_SignedDrmCertificate_descriptor,
				new java.lang.String[] { "DrmCertificate", "Signature", "Signer", "HashAlgorithm", });
		internal_static_WidevinePsshData_descriptor = getDescriptor().getMessageTypes().get(10);
		internal_static_WidevinePsshData_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(
				internal_static_WidevinePsshData_descriptor,
				new java.lang.String[] { "KeyIds", "ContentId", "CryptoPeriodIndex", "ProtectionScheme",
						"CryptoPeriodSeconds", "Type", "KeySequence", "GroupIds", "EntitledKeys", "VideoFeature",
						"Algorithm", "Provider", "TrackType", "Policy", "GroupedLicense", });
		internal_static_WidevinePsshData_EntitledKey_descriptor = internal_static_WidevinePsshData_descriptor
				.getNestedTypes().get(0);
		internal_static_WidevinePsshData_EntitledKey_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(
				internal_static_WidevinePsshData_EntitledKey_descriptor,
				new java.lang.String[] { "EntitlementKeyId", "KeyId", "Key", "Iv", "EntitlementKeySizeBytes", });
		internal_static_FileHashes_descriptor = getDescriptor().getMessageTypes().get(11);
		internal_static_FileHashes_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(
				internal_static_FileHashes_descriptor, new java.lang.String[] { "Signer", "Signatures", });
		internal_static_FileHashes_Signature_descriptor = internal_static_FileHashes_descriptor.getNestedTypes().get(0);
		internal_static_FileHashes_Signature_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(
				internal_static_FileHashes_Signature_descriptor,
				new java.lang.String[] { "Filename", "TestSigning", "SHA512Hash", "MainExe", "Signature", });
	}

	// @@protoc_insertion_point(outer_class_scope)
}
